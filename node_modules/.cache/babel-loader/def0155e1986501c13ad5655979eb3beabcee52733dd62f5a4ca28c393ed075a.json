{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport Point from '@mapbox/point-geometry';\nimport { BoxZoomHandler } from \"./handler/box_zoom\";\nimport { ClickZoomHandler } from \"./handler/click_zoom\";\nimport { CooperativeGesturesHandler } from \"./handler/cooperative_gestures\";\nimport { KeyboardHandler } from \"./handler/keyboard\";\nimport { BlockableMapEventHandler, MapEventHandler } from \"./handler/map_event\";\nimport { generateMousePanHandler, generateMousePitchHandler, generateMouseRotationHandler } from \"./handler/mouse\";\nimport { ScrollZoomHandler } from \"./handler/scroll_zoom\";\nimport { DoubleClickZoomHandler } from \"./handler/shim/dblclick_zoom\";\nimport { DragPanHandler } from \"./handler/shim/drag_pan\";\nimport { DragRotateHandler } from \"./handler/shim/drag_rotate\";\nimport { TwoFingersTouchZoomRotateHandler } from \"./handler/shim/two_fingers_touch\";\nimport { TapDragZoomHandler } from \"./handler/tap_drag_zoom\";\nimport { TapZoomHandler } from \"./handler/tap_zoom\";\nimport { TouchPanHandler } from \"./handler/touch_pan\";\nimport { TwoFingersTouchPitchHandler, TwoFingersTouchRotateHandler, TwoFingersTouchZoomHandler } from \"./handler/two_fingers_touch\";\nimport { HandlerInertia } from \"./handler_inertia\";\nimport { browser } from \"./util/browser\";\nimport { DOM } from \"./util/dom\";\nimport { Event } from \"./util/evented\";\nimport { extend } from \"./util/util\";\nconst isMoving = p => p.zoom || p.drag || p.pitch || p.rotate;\nclass RenderFrameEvent extends Event {\n  constructor(type, timeStamp) {\n    super(type);\n    _defineProperty(this, \"type\", 'renderFrame');\n    _defineProperty(this, \"timeStamp\", void 0);\n    this.timeStamp = timeStamp;\n  }\n}\n\n/**\n * Handlers interpret dom events and return camera changes that should be\n * applied to the map (`HandlerResult`s). The camera changes are all deltas.\n * The handler itself should have no knowledge of the map's current state.\n * This makes it easier to merge multiple results and keeps handlers simpler.\n * For example, if there is a mousedown and mousemove, the mousePan handler\n * would return a `panDelta` on the mousemove.\n */\n\n/**\n * All handler methods that are called with events can optionally return a `HandlerResult`.\n */\n\nfunction hasChange(result) {\n  return result.panDelta && result.panDelta.mag() || result.zoomDelta || result.bearingDelta || result.pitchDelta;\n}\nexport class HandlerManager {\n  constructor(map, options) {\n    _defineProperty(this, \"_map\", void 0);\n    _defineProperty(this, \"_el\", void 0);\n    _defineProperty(this, \"_handlers\", void 0);\n    _defineProperty(this, \"_eventsInProgress\", void 0);\n    _defineProperty(this, \"_frameId\", void 0);\n    _defineProperty(this, \"_inertia\", void 0);\n    _defineProperty(this, \"_bearingSnap\", void 0);\n    _defineProperty(this, \"_handlersById\", void 0);\n    _defineProperty(this, \"_updatingCamera\", void 0);\n    _defineProperty(this, \"_changes\", void 0);\n    _defineProperty(this, \"_zoom\", void 0);\n    _defineProperty(this, \"_previousActiveHandlers\", void 0);\n    _defineProperty(this, \"_listeners\", void 0);\n    _defineProperty(this, \"handleWindowEvent\", e => {\n      this.handleEvent(e, `${e.type}Window`);\n    });\n    _defineProperty(this, \"handleEvent\", (e, eventName) => {\n      if (e.type === 'blur') {\n        this.stop(true);\n        return;\n      }\n      this._updatingCamera = true;\n      const inputEvent = e.type === 'renderFrame' ? undefined : e;\n\n      /*\n       * We don't call e.preventDefault() for any events by default.\n       * Handlers are responsible for calling it where necessary.\n       */\n\n      const mergedHandlerResult = {\n        needsRenderFrame: false\n      };\n      const eventsInProgress = {};\n      const activeHandlers = {};\n      const eventTouches = e.touches;\n      const mapTouches = eventTouches ? this._getMapTouches(eventTouches) : undefined;\n      const points = mapTouches ? DOM.touchPos(this._map.getCanvasContainer(), mapTouches) : DOM.mousePos(this._map.getCanvasContainer(), e);\n      for (const {\n        handlerName,\n        handler,\n        allowed\n      } of this._handlers) {\n        if (!handler.isEnabled()) continue;\n        let data;\n        if (this._blockedByActive(activeHandlers, allowed, handlerName)) {\n          handler.reset();\n        } else {\n          if (handler[eventName || e.type]) {\n            data = handler[eventName || e.type](e, points, mapTouches);\n            this.mergeHandlerResult(mergedHandlerResult, eventsInProgress, data, handlerName, inputEvent);\n            if (data && data.needsRenderFrame) {\n              this._triggerRenderFrame();\n            }\n          }\n        }\n        if (data || handler.isActive()) {\n          activeHandlers[handlerName] = handler;\n        }\n      }\n      const deactivatedHandlers = {};\n      for (const name in this._previousActiveHandlers) {\n        if (!activeHandlers[name]) {\n          deactivatedHandlers[name] = inputEvent;\n        }\n      }\n      this._previousActiveHandlers = activeHandlers;\n      if (Object.keys(deactivatedHandlers).length || hasChange(mergedHandlerResult)) {\n        this._changes.push([mergedHandlerResult, eventsInProgress, deactivatedHandlers]);\n        this._triggerRenderFrame();\n      }\n      if (Object.keys(activeHandlers).length || hasChange(mergedHandlerResult)) {\n        this._map._stop(true);\n      }\n      this._updatingCamera = false;\n      const {\n        cameraAnimation\n      } = mergedHandlerResult;\n      if (cameraAnimation) {\n        this._inertia.clear();\n        this._fireEvents({}, {}, true);\n        this._changes = [];\n        cameraAnimation(this._map);\n      }\n    });\n    this._map = map;\n    this._el = this._map.getCanvasContainer();\n    this._handlers = [];\n    this._handlersById = {};\n    this._changes = [];\n    this._inertia = new HandlerInertia(map);\n    this._bearingSnap = options.bearingSnap || 7;\n    this._previousActiveHandlers = {};\n\n    // Track whether map is currently moving, to compute start/move/end events\n    this._eventsInProgress = {};\n    this._addDefaultHandlers(options);\n    const el = this._el;\n    this._listeners = [\n    // This needs to be `passive: true` so that a double tap fires two\n    // pairs of touchstart/end events in iOS Safari 13. If this is set to\n    // `passive: false` then the second pair of events is only fired if\n    // preventDefault() is called on the first touchstart. Calling preventDefault()\n    // undesirably prevents click events.\n    [el, 'touchstart', {\n      passive: true\n    }],\n    // This needs to be `passive: false` so that scrolls and pinches can be\n    // prevented in browsers that don't support `touch-actions: none`, for example iOS Safari 12.\n    [el, 'touchmove', {\n      passive: false\n    }], [el, 'touchend', undefined], [el, 'touchcancel', undefined], [el, 'mousedown', undefined], [el, 'mousemove', undefined], [el, 'mouseup', undefined],\n    // Bind window-level event listeners for move and up/end events. In the absence of\n    // the pointer capture API, which is not supported by all necessary platforms,\n    // window-level event listeners give us the best shot at capturing events that\n    // fall outside the map canvas element. Use `{capture: true}` for the move event\n    // to prevent map move events from being fired during a drag.\n    [document, 'mousemove', {\n      capture: true\n    }], [document, 'mouseup', undefined], [el, 'mouseover', undefined], [el, 'mouseout', undefined], [el, 'dblclick', undefined], [el, 'click', undefined], [el, 'keydown', {\n      capture: false\n    }], [el, 'keyup', undefined], [el, 'wheel', {\n      passive: false\n    }], [el, 'contextmenu', undefined], [window, 'blur', undefined]];\n    for (const [target, type, listenerOptions] of this._listeners) {\n      DOM.addEventListener(target, type, target === document ? this.handleWindowEvent : this.handleEvent, listenerOptions);\n    }\n  }\n  destroy() {\n    for (const [target, type, listenerOptions] of this._listeners) {\n      DOM.removeEventListener(target, type, target === document ? this.handleWindowEvent : this.handleEvent, listenerOptions);\n    }\n  }\n  _addDefaultHandlers(options) {\n    const map = this._map;\n    const el = map.getCanvasContainer();\n    this._add('mapEvent', new MapEventHandler(map, options));\n    const boxZoom = map.boxZoom = new BoxZoomHandler(map, options);\n    this._add('boxZoom', boxZoom);\n    if (options.interactive && options.boxZoom) {\n      boxZoom.enable();\n    }\n    const cooperativeGestures = map.cooperativeGestures = new CooperativeGesturesHandler(map, options.cooperativeGestures);\n    this._add('cooperativeGestures', cooperativeGestures);\n    if (options.cooperativeGestures) {\n      cooperativeGestures.enable();\n    }\n    const tapZoom = new TapZoomHandler(map);\n    const clickZoom = new ClickZoomHandler(map);\n    map.doubleClickZoom = new DoubleClickZoomHandler(clickZoom, tapZoom);\n    this._add('tapZoom', tapZoom);\n    this._add('clickZoom', clickZoom);\n    if (options.interactive && options.doubleClickZoom) {\n      map.doubleClickZoom.enable();\n    }\n    const tapDragZoom = new TapDragZoomHandler();\n    this._add('tapDragZoom', tapDragZoom);\n    const touchPitch = map.touchPitch = new TwoFingersTouchPitchHandler(map);\n    this._add('touchPitch', touchPitch);\n    if (options.interactive && options.touchPitch) {\n      map.touchPitch.enable(options.touchPitch);\n    }\n    const mouseRotate = generateMouseRotationHandler(options);\n    const mousePitch = generateMousePitchHandler(options);\n    map.dragRotate = new DragRotateHandler(options, mouseRotate, mousePitch);\n    this._add('mouseRotate', mouseRotate, ['mousePitch']);\n    this._add('mousePitch', mousePitch, ['mouseRotate']);\n    if (options.interactive && options.dragRotate) {\n      map.dragRotate.enable();\n    }\n    const mousePan = generateMousePanHandler(options);\n    const touchPan = new TouchPanHandler(options, map);\n    map.dragPan = new DragPanHandler(el, mousePan, touchPan);\n    this._add('mousePan', mousePan);\n    this._add('touchPan', touchPan, ['touchZoom', 'touchRotate']);\n    if (options.interactive && options.dragPan) {\n      map.dragPan.enable(options.dragPan);\n    }\n    const touchRotate = new TwoFingersTouchRotateHandler();\n    const touchZoom = new TwoFingersTouchZoomHandler();\n    map.touchZoomRotate = new TwoFingersTouchZoomRotateHandler(el, touchZoom, touchRotate, tapDragZoom);\n    this._add('touchRotate', touchRotate, ['touchPan', 'touchZoom']);\n    this._add('touchZoom', touchZoom, ['touchPan', 'touchRotate']);\n    if (options.interactive && options.touchZoomRotate) {\n      map.touchZoomRotate.enable(options.touchZoomRotate);\n    }\n    const scrollZoom = map.scrollZoom = new ScrollZoomHandler(map, () => this._triggerRenderFrame());\n    this._add('scrollZoom', scrollZoom, ['mousePan']);\n    if (options.interactive && options.scrollZoom) {\n      map.scrollZoom.enable(options.scrollZoom);\n    }\n    const keyboard = map.keyboard = new KeyboardHandler(map);\n    this._add('keyboard', keyboard);\n    if (options.interactive && options.keyboard) {\n      map.keyboard.enable();\n    }\n    this._add('blockableMapEvent', new BlockableMapEventHandler(map));\n  }\n  _add(handlerName, handler, allowed) {\n    this._handlers.push({\n      handlerName,\n      handler,\n      allowed\n    });\n    this._handlersById[handlerName] = handler;\n  }\n  stop(allowEndAnimation) {\n    // do nothing if this method was triggered by a gesture update\n    if (this._updatingCamera) return;\n    for (const {\n      handler\n    } of this._handlers) {\n      handler.reset();\n    }\n    this._inertia.clear();\n    this._fireEvents({}, {}, allowEndAnimation);\n    this._changes = [];\n  }\n  isActive() {\n    for (const {\n      handler\n    } of this._handlers) {\n      if (handler.isActive()) return true;\n    }\n    return false;\n  }\n  isZooming() {\n    return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();\n  }\n  isRotating() {\n    return !!this._eventsInProgress.rotate;\n  }\n  isMoving() {\n    return Boolean(isMoving(this._eventsInProgress)) || this.isZooming();\n  }\n  _blockedByActive(activeHandlers, allowed, myName) {\n    for (const name in activeHandlers) {\n      if (name === myName) continue;\n      if (!allowed || allowed.indexOf(name) < 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _getMapTouches(touches) {\n    const mapTouches = [];\n    for (const t of touches) {\n      const target = t.target;\n      if (this._el.contains(target)) {\n        mapTouches.push(t);\n      }\n    }\n    return mapTouches;\n  }\n  mergeHandlerResult(mergedHandlerResult, eventsInProgress, handlerResult, name, e) {\n    if (!handlerResult) return;\n    extend(mergedHandlerResult, handlerResult);\n    const eventData = {\n      handlerName: name,\n      originalEvent: handlerResult.originalEvent || e\n    };\n\n    // track which handler changed which camera property\n    if (handlerResult.zoomDelta !== undefined) {\n      eventsInProgress.zoom = eventData;\n    }\n    if (handlerResult.panDelta !== undefined) {\n      eventsInProgress.drag = eventData;\n    }\n    if (handlerResult.pitchDelta !== undefined) {\n      eventsInProgress.pitch = eventData;\n    }\n    if (handlerResult.bearingDelta !== undefined) {\n      eventsInProgress.rotate = eventData;\n    }\n  }\n  _applyChanges() {\n    const combined = {};\n    const combinedEventsInProgress = {};\n    const combinedDeactivatedHandlers = {};\n    for (const [change, eventsInProgress, deactivatedHandlers] of this._changes) {\n      if (change.panDelta) combined.panDelta = (combined.panDelta || new Point(0, 0))._add(change.panDelta);\n      if (change.zoomDelta) combined.zoomDelta = (combined.zoomDelta || 0) + change.zoomDelta;\n      if (change.bearingDelta) combined.bearingDelta = (combined.bearingDelta || 0) + change.bearingDelta;\n      if (change.pitchDelta) combined.pitchDelta = (combined.pitchDelta || 0) + change.pitchDelta;\n      if (change.around !== undefined) combined.around = change.around;\n      if (change.pinchAround !== undefined) combined.pinchAround = change.pinchAround;\n      if (change.noInertia) combined.noInertia = change.noInertia;\n      extend(combinedEventsInProgress, eventsInProgress);\n      extend(combinedDeactivatedHandlers, deactivatedHandlers);\n    }\n    this._updateMapTransform(combined, combinedEventsInProgress, combinedDeactivatedHandlers);\n    this._changes = [];\n  }\n  _updateMapTransform(combinedResult, combinedEventsInProgress, deactivatedHandlers) {\n    const map = this._map;\n    const tr = map._getTransformForUpdate();\n    if (!hasChange(combinedResult)) {\n      return this._fireEvents(combinedEventsInProgress, deactivatedHandlers, true);\n    }\n    const {\n      panDelta,\n      zoomDelta,\n      bearingDelta,\n      pitchDelta,\n      pinchAround\n    } = combinedResult;\n    let {\n      around\n    } = combinedResult;\n    if (pinchAround !== undefined) {\n      around = pinchAround;\n    }\n\n    // stop any ongoing camera animations (easeTo, flyTo)\n    map._stop(true);\n    around = around || map.transform.centerPoint;\n    const loc = tr.pointLocation(panDelta ? around.sub(panDelta) : around);\n    if (bearingDelta) tr.bearing += bearingDelta;\n    if (pitchDelta) tr.pitch += pitchDelta;\n    if (zoomDelta) tr.zoom += zoomDelta;\n    tr.setLocationAtPoint(loc, around);\n    map._applyUpdatedTransform(tr);\n    this._map._update();\n    if (!combinedResult.noInertia) this._inertia.record(combinedResult);\n    this._fireEvents(combinedEventsInProgress, deactivatedHandlers, true);\n  }\n  _fireEvents(newEventsInProgress, deactivatedHandlers, allowEndAnimation) {\n    const wasMoving = isMoving(this._eventsInProgress);\n    const nowMoving = isMoving(newEventsInProgress);\n    const startEvents = {};\n    for (const eventName in newEventsInProgress) {\n      const {\n        originalEvent\n      } = newEventsInProgress[eventName];\n      if (!this._eventsInProgress[eventName]) {\n        startEvents[`${eventName}start`] = originalEvent;\n      }\n      this._eventsInProgress[eventName] = newEventsInProgress[eventName];\n    }\n\n    // fire start events only after this._eventsInProgress has been updated\n    if (!wasMoving && nowMoving) {\n      this._fireEvent('movestart', nowMoving.originalEvent);\n    }\n    for (const name in startEvents) {\n      this._fireEvent(name, startEvents[name]);\n    }\n    if (nowMoving) {\n      this._fireEvent('move', nowMoving.originalEvent);\n    }\n    for (const eventName in newEventsInProgress) {\n      const {\n        originalEvent\n      } = newEventsInProgress[eventName];\n      this._fireEvent(eventName, originalEvent);\n    }\n    const endEvents = {};\n    let originalEndEvent;\n    for (const eventName in this._eventsInProgress) {\n      const {\n        handlerName,\n        originalEvent\n      } = this._eventsInProgress[eventName];\n      if (!this._handlersById[handlerName].isActive()) {\n        delete this._eventsInProgress[eventName];\n        originalEndEvent = deactivatedHandlers[handlerName] || originalEvent;\n        endEvents[`${eventName}end`] = originalEndEvent;\n      }\n    }\n    for (const name in endEvents) {\n      this._fireEvent(name, endEvents[name]);\n    }\n    const stillMoving = isMoving(this._eventsInProgress);\n    const finishedMoving = (wasMoving || nowMoving) && !stillMoving;\n    if (allowEndAnimation && finishedMoving) {\n      this._updatingCamera = true;\n      const inertialEase = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions);\n      const shouldSnapToNorth = bearing => bearing !== 0 && -this._bearingSnap < bearing && bearing < this._bearingSnap;\n      if (inertialEase && (inertialEase.essential || !browser.prefersReducedMotion)) {\n        if (shouldSnapToNorth(inertialEase.bearing || this._map.getBearing())) {\n          inertialEase.bearing = 0;\n        }\n        inertialEase.freezeElevation = true;\n        this._map.easeTo(inertialEase, {\n          originalEvent: originalEndEvent\n        });\n      } else {\n        this._map.fire(new Event('moveend', {\n          originalEvent: originalEndEvent\n        }));\n        if (shouldSnapToNorth(this._map.getBearing())) {\n          this._map.resetNorth();\n        }\n      }\n      this._updatingCamera = false;\n    }\n  }\n  _fireEvent(type, e) {\n    this._map.fire(new Event(type, e ? {\n      originalEvent: e\n    } : {}));\n  }\n  _requestFrame() {\n    this._map.triggerRepaint();\n    return this._map._renderTaskQueue.add(timeStamp => {\n      delete this._frameId;\n      this.handleEvent(new RenderFrameEvent('renderFrame', timeStamp));\n      this._applyChanges();\n    });\n  }\n  _triggerRenderFrame() {\n    if (this._frameId === undefined) {\n      this._frameId = this._requestFrame();\n    }\n  }\n}","map":{"version":3,"names":["_defineProperty","Point","BoxZoomHandler","ClickZoomHandler","CooperativeGesturesHandler","KeyboardHandler","BlockableMapEventHandler","MapEventHandler","generateMousePanHandler","generateMousePitchHandler","generateMouseRotationHandler","ScrollZoomHandler","DoubleClickZoomHandler","DragPanHandler","DragRotateHandler","TwoFingersTouchZoomRotateHandler","TapDragZoomHandler","TapZoomHandler","TouchPanHandler","TwoFingersTouchPitchHandler","TwoFingersTouchRotateHandler","TwoFingersTouchZoomHandler","HandlerInertia","browser","DOM","Event","extend","isMoving","p","zoom","drag","pitch","rotate","RenderFrameEvent","constructor","type","timeStamp","hasChange","result","panDelta","mag","zoomDelta","bearingDelta","pitchDelta","HandlerManager","map","options","e","handleEvent","eventName","stop","_updatingCamera","inputEvent","undefined","mergedHandlerResult","needsRenderFrame","eventsInProgress","activeHandlers","eventTouches","touches","mapTouches","_getMapTouches","points","touchPos","_map","getCanvasContainer","mousePos","handlerName","handler","allowed","_handlers","isEnabled","data","_blockedByActive","reset","mergeHandlerResult","_triggerRenderFrame","isActive","deactivatedHandlers","name","_previousActiveHandlers","Object","keys","length","_changes","push","_stop","cameraAnimation","_inertia","clear","_fireEvents","_el","_handlersById","_bearingSnap","bearingSnap","_eventsInProgress","_addDefaultHandlers","el","_listeners","passive","document","capture","window","target","listenerOptions","addEventListener","handleWindowEvent","destroy","removeEventListener","_add","boxZoom","interactive","enable","cooperativeGestures","tapZoom","clickZoom","doubleClickZoom","tapDragZoom","touchPitch","mouseRotate","mousePitch","dragRotate","mousePan","touchPan","dragPan","touchRotate","touchZoom","touchZoomRotate","scrollZoom","keyboard","allowEndAnimation","isZooming","isRotating","Boolean","myName","indexOf","t","contains","handlerResult","eventData","originalEvent","_applyChanges","combined","combinedEventsInProgress","combinedDeactivatedHandlers","change","around","pinchAround","noInertia","_updateMapTransform","combinedResult","tr","_getTransformForUpdate","transform","centerPoint","loc","pointLocation","sub","bearing","setLocationAtPoint","_applyUpdatedTransform","_update","record","newEventsInProgress","wasMoving","nowMoving","startEvents","_fireEvent","endEvents","originalEndEvent","stillMoving","finishedMoving","inertialEase","_onMoveEnd","_inertiaOptions","shouldSnapToNorth","essential","prefersReducedMotion","getBearing","freezeElevation","easeTo","fire","resetNorth","_requestFrame","triggerRepaint","_renderTaskQueue","add","_frameId"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/l7-map/es/map/handler_manager.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport Point from '@mapbox/point-geometry';\nimport { BoxZoomHandler } from \"./handler/box_zoom\";\nimport { ClickZoomHandler } from \"./handler/click_zoom\";\nimport { CooperativeGesturesHandler } from \"./handler/cooperative_gestures\";\nimport { KeyboardHandler } from \"./handler/keyboard\";\nimport { BlockableMapEventHandler, MapEventHandler } from \"./handler/map_event\";\nimport { generateMousePanHandler, generateMousePitchHandler, generateMouseRotationHandler } from \"./handler/mouse\";\nimport { ScrollZoomHandler } from \"./handler/scroll_zoom\";\nimport { DoubleClickZoomHandler } from \"./handler/shim/dblclick_zoom\";\nimport { DragPanHandler } from \"./handler/shim/drag_pan\";\nimport { DragRotateHandler } from \"./handler/shim/drag_rotate\";\nimport { TwoFingersTouchZoomRotateHandler } from \"./handler/shim/two_fingers_touch\";\nimport { TapDragZoomHandler } from \"./handler/tap_drag_zoom\";\nimport { TapZoomHandler } from \"./handler/tap_zoom\";\nimport { TouchPanHandler } from \"./handler/touch_pan\";\nimport { TwoFingersTouchPitchHandler, TwoFingersTouchRotateHandler, TwoFingersTouchZoomHandler } from \"./handler/two_fingers_touch\";\nimport { HandlerInertia } from \"./handler_inertia\";\nimport { browser } from \"./util/browser\";\nimport { DOM } from \"./util/dom\";\nimport { Event } from \"./util/evented\";\nimport { extend } from \"./util/util\";\nconst isMoving = p => p.zoom || p.drag || p.pitch || p.rotate;\nclass RenderFrameEvent extends Event {\n  constructor(type, timeStamp) {\n    super(type);\n    _defineProperty(this, \"type\", 'renderFrame');\n    _defineProperty(this, \"timeStamp\", void 0);\n    this.timeStamp = timeStamp;\n  }\n}\n\n/**\n * Handlers interpret dom events and return camera changes that should be\n * applied to the map (`HandlerResult`s). The camera changes are all deltas.\n * The handler itself should have no knowledge of the map's current state.\n * This makes it easier to merge multiple results and keeps handlers simpler.\n * For example, if there is a mousedown and mousemove, the mousePan handler\n * would return a `panDelta` on the mousemove.\n */\n\n/**\n * All handler methods that are called with events can optionally return a `HandlerResult`.\n */\n\nfunction hasChange(result) {\n  return result.panDelta && result.panDelta.mag() || result.zoomDelta || result.bearingDelta || result.pitchDelta;\n}\nexport class HandlerManager {\n  constructor(map, options) {\n    _defineProperty(this, \"_map\", void 0);\n    _defineProperty(this, \"_el\", void 0);\n    _defineProperty(this, \"_handlers\", void 0);\n    _defineProperty(this, \"_eventsInProgress\", void 0);\n    _defineProperty(this, \"_frameId\", void 0);\n    _defineProperty(this, \"_inertia\", void 0);\n    _defineProperty(this, \"_bearingSnap\", void 0);\n    _defineProperty(this, \"_handlersById\", void 0);\n    _defineProperty(this, \"_updatingCamera\", void 0);\n    _defineProperty(this, \"_changes\", void 0);\n    _defineProperty(this, \"_zoom\", void 0);\n    _defineProperty(this, \"_previousActiveHandlers\", void 0);\n    _defineProperty(this, \"_listeners\", void 0);\n    _defineProperty(this, \"handleWindowEvent\", e => {\n      this.handleEvent(e, `${e.type}Window`);\n    });\n    _defineProperty(this, \"handleEvent\", (e, eventName) => {\n      if (e.type === 'blur') {\n        this.stop(true);\n        return;\n      }\n      this._updatingCamera = true;\n      const inputEvent = e.type === 'renderFrame' ? undefined : e;\n\n      /*\n       * We don't call e.preventDefault() for any events by default.\n       * Handlers are responsible for calling it where necessary.\n       */\n\n      const mergedHandlerResult = {\n        needsRenderFrame: false\n      };\n      const eventsInProgress = {};\n      const activeHandlers = {};\n      const eventTouches = e.touches;\n      const mapTouches = eventTouches ? this._getMapTouches(eventTouches) : undefined;\n      const points = mapTouches ? DOM.touchPos(this._map.getCanvasContainer(), mapTouches) : DOM.mousePos(this._map.getCanvasContainer(), e);\n      for (const {\n        handlerName,\n        handler,\n        allowed\n      } of this._handlers) {\n        if (!handler.isEnabled()) continue;\n        let data;\n        if (this._blockedByActive(activeHandlers, allowed, handlerName)) {\n          handler.reset();\n        } else {\n          if (handler[eventName || e.type]) {\n            data = handler[eventName || e.type](e, points, mapTouches);\n            this.mergeHandlerResult(mergedHandlerResult, eventsInProgress, data, handlerName, inputEvent);\n            if (data && data.needsRenderFrame) {\n              this._triggerRenderFrame();\n            }\n          }\n        }\n        if (data || handler.isActive()) {\n          activeHandlers[handlerName] = handler;\n        }\n      }\n      const deactivatedHandlers = {};\n      for (const name in this._previousActiveHandlers) {\n        if (!activeHandlers[name]) {\n          deactivatedHandlers[name] = inputEvent;\n        }\n      }\n      this._previousActiveHandlers = activeHandlers;\n      if (Object.keys(deactivatedHandlers).length || hasChange(mergedHandlerResult)) {\n        this._changes.push([mergedHandlerResult, eventsInProgress, deactivatedHandlers]);\n        this._triggerRenderFrame();\n      }\n      if (Object.keys(activeHandlers).length || hasChange(mergedHandlerResult)) {\n        this._map._stop(true);\n      }\n      this._updatingCamera = false;\n      const {\n        cameraAnimation\n      } = mergedHandlerResult;\n      if (cameraAnimation) {\n        this._inertia.clear();\n        this._fireEvents({}, {}, true);\n        this._changes = [];\n        cameraAnimation(this._map);\n      }\n    });\n    this._map = map;\n    this._el = this._map.getCanvasContainer();\n    this._handlers = [];\n    this._handlersById = {};\n    this._changes = [];\n    this._inertia = new HandlerInertia(map);\n    this._bearingSnap = options.bearingSnap || 7;\n    this._previousActiveHandlers = {};\n\n    // Track whether map is currently moving, to compute start/move/end events\n    this._eventsInProgress = {};\n    this._addDefaultHandlers(options);\n    const el = this._el;\n    this._listeners = [\n    // This needs to be `passive: true` so that a double tap fires two\n    // pairs of touchstart/end events in iOS Safari 13. If this is set to\n    // `passive: false` then the second pair of events is only fired if\n    // preventDefault() is called on the first touchstart. Calling preventDefault()\n    // undesirably prevents click events.\n    [el, 'touchstart', {\n      passive: true\n    }],\n    // This needs to be `passive: false` so that scrolls and pinches can be\n    // prevented in browsers that don't support `touch-actions: none`, for example iOS Safari 12.\n    [el, 'touchmove', {\n      passive: false\n    }], [el, 'touchend', undefined], [el, 'touchcancel', undefined], [el, 'mousedown', undefined], [el, 'mousemove', undefined], [el, 'mouseup', undefined],\n    // Bind window-level event listeners for move and up/end events. In the absence of\n    // the pointer capture API, which is not supported by all necessary platforms,\n    // window-level event listeners give us the best shot at capturing events that\n    // fall outside the map canvas element. Use `{capture: true}` for the move event\n    // to prevent map move events from being fired during a drag.\n    [document, 'mousemove', {\n      capture: true\n    }], [document, 'mouseup', undefined], [el, 'mouseover', undefined], [el, 'mouseout', undefined], [el, 'dblclick', undefined], [el, 'click', undefined], [el, 'keydown', {\n      capture: false\n    }], [el, 'keyup', undefined], [el, 'wheel', {\n      passive: false\n    }], [el, 'contextmenu', undefined], [window, 'blur', undefined]];\n    for (const [target, type, listenerOptions] of this._listeners) {\n      DOM.addEventListener(target, type, target === document ? this.handleWindowEvent : this.handleEvent, listenerOptions);\n    }\n  }\n  destroy() {\n    for (const [target, type, listenerOptions] of this._listeners) {\n      DOM.removeEventListener(target, type, target === document ? this.handleWindowEvent : this.handleEvent, listenerOptions);\n    }\n  }\n  _addDefaultHandlers(options) {\n    const map = this._map;\n    const el = map.getCanvasContainer();\n    this._add('mapEvent', new MapEventHandler(map, options));\n    const boxZoom = map.boxZoom = new BoxZoomHandler(map, options);\n    this._add('boxZoom', boxZoom);\n    if (options.interactive && options.boxZoom) {\n      boxZoom.enable();\n    }\n    const cooperativeGestures = map.cooperativeGestures = new CooperativeGesturesHandler(map, options.cooperativeGestures);\n    this._add('cooperativeGestures', cooperativeGestures);\n    if (options.cooperativeGestures) {\n      cooperativeGestures.enable();\n    }\n    const tapZoom = new TapZoomHandler(map);\n    const clickZoom = new ClickZoomHandler(map);\n    map.doubleClickZoom = new DoubleClickZoomHandler(clickZoom, tapZoom);\n    this._add('tapZoom', tapZoom);\n    this._add('clickZoom', clickZoom);\n    if (options.interactive && options.doubleClickZoom) {\n      map.doubleClickZoom.enable();\n    }\n    const tapDragZoom = new TapDragZoomHandler();\n    this._add('tapDragZoom', tapDragZoom);\n    const touchPitch = map.touchPitch = new TwoFingersTouchPitchHandler(map);\n    this._add('touchPitch', touchPitch);\n    if (options.interactive && options.touchPitch) {\n      map.touchPitch.enable(options.touchPitch);\n    }\n    const mouseRotate = generateMouseRotationHandler(options);\n    const mousePitch = generateMousePitchHandler(options);\n    map.dragRotate = new DragRotateHandler(options, mouseRotate, mousePitch);\n    this._add('mouseRotate', mouseRotate, ['mousePitch']);\n    this._add('mousePitch', mousePitch, ['mouseRotate']);\n    if (options.interactive && options.dragRotate) {\n      map.dragRotate.enable();\n    }\n    const mousePan = generateMousePanHandler(options);\n    const touchPan = new TouchPanHandler(options, map);\n    map.dragPan = new DragPanHandler(el, mousePan, touchPan);\n    this._add('mousePan', mousePan);\n    this._add('touchPan', touchPan, ['touchZoom', 'touchRotate']);\n    if (options.interactive && options.dragPan) {\n      map.dragPan.enable(options.dragPan);\n    }\n    const touchRotate = new TwoFingersTouchRotateHandler();\n    const touchZoom = new TwoFingersTouchZoomHandler();\n    map.touchZoomRotate = new TwoFingersTouchZoomRotateHandler(el, touchZoom, touchRotate, tapDragZoom);\n    this._add('touchRotate', touchRotate, ['touchPan', 'touchZoom']);\n    this._add('touchZoom', touchZoom, ['touchPan', 'touchRotate']);\n    if (options.interactive && options.touchZoomRotate) {\n      map.touchZoomRotate.enable(options.touchZoomRotate);\n    }\n    const scrollZoom = map.scrollZoom = new ScrollZoomHandler(map, () => this._triggerRenderFrame());\n    this._add('scrollZoom', scrollZoom, ['mousePan']);\n    if (options.interactive && options.scrollZoom) {\n      map.scrollZoom.enable(options.scrollZoom);\n    }\n    const keyboard = map.keyboard = new KeyboardHandler(map);\n    this._add('keyboard', keyboard);\n    if (options.interactive && options.keyboard) {\n      map.keyboard.enable();\n    }\n    this._add('blockableMapEvent', new BlockableMapEventHandler(map));\n  }\n  _add(handlerName, handler, allowed) {\n    this._handlers.push({\n      handlerName,\n      handler,\n      allowed\n    });\n    this._handlersById[handlerName] = handler;\n  }\n  stop(allowEndAnimation) {\n    // do nothing if this method was triggered by a gesture update\n    if (this._updatingCamera) return;\n    for (const {\n      handler\n    } of this._handlers) {\n      handler.reset();\n    }\n    this._inertia.clear();\n    this._fireEvents({}, {}, allowEndAnimation);\n    this._changes = [];\n  }\n  isActive() {\n    for (const {\n      handler\n    } of this._handlers) {\n      if (handler.isActive()) return true;\n    }\n    return false;\n  }\n  isZooming() {\n    return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();\n  }\n  isRotating() {\n    return !!this._eventsInProgress.rotate;\n  }\n  isMoving() {\n    return Boolean(isMoving(this._eventsInProgress)) || this.isZooming();\n  }\n  _blockedByActive(activeHandlers, allowed, myName) {\n    for (const name in activeHandlers) {\n      if (name === myName) continue;\n      if (!allowed || allowed.indexOf(name) < 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _getMapTouches(touches) {\n    const mapTouches = [];\n    for (const t of touches) {\n      const target = t.target;\n      if (this._el.contains(target)) {\n        mapTouches.push(t);\n      }\n    }\n    return mapTouches;\n  }\n  mergeHandlerResult(mergedHandlerResult, eventsInProgress, handlerResult, name, e) {\n    if (!handlerResult) return;\n    extend(mergedHandlerResult, handlerResult);\n    const eventData = {\n      handlerName: name,\n      originalEvent: handlerResult.originalEvent || e\n    };\n\n    // track which handler changed which camera property\n    if (handlerResult.zoomDelta !== undefined) {\n      eventsInProgress.zoom = eventData;\n    }\n    if (handlerResult.panDelta !== undefined) {\n      eventsInProgress.drag = eventData;\n    }\n    if (handlerResult.pitchDelta !== undefined) {\n      eventsInProgress.pitch = eventData;\n    }\n    if (handlerResult.bearingDelta !== undefined) {\n      eventsInProgress.rotate = eventData;\n    }\n  }\n  _applyChanges() {\n    const combined = {};\n    const combinedEventsInProgress = {};\n    const combinedDeactivatedHandlers = {};\n    for (const [change, eventsInProgress, deactivatedHandlers] of this._changes) {\n      if (change.panDelta) combined.panDelta = (combined.panDelta || new Point(0, 0))._add(change.panDelta);\n      if (change.zoomDelta) combined.zoomDelta = (combined.zoomDelta || 0) + change.zoomDelta;\n      if (change.bearingDelta) combined.bearingDelta = (combined.bearingDelta || 0) + change.bearingDelta;\n      if (change.pitchDelta) combined.pitchDelta = (combined.pitchDelta || 0) + change.pitchDelta;\n      if (change.around !== undefined) combined.around = change.around;\n      if (change.pinchAround !== undefined) combined.pinchAround = change.pinchAround;\n      if (change.noInertia) combined.noInertia = change.noInertia;\n      extend(combinedEventsInProgress, eventsInProgress);\n      extend(combinedDeactivatedHandlers, deactivatedHandlers);\n    }\n    this._updateMapTransform(combined, combinedEventsInProgress, combinedDeactivatedHandlers);\n    this._changes = [];\n  }\n  _updateMapTransform(combinedResult, combinedEventsInProgress, deactivatedHandlers) {\n    const map = this._map;\n    const tr = map._getTransformForUpdate();\n    if (!hasChange(combinedResult)) {\n      return this._fireEvents(combinedEventsInProgress, deactivatedHandlers, true);\n    }\n    const {\n      panDelta,\n      zoomDelta,\n      bearingDelta,\n      pitchDelta,\n      pinchAround\n    } = combinedResult;\n    let {\n      around\n    } = combinedResult;\n    if (pinchAround !== undefined) {\n      around = pinchAround;\n    }\n\n    // stop any ongoing camera animations (easeTo, flyTo)\n    map._stop(true);\n    around = around || map.transform.centerPoint;\n    const loc = tr.pointLocation(panDelta ? around.sub(panDelta) : around);\n    if (bearingDelta) tr.bearing += bearingDelta;\n    if (pitchDelta) tr.pitch += pitchDelta;\n    if (zoomDelta) tr.zoom += zoomDelta;\n    tr.setLocationAtPoint(loc, around);\n    map._applyUpdatedTransform(tr);\n    this._map._update();\n    if (!combinedResult.noInertia) this._inertia.record(combinedResult);\n    this._fireEvents(combinedEventsInProgress, deactivatedHandlers, true);\n  }\n  _fireEvents(newEventsInProgress, deactivatedHandlers, allowEndAnimation) {\n    const wasMoving = isMoving(this._eventsInProgress);\n    const nowMoving = isMoving(newEventsInProgress);\n    const startEvents = {};\n    for (const eventName in newEventsInProgress) {\n      const {\n        originalEvent\n      } = newEventsInProgress[eventName];\n      if (!this._eventsInProgress[eventName]) {\n        startEvents[`${eventName}start`] = originalEvent;\n      }\n      this._eventsInProgress[eventName] = newEventsInProgress[eventName];\n    }\n\n    // fire start events only after this._eventsInProgress has been updated\n    if (!wasMoving && nowMoving) {\n      this._fireEvent('movestart', nowMoving.originalEvent);\n    }\n    for (const name in startEvents) {\n      this._fireEvent(name, startEvents[name]);\n    }\n    if (nowMoving) {\n      this._fireEvent('move', nowMoving.originalEvent);\n    }\n    for (const eventName in newEventsInProgress) {\n      const {\n        originalEvent\n      } = newEventsInProgress[eventName];\n      this._fireEvent(eventName, originalEvent);\n    }\n    const endEvents = {};\n    let originalEndEvent;\n    for (const eventName in this._eventsInProgress) {\n      const {\n        handlerName,\n        originalEvent\n      } = this._eventsInProgress[eventName];\n      if (!this._handlersById[handlerName].isActive()) {\n        delete this._eventsInProgress[eventName];\n        originalEndEvent = deactivatedHandlers[handlerName] || originalEvent;\n        endEvents[`${eventName}end`] = originalEndEvent;\n      }\n    }\n    for (const name in endEvents) {\n      this._fireEvent(name, endEvents[name]);\n    }\n    const stillMoving = isMoving(this._eventsInProgress);\n    const finishedMoving = (wasMoving || nowMoving) && !stillMoving;\n    if (allowEndAnimation && finishedMoving) {\n      this._updatingCamera = true;\n      const inertialEase = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions);\n      const shouldSnapToNorth = bearing => bearing !== 0 && -this._bearingSnap < bearing && bearing < this._bearingSnap;\n      if (inertialEase && (inertialEase.essential || !browser.prefersReducedMotion)) {\n        if (shouldSnapToNorth(inertialEase.bearing || this._map.getBearing())) {\n          inertialEase.bearing = 0;\n        }\n        inertialEase.freezeElevation = true;\n        this._map.easeTo(inertialEase, {\n          originalEvent: originalEndEvent\n        });\n      } else {\n        this._map.fire(new Event('moveend', {\n          originalEvent: originalEndEvent\n        }));\n        if (shouldSnapToNorth(this._map.getBearing())) {\n          this._map.resetNorth();\n        }\n      }\n      this._updatingCamera = false;\n    }\n  }\n  _fireEvent(type, e) {\n    this._map.fire(new Event(type, e ? {\n      originalEvent: e\n    } : {}));\n  }\n  _requestFrame() {\n    this._map.triggerRepaint();\n    return this._map._renderTaskQueue.add(timeStamp => {\n      delete this._frameId;\n      this.handleEvent(new RenderFrameEvent('renderFrame', timeStamp));\n      this._applyChanges();\n    });\n  }\n  _triggerRenderFrame() {\n    if (this._frameId === undefined) {\n      this._frameId = this._requestFrame();\n    }\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}