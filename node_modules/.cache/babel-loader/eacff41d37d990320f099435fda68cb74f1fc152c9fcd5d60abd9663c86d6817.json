{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Platform, NumberExt, ObjectExt, Dom, FunctionExt } from '../../util';\nimport { Point, Rectangle } from '../../geometry';\nimport { View } from '../../view/view';\nimport { Renderer } from '../../graph/renderer';\nimport { GraphView } from '../../graph/view';\nimport { BackgroundManager } from '../../graph/background';\nexport class Scroller extends View {\n  constructor(options) {\n    super();\n    this.padding = {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0\n    };\n    this.options = Util.getOptions(options);\n    const scale = this.graph.transform.getScale();\n    this.sx = scale.sx;\n    this.sy = scale.sy;\n    const width = this.options.width || this.graph.options.width;\n    const height = this.options.height || this.graph.options.height;\n    this.container = document.createElement('div');\n    this.$container = this.$(this.container).addClass(this.prefixClassName(Util.containerClass)).css({\n      width,\n      height\n    });\n    if (this.options.pageVisible) {\n      this.$container.addClass(this.prefixClassName(Util.pagedClass));\n    }\n    if (this.options.className) {\n      this.$container.addClass(this.options.className);\n    }\n    const graphContainer = this.graph.container;\n    if (graphContainer.parentNode) {\n      this.$container.insertBefore(graphContainer);\n    }\n    // copy style\n    const style = graphContainer.getAttribute('style');\n    if (style) {\n      const obj = {};\n      const styles = style.split(';');\n      styles.forEach(item => {\n        const section = item.trim();\n        if (section) {\n          const pair = section.split(':');\n          if (pair.length) {\n            obj[pair[0].trim()] = pair[1] ? pair[1].trim() : '';\n          }\n        }\n      });\n      Object.keys(obj).forEach(key => {\n        if (key === 'width' || key === 'height') {\n          return;\n        }\n        graphContainer.style[key] = '';\n        this.container.style[key] = obj[key];\n      });\n    }\n    this.content = document.createElement('div');\n    this.$content = this.$(this.content).addClass(this.prefixClassName(Util.contentClass)).css({\n      width: this.graph.options.width,\n      height: this.graph.options.height\n    });\n    // custom background\n    this.background = document.createElement('div');\n    this.$background = this.$(this.background).addClass(this.prefixClassName(Util.backgroundClass));\n    this.$content.append(this.background);\n    if (!this.options.pageVisible) {\n      this.$content.append(this.graph.view.grid);\n    }\n    this.$content.append(graphContainer);\n    this.$content.appendTo(this.container);\n    this.startListening();\n    if (!this.options.pageVisible) {\n      this.graph.grid.update();\n    }\n    this.backgroundManager = new Scroller.Background(this);\n    if (!this.options.autoResize) {\n      this.update();\n    }\n  }\n  get graph() {\n    return this.options.graph;\n  }\n  get model() {\n    return this.graph.model;\n  }\n  startListening() {\n    const graph = this.graph;\n    const model = this.model;\n    graph.on('scale', this.onScale, this);\n    graph.on('resize', this.onResize, this);\n    graph.on('before:print', this.storeScrollPosition, this);\n    graph.on('before:export', this.storeScrollPosition, this);\n    graph.on('after:print', this.restoreScrollPosition, this);\n    graph.on('after:export', this.restoreScrollPosition, this);\n    graph.on('render:done', this.onRenderDone, this);\n    graph.on('unfreeze', this.onUpdate, this);\n    model.on('reseted', this.onUpdate, this);\n    model.on('cell:added', this.onUpdate, this);\n    model.on('cell:removed', this.onUpdate, this);\n    model.on('cell:changed', this.onUpdate, this);\n    model.on('batch:stop', this.onBatchStop, this);\n    this.delegateBackgroundEvents();\n  }\n  stopListening() {\n    const graph = this.graph;\n    const model = this.model;\n    graph.off('scale', this.onScale, this);\n    graph.off('resize', this.onResize, this);\n    graph.off('beforeprint', this.storeScrollPosition, this);\n    graph.off('beforeexport', this.storeScrollPosition, this);\n    graph.off('afterprint', this.restoreScrollPosition, this);\n    graph.off('afterexport', this.restoreScrollPosition, this);\n    graph.off('render:done', this.onRenderDone, this);\n    graph.off('unfreeze', this.onUpdate, this);\n    model.off('reseted', this.onUpdate, this);\n    model.off('cell:added', this.onUpdate, this);\n    model.off('cell:removed', this.onUpdate, this);\n    model.off('cell:changed', this.onUpdate, this);\n    model.off('batch:stop', this.onBatchStop, this);\n    this.undelegateBackgroundEvents();\n  }\n  enableAutoResize() {\n    this.options.autoResize = true;\n  }\n  disableAutoResize() {\n    this.options.autoResize = false;\n  }\n  onUpdate() {\n    if (this.graph.isAsync() || !this.options.autoResize) {\n      return;\n    }\n    this.update();\n  }\n  onBatchStop(args) {\n    if (this.graph.isAsync() || !this.options.autoResize) {\n      return;\n    }\n    if (Renderer.UPDATE_DELAYING_BATCHES.includes(args.name)) {\n      this.update();\n    }\n  }\n  delegateBackgroundEvents(events) {\n    const evts = events || GraphView.events;\n    this.delegatedHandlers = Object.keys(evts).reduce((memo, name) => {\n      const handler = evts[name];\n      if (name.indexOf(' ') === -1) {\n        if (typeof handler === 'function') {\n          memo[name] = handler;\n        } else {\n          let method = this.graph.view[handler];\n          if (typeof method === 'function') {\n            method = method.bind(this.graph.view);\n            memo[name] = method;\n          }\n        }\n      }\n      return memo;\n    }, {});\n    this.onBackgroundEvent = this.onBackgroundEvent.bind(this);\n    Object.keys(this.delegatedHandlers).forEach(name => {\n      this.delegateEvent(name, {\n        guarded: false\n      }, this.onBackgroundEvent);\n    });\n  }\n  undelegateBackgroundEvents() {\n    Object.keys(this.delegatedHandlers).forEach(name => {\n      this.undelegateEvent(name, this.onBackgroundEvent);\n    });\n  }\n  onBackgroundEvent(e) {\n    let valid = false;\n    const target = e.target;\n    if (!this.options.pageVisible) {\n      const view = this.graph.view;\n      valid = view.background === target || view.grid === target;\n    } else if (this.options.background) {\n      valid = this.background === target;\n    } else {\n      valid = this.content === target;\n    }\n    if (valid) {\n      const handler = this.delegatedHandlers[e.type];\n      if (typeof handler === 'function') {\n        handler.apply(this.graph, arguments); // eslint-disable-line\n      }\n    }\n  }\n  onRenderDone({\n    stats\n  }) {\n    if (this.options.autoResize && stats.priority < 2) {\n      this.update();\n    }\n  }\n  onResize() {\n    if (this.cachedCenterPoint) {\n      this.centerPoint(this.cachedCenterPoint.x, this.cachedCenterPoint.y);\n      this.updatePageBreak();\n    }\n  }\n  onScale({\n    sx,\n    sy,\n    ox,\n    oy\n  }) {\n    this.updateScale(sx, sy);\n    if (ox || oy) {\n      this.centerPoint(ox, oy);\n      this.updatePageBreak();\n    }\n    const autoResizeOptions = this.options.autoResizeOptions || this.options.fitTocontentOptions;\n    if (typeof autoResizeOptions === 'function') {\n      this.update();\n    }\n  }\n  storeScrollPosition() {\n    this.cachedScrollLeft = this.container.scrollLeft;\n    this.cachedScrollTop = this.container.scrollTop;\n  }\n  restoreScrollPosition() {\n    this.container.scrollLeft = this.cachedScrollLeft;\n    this.container.scrollTop = this.cachedScrollTop;\n    this.cachedScrollLeft = null;\n    this.cachedScrollTop = null;\n  }\n  storeClientSize() {\n    this.cachedClientSize = {\n      width: this.container.clientWidth,\n      height: this.container.clientHeight\n    };\n  }\n  restoreClientSize() {\n    this.cachedClientSize = null;\n  }\n  beforeManipulation() {\n    if (Platform.IS_IE || Platform.IS_EDGE) {\n      this.$container.css('visibility', 'hidden');\n    }\n  }\n  afterManipulation() {\n    if (Platform.IS_IE || Platform.IS_EDGE) {\n      this.$container.css('visibility', 'visible');\n    }\n  }\n  updatePageSize(width, height) {\n    if (width != null) {\n      this.options.pageWidth = width;\n    }\n    if (height != null) {\n      this.options.pageHeight = height;\n    }\n    this.updatePageBreak();\n  }\n  updatePageBreak() {\n    if (this.pageBreak && this.pageBreak.parentNode) {\n      this.pageBreak.parentNode.removeChild(this.pageBreak);\n    }\n    this.pageBreak = null;\n    if (this.options.pageVisible && this.options.pageBreak) {\n      const graphWidth = this.graph.options.width;\n      const graphHeight = this.graph.options.height;\n      const pageWidth = this.options.pageWidth * this.sx;\n      const pageHeight = this.options.pageHeight * this.sy;\n      if (pageWidth === 0 || pageHeight === 0) {\n        return;\n      }\n      if (graphWidth > pageWidth || graphHeight > pageHeight) {\n        let hasPageBreak = false;\n        const container = document.createElement('div');\n        for (let i = 1, l = Math.floor(graphWidth / pageWidth); i < l; i += 1) {\n          this.$('<div/>').addClass(this.prefixClassName(`graph-pagebreak-vertical`)).css({\n            left: i * pageWidth\n          }).appendTo(container);\n          hasPageBreak = true;\n        }\n        for (let i = 1, l = Math.floor(graphHeight / pageHeight); i < l; i += 1) {\n          this.$('<div/>').addClass(this.prefixClassName(`graph-pagebreak-horizontal`)).css({\n            top: i * pageHeight\n          }).appendTo(container);\n          hasPageBreak = true;\n        }\n        if (hasPageBreak) {\n          Dom.addClass(container, this.prefixClassName('graph-pagebreak'));\n          this.$(this.graph.view.grid).after(container);\n          this.pageBreak = container;\n        }\n      }\n    }\n  }\n  update() {\n    const size = this.getClientSize();\n    this.cachedCenterPoint = this.clientToLocalPoint(size.width / 2, size.height / 2);\n    let resizeOptions = this.options.autoResizeOptions || this.options.fitTocontentOptions;\n    if (typeof resizeOptions === 'function') {\n      resizeOptions = FunctionExt.call(resizeOptions, this, this);\n    }\n    const options = Object.assign({\n      gridWidth: this.options.pageWidth,\n      gridHeight: this.options.pageHeight,\n      allowNewOrigin: 'negative',\n      contentArea: this.calcContextArea(resizeOptions)\n    }, resizeOptions);\n    this.graph.fitToContent(this.getFitToContentOptions(options));\n  }\n  calcContextArea(resizeOptions) {\n    const direction = resizeOptions === null || resizeOptions === void 0 ? void 0 : resizeOptions.direction;\n    if (!direction) {\n      return this.graph.transform.getContentArea(resizeOptions);\n    }\n    function getCellBBox(cell) {\n      let rect = cell.getBBox();\n      if (rect) {\n        if (cell.isNode()) {\n          const angle = cell.getAngle();\n          if (angle != null && angle !== 0) {\n            rect = rect.bbox(angle);\n          }\n        }\n      }\n      return rect;\n    }\n    const gridWidth = this.options.pageWidth || 1;\n    const gridHeight = this.options.pageHeight || 1;\n    let calculativeCells = this.graph.getCells();\n    if (!direction.includes('top')) {\n      calculativeCells = calculativeCells.filter(cell => {\n        const bbox = getCellBBox(cell);\n        return bbox.y >= 0;\n      });\n    }\n    if (!direction.includes('left')) {\n      calculativeCells = calculativeCells.filter(cell => {\n        const bbox = getCellBBox(cell);\n        return bbox.x >= 0;\n      });\n    }\n    if (!direction.includes('right')) {\n      calculativeCells = calculativeCells.filter(cell => {\n        const bbox = getCellBBox(cell);\n        return bbox.x + bbox.width <= gridWidth;\n      });\n    }\n    if (!direction.includes('bottom')) {\n      calculativeCells = calculativeCells.filter(cell => {\n        const bbox = getCellBBox(cell);\n        return bbox.y + bbox.height <= gridHeight;\n      });\n    }\n    return this.model.getCellsBBox(calculativeCells) || new Rectangle();\n  }\n  getFitToContentOptions(options) {\n    const sx = this.sx;\n    const sy = this.sy;\n    options.gridWidth && (options.gridWidth *= sx);\n    options.gridHeight && (options.gridHeight *= sy);\n    options.minWidth && (options.minWidth *= sx);\n    options.minHeight && (options.minHeight *= sy);\n    if (typeof options.padding === 'object') {\n      options.padding = {\n        left: (options.padding.left || 0) * sx,\n        right: (options.padding.right || 0) * sx,\n        top: (options.padding.top || 0) * sy,\n        bottom: (options.padding.bottom || 0) * sy\n      };\n    } else if (typeof options.padding === 'number') {\n      options.padding *= sx;\n    }\n    if (!this.options.autoResize) {\n      options.contentArea = Rectangle.create();\n    }\n    return options;\n  }\n  updateScale(sx, sy) {\n    const options = this.graph.options;\n    const dx = sx / this.sx;\n    const dy = sy / this.sy;\n    this.sx = sx;\n    this.sy = sy;\n    this.graph.translate(options.x * dx, options.y * dy);\n    this.graph.resizeGraph(options.width * dx, options.height * dy);\n  }\n  scrollbarPosition(left, top, options) {\n    if (left == null && top == null) {\n      return {\n        left: this.container.scrollLeft,\n        top: this.container.scrollTop\n      };\n    }\n    const prop = {};\n    if (typeof left === 'number') {\n      prop.scrollLeft = left;\n    }\n    if (typeof top === 'number') {\n      prop.scrollTop = top;\n    }\n    if (options && options.animation) {\n      this.$container.animate(prop, options.animation);\n    } else {\n      this.$container.prop(prop);\n    }\n    return this;\n  }\n  /**\n   * Try to scroll to ensure that the position (x,y) on the graph (in local\n   * coordinates) is at the center of the viewport. If only one of the\n   * coordinates is specified, only scroll in the specified dimension and\n   * keep the other coordinate unchanged.\n   */\n  scrollToPoint(x, y, options) {\n    const size = this.getClientSize();\n    const ctm = this.graph.matrix();\n    const prop = {};\n    if (typeof x === 'number') {\n      prop.scrollLeft = x - size.width / 2 + ctm.e + (this.padding.left || 0);\n    }\n    if (typeof y === 'number') {\n      prop.scrollTop = y - size.height / 2 + ctm.f + (this.padding.top || 0);\n    }\n    if (options && options.animation) {\n      this.$container.animate(prop, options.animation);\n    } else {\n      this.$container.prop(prop);\n    }\n    return this;\n  }\n  /**\n   * Try to scroll to ensure that the center of graph content is at the\n   * center of the viewport.\n   */\n  scrollToContent(options) {\n    const sx = this.sx;\n    const sy = this.sy;\n    const center = this.graph.getContentArea().getCenter();\n    return this.scrollToPoint(center.x * sx, center.y * sy, options);\n  }\n  /**\n   * Try to scroll to ensure that the center of cell is at the center of\n   * the viewport.\n   */\n  scrollToCell(cell, options) {\n    const sx = this.sx;\n    const sy = this.sy;\n    const center = cell.getBBox().getCenter();\n    return this.scrollToPoint(center.x * sx, center.y * sy, options);\n  }\n  /**\n   * The center methods are more aggressive than the scroll methods. These\n   * methods position the graph so that a specific point on the graph lies\n   * at the center of the viewport, adding paddings around the paper if\n   * necessary (e.g. if the requested point lies in a corner of the paper).\n   * This means that the requested point will always move into the center\n   * of the viewport. (Use the scroll functions to avoid adding paddings\n   * and only scroll the viewport as far as the graph boundary.)\n   */\n  /**\n   * Position the center of graph to the center of the viewport.\n   */\n  center(optons) {\n    return this.centerPoint(optons);\n  }\n  centerPoint(x, y, options) {\n    const ctm = this.graph.matrix();\n    const sx = ctm.a;\n    const sy = ctm.d;\n    const tx = -ctm.e;\n    const ty = -ctm.f;\n    const tWidth = tx + this.graph.options.width;\n    const tHeight = ty + this.graph.options.height;\n    let localOptions;\n    this.storeClientSize(); // avoid multilple reflow\n    if (typeof x === 'number' || typeof y === 'number') {\n      localOptions = options;\n      const visibleCenter = this.getVisibleArea().getCenter();\n      if (typeof x === 'number') {\n        x *= sx; // eslint-disable-line\n      } else {\n        x = visibleCenter.x; // eslint-disable-line\n      }\n      if (typeof y === 'number') {\n        y *= sy; // eslint-disable-line\n      } else {\n        y = visibleCenter.y; // eslint-disable-line\n      }\n    } else {\n      localOptions = x;\n      x = (tx + tWidth) / 2; // eslint-disable-line\n      y = (ty + tHeight) / 2; // eslint-disable-line\n    }\n    if (localOptions && localOptions.padding) {\n      return this.positionPoint({\n        x,\n        y\n      }, '50%', '50%', localOptions);\n    }\n    const padding = this.getPadding();\n    const clientSize = this.getClientSize();\n    const cx = clientSize.width / 2;\n    const cy = clientSize.height / 2;\n    const left = cx - padding.left - x + tx;\n    const right = cx - padding.right + x - tWidth;\n    const top = cy - padding.top - y + ty;\n    const bottom = cy - padding.bottom + y - tHeight;\n    this.addPadding(Math.max(left, 0), Math.max(right, 0), Math.max(top, 0), Math.max(bottom, 0));\n    const result = this.scrollToPoint(x, y, localOptions || undefined);\n    this.restoreClientSize();\n    return result;\n  }\n  centerContent(options) {\n    return this.positionContent('center', options);\n  }\n  centerCell(cell, options) {\n    return this.positionCell(cell, 'center', options);\n  }\n  /**\n   * The position methods are a more general version of the center methods.\n   * They position the graph so that a specific point on the graph lies at\n   * requested coordinates inside the viewport.\n   */\n  /**\n   *\n   */\n  positionContent(pos, options) {\n    const rect = this.graph.getContentArea(options);\n    return this.positionRect(rect, pos, options);\n  }\n  positionCell(cell, pos, options) {\n    const bbox = cell.getBBox();\n    return this.positionRect(bbox, pos, options);\n  }\n  positionRect(rect, pos, options) {\n    const bbox = Rectangle.create(rect);\n    switch (pos) {\n      case 'center':\n        return this.positionPoint(bbox.getCenter(), '50%', '50%', options);\n      case 'top':\n        return this.positionPoint(bbox.getTopCenter(), '50%', 0, options);\n      case 'top-right':\n        return this.positionPoint(bbox.getTopRight(), '100%', 0, options);\n      case 'right':\n        return this.positionPoint(bbox.getRightMiddle(), '100%', '50%', options);\n      case 'bottom-right':\n        return this.positionPoint(bbox.getBottomRight(), '100%', '100%', options);\n      case 'bottom':\n        return this.positionPoint(bbox.getBottomCenter(), '50%', '100%', options);\n      case 'bottom-left':\n        return this.positionPoint(bbox.getBottomLeft(), 0, '100%', options);\n      case 'left':\n        return this.positionPoint(bbox.getLeftMiddle(), 0, '50%', options);\n      case 'top-left':\n        return this.positionPoint(bbox.getTopLeft(), 0, 0, options);\n      default:\n        return this;\n    }\n  }\n  positionPoint(point, x, y, options = {}) {\n    const {\n        padding: pad\n      } = options,\n      localOptions = __rest(options, [\"padding\"]);\n    const padding = NumberExt.normalizeSides(pad);\n    const clientRect = Rectangle.fromSize(this.getClientSize());\n    const targetRect = clientRect.clone().moveAndExpand({\n      x: padding.left,\n      y: padding.top,\n      width: -padding.right - padding.left,\n      height: -padding.top - padding.bottom\n    });\n    // eslint-disable-next-line\n    x = NumberExt.normalizePercentage(x, Math.max(0, targetRect.width));\n    if (x < 0) {\n      x = targetRect.width + x; // eslint-disable-line\n    }\n    // eslint-disable-next-line\n    y = NumberExt.normalizePercentage(y, Math.max(0, targetRect.height));\n    if (y < 0) {\n      y = targetRect.height + y; // eslint-disable-line\n    }\n    const origin = targetRect.getTopLeft().translate(x, y);\n    const diff = clientRect.getCenter().diff(origin);\n    const scale = this.zoom();\n    const rawDiff = diff.scale(1 / scale, 1 / scale);\n    const result = Point.create(point).translate(rawDiff);\n    return this.centerPoint(result.x, result.y, localOptions);\n  }\n  zoom(factor, options) {\n    if (factor == null) {\n      return this.sx;\n    }\n    options = options || {}; // eslint-disable-line\n    let cx;\n    let cy;\n    const clientSize = this.getClientSize();\n    const center = this.clientToLocalPoint(clientSize.width / 2, clientSize.height / 2);\n    let sx = factor;\n    let sy = factor;\n    if (!options.absolute) {\n      sx += this.sx;\n      sy += this.sy;\n    }\n    if (options.scaleGrid) {\n      sx = Math.round(sx / options.scaleGrid) * options.scaleGrid;\n      sy = Math.round(sy / options.scaleGrid) * options.scaleGrid;\n    }\n    if (options.maxScale) {\n      sx = Math.min(options.maxScale, sx);\n      sy = Math.min(options.maxScale, sy);\n    }\n    if (options.minScale) {\n      sx = Math.max(options.minScale, sx);\n      sy = Math.max(options.minScale, sy);\n    }\n    sx = this.graph.transform.clampScale(sx);\n    sy = this.graph.transform.clampScale(sy);\n    if (options.center) {\n      const fx = sx / this.sx;\n      const fy = sy / this.sy;\n      cx = options.center.x - (options.center.x - center.x) / fx;\n      cy = options.center.y - (options.center.y - center.y) / fy;\n    } else {\n      cx = center.x;\n      cy = center.y;\n    }\n    this.beforeManipulation();\n    this.graph.transform.scale(sx, sy);\n    this.centerPoint(cx, cy);\n    this.afterManipulation();\n    return this;\n  }\n  zoomToRect(rect, options = {}) {\n    const area = Rectangle.create(rect);\n    const graph = this.graph;\n    options.contentArea = area;\n    if (options.viewportArea == null) {\n      options.viewportArea = {\n        x: graph.options.x,\n        y: graph.options.y,\n        width: this.$container.width(),\n        height: this.$container.height()\n      };\n    }\n    this.beforeManipulation();\n    graph.transform.scaleContentToFitImpl(options, false);\n    const center = area.getCenter();\n    this.centerPoint(center.x, center.y);\n    this.afterManipulation();\n    return this;\n  }\n  zoomToFit(options = {}) {\n    return this.zoomToRect(this.graph.getContentArea(options), options);\n  }\n  transitionToPoint(x, y, options) {\n    if (typeof x === 'object') {\n      options = y; // eslint-disable-line\n      y = x.y; // eslint-disable-line\n      x = x.x; // eslint-disable-line\n    } else {\n      y = y; // eslint-disable-line\n    }\n    if (options == null) {\n      options = {}; // eslint-disable-line\n    }\n    let transform;\n    let transformOrigin;\n    const scale = this.sx;\n    const targetScale = Math.max(options.scale || scale, 0.000001);\n    const clientSize = this.getClientSize();\n    const targetPoint = new Point(x, y);\n    const localPoint = this.clientToLocalPoint(clientSize.width / 2, clientSize.height / 2);\n    if (scale === targetScale) {\n      const translate = localPoint.diff(targetPoint).scale(scale, scale).round();\n      transform = `translate(${translate.x}px,${translate.y}px)`;\n    } else {\n      const delta = targetScale / (scale - targetScale) * targetPoint.distance(localPoint);\n      const range = localPoint.clone().move(targetPoint, delta);\n      const origin = this.localToBackgroundPoint(range).round();\n      transform = `scale(${targetScale / scale})`;\n      transformOrigin = `${origin.x}px ${origin.y}px`;\n    }\n    const onTransitionEnd = options.onTransitionEnd;\n    this.$container.addClass(Util.transitionClassName);\n    this.$content.off(Util.transitionEventName).on(Util.transitionEventName, e => {\n      this.syncTransition(targetScale, {\n        x: x,\n        y: y\n      });\n      if (typeof onTransitionEnd === 'function') {\n        FunctionExt.call(onTransitionEnd, this, e.originalEvent);\n      }\n    }).css({\n      transform,\n      transformOrigin,\n      transition: 'transform',\n      transitionDuration: options.duration || '1s',\n      transitionDelay: options.delay,\n      transitionTimingFunction: options.timing\n    });\n    return this;\n  }\n  syncTransition(scale, p) {\n    this.beforeManipulation();\n    this.graph.scale(scale);\n    this.removeTransition();\n    this.centerPoint(p.x, p.y);\n    this.afterManipulation();\n    return this;\n  }\n  removeTransition() {\n    this.$container.removeClass(Util.transitionClassName);\n    this.$content.off(Util.transitionEventName).css({\n      transform: '',\n      transformOrigin: '',\n      transition: '',\n      transitionDuration: '',\n      transitionDelay: '',\n      transitionTimingFunction: ''\n    });\n    return this;\n  }\n  transitionToRect(rectangle, options = {}) {\n    const rect = Rectangle.create(rectangle);\n    const maxScale = options.maxScale || Infinity;\n    const minScale = options.minScale || Number.MIN_VALUE;\n    const scaleGrid = options.scaleGrid || null;\n    const PIXEL_SIZE = options.visibility || 1;\n    const center = options.center ? Point.create(options.center) : rect.getCenter();\n    const clientSize = this.getClientSize();\n    const w = clientSize.width * PIXEL_SIZE;\n    const h = clientSize.height * PIXEL_SIZE;\n    let scale = new Rectangle(center.x - w / 2, center.y - h / 2, w, h).getMaxUniformScaleToFit(rect, center);\n    scale = Math.min(scale, maxScale);\n    if (scaleGrid) {\n      scale = Math.floor(scale / scaleGrid) * scaleGrid;\n    }\n    scale = Math.max(minScale, scale);\n    return this.transitionToPoint(center, Object.assign({\n      scale\n    }, options));\n  }\n  startPanning(evt) {\n    const e = this.normalizeEvent(evt);\n    this.clientX = e.clientX;\n    this.clientY = e.clientY;\n    this.trigger('pan:start', {\n      e\n    });\n    this.$(document.body).on({\n      'mousemove.panning touchmove.panning': this.pan.bind(this),\n      'mouseup.panning touchend.panning': this.stopPanning.bind(this),\n      'mouseleave.panning': this.stopPanning.bind(this)\n    });\n    this.$(window).on('mouseup.panning', this.stopPanning.bind(this));\n  }\n  pan(evt) {\n    const e = this.normalizeEvent(evt);\n    const dx = e.clientX - this.clientX;\n    const dy = e.clientY - this.clientY;\n    this.container.scrollTop -= dy;\n    this.container.scrollLeft -= dx;\n    this.clientX = e.clientX;\n    this.clientY = e.clientY;\n    this.trigger('panning', {\n      e\n    });\n  }\n  stopPanning(e) {\n    this.$(document.body).off('.panning');\n    this.$(window).off('.panning');\n    this.trigger('pan:stop', {\n      e\n    });\n  }\n  clientToLocalPoint(a, b) {\n    let x = typeof a === 'object' ? a.x : a;\n    let y = typeof a === 'object' ? a.y : b;\n    const ctm = this.graph.matrix();\n    x += this.container.scrollLeft - this.padding.left - ctm.e;\n    y += this.container.scrollTop - this.padding.top - ctm.f;\n    return new Point(x / ctm.a, y / ctm.d);\n  }\n  localToBackgroundPoint(x, y) {\n    const p = typeof x === 'object' ? Point.create(x) : new Point(x, y);\n    const ctm = this.graph.matrix();\n    const padding = this.padding;\n    return Dom.transformPoint(p, ctm).translate(padding.left, padding.top);\n  }\n  resize(width, height) {\n    let w = width != null ? width : this.container.offsetWidth;\n    let h = height != null ? height : this.container.offsetHeight;\n    if (typeof w === 'number') {\n      w = Math.round(w);\n    }\n    if (typeof h === 'number') {\n      h = Math.round(h);\n    }\n    this.options.width = w;\n    this.options.height = h;\n    this.$container.css({\n      width: w,\n      height: h\n    });\n    this.update();\n  }\n  getClientSize() {\n    if (this.cachedClientSize) {\n      return this.cachedClientSize;\n    }\n    return {\n      width: this.container.clientWidth,\n      height: this.container.clientHeight\n    };\n  }\n  autoScroll(clientX, clientY) {\n    const buffer = 10;\n    const container = this.container;\n    const rect = container.getBoundingClientRect();\n    let dx = 0;\n    let dy = 0;\n    if (clientX <= rect.left + buffer) {\n      dx = -buffer;\n    }\n    if (clientY <= rect.top + buffer) {\n      dy = -buffer;\n    }\n    if (clientX >= rect.right - buffer) {\n      dx = buffer;\n    }\n    if (clientY >= rect.bottom - buffer) {\n      dy = buffer;\n    }\n    if (dx !== 0) {\n      container.scrollLeft += dx;\n    }\n    if (dy !== 0) {\n      container.scrollTop += dy;\n    }\n    return {\n      scrollerX: dx,\n      scrollerY: dy\n    };\n  }\n  addPadding(left, right, top, bottom) {\n    let padding = this.getPadding();\n    this.padding = {\n      left: Math.round(padding.left + (left || 0)),\n      top: Math.round(padding.top + (top || 0)),\n      bottom: Math.round(padding.bottom + (bottom || 0)),\n      right: Math.round(padding.right + (right || 0))\n    };\n    padding = this.padding;\n    this.$content.css({\n      width: padding.left + this.graph.options.width + padding.right,\n      height: padding.top + this.graph.options.height + padding.bottom\n    });\n    const container = this.graph.container;\n    container.style.left = `${this.padding.left}px`;\n    container.style.top = `${this.padding.top}px`;\n    return this;\n  }\n  getPadding() {\n    const padding = this.options.padding;\n    if (typeof padding === 'function') {\n      return NumberExt.normalizeSides(FunctionExt.call(padding, this, this));\n    }\n    return NumberExt.normalizeSides(padding);\n  }\n  /**\n   * Returns the untransformed size and origin of the current viewport.\n   */\n  getVisibleArea() {\n    const ctm = this.graph.matrix();\n    const size = this.getClientSize();\n    const box = {\n      x: this.container.scrollLeft || 0,\n      y: this.container.scrollTop || 0,\n      width: size.width,\n      height: size.height\n    };\n    const area = Dom.transformRectangle(box, ctm.inverse());\n    area.x -= (this.padding.left || 0) / this.sx;\n    area.y -= (this.padding.top || 0) / this.sy;\n    return area;\n  }\n  isCellVisible(cell, options = {}) {\n    const bbox = cell.getBBox();\n    const area = this.getVisibleArea();\n    return options.strict ? area.containsRect(bbox) : area.isIntersectWithRect(bbox);\n  }\n  isPointVisible(point) {\n    return this.getVisibleArea().containsPoint(point);\n  }\n  /**\n   * Lock the current viewport by disabling user scrolling.\n   */\n  lock() {\n    this.$container.css('overflow', 'hidden');\n    return this;\n  }\n  /**\n   * Enable user scrolling if previously locked.\n   */\n  unlock() {\n    this.$container.css('overflow', 'scroll');\n    return this;\n  }\n  onRemove() {\n    this.stopListening();\n  }\n  dispose() {\n    this.$(this.graph.container).insertBefore(this.$container);\n    this.remove();\n  }\n}\n__decorate([View.dispose()], Scroller.prototype, \"dispose\", null);\n(function (Scroller) {\n  class Background extends BackgroundManager {\n    constructor(scroller) {\n      super(scroller.graph);\n      this.scroller = scroller;\n      if (scroller.options.background) {\n        this.draw(scroller.options.background);\n      }\n    }\n    get elem() {\n      return this.scroller.background;\n    }\n    init() {\n      this.graph.on('scale', this.update, this);\n      this.graph.on('translate', this.update, this);\n    }\n    updateBackgroundOptions(options) {\n      this.scroller.options.background = options;\n    }\n  }\n  Scroller.Background = Background;\n})(Scroller || (Scroller = {}));\nvar Util;\n(function (Util) {\n  Util.containerClass = 'graph-scroller';\n  Util.panningClass = `${Util.containerClass}-panning`;\n  Util.pannableClass = `${Util.containerClass}-pannable`;\n  Util.pagedClass = `${Util.containerClass}-paged`;\n  Util.contentClass = `${Util.containerClass}-content`;\n  Util.backgroundClass = `${Util.containerClass}-background`;\n  Util.transitionClassName = 'transition-in-progress';\n  Util.transitionEventName = 'transitionend.graph-scroller-transition';\n  Util.defaultOptions = {\n    padding() {\n      const size = this.getClientSize();\n      const minWidth = Math.max(this.options.minVisibleWidth || 0, 1) || 1;\n      const minHeight = Math.max(this.options.minVisibleHeight || 0, 1) || 1;\n      const left = Math.max(size.width - minWidth, 0);\n      const top = Math.max(size.height - minHeight, 0);\n      return {\n        left,\n        top,\n        right: left,\n        bottom: top\n      };\n    },\n    minVisibleWidth: 50,\n    minVisibleHeight: 50,\n    pageVisible: false,\n    pageBreak: false,\n    autoResize: true\n  };\n  function getOptions(options) {\n    const result = ObjectExt.merge({}, Util.defaultOptions, options);\n    if (result.pageWidth == null) {\n      result.pageWidth = options.graph.options.width;\n    }\n    if (result.pageHeight == null) {\n      result.pageHeight = options.graph.options.height;\n    }\n    return result;\n  }\n  Util.getOptions = getOptions;\n})(Util || (Util = {}));","map":{"version":3,"names":["Platform","NumberExt","ObjectExt","Dom","FunctionExt","Point","Rectangle","View","Renderer","GraphView","BackgroundManager","Scroller","constructor","options","padding","left","top","right","bottom","Util","getOptions","scale","graph","transform","getScale","sx","sy","width","height","container","document","createElement","$container","$","addClass","prefixClassName","containerClass","css","pageVisible","pagedClass","className","graphContainer","parentNode","insertBefore","style","getAttribute","obj","styles","split","forEach","item","section","trim","pair","length","Object","keys","key","content","$content","contentClass","background","$background","backgroundClass","append","view","grid","appendTo","startListening","update","backgroundManager","Background","autoResize","model","on","onScale","onResize","storeScrollPosition","restoreScrollPosition","onRenderDone","onUpdate","onBatchStop","delegateBackgroundEvents","stopListening","off","undelegateBackgroundEvents","enableAutoResize","disableAutoResize","isAsync","args","UPDATE_DELAYING_BATCHES","includes","name","events","evts","delegatedHandlers","reduce","memo","handler","indexOf","method","bind","onBackgroundEvent","delegateEvent","guarded","undelegateEvent","e","valid","target","type","apply","arguments","stats","priority","cachedCenterPoint","centerPoint","x","y","updatePageBreak","ox","oy","updateScale","autoResizeOptions","fitTocontentOptions","cachedScrollLeft","scrollLeft","cachedScrollTop","scrollTop","storeClientSize","cachedClientSize","clientWidth","clientHeight","restoreClientSize","beforeManipulation","IS_IE","IS_EDGE","afterManipulation","updatePageSize","pageWidth","pageHeight","pageBreak","removeChild","graphWidth","graphHeight","hasPageBreak","i","l","Math","floor","after","size","getClientSize","clientToLocalPoint","resizeOptions","call","assign","gridWidth","gridHeight","allowNewOrigin","contentArea","calcContextArea","fitToContent","getFitToContentOptions","direction","getContentArea","getCellBBox","cell","rect","getBBox","isNode","angle","getAngle","bbox","calculativeCells","getCells","filter","getCellsBBox","minWidth","minHeight","create","dx","dy","translate","resizeGraph","scrollbarPosition","prop","animation","animate","scrollToPoint","ctm","matrix","f","scrollToContent","center","getCenter","scrollToCell","optons","a","d","tx","ty","tWidth","tHeight","localOptions","visibleCenter","getVisibleArea","positionPoint","getPadding","clientSize","cx","cy","addPadding","max","result","undefined","centerContent","positionContent","centerCell","positionCell","pos","positionRect","getTopCenter","getTopRight","getRightMiddle","getBottomRight","getBottomCenter","getBottomLeft","getLeftMiddle","getTopLeft","point","pad","__rest","normalizeSides","clientRect","fromSize","targetRect","clone","moveAndExpand","normalizePercentage","origin","diff","zoom","rawDiff","factor","absolute","scaleGrid","round","maxScale","min","minScale","clampScale","fx","fy","zoomToRect","area","viewportArea","scaleContentToFitImpl","zoomToFit","transitionToPoint","transformOrigin","targetScale","targetPoint","localPoint","delta","distance","range","move","localToBackgroundPoint","onTransitionEnd","transitionClassName","transitionEventName","syncTransition","originalEvent","transition","transitionDuration","duration","transitionDelay","delay","transitionTimingFunction","timing","p","removeTransition","removeClass","transitionToRect","rectangle","Infinity","Number","MIN_VALUE","PIXEL_SIZE","visibility","w","h","getMaxUniformScaleToFit","startPanning","evt","normalizeEvent","clientX","clientY","trigger","body","pan","stopPanning","window","b","transformPoint","resize","offsetWidth","offsetHeight","autoScroll","buffer","getBoundingClientRect","scrollerX","scrollerY","box","transformRectangle","inverse","isCellVisible","strict","containsRect","isIntersectWithRect","isPointVisible","containsPoint","lock","unlock","onRemove","dispose","remove","__decorate","scroller","draw","elem","init","updateBackgroundOptions","panningClass","pannableClass","defaultOptions","minVisibleWidth","minVisibleHeight","merge"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/addon/scroller/index.ts"],"sourcesContent":["import { Platform, NumberExt, ObjectExt, Dom, FunctionExt } from '../../util'\nimport { Point, Rectangle } from '../../geometry'\nimport { Model } from '../../model/model'\nimport { Cell } from '../../model/cell'\nimport { View } from '../../view/view'\nimport { Graph } from '../../graph'\nimport { Renderer } from '../../graph/renderer'\nimport { GraphView } from '../../graph/view'\nimport { EventArgs } from '../../graph/events'\nimport { TransformManager } from '../../graph/transform'\nimport { BackgroundManager } from '../../graph/background'\n\nexport class Scroller extends View {\n  public readonly options: Scroller.Options\n  public readonly container: HTMLDivElement\n  public readonly content: HTMLDivElement\n  public readonly background: HTMLDivElement\n  public readonly $container: JQuery<HTMLElement>\n  public readonly backgroundManager: Scroller.Background\n  protected readonly $background: JQuery<HTMLElement>\n  protected readonly $content: JQuery<HTMLElement>\n  protected pageBreak: HTMLDivElement | null\n\n  public get graph() {\n    return this.options.graph\n  }\n\n  public get model() {\n    return this.graph.model\n  }\n\n  protected sx: number\n  protected sy: number\n  protected clientX: number\n  protected clientY: number\n  protected padding = { left: 0, top: 0, right: 0, bottom: 0 }\n  protected cachedScrollLeft: number | null\n  protected cachedScrollTop: number | null\n  protected cachedCenterPoint: Point.PointLike | null\n  protected cachedClientSize: { width: number; height: number } | null\n  protected delegatedHandlers: { [name: string]: (...args: any) => any }\n\n  constructor(options: Scroller.Options) {\n    super()\n\n    this.options = Util.getOptions(options)\n\n    const scale = this.graph.transform.getScale()\n    this.sx = scale.sx\n    this.sy = scale.sy\n\n    const width = this.options.width || this.graph.options.width\n    const height = this.options.height || this.graph.options.height\n    this.container = document.createElement('div')\n    this.$container = this.$(this.container)\n      .addClass(this.prefixClassName(Util.containerClass))\n      .css({ width, height })\n\n    if (this.options.pageVisible) {\n      this.$container.addClass(this.prefixClassName(Util.pagedClass))\n    }\n\n    if (this.options.className) {\n      this.$container.addClass(this.options.className)\n    }\n\n    const graphContainer = this.graph.container\n\n    if (graphContainer.parentNode) {\n      this.$container.insertBefore(graphContainer)\n    }\n\n    // copy style\n    const style = graphContainer.getAttribute('style')\n    if (style) {\n      const obj: { [name: string]: string } = {}\n      const styles = style.split(';')\n      styles.forEach((item) => {\n        const section = item.trim()\n        if (section) {\n          const pair = section.split(':')\n          if (pair.length) {\n            obj[pair[0].trim()] = pair[1] ? pair[1].trim() : ''\n          }\n        }\n      })\n\n      Object.keys(obj).forEach((key: any) => {\n        if (key === 'width' || key === 'height') {\n          return\n        }\n\n        graphContainer.style[key] = ''\n        this.container.style[key] = obj[key]\n      })\n    }\n\n    this.content = document.createElement('div')\n    this.$content = this.$(this.content)\n      .addClass(this.prefixClassName(Util.contentClass))\n      .css({\n        width: this.graph.options.width,\n        height: this.graph.options.height,\n      })\n\n    // custom background\n    this.background = document.createElement('div')\n    this.$background = this.$(this.background).addClass(\n      this.prefixClassName(Util.backgroundClass),\n    )\n    this.$content.append(this.background)\n\n    if (!this.options.pageVisible) {\n      this.$content.append(this.graph.view.grid)\n    }\n    this.$content.append(graphContainer)\n    this.$content.appendTo(this.container)\n\n    this.startListening()\n\n    if (!this.options.pageVisible) {\n      this.graph.grid.update()\n    }\n\n    this.backgroundManager = new Scroller.Background(this)\n\n    if (!this.options.autoResize) {\n      this.update()\n    }\n  }\n\n  protected startListening() {\n    const graph = this.graph\n    const model = this.model\n\n    graph.on('scale', this.onScale, this)\n    graph.on('resize', this.onResize, this)\n    graph.on('before:print', this.storeScrollPosition, this)\n    graph.on('before:export', this.storeScrollPosition, this)\n    graph.on('after:print', this.restoreScrollPosition, this)\n    graph.on('after:export', this.restoreScrollPosition, this)\n\n    graph.on('render:done', this.onRenderDone, this)\n    graph.on('unfreeze', this.onUpdate, this)\n    model.on('reseted', this.onUpdate, this)\n    model.on('cell:added', this.onUpdate, this)\n    model.on('cell:removed', this.onUpdate, this)\n    model.on('cell:changed', this.onUpdate, this)\n    model.on('batch:stop', this.onBatchStop, this)\n\n    this.delegateBackgroundEvents()\n  }\n\n  protected stopListening() {\n    const graph = this.graph\n    const model = this.model\n\n    graph.off('scale', this.onScale, this)\n    graph.off('resize', this.onResize, this)\n    graph.off('beforeprint', this.storeScrollPosition, this)\n    graph.off('beforeexport', this.storeScrollPosition, this)\n    graph.off('afterprint', this.restoreScrollPosition, this)\n    graph.off('afterexport', this.restoreScrollPosition, this)\n\n    graph.off('render:done', this.onRenderDone, this)\n    graph.off('unfreeze', this.onUpdate, this)\n    model.off('reseted', this.onUpdate, this)\n    model.off('cell:added', this.onUpdate, this)\n    model.off('cell:removed', this.onUpdate, this)\n    model.off('cell:changed', this.onUpdate, this)\n    model.off('batch:stop', this.onBatchStop, this)\n\n    this.undelegateBackgroundEvents()\n  }\n\n  public enableAutoResize() {\n    this.options.autoResize = true\n  }\n\n  public disableAutoResize() {\n    this.options.autoResize = false\n  }\n\n  protected onUpdate() {\n    if (this.graph.isAsync() || !this.options.autoResize) {\n      return\n    }\n\n    this.update()\n  }\n\n  onBatchStop(args: { name: Model.BatchName }) {\n    if (this.graph.isAsync() || !this.options.autoResize) {\n      return\n    }\n\n    if (Renderer.UPDATE_DELAYING_BATCHES.includes(args.name)) {\n      this.update()\n    }\n  }\n\n  protected delegateBackgroundEvents(events?: View.Events) {\n    const evts = events || GraphView.events\n    this.delegatedHandlers = Object.keys(evts).reduce<{\n      [name: string]: (...args: any) => any\n    }>((memo, name) => {\n      const handler = evts[name]\n      if (name.indexOf(' ') === -1) {\n        if (typeof handler === 'function') {\n          memo[name] = handler as (...args: any) => any\n        } else {\n          let method = this.graph.view[handler as keyof GraphView]\n          if (typeof method === 'function') {\n            method = method.bind(this.graph.view)\n            memo[name] = method as (...args: any) => any\n          }\n        }\n      }\n      return memo\n    }, {})\n\n    this.onBackgroundEvent = this.onBackgroundEvent.bind(this)\n    Object.keys(this.delegatedHandlers).forEach((name) => {\n      this.delegateEvent(\n        name,\n        {\n          guarded: false,\n        },\n        this.onBackgroundEvent,\n      )\n    })\n  }\n\n  protected undelegateBackgroundEvents() {\n    Object.keys(this.delegatedHandlers).forEach((name) => {\n      this.undelegateEvent(name, this.onBackgroundEvent)\n    })\n  }\n\n  protected onBackgroundEvent(e: JQuery.TriggeredEvent) {\n    let valid = false\n    const target = e.target\n\n    if (!this.options.pageVisible) {\n      const view = this.graph.view\n      valid = view.background === target || view.grid === target\n    } else if (this.options.background) {\n      valid = this.background === target\n    } else {\n      valid = this.content === target\n    }\n\n    if (valid) {\n      const handler = this.delegatedHandlers[e.type]\n      if (typeof handler === 'function') {\n        handler.apply(this.graph, arguments) // eslint-disable-line\n      }\n    }\n  }\n\n  protected onRenderDone({ stats }: EventArgs['render:done']) {\n    if (this.options.autoResize && stats.priority < 2) {\n      this.update()\n    }\n  }\n\n  protected onResize() {\n    if (this.cachedCenterPoint) {\n      this.centerPoint(this.cachedCenterPoint.x, this.cachedCenterPoint.y)\n      this.updatePageBreak()\n    }\n  }\n\n  protected onScale({ sx, sy, ox, oy }: EventArgs['scale']) {\n    this.updateScale(sx, sy)\n\n    if (ox || oy) {\n      this.centerPoint(ox, oy)\n      this.updatePageBreak()\n    }\n\n    const autoResizeOptions =\n      this.options.autoResizeOptions || this.options.fitTocontentOptions\n\n    if (typeof autoResizeOptions === 'function') {\n      this.update()\n    }\n  }\n\n  protected storeScrollPosition() {\n    this.cachedScrollLeft = this.container.scrollLeft\n    this.cachedScrollTop = this.container.scrollTop\n  }\n\n  protected restoreScrollPosition() {\n    this.container.scrollLeft = this.cachedScrollLeft!\n    this.container.scrollTop = this.cachedScrollTop!\n    this.cachedScrollLeft = null\n    this.cachedScrollTop = null\n  }\n\n  protected storeClientSize() {\n    this.cachedClientSize = {\n      width: this.container.clientWidth,\n      height: this.container.clientHeight,\n    }\n  }\n\n  protected restoreClientSize() {\n    this.cachedClientSize = null\n  }\n\n  protected beforeManipulation() {\n    if (Platform.IS_IE || Platform.IS_EDGE) {\n      this.$container.css('visibility', 'hidden')\n    }\n  }\n\n  protected afterManipulation() {\n    if (Platform.IS_IE || Platform.IS_EDGE) {\n      this.$container.css('visibility', 'visible')\n    }\n  }\n\n  public updatePageSize(width?: number, height?: number) {\n    if (width != null) {\n      this.options.pageWidth = width\n    }\n\n    if (height != null) {\n      this.options.pageHeight = height\n    }\n\n    this.updatePageBreak()\n  }\n\n  protected updatePageBreak() {\n    if (this.pageBreak && this.pageBreak.parentNode) {\n      this.pageBreak.parentNode.removeChild(this.pageBreak)\n    }\n\n    this.pageBreak = null\n\n    if (this.options.pageVisible && this.options.pageBreak) {\n      const graphWidth = this.graph.options.width\n      const graphHeight = this.graph.options.height\n      const pageWidth = this.options.pageWidth! * this.sx\n      const pageHeight = this.options.pageHeight! * this.sy\n\n      if (pageWidth === 0 || pageHeight === 0) {\n        return\n      }\n\n      if (graphWidth > pageWidth || graphHeight > pageHeight) {\n        let hasPageBreak = false\n        const container = document.createElement('div')\n\n        for (let i = 1, l = Math.floor(graphWidth / pageWidth); i < l; i += 1) {\n          this.$('<div/>')\n            .addClass(this.prefixClassName(`graph-pagebreak-vertical`))\n            .css({ left: i * pageWidth })\n            .appendTo(container)\n          hasPageBreak = true\n        }\n\n        for (\n          let i = 1, l = Math.floor(graphHeight / pageHeight);\n          i < l;\n          i += 1\n        ) {\n          this.$('<div/>')\n            .addClass(this.prefixClassName(`graph-pagebreak-horizontal`))\n            .css({ top: i * pageHeight })\n            .appendTo(container)\n          hasPageBreak = true\n        }\n\n        if (hasPageBreak) {\n          Dom.addClass(container, this.prefixClassName('graph-pagebreak'))\n          this.$(this.graph.view.grid).after(container)\n          this.pageBreak = container\n        }\n      }\n    }\n  }\n\n  update() {\n    const size = this.getClientSize()\n    this.cachedCenterPoint = this.clientToLocalPoint(\n      size.width / 2,\n      size.height / 2,\n    )\n\n    let resizeOptions =\n      this.options.autoResizeOptions || this.options.fitTocontentOptions\n    if (typeof resizeOptions === 'function') {\n      resizeOptions = FunctionExt.call(resizeOptions, this, this)\n    }\n\n    const options: TransformManager.FitToContentFullOptions = {\n      gridWidth: this.options.pageWidth,\n      gridHeight: this.options.pageHeight,\n      allowNewOrigin: 'negative',\n      contentArea: this.calcContextArea(resizeOptions),\n      ...resizeOptions,\n    }\n\n    this.graph.fitToContent(this.getFitToContentOptions(options))\n  }\n\n  protected calcContextArea(\n    resizeOptions:\n      | (TransformManager.FitToContentFullOptions & {\n          direction?:\n            | Scroller.AutoResizeDirection\n            | Scroller.AutoResizeDirection[]\n        })\n      | undefined,\n  ) {\n    const direction = resizeOptions?.direction\n\n    if (!direction) {\n      return this.graph.transform.getContentArea(resizeOptions)\n    }\n\n    function getCellBBox(cell: Cell) {\n      let rect = cell.getBBox()\n      if (rect) {\n        if (cell.isNode()) {\n          const angle = cell.getAngle()\n          if (angle != null && angle !== 0) {\n            rect = rect.bbox(angle)\n          }\n        }\n      }\n      return rect\n    }\n\n    const gridWidth = this.options.pageWidth || 1\n    const gridHeight = this.options.pageHeight || 1\n    let calculativeCells = this.graph.getCells()\n\n    if (!direction.includes('top')) {\n      calculativeCells = calculativeCells.filter((cell) => {\n        const bbox = getCellBBox(cell)\n        return bbox.y >= 0\n      })\n    }\n\n    if (!direction.includes('left')) {\n      calculativeCells = calculativeCells.filter((cell) => {\n        const bbox = getCellBBox(cell)\n        return bbox.x >= 0\n      })\n    }\n\n    if (!direction.includes('right')) {\n      calculativeCells = calculativeCells.filter((cell) => {\n        const bbox = getCellBBox(cell)\n        return bbox.x + bbox.width <= gridWidth\n      })\n    }\n\n    if (!direction.includes('bottom')) {\n      calculativeCells = calculativeCells.filter((cell) => {\n        const bbox = getCellBBox(cell)\n        return bbox.y + bbox.height <= gridHeight\n      })\n    }\n\n    return this.model.getCellsBBox(calculativeCells) || new Rectangle()\n  }\n\n  protected getFitToContentOptions(\n    options: TransformManager.FitToContentFullOptions,\n  ) {\n    const sx = this.sx\n    const sy = this.sy\n\n    options.gridWidth && (options.gridWidth *= sx)\n    options.gridHeight && (options.gridHeight *= sy)\n    options.minWidth && (options.minWidth *= sx)\n    options.minHeight && (options.minHeight *= sy)\n\n    if (typeof options.padding === 'object') {\n      options.padding = {\n        left: (options.padding.left || 0) * sx,\n        right: (options.padding.right || 0) * sx,\n        top: (options.padding.top || 0) * sy,\n        bottom: (options.padding.bottom || 0) * sy,\n      }\n    } else if (typeof options.padding === 'number') {\n      options.padding *= sx\n    }\n\n    if (!this.options.autoResize) {\n      options.contentArea = Rectangle.create()\n    }\n\n    return options\n  }\n\n  protected updateScale(sx: number, sy: number) {\n    const options = this.graph.options\n\n    const dx = sx / this.sx\n    const dy = sy / this.sy\n\n    this.sx = sx\n    this.sy = sy\n\n    this.graph.translate(options.x * dx, options.y * dy)\n    this.graph.resizeGraph(options.width * dx, options.height * dy)\n  }\n\n  scrollbarPosition(): { left: number; top: number }\n  scrollbarPosition(\n    left?: number,\n    top?: number,\n    options?: Scroller.ScrollOptions,\n  ): this\n  scrollbarPosition(\n    left?: number,\n    top?: number,\n    options?: Scroller.ScrollOptions,\n  ) {\n    if (left == null && top == null) {\n      return {\n        left: this.container.scrollLeft,\n        top: this.container.scrollTop,\n      }\n    }\n\n    const prop: { [key: string]: number } = {}\n    if (typeof left === 'number') {\n      prop.scrollLeft = left\n    }\n\n    if (typeof top === 'number') {\n      prop.scrollTop = top\n    }\n\n    if (options && options.animation) {\n      this.$container.animate(prop, options.animation)\n    } else {\n      this.$container.prop(prop)\n    }\n\n    return this\n  }\n\n  /**\n   * Try to scroll to ensure that the position (x,y) on the graph (in local\n   * coordinates) is at the center of the viewport. If only one of the\n   * coordinates is specified, only scroll in the specified dimension and\n   * keep the other coordinate unchanged.\n   */\n  scrollToPoint(\n    x: number | null | undefined,\n    y: number | null | undefined,\n    options?: Scroller.ScrollOptions,\n  ) {\n    const size = this.getClientSize()\n    const ctm = this.graph.matrix()\n    const prop: { [key: string]: number } = {}\n\n    if (typeof x === 'number') {\n      prop.scrollLeft = x - size.width / 2 + ctm.e + (this.padding.left || 0)\n    }\n\n    if (typeof y === 'number') {\n      prop.scrollTop = y - size.height / 2 + ctm.f + (this.padding.top || 0)\n    }\n\n    if (options && options.animation) {\n      this.$container.animate(prop, options.animation)\n    } else {\n      this.$container.prop(prop)\n    }\n\n    return this\n  }\n\n  /**\n   * Try to scroll to ensure that the center of graph content is at the\n   * center of the viewport.\n   */\n  scrollToContent(options?: Scroller.ScrollOptions) {\n    const sx = this.sx\n    const sy = this.sy\n    const center = this.graph.getContentArea().getCenter()\n    return this.scrollToPoint(center.x * sx, center.y * sy, options)\n  }\n\n  /**\n   * Try to scroll to ensure that the center of cell is at the center of\n   * the viewport.\n   */\n  scrollToCell(cell: Cell, options?: Scroller.ScrollOptions) {\n    const sx = this.sx\n    const sy = this.sy\n    const center = cell.getBBox().getCenter()\n    return this.scrollToPoint(center.x * sx, center.y * sy, options)\n  }\n\n  /**\n   * The center methods are more aggressive than the scroll methods. These\n   * methods position the graph so that a specific point on the graph lies\n   * at the center of the viewport, adding paddings around the paper if\n   * necessary (e.g. if the requested point lies in a corner of the paper).\n   * This means that the requested point will always move into the center\n   * of the viewport. (Use the scroll functions to avoid adding paddings\n   * and only scroll the viewport as far as the graph boundary.)\n   */\n\n  /**\n   * Position the center of graph to the center of the viewport.\n   */\n  center(optons?: Scroller.CenterOptions) {\n    return this.centerPoint(optons)\n  }\n\n  /**\n   * Position the point (x,y) on the graph (in local coordinates) to the\n   * center of the viewport. If only one of the coordinates is specified,\n   * only center along the specified dimension and keep the other coordinate\n   * unchanged.\n   */\n  centerPoint(\n    x: number,\n    y: null | number,\n    options?: Scroller.CenterOptions,\n  ): this\n  centerPoint(\n    x: null | number,\n    y: number,\n    options?: Scroller.CenterOptions,\n  ): this\n  centerPoint(optons?: Scroller.CenterOptions): this\n  centerPoint(\n    x?: number | null | Scroller.CenterOptions,\n    y?: number | null,\n    options?: Scroller.CenterOptions,\n  ) {\n    const ctm = this.graph.matrix()\n    const sx = ctm.a\n    const sy = ctm.d\n    const tx = -ctm.e\n    const ty = -ctm.f\n    const tWidth = tx + this.graph.options.width\n    const tHeight = ty + this.graph.options.height\n\n    let localOptions: Scroller.CenterOptions | null | undefined\n\n    this.storeClientSize() // avoid multilple reflow\n\n    if (typeof x === 'number' || typeof y === 'number') {\n      localOptions = options\n      const visibleCenter = this.getVisibleArea().getCenter()\n      if (typeof x === 'number') {\n        x *= sx // eslint-disable-line\n      } else {\n        x = visibleCenter.x // eslint-disable-line\n      }\n\n      if (typeof y === 'number') {\n        y *= sy // eslint-disable-line\n      } else {\n        y = visibleCenter.y // eslint-disable-line\n      }\n    } else {\n      localOptions = x\n      x = (tx + tWidth) / 2 // eslint-disable-line\n      y = (ty + tHeight) / 2 // eslint-disable-line\n    }\n\n    if (localOptions && localOptions.padding) {\n      return this.positionPoint({ x, y }, '50%', '50%', localOptions)\n    }\n\n    const padding = this.getPadding()\n    const clientSize = this.getClientSize()\n    const cx = clientSize.width / 2\n    const cy = clientSize.height / 2\n    const left = cx - padding.left - x + tx\n    const right = cx - padding.right + x - tWidth\n    const top = cy - padding.top - y + ty\n    const bottom = cy - padding.bottom + y - tHeight\n\n    this.addPadding(\n      Math.max(left, 0),\n      Math.max(right, 0),\n      Math.max(top, 0),\n      Math.max(bottom, 0),\n    )\n\n    const result = this.scrollToPoint(x, y, localOptions || undefined)\n\n    this.restoreClientSize()\n\n    return result\n  }\n\n  centerContent(options?: Scroller.PositionContentOptions) {\n    return this.positionContent('center', options)\n  }\n\n  centerCell(cell: Cell, options?: Scroller.CenterOptions) {\n    return this.positionCell(cell, 'center', options)\n  }\n\n  /**\n   * The position methods are a more general version of the center methods.\n   * They position the graph so that a specific point on the graph lies at\n   * requested coordinates inside the viewport.\n   */\n\n  /**\n   *\n   */\n  positionContent(\n    pos: Scroller.Direction,\n    options?: Scroller.PositionContentOptions,\n  ) {\n    const rect = this.graph.getContentArea(options)\n    return this.positionRect(rect, pos, options)\n  }\n\n  positionCell(\n    cell: Cell,\n    pos: Scroller.Direction,\n    options?: Scroller.CenterOptions,\n  ) {\n    const bbox = cell.getBBox()\n    return this.positionRect(bbox, pos, options)\n  }\n\n  positionRect(\n    rect: Rectangle.RectangleLike,\n    pos: Scroller.Direction,\n    options?: Scroller.CenterOptions,\n  ) {\n    const bbox = Rectangle.create(rect)\n    switch (pos) {\n      case 'center':\n        return this.positionPoint(bbox.getCenter(), '50%', '50%', options)\n      case 'top':\n        return this.positionPoint(bbox.getTopCenter(), '50%', 0, options)\n      case 'top-right':\n        return this.positionPoint(bbox.getTopRight(), '100%', 0, options)\n      case 'right':\n        return this.positionPoint(bbox.getRightMiddle(), '100%', '50%', options)\n      case 'bottom-right':\n        return this.positionPoint(\n          bbox.getBottomRight(),\n          '100%',\n          '100%',\n          options,\n        )\n      case 'bottom':\n        return this.positionPoint(\n          bbox.getBottomCenter(),\n          '50%',\n          '100%',\n          options,\n        )\n      case 'bottom-left':\n        return this.positionPoint(bbox.getBottomLeft(), 0, '100%', options)\n      case 'left':\n        return this.positionPoint(bbox.getLeftMiddle(), 0, '50%', options)\n      case 'top-left':\n        return this.positionPoint(bbox.getTopLeft(), 0, 0, options)\n      default:\n        return this\n    }\n  }\n\n  positionPoint(\n    point: Point.PointLike,\n    x: number | string,\n    y: number | string,\n    options: Scroller.CenterOptions = {},\n  ) {\n    const { padding: pad, ...localOptions } = options\n    const padding = NumberExt.normalizeSides(pad)\n    const clientRect = Rectangle.fromSize(this.getClientSize())\n    const targetRect = clientRect.clone().moveAndExpand({\n      x: padding.left,\n      y: padding.top,\n      width: -padding.right - padding.left,\n      height: -padding.top - padding.bottom,\n    })\n\n    // eslint-disable-next-line\n    x = NumberExt.normalizePercentage(x, Math.max(0, targetRect.width))\n    if (x < 0) {\n      x = targetRect.width + x // eslint-disable-line\n    }\n\n    // eslint-disable-next-line\n    y = NumberExt.normalizePercentage(y, Math.max(0, targetRect.height))\n    if (y < 0) {\n      y = targetRect.height + y // eslint-disable-line\n    }\n\n    const origin = targetRect.getTopLeft().translate(x, y)\n    const diff = clientRect.getCenter().diff(origin)\n    const scale = this.zoom()\n    const rawDiff = diff.scale(1 / scale, 1 / scale)\n    const result = Point.create(point).translate(rawDiff)\n    return this.centerPoint(result.x, result.y, localOptions)\n  }\n\n  zoom(): number\n  zoom(factor: number, options?: TransformManager.ZoomOptions): this\n  zoom(factor?: number, options?: TransformManager.ZoomOptions) {\n    if (factor == null) {\n      return this.sx\n    }\n\n    options = options || {} // eslint-disable-line\n\n    let cx\n    let cy\n    const clientSize = this.getClientSize()\n    const center = this.clientToLocalPoint(\n      clientSize.width / 2,\n      clientSize.height / 2,\n    )\n\n    let sx = factor\n    let sy = factor\n\n    if (!options.absolute) {\n      sx += this.sx\n      sy += this.sy\n    }\n\n    if (options.scaleGrid) {\n      sx = Math.round(sx / options.scaleGrid) * options.scaleGrid\n      sy = Math.round(sy / options.scaleGrid) * options.scaleGrid\n    }\n\n    if (options.maxScale) {\n      sx = Math.min(options.maxScale, sx)\n      sy = Math.min(options.maxScale, sy)\n    }\n\n    if (options.minScale) {\n      sx = Math.max(options.minScale, sx)\n      sy = Math.max(options.minScale, sy)\n    }\n\n    sx = this.graph.transform.clampScale(sx)\n    sy = this.graph.transform.clampScale(sy)\n\n    if (options.center) {\n      const fx = sx / this.sx\n      const fy = sy / this.sy\n      cx = options.center.x - (options.center.x - center.x) / fx\n      cy = options.center.y - (options.center.y - center.y) / fy\n    } else {\n      cx = center.x\n      cy = center.y\n    }\n\n    this.beforeManipulation()\n    this.graph.transform.scale(sx, sy)\n    this.centerPoint(cx, cy)\n    this.afterManipulation()\n\n    return this\n  }\n\n  zoomToRect(\n    rect: Rectangle.RectangleLike,\n    options: TransformManager.ScaleContentToFitOptions = {},\n  ) {\n    const area = Rectangle.create(rect)\n    const graph = this.graph\n\n    options.contentArea = area\n    if (options.viewportArea == null) {\n      options.viewportArea = {\n        x: graph.options.x,\n        y: graph.options.y,\n        width: this.$container.width()!,\n        height: this.$container.height()!,\n      }\n    }\n\n    this.beforeManipulation()\n    graph.transform.scaleContentToFitImpl(options, false)\n    const center = area.getCenter()\n    this.centerPoint(center.x, center.y)\n    this.afterManipulation()\n\n    return this\n  }\n\n  zoomToFit(\n    options: TransformManager.GetContentAreaOptions &\n      TransformManager.ScaleContentToFitOptions = {},\n  ) {\n    return this.zoomToRect(this.graph.getContentArea(options), options)\n  }\n\n  transitionToPoint(\n    p: Point.PointLike,\n    options?: Scroller.TransitionOptions,\n  ): this\n  transitionToPoint(\n    x: number,\n    y: number,\n    options?: Scroller.TransitionOptions,\n  ): this\n  transitionToPoint(\n    x: number | Point.PointLike,\n    y?: number | Scroller.TransitionOptions,\n    options?: Scroller.TransitionOptions,\n  ) {\n    if (typeof x === 'object') {\n      options = y as Scroller.TransitionOptions // eslint-disable-line\n      y = x.y // eslint-disable-line\n      x = x.x // eslint-disable-line\n    } else {\n      y = y as number // eslint-disable-line\n    }\n\n    if (options == null) {\n      options = {} // eslint-disable-line\n    }\n\n    let transform\n    let transformOrigin\n    const scale = this.sx\n    const targetScale = Math.max(options.scale || scale, 0.000001)\n    const clientSize = this.getClientSize()\n    const targetPoint = new Point(x, y)\n    const localPoint = this.clientToLocalPoint(\n      clientSize.width / 2,\n      clientSize.height / 2,\n    )\n\n    if (scale === targetScale) {\n      const translate = localPoint.diff(targetPoint).scale(scale, scale).round()\n      transform = `translate(${translate.x}px,${translate.y}px)`\n    } else {\n      const delta =\n        (targetScale / (scale - targetScale)) * targetPoint.distance(localPoint)\n      const range = localPoint.clone().move(targetPoint, delta)\n      const origin = this.localToBackgroundPoint(range).round()\n      transform = `scale(${targetScale / scale})`\n      transformOrigin = `${origin.x}px ${origin.y}px`\n    }\n\n    const onTransitionEnd = options.onTransitionEnd\n    this.$container.addClass(Util.transitionClassName)\n    this.$content\n      .off(Util.transitionEventName)\n      .on(Util.transitionEventName, (e) => {\n        this.syncTransition(targetScale, { x: x as number, y: y as number })\n        if (typeof onTransitionEnd === 'function') {\n          FunctionExt.call(\n            onTransitionEnd,\n            this,\n            e.originalEvent as TransitionEvent,\n          )\n        }\n      })\n      .css({\n        transform,\n        transformOrigin,\n        transition: 'transform',\n        transitionDuration: options.duration || '1s',\n        transitionDelay: options.delay,\n        transitionTimingFunction: options.timing,\n      } as JQuery.PlainObject<string>)\n\n    return this\n  }\n\n  protected syncTransition(scale: number, p: Point.PointLike) {\n    this.beforeManipulation()\n    this.graph.scale(scale)\n    this.removeTransition()\n    this.centerPoint(p.x, p.y)\n    this.afterManipulation()\n    return this\n  }\n\n  protected removeTransition() {\n    this.$container.removeClass(Util.transitionClassName)\n    this.$content.off(Util.transitionEventName).css({\n      transform: '',\n      transformOrigin: '',\n      transition: '',\n      transitionDuration: '',\n      transitionDelay: '',\n      transitionTimingFunction: '',\n    })\n    return this\n  }\n\n  transitionToRect(\n    rectangle: Rectangle.RectangleLike,\n    options: Scroller.TransitionToRectOptions = {},\n  ) {\n    const rect = Rectangle.create(rectangle)\n    const maxScale = options.maxScale || Infinity\n    const minScale = options.minScale || Number.MIN_VALUE\n    const scaleGrid = options.scaleGrid || null\n    const PIXEL_SIZE = options.visibility || 1\n    const center = options.center\n      ? Point.create(options.center)\n      : rect.getCenter()\n    const clientSize = this.getClientSize()\n    const w = clientSize.width * PIXEL_SIZE\n    const h = clientSize.height * PIXEL_SIZE\n    let scale = new Rectangle(\n      center.x - w / 2,\n      center.y - h / 2,\n      w,\n      h,\n    ).getMaxUniformScaleToFit(rect, center)\n\n    scale = Math.min(scale, maxScale)\n    if (scaleGrid) {\n      scale = Math.floor(scale / scaleGrid) * scaleGrid\n    }\n    scale = Math.max(minScale, scale)\n\n    return this.transitionToPoint(center, {\n      scale,\n      ...options,\n    })\n  }\n\n  startPanning(evt: JQuery.MouseDownEvent) {\n    const e = this.normalizeEvent(evt)\n    this.clientX = e.clientX\n    this.clientY = e.clientY\n    this.trigger('pan:start', { e })\n    this.$(document.body).on({\n      'mousemove.panning touchmove.panning': this.pan.bind(this),\n      'mouseup.panning touchend.panning': this.stopPanning.bind(this),\n      'mouseleave.panning': this.stopPanning.bind(this),\n    })\n    this.$(window).on('mouseup.panning', this.stopPanning.bind(this))\n  }\n\n  pan(evt: JQuery.MouseMoveEvent) {\n    const e = this.normalizeEvent(evt)\n    const dx = e.clientX - this.clientX\n    const dy = e.clientY - this.clientY\n    this.container.scrollTop -= dy\n    this.container.scrollLeft -= dx\n    this.clientX = e.clientX\n    this.clientY = e.clientY\n    this.trigger('panning', { e })\n  }\n\n  stopPanning(e: JQuery.MouseUpEvent) {\n    this.$(document.body).off('.panning')\n    this.$(window).off('.panning')\n    this.trigger('pan:stop', { e })\n  }\n\n  clientToLocalPoint(p: Point.PointLike): Point\n  clientToLocalPoint(x: number, y: number): Point\n  clientToLocalPoint(a: number | Point.PointLike, b?: number) {\n    let x = typeof a === 'object' ? a.x : a\n    let y = typeof a === 'object' ? a.y : (b as number)\n\n    const ctm = this.graph.matrix()\n\n    x += this.container.scrollLeft - this.padding.left - ctm.e\n    y += this.container.scrollTop - this.padding.top - ctm.f\n\n    return new Point(x / ctm.a, y / ctm.d)\n  }\n\n  localToBackgroundPoint(p: Point.PointLike): Point\n  localToBackgroundPoint(x: number, y: number): Point\n  localToBackgroundPoint(x: number | Point.PointLike, y?: number) {\n    const p = typeof x === 'object' ? Point.create(x) : new Point(x, y)\n    const ctm = this.graph.matrix()\n    const padding = this.padding\n    return Dom.transformPoint(p, ctm).translate(padding.left, padding.top)\n  }\n\n  resize(width?: number, height?: number) {\n    let w = width != null ? width : this.container.offsetWidth\n    let h = height != null ? height : this.container.offsetHeight\n\n    if (typeof w === 'number') {\n      w = Math.round(w)\n    }\n    if (typeof h === 'number') {\n      h = Math.round(h)\n    }\n\n    this.options.width = w\n    this.options.height = h\n    this.$container.css({ width: w, height: h })\n    this.update()\n  }\n\n  getClientSize() {\n    if (this.cachedClientSize) {\n      return this.cachedClientSize\n    }\n    return {\n      width: this.container.clientWidth,\n      height: this.container.clientHeight,\n    }\n  }\n\n  autoScroll(clientX: number, clientY: number) {\n    const buffer = 10\n    const container = this.container\n    const rect = container.getBoundingClientRect()\n\n    let dx = 0\n    let dy = 0\n    if (clientX <= rect.left + buffer) {\n      dx = -buffer\n    }\n\n    if (clientY <= rect.top + buffer) {\n      dy = -buffer\n    }\n\n    if (clientX >= rect.right - buffer) {\n      dx = buffer\n    }\n\n    if (clientY >= rect.bottom - buffer) {\n      dy = buffer\n    }\n\n    if (dx !== 0) {\n      container.scrollLeft += dx\n    }\n\n    if (dy !== 0) {\n      container.scrollTop += dy\n    }\n\n    return {\n      scrollerX: dx,\n      scrollerY: dy,\n    }\n  }\n\n  protected addPadding(\n    left?: number,\n    right?: number,\n    top?: number,\n    bottom?: number,\n  ) {\n    let padding = this.getPadding()\n    this.padding = {\n      left: Math.round(padding.left + (left || 0)),\n      top: Math.round(padding.top + (top || 0)),\n      bottom: Math.round(padding.bottom + (bottom || 0)),\n      right: Math.round(padding.right + (right || 0)),\n    }\n\n    padding = this.padding\n\n    this.$content.css({\n      width: padding.left + this.graph.options.width + padding.right,\n      height: padding.top + this.graph.options.height + padding.bottom,\n    })\n\n    const container = this.graph.container\n    container.style.left = `${this.padding.left}px`\n    container.style.top = `${this.padding.top}px`\n\n    return this\n  }\n\n  protected getPadding() {\n    const padding = this.options.padding\n    if (typeof padding === 'function') {\n      return NumberExt.normalizeSides(FunctionExt.call(padding, this, this))\n    }\n\n    return NumberExt.normalizeSides(padding)\n  }\n\n  /**\n   * Returns the untransformed size and origin of the current viewport.\n   */\n  getVisibleArea() {\n    const ctm = this.graph.matrix()\n    const size = this.getClientSize()\n    const box = {\n      x: this.container.scrollLeft || 0,\n      y: this.container.scrollTop || 0,\n      width: size.width,\n      height: size.height,\n    }\n    const area = Dom.transformRectangle(box, ctm.inverse())\n    area.x -= (this.padding.left || 0) / this.sx\n    area.y -= (this.padding.top || 0) / this.sy\n    return area\n  }\n\n  isCellVisible(cell: Cell, options: { strict?: boolean } = {}) {\n    const bbox = cell.getBBox()\n    const area = this.getVisibleArea()\n    return options.strict\n      ? area.containsRect(bbox)\n      : area.isIntersectWithRect(bbox)\n  }\n\n  isPointVisible(point: Point.PointLike) {\n    return this.getVisibleArea().containsPoint(point)\n  }\n\n  /**\n   * Lock the current viewport by disabling user scrolling.\n   */\n  lock() {\n    this.$container.css('overflow', 'hidden')\n    return this\n  }\n\n  /**\n   * Enable user scrolling if previously locked.\n   */\n  unlock() {\n    this.$container.css('overflow', 'scroll')\n    return this\n  }\n\n  protected onRemove() {\n    this.stopListening()\n  }\n\n  @View.dispose()\n  dispose() {\n    this.$(this.graph.container).insertBefore(this.$container)\n    this.remove()\n  }\n}\n\nexport namespace Scroller {\n  export interface CommonOptions {\n    className?: string\n    width?: number\n    height?: number\n    pageWidth?: number\n    pageHeight?: number\n    pageVisible?: boolean\n    pageBreak?: boolean\n    minVisibleWidth?: number\n    minVisibleHeight?: number\n    background?: false | BackgroundManager.Options\n    autoResize?: boolean\n    padding?:\n      | NumberExt.SideOptions\n      | ((this: Scroller, scroller: Scroller) => NumberExt.SideOptions)\n    /**\n     * **Deprecation Notice:** Scroller option `fitTocontentOptions` is deprecated and will be\n     * moved in next major release. Use `autoResizeOptions` instead.\n     *\n     * @deprecated\n     */\n    fitTocontentOptions?:\n      | (TransformManager.FitToContentFullOptions & {\n          direction?: AutoResizeDirection | AutoResizeDirection[]\n        })\n      | ((\n          this: Scroller,\n          scroller: Scroller,\n        ) => TransformManager.FitToContentFullOptions & {\n          direction?: AutoResizeDirection | AutoResizeDirection[]\n        })\n    autoResizeOptions?:\n      | (TransformManager.FitToContentFullOptions & {\n          direction?: AutoResizeDirection | AutoResizeDirection[]\n        })\n      | ((\n          this: Scroller,\n          scroller: Scroller,\n        ) => TransformManager.FitToContentFullOptions & {\n          direction?: AutoResizeDirection | AutoResizeDirection[]\n        })\n  }\n\n  export interface Options extends CommonOptions {\n    graph: Graph\n  }\n\n  export interface ScrollOptions {\n    animation?: JQuery.EffectsOptions<HTMLElement>\n  }\n\n  export interface CenterOptions extends ScrollOptions {\n    padding?: NumberExt.SideOptions\n  }\n\n  export type PositionContentOptions = TransformManager.GetContentAreaOptions &\n    Scroller.CenterOptions\n\n  export type Direction =\n    | 'center'\n    | 'top'\n    | 'top-right'\n    | 'top-left'\n    | 'right'\n    | 'bottom-right'\n    | 'bottom'\n    | 'bottom-left'\n    | 'left'\n\n  export interface TransitionOptions {\n    /**\n     * The zoom level to reach at the end of the transition.\n     */\n    scale?: number\n    duration?: string\n    delay?: string\n    timing?: string\n    onTransitionEnd?: (this: Scroller, e: TransitionEvent) => void\n  }\n\n  export interface TransitionToRectOptions extends TransitionOptions {\n    minScale?: number\n    maxScale?: number\n    scaleGrid?: number\n    visibility?: number\n    center?: Point.PointLike\n  }\n\n  export type AutoResizeDirection = 'top' | 'right' | 'bottom' | 'left'\n}\n\nexport namespace Scroller {\n  export class Background extends BackgroundManager {\n    protected readonly scroller: Scroller\n\n    protected get elem() {\n      return this.scroller.background\n    }\n\n    constructor(scroller: Scroller) {\n      super(scroller.graph)\n\n      this.scroller = scroller\n      if (scroller.options.background) {\n        this.draw(scroller.options.background)\n      }\n    }\n\n    protected init() {\n      this.graph.on('scale', this.update, this)\n      this.graph.on('translate', this.update, this)\n    }\n\n    protected updateBackgroundOptions(options?: BackgroundManager.Options) {\n      this.scroller.options.background = options\n    }\n  }\n}\n\nnamespace Util {\n  export const containerClass = 'graph-scroller'\n  export const panningClass = `${containerClass}-panning`\n  export const pannableClass = `${containerClass}-pannable`\n  export const pagedClass = `${containerClass}-paged`\n  export const contentClass = `${containerClass}-content`\n  export const backgroundClass = `${containerClass}-background`\n  export const transitionClassName = 'transition-in-progress'\n  export const transitionEventName = 'transitionend.graph-scroller-transition'\n\n  export const defaultOptions: Partial<Scroller.Options> = {\n    padding() {\n      const size = this.getClientSize()\n      const minWidth = Math.max(this.options.minVisibleWidth || 0, 1) || 1\n      const minHeight = Math.max(this.options.minVisibleHeight || 0, 1) || 1\n      const left = Math.max(size.width - minWidth, 0)\n      const top = Math.max(size.height - minHeight, 0)\n      return { left, top, right: left, bottom: top }\n    },\n    minVisibleWidth: 50,\n    minVisibleHeight: 50,\n    pageVisible: false,\n    pageBreak: false,\n    autoResize: true,\n  }\n\n  export function getOptions(options: Scroller.Options) {\n    const result = ObjectExt.merge({}, defaultOptions, options)\n\n    if (result.pageWidth == null) {\n      result.pageWidth = options.graph.options.width\n    }\n    if (result.pageHeight == null) {\n      result.pageHeight = options.graph.options.height\n    }\n\n    return result as Scroller.Options\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}