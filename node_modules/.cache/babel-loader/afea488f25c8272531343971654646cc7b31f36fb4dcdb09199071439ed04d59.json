{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport Point from '@mapbox/point-geometry';\nimport { mat2, mat4, vec4 } from 'gl-matrix';\nimport { clamp, interpolates, wrap } from \"../util/util\";\nimport { EdgeInsets } from \"./edge_insets\";\nimport { LngLat } from \"./lng_lat\";\nimport { LngLatBounds } from \"./lng_lat_bounds\";\nimport { MercatorCoordinate, mercatorXfromLng, mercatorYfromLat, mercatorZfromAltitude } from \"./mercator_coordinate\";\nexport const MAX_VALID_LATITUDE = 85.051129;\n\n/**\n * @internal\n * A single transform, generally used for a single tile to be\n * scaled, rotated, and zoomed.\n */\nexport class Transform {\n  constructor(minZoom, maxZoom, minPitch, maxPitch, renderWorldCopies) {\n    _defineProperty(this, \"tileSize\", void 0);\n    _defineProperty(this, \"tileZoom\", void 0);\n    _defineProperty(this, \"lngRange\", void 0);\n    _defineProperty(this, \"latRange\", void 0);\n    _defineProperty(this, \"scale\", void 0);\n    _defineProperty(this, \"width\", void 0);\n    _defineProperty(this, \"height\", void 0);\n    _defineProperty(this, \"angle\", void 0);\n    _defineProperty(this, \"rotationMatrix\", void 0);\n    _defineProperty(this, \"pixelsToGLUnits\", void 0);\n    _defineProperty(this, \"cameraToCenterDistance\", void 0);\n    _defineProperty(this, \"mercatorMatrix\", void 0);\n    _defineProperty(this, \"projMatrix\", void 0);\n    _defineProperty(this, \"invProjMatrix\", void 0);\n    _defineProperty(this, \"alignedProjMatrix\", void 0);\n    _defineProperty(this, \"pixelMatrix\", void 0);\n    _defineProperty(this, \"pixelMatrix3D\", void 0);\n    _defineProperty(this, \"pixelMatrixInverse\", void 0);\n    _defineProperty(this, \"glCoordMatrix\", void 0);\n    _defineProperty(this, \"labelPlaneMatrix\", void 0);\n    _defineProperty(this, \"minElevationForCurrentTile\", void 0);\n    _defineProperty(this, \"_fov\", void 0);\n    _defineProperty(this, \"_pitch\", void 0);\n    _defineProperty(this, \"_zoom\", void 0);\n    _defineProperty(this, \"_unmodified\", void 0);\n    _defineProperty(this, \"_renderWorldCopies\", void 0);\n    _defineProperty(this, \"_minZoom\", void 0);\n    _defineProperty(this, \"_maxZoom\", void 0);\n    _defineProperty(this, \"_minPitch\", void 0);\n    _defineProperty(this, \"_maxPitch\", void 0);\n    _defineProperty(this, \"_center\", void 0);\n    _defineProperty(this, \"_elevation\", void 0);\n    _defineProperty(this, \"_pixelPerMeter\", void 0);\n    _defineProperty(this, \"_edgeInsets\", void 0);\n    _defineProperty(this, \"_constraining\", void 0);\n    _defineProperty(this, \"_posMatrixCache\", void 0);\n    _defineProperty(this, \"_alignedPosMatrixCache\", void 0);\n    this.tileSize = 512; // constant\n\n    this._renderWorldCopies = renderWorldCopies === undefined ? true : !!renderWorldCopies;\n    this._minZoom = minZoom || 0;\n    this._maxZoom = maxZoom || 22;\n    this._minPitch = minPitch === undefined || minPitch === null ? 0 : minPitch;\n    this._maxPitch = maxPitch === undefined || maxPitch === null ? 60 : maxPitch;\n    this.setMaxBounds();\n    this.width = 0;\n    this.height = 0;\n    this._center = new LngLat(0, 0);\n    this._elevation = 0;\n    this.zoom = 0;\n    this.angle = 0;\n    this._fov = 0.6435011087932844;\n    this._pitch = 0;\n    this._unmodified = true;\n    this._edgeInsets = new EdgeInsets();\n    this._posMatrixCache = {};\n    this._alignedPosMatrixCache = {};\n    this.minElevationForCurrentTile = 0;\n  }\n  clone() {\n    const clone = new Transform(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);\n    clone.apply(this);\n    return clone;\n  }\n  apply(that) {\n    this.tileSize = that.tileSize;\n    this.latRange = that.latRange;\n    this.width = that.width;\n    this.height = that.height;\n    this._center = that._center;\n    this._elevation = that._elevation;\n    this.minElevationForCurrentTile = that.minElevationForCurrentTile;\n    this.zoom = that.zoom;\n    this.angle = that.angle;\n    this._fov = that._fov;\n    this._pitch = that._pitch;\n    this._unmodified = that._unmodified;\n    this._edgeInsets = that._edgeInsets.clone();\n    this._calcMatrices();\n  }\n  get minZoom() {\n    return this._minZoom;\n  }\n  set minZoom(zoom) {\n    if (this._minZoom === zoom) return;\n    this._minZoom = zoom;\n    this.zoom = Math.max(this.zoom, zoom);\n  }\n  get maxZoom() {\n    return this._maxZoom;\n  }\n  set maxZoom(zoom) {\n    if (this._maxZoom === zoom) return;\n    this._maxZoom = zoom;\n    this.zoom = Math.min(this.zoom, zoom);\n  }\n  get minPitch() {\n    return this._minPitch;\n  }\n  set minPitch(pitch) {\n    if (this._minPitch === pitch) return;\n    this._minPitch = pitch;\n    this.pitch = Math.max(this.pitch, pitch);\n  }\n  get maxPitch() {\n    return this._maxPitch;\n  }\n  set maxPitch(pitch) {\n    if (this._maxPitch === pitch) return;\n    this._maxPitch = pitch;\n    this.pitch = Math.min(this.pitch, pitch);\n  }\n  get renderWorldCopies() {\n    return this._renderWorldCopies;\n  }\n  set renderWorldCopies(renderWorldCopies) {\n    if (renderWorldCopies === undefined) {\n      renderWorldCopies = true;\n    } else if (renderWorldCopies === null) {\n      renderWorldCopies = false;\n    }\n    this._renderWorldCopies = renderWorldCopies;\n  }\n  get worldSize() {\n    return this.tileSize * this.scale;\n  }\n  get centerOffset() {\n    return this.centerPoint._sub(this.size._div(2));\n  }\n  get size() {\n    return new Point(this.width, this.height);\n  }\n  get bearing() {\n    return -this.angle / Math.PI * 180;\n  }\n  set bearing(bearing) {\n    const b = -wrap(bearing, -180, 180) * Math.PI / 180;\n    if (this.angle === b) return;\n    this._unmodified = false;\n    this.angle = b;\n    this._calcMatrices();\n\n    // 2x2 matrix for rotating points\n    this.rotationMatrix = mat2.create();\n    mat2.rotate(this.rotationMatrix, this.rotationMatrix, this.angle);\n  }\n  get pitch() {\n    return this._pitch / Math.PI * 180;\n  }\n  set pitch(pitch) {\n    const p = clamp(pitch, this.minPitch, this.maxPitch) / 180 * Math.PI;\n    if (this._pitch === p) return;\n    this._unmodified = false;\n    this._pitch = p;\n    this._calcMatrices();\n  }\n  get fov() {\n    return this._fov / Math.PI * 180;\n  }\n  set fov(fov) {\n    fov = Math.max(0.01, Math.min(60, fov));\n    if (this._fov === fov) return;\n    this._unmodified = false;\n    this._fov = fov / 180 * Math.PI;\n    this._calcMatrices();\n  }\n  get zoom() {\n    return this._zoom;\n  }\n  set zoom(zoom) {\n    const constrainedZoom = Math.min(Math.max(zoom, this.minZoom), this.maxZoom);\n    if (this._zoom === constrainedZoom) return;\n    this._unmodified = false;\n    this._zoom = constrainedZoom;\n    this.tileZoom = Math.max(0, Math.floor(constrainedZoom));\n    this.scale = this.zoomScale(constrainedZoom);\n    this._constrain();\n    this._calcMatrices();\n  }\n  get center() {\n    return this._center;\n  }\n  set center(center) {\n    if (center.lat === this._center.lat && center.lng === this._center.lng) return;\n    this._unmodified = false;\n    this._center = center;\n    this._constrain();\n    this._calcMatrices();\n  }\n\n  /**\n   * Elevation at current center point, meters above sea level\n   */\n  get elevation() {\n    return this._elevation;\n  }\n  set elevation(elevation) {\n    if (elevation === this._elevation) return;\n    this._elevation = elevation;\n    this._constrain();\n    this._calcMatrices();\n  }\n  get padding() {\n    return this._edgeInsets.toJSON();\n  }\n  set padding(padding) {\n    if (this._edgeInsets.equals(padding)) return;\n    this._unmodified = false;\n    //Update edge-insets inplace\n    this._edgeInsets.interpolate(this._edgeInsets, padding, 1);\n    this._calcMatrices();\n  }\n\n  /**\n   * The center of the screen in pixels with the top-left corner being (0,0)\n   * and +y axis pointing downwards. This accounts for padding.\n   */\n  get centerPoint() {\n    return this._edgeInsets.getCenter(this.width, this.height);\n  }\n\n  /**\n   * Returns if the padding params match\n   *\n   * @param padding - the padding to check against\n   * @returns true if they are equal, false otherwise\n   */\n  isPaddingEqual(padding) {\n    return this._edgeInsets.equals(padding);\n  }\n\n  /**\n   * Helper method to update edge-insets in place\n   *\n   * @param start - the starting padding\n   * @param target - the target padding\n   * @param t - the step/weight\n   */\n  interpolatePadding(start, target, t) {\n    this._unmodified = false;\n    this._edgeInsets.interpolate(start, target, t);\n    this._constrain();\n    this._calcMatrices();\n  }\n\n  /**\n   * Return a zoom level that will cover all tiles the transform\n   * @param options - the options\n   * @returns zoom level An integer zoom level at which all tiles will be visible.\n   */\n  coveringZoomLevel(options) {\n    const z = (options.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / options.tileSize));\n    // At negative zoom levels load tiles from z0 because negative tile zoom levels don't exist.\n    return Math.max(0, z);\n  }\n  resize(width, height) {\n    this.width = width;\n    this.height = height;\n    this.pixelsToGLUnits = [2 / width, -2 / height];\n    this._constrain();\n    this._calcMatrices();\n  }\n  get unmodified() {\n    return this._unmodified;\n  }\n  zoomScale(zoom) {\n    return Math.pow(2, zoom);\n  }\n  scaleZoom(scale) {\n    return Math.log(scale) / Math.LN2;\n  }\n\n  /**\n   * Convert from LngLat to world coordinates (Mercator coordinates scaled by 512)\n   * @param lnglat - the lngLat\n   * @returns Point\n   */\n  project(lnglat) {\n    const lat = clamp(lnglat.lat, -MAX_VALID_LATITUDE, MAX_VALID_LATITUDE);\n    return new Point(mercatorXfromLng(lnglat.lng) * this.worldSize, mercatorYfromLat(lat) * this.worldSize);\n  }\n\n  /**\n   * Convert from world coordinates ([0, 512],[0, 512]) to LngLat ([-180, 180], [-90, 90])\n   * @param point - world coordinate\n   * @returns LngLat\n   */\n  unproject(point) {\n    return new MercatorCoordinate(point.x / this.worldSize, point.y / this.worldSize).toLngLat();\n  }\n  get point() {\n    return this.project(this.center);\n  }\n\n  /**\n   * get the camera position in LngLat and altitudes in meter\n   * @returns An object with lngLat & altitude.\n   */\n  getCameraPosition() {\n    const lngLat = this.pointLocation(this.getCameraPoint());\n    const altitude = Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter;\n    return {\n      lngLat,\n      altitude: altitude + this.elevation\n    };\n  }\n  setLocationAtPoint(lnglat, point) {\n    const a = this.pointCoordinate(point);\n    const b = this.pointCoordinate(this.centerPoint);\n    const loc = this.locationCoordinate(lnglat);\n    const newCenter = new MercatorCoordinate(loc.x - (a.x - b.x), loc.y - (a.y - b.y));\n    this.center = this.coordinateLocation(newCenter);\n    if (this._renderWorldCopies) {\n      this.center = this.center.wrap();\n    }\n  }\n\n  /**\n   * Given a LngLat location, return the screen point that corresponds to it\n   * @param lnglat - location\n   * @param terrain - optional terrain\n   * @returns screen point\n   */\n  locationPoint(lnglat) {\n    return this.coordinatePoint(this.locationCoordinate(lnglat));\n  }\n\n  /**\n   * Given a point on screen, return its lnglat\n   * @param p - screen point\n   * @param terrain - optional terrain\n   * @returns lnglat location\n   */\n  pointLocation(p) {\n    return this.coordinateLocation(this.pointCoordinate(p));\n  }\n\n  /**\n   * Given a geographical lnglat, return an unrounded\n   * coordinate that represents it at low zoom level.\n   * @param lnglat - the location\n   * @returns The mercator coordinate\n   */\n  locationCoordinate(lnglat) {\n    return MercatorCoordinate.fromLngLat(lnglat);\n  }\n\n  /**\n   * Given a Coordinate, return its geographical position.\n   * @param coord - mercator coordinates\n   * @returns lng and lat\n   */\n  coordinateLocation(coord) {\n    return coord && coord.toLngLat();\n  }\n\n  /**\n   * Given a Point, return its mercator coordinate.\n   * @param p - the point\n   * @param terrain - optional terrain\n   * @returns lnglat\n   */\n  pointCoordinate(p) {\n    // calculate point-coordinate on flat earth\n    const targetZ = 0;\n    // since we don't know the correct projected z value for the point,\n    // unproject two points to get a line and then find the point on that\n    // line with z=0\n\n    const coord0 = [p.x, p.y, 0, 1];\n    const coord1 = [p.x, p.y, 1, 1];\n    vec4.transformMat4(coord0, coord0, this.pixelMatrixInverse);\n    vec4.transformMat4(coord1, coord1, this.pixelMatrixInverse);\n    const w0 = coord0[3];\n    const w1 = coord1[3];\n    const x0 = coord0[0] / w0;\n    const x1 = coord1[0] / w1;\n    const y0 = coord0[1] / w0;\n    const y1 = coord1[1] / w1;\n    const z0 = coord0[2] / w0;\n    const z1 = coord1[2] / w1;\n    const t = z0 === z1 ? 0 : (targetZ - z0) / (z1 - z0);\n    return new MercatorCoordinate(interpolates.number(x0, x1, t) / this.worldSize, interpolates.number(y0, y1, t) / this.worldSize);\n  }\n\n  /**\n   * Given a coordinate, return the screen point that corresponds to it\n   * @param coord - the coordinates\n   * @param elevation - the elevation\n   * @param pixelMatrix - the pixel matrix\n   * @returns screen point\n   */\n  coordinatePoint(coord, elevation = 0, pixelMatrix = this.pixelMatrix) {\n    const p = [coord.x * this.worldSize, coord.y * this.worldSize, elevation, 1];\n    vec4.transformMat4(p, p, pixelMatrix);\n    return new Point(p[0] / p[3], p[1] / p[3]);\n  }\n\n  /**\n   * Returns the map's geographical bounds. When the bearing or pitch is non-zero, the visible region is not\n   * an axis-aligned rectangle, and the result is the smallest bounds that encompasses the visible region.\n   * @returns Returns a {@link LngLatBounds} object describing the map's geographical bounds.\n   */\n  getBounds() {\n    const top = Math.max(0, this.height / 2 - this.getHorizon());\n    return new LngLatBounds().extend(this.pointLocation(new Point(0, top))).extend(this.pointLocation(new Point(this.width, top))).extend(this.pointLocation(new Point(this.width, this.height))).extend(this.pointLocation(new Point(0, this.height)));\n  }\n\n  /**\n   * Returns the maximum geographical bounds the map is constrained to, or `null` if none set.\n   * @returns max bounds\n   */\n  getMaxBounds() {\n    if (!this.latRange || this.latRange.length !== 2 || !this.lngRange || this.lngRange.length !== 2) return null;\n    return new LngLatBounds([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]);\n  }\n\n  /**\n   * Calculate pixel height of the visible horizon in relation to map-center (e.g. height/2),\n   * multiplied by a static factor to simulate the earth-radius.\n   * The calculated value is the horizontal line from the camera-height to sea-level.\n   * @returns Horizon above center in pixels.\n   */\n  getHorizon() {\n    return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;\n  }\n\n  /**\n   * Sets or clears the map's geographical constraints.\n   * @param bounds - A {@link LngLatBounds} object describing the new geographic boundaries of the map.\n   */\n  setMaxBounds(bounds) {\n    if (bounds) {\n      this.lngRange = [bounds.getWest(), bounds.getEast()];\n      this.latRange = [bounds.getSouth(), bounds.getNorth()];\n      this._constrain();\n    } else {\n      this.lngRange = null;\n      this.latRange = [-MAX_VALID_LATITUDE, MAX_VALID_LATITUDE];\n    }\n  }\n  customLayerMatrix() {\n    return this.mercatorMatrix.slice();\n  }\n\n  /**\n   * Get center lngLat and zoom to ensure that\n   * 1) everything beyond the bounds is excluded\n   * 2) a given lngLat is as near the center as possible\n   * Bounds are those set by maxBounds or North & South \"Poles\" and, if only 1 globe is displayed, antimeridian.\n   */\n  getConstrained(lngLat, zoom) {\n    zoom = clamp(+zoom, this.minZoom, this.maxZoom);\n    const result = {\n      center: new LngLat(lngLat.lng, lngLat.lat),\n      zoom\n    };\n    let lngRange = this.lngRange;\n    if (!this._renderWorldCopies && lngRange === null) {\n      const almost180 = 180 - 1e-10;\n      lngRange = [-almost180, almost180];\n    }\n    const worldSize = this.tileSize * this.zoomScale(result.zoom); // A world size for the requested zoom level, not the current world size\n    let minY = 0;\n    let maxY = worldSize;\n    let minX = 0;\n    let maxX = worldSize;\n    let scaleY = 0;\n    let scaleX = 0;\n    const {\n      x: screenWidth,\n      y: screenHeight\n    } = this.size;\n    if (this.latRange) {\n      const latRange = this.latRange;\n      minY = mercatorYfromLat(latRange[1]) * worldSize;\n      maxY = mercatorYfromLat(latRange[0]) * worldSize;\n      const shouldZoomIn = maxY - minY < screenHeight;\n      if (shouldZoomIn) scaleY = screenHeight / (maxY - minY);\n    }\n    if (lngRange) {\n      minX = wrap(mercatorXfromLng(lngRange[0]) * worldSize, 0, worldSize);\n      maxX = wrap(mercatorXfromLng(lngRange[1]) * worldSize, 0, worldSize);\n      if (maxX < minX) maxX += worldSize;\n      const shouldZoomIn = maxX - minX < screenWidth;\n      if (shouldZoomIn) scaleX = screenWidth / (maxX - minX);\n    }\n    const {\n      x: originalX,\n      y: originalY\n    } = this.project.call({\n      worldSize\n    }, lngLat);\n    let modifiedX, modifiedY;\n    const scale = Math.max(scaleX || 0, scaleY || 0);\n    if (scale) {\n      // zoom in to exclude all beyond the given lng/lat ranges\n      const newPoint = new Point(scaleX ? (maxX + minX) / 2 : originalX, scaleY ? (maxY + minY) / 2 : originalY);\n      result.center = this.unproject.call({\n        worldSize\n      }, newPoint).wrap();\n      result.zoom += this.scaleZoom(scale);\n      return result;\n    }\n    if (this.latRange) {\n      const h2 = screenHeight / 2;\n      if (originalY - h2 < minY) modifiedY = minY + h2;\n      if (originalY + h2 > maxY) modifiedY = maxY - h2;\n    }\n    if (lngRange) {\n      const centerX = (minX + maxX) / 2;\n      let wrappedX = originalX;\n      if (this._renderWorldCopies) {\n        wrappedX = wrap(originalX, centerX - worldSize / 2, centerX + worldSize / 2);\n      }\n      const w2 = screenWidth / 2;\n      if (wrappedX - w2 < minX) modifiedX = minX + w2;\n      if (wrappedX + w2 > maxX) modifiedX = maxX - w2;\n    }\n\n    // pan the map if the screen goes off the range\n    if (modifiedX !== undefined || modifiedY !== undefined) {\n      var _modifiedX, _modifiedY;\n      const newPoint = new Point((_modifiedX = modifiedX) !== null && _modifiedX !== void 0 ? _modifiedX : originalX, (_modifiedY = modifiedY) !== null && _modifiedY !== void 0 ? _modifiedY : originalY);\n      result.center = this.unproject.call({\n        worldSize\n      }, newPoint).wrap();\n    }\n    return result;\n  }\n  _constrain() {\n    if (!this.center || !this.width || !this.height || this._constraining) return;\n    this._constraining = true;\n    const unmodified = this._unmodified;\n    const {\n      center,\n      zoom\n    } = this.getConstrained(this.center, this.zoom);\n    this.center = center;\n    this.zoom = zoom;\n    this._unmodified = unmodified;\n    this._constraining = false;\n  }\n  _calcMatrices() {\n    if (!this.height) return;\n    const halfFov = this._fov / 2;\n    const offset = this.centerOffset;\n    const x = this.point.x,\n      y = this.point.y;\n    this.cameraToCenterDistance = 0.5 / Math.tan(halfFov) * this.height;\n    this._pixelPerMeter = mercatorZfromAltitude(1, this.center.lat) * this.worldSize;\n    let m = mat4.identity(new Float64Array(16));\n    mat4.scale(m, m, [this.width / 2, -this.height / 2, 1]);\n    mat4.translate(m, m, [1, -1, 0]);\n    this.labelPlaneMatrix = m;\n    m = mat4.identity(new Float64Array(16));\n    mat4.scale(m, m, [1, -1, 1]);\n    mat4.translate(m, m, [-1, -1, 0]);\n    mat4.scale(m, m, [2 / this.width, 2 / this.height, 1]);\n    this.glCoordMatrix = m;\n\n    // Calculate the camera to sea-level distance in pixel in respect of terrain\n    const cameraToSeaLevelDistance = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch);\n    // In case of negative minimum elevation (e.g. the dead see, under the sea maps) use a lower plane for calculation\n    const minElevation = Math.min(this.elevation, this.minElevationForCurrentTile);\n    const cameraToLowestPointDistance = cameraToSeaLevelDistance - minElevation * this._pixelPerMeter / Math.cos(this._pitch);\n    const lowestPlane = minElevation < 0 ? cameraToLowestPointDistance : cameraToSeaLevelDistance;\n\n    // Find the distance from the center point [width/2 + offset.x, height/2 + offset.y] to the\n    // center top point [width/2 + offset.x, 0] in Z units, using the law of sines.\n    // 1 Z unit is equivalent to 1 horizontal px at the center of the map\n    // (the distance between[width/2, height/2] and [width/2 + 1, height/2])\n    const groundAngle = Math.PI / 2 + this._pitch;\n    const fovAboveCenter = this._fov * (0.5 + offset.y / this.height);\n    const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * lowestPlane / Math.sin(clamp(Math.PI - groundAngle - fovAboveCenter, 0.01, Math.PI - 0.01));\n\n    // Find the distance from the center point to the horizon\n    const horizon = this.getHorizon();\n    const horizonAngle = Math.atan(horizon / this.cameraToCenterDistance);\n    const fovCenterToHorizon = 2 * horizonAngle * (0.5 + offset.y / (horizon * 2));\n    const topHalfSurfaceDistanceHorizon = Math.sin(fovCenterToHorizon) * lowestPlane / Math.sin(clamp(Math.PI - groundAngle - fovCenterToHorizon, 0.01, Math.PI - 0.01));\n\n    // Calculate z distance of the farthest fragment that should be rendered.\n    // Add a bit extra to avoid precision problems when a fragment's distance is exactly `furthestDistance`\n    const topHalfMinDistance = Math.min(topHalfSurfaceDistance, topHalfSurfaceDistanceHorizon);\n    const farZ = (Math.cos(Math.PI / 2 - this._pitch) * topHalfMinDistance + lowestPlane) * 1.01;\n\n    // The larger the value of nearZ is\n    // - the more depth precision is available for features (good)\n    // - clipping starts appearing sooner when the camera is close to 3d features (bad)\n    //\n    // Other values work for mapbox-gl-js but deckgl was encountering precision issues\n    // when rendering custom layers. This value was experimentally chosen and\n    // seems to solve z-fighting issues in deckgl while not clipping buildings too close to the camera.\n    const nearZ = this.height / 50;\n\n    // matrix for conversion from location to clip space(-1 .. 1)\n    m = new Float64Array(16);\n    mat4.perspective(m, this._fov, this.width / this.height, nearZ, farZ);\n\n    // Apply center of perspective offset\n    m[8] = -offset.x * 2 / this.width;\n    m[9] = offset.y * 2 / this.height;\n    mat4.scale(m, m, [1, -1, 1]);\n    mat4.translate(m, m, [0, 0, -this.cameraToCenterDistance]);\n    mat4.rotateX(m, m, this._pitch);\n    mat4.rotateZ(m, m, this.angle);\n    mat4.translate(m, m, [-x, -y, 0]);\n\n    // The mercatorMatrix can be used to transform points from mercator coordinates\n    // ([0, 0] nw, [1, 1] se) to clip space.\n    this.mercatorMatrix = mat4.scale([], m, [this.worldSize, this.worldSize, this.worldSize]);\n\n    // scale vertically to meters per pixel (inverse of ground resolution):\n    mat4.scale(m, m, [1, 1, this._pixelPerMeter]);\n\n    // matrix for conversion from world space to screen coordinates in 2D\n    this.pixelMatrix = mat4.multiply(new Float64Array(16), this.labelPlaneMatrix, m);\n\n    // matrix for conversion from world space to clip space (-1 .. 1)\n    mat4.translate(m, m, [0, 0, -this.elevation]); // elevate camera over terrain\n    this.projMatrix = m;\n    this.invProjMatrix = mat4.invert([], m);\n\n    // matrix for conversion from world space to screen coordinates in 3D\n    this.pixelMatrix3D = mat4.multiply(new Float64Array(16), this.labelPlaneMatrix, m);\n\n    // Make a second projection matrix that is aligned to a pixel grid for rendering raster tiles.\n    // We're rounding the (floating point) x/y values to achieve to avoid rendering raster images to fractional\n    // coordinates. Additionally, we adjust by half a pixel in either direction in case that viewport dimension\n    // is an odd integer to preserve rendering to the pixel grid. We're rotating this shift based on the angle\n    // of the transformation so that 0°, 90°, 180°, and 270° rasters are crisp, and adjust the shift so that\n    // it is always <= 0.5 pixels.\n    const xShift = this.width % 2 / 2,\n      yShift = this.height % 2 / 2,\n      angleCos = Math.cos(this.angle),\n      angleSin = Math.sin(this.angle),\n      dx = x - Math.round(x) + angleCos * xShift + angleSin * yShift,\n      dy = y - Math.round(y) + angleCos * yShift + angleSin * xShift;\n    const alignedM = new Float64Array(m);\n    mat4.translate(alignedM, alignedM, [dx > 0.5 ? dx - 1 : dx, dy > 0.5 ? dy - 1 : dy, 0]);\n    this.alignedProjMatrix = alignedM;\n\n    // inverse matrix for conversion from screen coordinates to location\n    m = mat4.invert(new Float64Array(16), this.pixelMatrix);\n    if (!m) throw new Error('failed to invert matrix');\n    this.pixelMatrixInverse = m;\n    this._posMatrixCache = {};\n    this._alignedPosMatrixCache = {};\n  }\n  maxPitchScaleFactor() {\n    // calcMatrices hasn't run yet\n    if (!this.pixelMatrixInverse) return 1;\n    const coord = this.pointCoordinate(new Point(0, 0));\n    const p = [coord.x * this.worldSize, coord.y * this.worldSize, 0, 1];\n    const topPoint = vec4.transformMat4(p, p, this.pixelMatrix);\n    return topPoint[3] / this.cameraToCenterDistance;\n  }\n\n  /**\n   * The camera looks at the map from a 3D (lng, lat, altitude) location. Let's use `cameraLocation`\n   * as the name for the location under the camera and on the surface of the earth (lng, lat, 0).\n   * `cameraPoint` is the projected position of the `cameraLocation`.\n   *\n   * This point is useful to us because only fill-extrusions that are between `cameraPoint` and\n   * the query point on the surface of the earth can extend and intersect the query.\n   *\n   * When the map is not pitched the `cameraPoint` is equivalent to the center of the map because\n   * the camera is right above the center of the map.\n   */\n  getCameraPoint() {\n    const pitch = this._pitch;\n    const yOffset = Math.tan(pitch) * (this.cameraToCenterDistance || 1);\n    return this.centerPoint.add(new Point(0, yOffset));\n  }\n\n  /**\n   * When the map is pitched, some of the 3D features that intersect a query will not intersect\n   * the query at the surface of the earth. Instead the feature may be closer and only intersect\n   * the query because it extrudes into the air.\n   * @param queryGeometry - For point queries, the line from the query point to the \"camera point\",\n   * for other geometries, the envelope of the query geometry and the \"camera point\"\n   * @returns a geometry that includes all of the original query as well as all possible ares of the\n   * screen where the *base* of a visible extrusion could be.\n   *\n   */\n  getCameraQueryGeometry(queryGeometry) {\n    const c = this.getCameraPoint();\n    if (queryGeometry.length === 1) {\n      return [queryGeometry[0], c];\n    } else {\n      let minX = c.x;\n      let minY = c.y;\n      let maxX = c.x;\n      let maxY = c.y;\n      for (const p of queryGeometry) {\n        minX = Math.min(minX, p.x);\n        minY = Math.min(minY, p.y);\n        maxX = Math.max(maxX, p.x);\n        maxY = Math.max(maxY, p.y);\n      }\n      return [new Point(minX, minY), new Point(maxX, minY), new Point(maxX, maxY), new Point(minX, maxY), new Point(minX, minY)];\n    }\n  }\n  /**\n   * Return the distance to the camera in clip space from a LngLat.\n   * This can be compared to the value from the depth buffer (terrain.depthAtPoint)\n   * to determine whether a point is occluded.\n   * @param lngLat - the point\n   * @param elevation - the point's elevation\n   * @returns depth value in clip space (between 0 and 1)\n   */\n  lngLatToCameraDepth(lngLat, elevation) {\n    const coord = this.locationCoordinate(lngLat);\n    const p = [coord.x * this.worldSize, coord.y * this.worldSize, elevation, 1];\n    vec4.transformMat4(p, p, this.projMatrix);\n    return p[2] / p[3];\n  }\n}","map":{"version":3,"names":["_defineProperty","Point","mat2","mat4","vec4","clamp","interpolates","wrap","EdgeInsets","LngLat","LngLatBounds","MercatorCoordinate","mercatorXfromLng","mercatorYfromLat","mercatorZfromAltitude","MAX_VALID_LATITUDE","Transform","constructor","minZoom","maxZoom","minPitch","maxPitch","renderWorldCopies","tileSize","_renderWorldCopies","undefined","_minZoom","_maxZoom","_minPitch","_maxPitch","setMaxBounds","width","height","_center","_elevation","zoom","angle","_fov","_pitch","_unmodified","_edgeInsets","_posMatrixCache","_alignedPosMatrixCache","minElevationForCurrentTile","clone","apply","that","latRange","_calcMatrices","Math","max","min","pitch","worldSize","scale","centerOffset","centerPoint","_sub","size","_div","bearing","PI","b","rotationMatrix","create","rotate","p","fov","_zoom","constrainedZoom","tileZoom","floor","zoomScale","_constrain","center","lat","lng","elevation","padding","toJSON","equals","interpolate","getCenter","isPaddingEqual","interpolatePadding","start","target","t","coveringZoomLevel","options","z","roundZoom","round","scaleZoom","resize","pixelsToGLUnits","unmodified","pow","log","LN2","project","lnglat","unproject","point","x","y","toLngLat","getCameraPosition","lngLat","pointLocation","getCameraPoint","altitude","cos","cameraToCenterDistance","_pixelPerMeter","setLocationAtPoint","a","pointCoordinate","loc","locationCoordinate","newCenter","coordinateLocation","locationPoint","coordinatePoint","fromLngLat","coord","targetZ","coord0","coord1","transformMat4","pixelMatrixInverse","w0","w1","x0","x1","y0","y1","z0","z1","number","pixelMatrix","getBounds","top","getHorizon","extend","getMaxBounds","length","lngRange","tan","bounds","getWest","getEast","getSouth","getNorth","customLayerMatrix","mercatorMatrix","slice","getConstrained","result","almost180","minY","maxY","minX","maxX","scaleY","scaleX","screenWidth","screenHeight","shouldZoomIn","originalX","originalY","call","modifiedX","modifiedY","newPoint","h2","centerX","wrappedX","w2","_modifiedX","_modifiedY","_constraining","halfFov","offset","m","identity","Float64Array","translate","labelPlaneMatrix","glCoordMatrix","cameraToSeaLevelDistance","minElevation","cameraToLowestPointDistance","lowestPlane","groundAngle","fovAboveCenter","topHalfSurfaceDistance","sin","horizon","horizonAngle","atan","fovCenterToHorizon","topHalfSurfaceDistanceHorizon","topHalfMinDistance","farZ","nearZ","perspective","rotateX","rotateZ","multiply","projMatrix","invProjMatrix","invert","pixelMatrix3D","xShift","yShift","angleCos","angleSin","dx","dy","alignedM","alignedProjMatrix","Error","maxPitchScaleFactor","topPoint","yOffset","add","getCameraQueryGeometry","queryGeometry","c","lngLatToCameraDepth"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/l7-map/es/map/geo/transform.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport Point from '@mapbox/point-geometry';\nimport { mat2, mat4, vec4 } from 'gl-matrix';\nimport { clamp, interpolates, wrap } from \"../util/util\";\nimport { EdgeInsets } from \"./edge_insets\";\nimport { LngLat } from \"./lng_lat\";\nimport { LngLatBounds } from \"./lng_lat_bounds\";\nimport { MercatorCoordinate, mercatorXfromLng, mercatorYfromLat, mercatorZfromAltitude } from \"./mercator_coordinate\";\nexport const MAX_VALID_LATITUDE = 85.051129;\n\n/**\n * @internal\n * A single transform, generally used for a single tile to be\n * scaled, rotated, and zoomed.\n */\nexport class Transform {\n  constructor(minZoom, maxZoom, minPitch, maxPitch, renderWorldCopies) {\n    _defineProperty(this, \"tileSize\", void 0);\n    _defineProperty(this, \"tileZoom\", void 0);\n    _defineProperty(this, \"lngRange\", void 0);\n    _defineProperty(this, \"latRange\", void 0);\n    _defineProperty(this, \"scale\", void 0);\n    _defineProperty(this, \"width\", void 0);\n    _defineProperty(this, \"height\", void 0);\n    _defineProperty(this, \"angle\", void 0);\n    _defineProperty(this, \"rotationMatrix\", void 0);\n    _defineProperty(this, \"pixelsToGLUnits\", void 0);\n    _defineProperty(this, \"cameraToCenterDistance\", void 0);\n    _defineProperty(this, \"mercatorMatrix\", void 0);\n    _defineProperty(this, \"projMatrix\", void 0);\n    _defineProperty(this, \"invProjMatrix\", void 0);\n    _defineProperty(this, \"alignedProjMatrix\", void 0);\n    _defineProperty(this, \"pixelMatrix\", void 0);\n    _defineProperty(this, \"pixelMatrix3D\", void 0);\n    _defineProperty(this, \"pixelMatrixInverse\", void 0);\n    _defineProperty(this, \"glCoordMatrix\", void 0);\n    _defineProperty(this, \"labelPlaneMatrix\", void 0);\n    _defineProperty(this, \"minElevationForCurrentTile\", void 0);\n    _defineProperty(this, \"_fov\", void 0);\n    _defineProperty(this, \"_pitch\", void 0);\n    _defineProperty(this, \"_zoom\", void 0);\n    _defineProperty(this, \"_unmodified\", void 0);\n    _defineProperty(this, \"_renderWorldCopies\", void 0);\n    _defineProperty(this, \"_minZoom\", void 0);\n    _defineProperty(this, \"_maxZoom\", void 0);\n    _defineProperty(this, \"_minPitch\", void 0);\n    _defineProperty(this, \"_maxPitch\", void 0);\n    _defineProperty(this, \"_center\", void 0);\n    _defineProperty(this, \"_elevation\", void 0);\n    _defineProperty(this, \"_pixelPerMeter\", void 0);\n    _defineProperty(this, \"_edgeInsets\", void 0);\n    _defineProperty(this, \"_constraining\", void 0);\n    _defineProperty(this, \"_posMatrixCache\", void 0);\n    _defineProperty(this, \"_alignedPosMatrixCache\", void 0);\n    this.tileSize = 512; // constant\n\n    this._renderWorldCopies = renderWorldCopies === undefined ? true : !!renderWorldCopies;\n    this._minZoom = minZoom || 0;\n    this._maxZoom = maxZoom || 22;\n    this._minPitch = minPitch === undefined || minPitch === null ? 0 : minPitch;\n    this._maxPitch = maxPitch === undefined || maxPitch === null ? 60 : maxPitch;\n    this.setMaxBounds();\n    this.width = 0;\n    this.height = 0;\n    this._center = new LngLat(0, 0);\n    this._elevation = 0;\n    this.zoom = 0;\n    this.angle = 0;\n    this._fov = 0.6435011087932844;\n    this._pitch = 0;\n    this._unmodified = true;\n    this._edgeInsets = new EdgeInsets();\n    this._posMatrixCache = {};\n    this._alignedPosMatrixCache = {};\n    this.minElevationForCurrentTile = 0;\n  }\n  clone() {\n    const clone = new Transform(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);\n    clone.apply(this);\n    return clone;\n  }\n  apply(that) {\n    this.tileSize = that.tileSize;\n    this.latRange = that.latRange;\n    this.width = that.width;\n    this.height = that.height;\n    this._center = that._center;\n    this._elevation = that._elevation;\n    this.minElevationForCurrentTile = that.minElevationForCurrentTile;\n    this.zoom = that.zoom;\n    this.angle = that.angle;\n    this._fov = that._fov;\n    this._pitch = that._pitch;\n    this._unmodified = that._unmodified;\n    this._edgeInsets = that._edgeInsets.clone();\n    this._calcMatrices();\n  }\n  get minZoom() {\n    return this._minZoom;\n  }\n  set minZoom(zoom) {\n    if (this._minZoom === zoom) return;\n    this._minZoom = zoom;\n    this.zoom = Math.max(this.zoom, zoom);\n  }\n  get maxZoom() {\n    return this._maxZoom;\n  }\n  set maxZoom(zoom) {\n    if (this._maxZoom === zoom) return;\n    this._maxZoom = zoom;\n    this.zoom = Math.min(this.zoom, zoom);\n  }\n  get minPitch() {\n    return this._minPitch;\n  }\n  set minPitch(pitch) {\n    if (this._minPitch === pitch) return;\n    this._minPitch = pitch;\n    this.pitch = Math.max(this.pitch, pitch);\n  }\n  get maxPitch() {\n    return this._maxPitch;\n  }\n  set maxPitch(pitch) {\n    if (this._maxPitch === pitch) return;\n    this._maxPitch = pitch;\n    this.pitch = Math.min(this.pitch, pitch);\n  }\n  get renderWorldCopies() {\n    return this._renderWorldCopies;\n  }\n  set renderWorldCopies(renderWorldCopies) {\n    if (renderWorldCopies === undefined) {\n      renderWorldCopies = true;\n    } else if (renderWorldCopies === null) {\n      renderWorldCopies = false;\n    }\n    this._renderWorldCopies = renderWorldCopies;\n  }\n  get worldSize() {\n    return this.tileSize * this.scale;\n  }\n  get centerOffset() {\n    return this.centerPoint._sub(this.size._div(2));\n  }\n  get size() {\n    return new Point(this.width, this.height);\n  }\n  get bearing() {\n    return -this.angle / Math.PI * 180;\n  }\n  set bearing(bearing) {\n    const b = -wrap(bearing, -180, 180) * Math.PI / 180;\n    if (this.angle === b) return;\n    this._unmodified = false;\n    this.angle = b;\n    this._calcMatrices();\n\n    // 2x2 matrix for rotating points\n    this.rotationMatrix = mat2.create();\n    mat2.rotate(this.rotationMatrix, this.rotationMatrix, this.angle);\n  }\n  get pitch() {\n    return this._pitch / Math.PI * 180;\n  }\n  set pitch(pitch) {\n    const p = clamp(pitch, this.minPitch, this.maxPitch) / 180 * Math.PI;\n    if (this._pitch === p) return;\n    this._unmodified = false;\n    this._pitch = p;\n    this._calcMatrices();\n  }\n  get fov() {\n    return this._fov / Math.PI * 180;\n  }\n  set fov(fov) {\n    fov = Math.max(0.01, Math.min(60, fov));\n    if (this._fov === fov) return;\n    this._unmodified = false;\n    this._fov = fov / 180 * Math.PI;\n    this._calcMatrices();\n  }\n  get zoom() {\n    return this._zoom;\n  }\n  set zoom(zoom) {\n    const constrainedZoom = Math.min(Math.max(zoom, this.minZoom), this.maxZoom);\n    if (this._zoom === constrainedZoom) return;\n    this._unmodified = false;\n    this._zoom = constrainedZoom;\n    this.tileZoom = Math.max(0, Math.floor(constrainedZoom));\n    this.scale = this.zoomScale(constrainedZoom);\n    this._constrain();\n    this._calcMatrices();\n  }\n  get center() {\n    return this._center;\n  }\n  set center(center) {\n    if (center.lat === this._center.lat && center.lng === this._center.lng) return;\n    this._unmodified = false;\n    this._center = center;\n    this._constrain();\n    this._calcMatrices();\n  }\n\n  /**\n   * Elevation at current center point, meters above sea level\n   */\n  get elevation() {\n    return this._elevation;\n  }\n  set elevation(elevation) {\n    if (elevation === this._elevation) return;\n    this._elevation = elevation;\n    this._constrain();\n    this._calcMatrices();\n  }\n  get padding() {\n    return this._edgeInsets.toJSON();\n  }\n  set padding(padding) {\n    if (this._edgeInsets.equals(padding)) return;\n    this._unmodified = false;\n    //Update edge-insets inplace\n    this._edgeInsets.interpolate(this._edgeInsets, padding, 1);\n    this._calcMatrices();\n  }\n\n  /**\n   * The center of the screen in pixels with the top-left corner being (0,0)\n   * and +y axis pointing downwards. This accounts for padding.\n   */\n  get centerPoint() {\n    return this._edgeInsets.getCenter(this.width, this.height);\n  }\n\n  /**\n   * Returns if the padding params match\n   *\n   * @param padding - the padding to check against\n   * @returns true if they are equal, false otherwise\n   */\n  isPaddingEqual(padding) {\n    return this._edgeInsets.equals(padding);\n  }\n\n  /**\n   * Helper method to update edge-insets in place\n   *\n   * @param start - the starting padding\n   * @param target - the target padding\n   * @param t - the step/weight\n   */\n  interpolatePadding(start, target, t) {\n    this._unmodified = false;\n    this._edgeInsets.interpolate(start, target, t);\n    this._constrain();\n    this._calcMatrices();\n  }\n\n  /**\n   * Return a zoom level that will cover all tiles the transform\n   * @param options - the options\n   * @returns zoom level An integer zoom level at which all tiles will be visible.\n   */\n  coveringZoomLevel(options) {\n    const z = (options.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / options.tileSize));\n    // At negative zoom levels load tiles from z0 because negative tile zoom levels don't exist.\n    return Math.max(0, z);\n  }\n  resize(width, height) {\n    this.width = width;\n    this.height = height;\n    this.pixelsToGLUnits = [2 / width, -2 / height];\n    this._constrain();\n    this._calcMatrices();\n  }\n  get unmodified() {\n    return this._unmodified;\n  }\n  zoomScale(zoom) {\n    return Math.pow(2, zoom);\n  }\n  scaleZoom(scale) {\n    return Math.log(scale) / Math.LN2;\n  }\n\n  /**\n   * Convert from LngLat to world coordinates (Mercator coordinates scaled by 512)\n   * @param lnglat - the lngLat\n   * @returns Point\n   */\n  project(lnglat) {\n    const lat = clamp(lnglat.lat, -MAX_VALID_LATITUDE, MAX_VALID_LATITUDE);\n    return new Point(mercatorXfromLng(lnglat.lng) * this.worldSize, mercatorYfromLat(lat) * this.worldSize);\n  }\n\n  /**\n   * Convert from world coordinates ([0, 512],[0, 512]) to LngLat ([-180, 180], [-90, 90])\n   * @param point - world coordinate\n   * @returns LngLat\n   */\n  unproject(point) {\n    return new MercatorCoordinate(point.x / this.worldSize, point.y / this.worldSize).toLngLat();\n  }\n  get point() {\n    return this.project(this.center);\n  }\n\n  /**\n   * get the camera position in LngLat and altitudes in meter\n   * @returns An object with lngLat & altitude.\n   */\n  getCameraPosition() {\n    const lngLat = this.pointLocation(this.getCameraPoint());\n    const altitude = Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter;\n    return {\n      lngLat,\n      altitude: altitude + this.elevation\n    };\n  }\n  setLocationAtPoint(lnglat, point) {\n    const a = this.pointCoordinate(point);\n    const b = this.pointCoordinate(this.centerPoint);\n    const loc = this.locationCoordinate(lnglat);\n    const newCenter = new MercatorCoordinate(loc.x - (a.x - b.x), loc.y - (a.y - b.y));\n    this.center = this.coordinateLocation(newCenter);\n    if (this._renderWorldCopies) {\n      this.center = this.center.wrap();\n    }\n  }\n\n  /**\n   * Given a LngLat location, return the screen point that corresponds to it\n   * @param lnglat - location\n   * @param terrain - optional terrain\n   * @returns screen point\n   */\n  locationPoint(lnglat) {\n    return this.coordinatePoint(this.locationCoordinate(lnglat));\n  }\n\n  /**\n   * Given a point on screen, return its lnglat\n   * @param p - screen point\n   * @param terrain - optional terrain\n   * @returns lnglat location\n   */\n  pointLocation(p) {\n    return this.coordinateLocation(this.pointCoordinate(p));\n  }\n\n  /**\n   * Given a geographical lnglat, return an unrounded\n   * coordinate that represents it at low zoom level.\n   * @param lnglat - the location\n   * @returns The mercator coordinate\n   */\n  locationCoordinate(lnglat) {\n    return MercatorCoordinate.fromLngLat(lnglat);\n  }\n\n  /**\n   * Given a Coordinate, return its geographical position.\n   * @param coord - mercator coordinates\n   * @returns lng and lat\n   */\n  coordinateLocation(coord) {\n    return coord && coord.toLngLat();\n  }\n\n  /**\n   * Given a Point, return its mercator coordinate.\n   * @param p - the point\n   * @param terrain - optional terrain\n   * @returns lnglat\n   */\n  pointCoordinate(p) {\n    // calculate point-coordinate on flat earth\n    const targetZ = 0;\n    // since we don't know the correct projected z value for the point,\n    // unproject two points to get a line and then find the point on that\n    // line with z=0\n\n    const coord0 = [p.x, p.y, 0, 1];\n    const coord1 = [p.x, p.y, 1, 1];\n    vec4.transformMat4(coord0, coord0, this.pixelMatrixInverse);\n    vec4.transformMat4(coord1, coord1, this.pixelMatrixInverse);\n    const w0 = coord0[3];\n    const w1 = coord1[3];\n    const x0 = coord0[0] / w0;\n    const x1 = coord1[0] / w1;\n    const y0 = coord0[1] / w0;\n    const y1 = coord1[1] / w1;\n    const z0 = coord0[2] / w0;\n    const z1 = coord1[2] / w1;\n    const t = z0 === z1 ? 0 : (targetZ - z0) / (z1 - z0);\n    return new MercatorCoordinate(interpolates.number(x0, x1, t) / this.worldSize, interpolates.number(y0, y1, t) / this.worldSize);\n  }\n\n  /**\n   * Given a coordinate, return the screen point that corresponds to it\n   * @param coord - the coordinates\n   * @param elevation - the elevation\n   * @param pixelMatrix - the pixel matrix\n   * @returns screen point\n   */\n  coordinatePoint(coord, elevation = 0, pixelMatrix = this.pixelMatrix) {\n    const p = [coord.x * this.worldSize, coord.y * this.worldSize, elevation, 1];\n    vec4.transformMat4(p, p, pixelMatrix);\n    return new Point(p[0] / p[3], p[1] / p[3]);\n  }\n\n  /**\n   * Returns the map's geographical bounds. When the bearing or pitch is non-zero, the visible region is not\n   * an axis-aligned rectangle, and the result is the smallest bounds that encompasses the visible region.\n   * @returns Returns a {@link LngLatBounds} object describing the map's geographical bounds.\n   */\n  getBounds() {\n    const top = Math.max(0, this.height / 2 - this.getHorizon());\n    return new LngLatBounds().extend(this.pointLocation(new Point(0, top))).extend(this.pointLocation(new Point(this.width, top))).extend(this.pointLocation(new Point(this.width, this.height))).extend(this.pointLocation(new Point(0, this.height)));\n  }\n\n  /**\n   * Returns the maximum geographical bounds the map is constrained to, or `null` if none set.\n   * @returns max bounds\n   */\n  getMaxBounds() {\n    if (!this.latRange || this.latRange.length !== 2 || !this.lngRange || this.lngRange.length !== 2) return null;\n    return new LngLatBounds([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]);\n  }\n\n  /**\n   * Calculate pixel height of the visible horizon in relation to map-center (e.g. height/2),\n   * multiplied by a static factor to simulate the earth-radius.\n   * The calculated value is the horizontal line from the camera-height to sea-level.\n   * @returns Horizon above center in pixels.\n   */\n  getHorizon() {\n    return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;\n  }\n\n  /**\n   * Sets or clears the map's geographical constraints.\n   * @param bounds - A {@link LngLatBounds} object describing the new geographic boundaries of the map.\n   */\n  setMaxBounds(bounds) {\n    if (bounds) {\n      this.lngRange = [bounds.getWest(), bounds.getEast()];\n      this.latRange = [bounds.getSouth(), bounds.getNorth()];\n      this._constrain();\n    } else {\n      this.lngRange = null;\n      this.latRange = [-MAX_VALID_LATITUDE, MAX_VALID_LATITUDE];\n    }\n  }\n  customLayerMatrix() {\n    return this.mercatorMatrix.slice();\n  }\n\n  /**\n   * Get center lngLat and zoom to ensure that\n   * 1) everything beyond the bounds is excluded\n   * 2) a given lngLat is as near the center as possible\n   * Bounds are those set by maxBounds or North & South \"Poles\" and, if only 1 globe is displayed, antimeridian.\n   */\n  getConstrained(lngLat, zoom) {\n    zoom = clamp(+zoom, this.minZoom, this.maxZoom);\n    const result = {\n      center: new LngLat(lngLat.lng, lngLat.lat),\n      zoom\n    };\n    let lngRange = this.lngRange;\n    if (!this._renderWorldCopies && lngRange === null) {\n      const almost180 = 180 - 1e-10;\n      lngRange = [-almost180, almost180];\n    }\n    const worldSize = this.tileSize * this.zoomScale(result.zoom); // A world size for the requested zoom level, not the current world size\n    let minY = 0;\n    let maxY = worldSize;\n    let minX = 0;\n    let maxX = worldSize;\n    let scaleY = 0;\n    let scaleX = 0;\n    const {\n      x: screenWidth,\n      y: screenHeight\n    } = this.size;\n    if (this.latRange) {\n      const latRange = this.latRange;\n      minY = mercatorYfromLat(latRange[1]) * worldSize;\n      maxY = mercatorYfromLat(latRange[0]) * worldSize;\n      const shouldZoomIn = maxY - minY < screenHeight;\n      if (shouldZoomIn) scaleY = screenHeight / (maxY - minY);\n    }\n    if (lngRange) {\n      minX = wrap(mercatorXfromLng(lngRange[0]) * worldSize, 0, worldSize);\n      maxX = wrap(mercatorXfromLng(lngRange[1]) * worldSize, 0, worldSize);\n      if (maxX < minX) maxX += worldSize;\n      const shouldZoomIn = maxX - minX < screenWidth;\n      if (shouldZoomIn) scaleX = screenWidth / (maxX - minX);\n    }\n    const {\n      x: originalX,\n      y: originalY\n    } = this.project.call({\n      worldSize\n    }, lngLat);\n    let modifiedX, modifiedY;\n    const scale = Math.max(scaleX || 0, scaleY || 0);\n    if (scale) {\n      // zoom in to exclude all beyond the given lng/lat ranges\n      const newPoint = new Point(scaleX ? (maxX + minX) / 2 : originalX, scaleY ? (maxY + minY) / 2 : originalY);\n      result.center = this.unproject.call({\n        worldSize\n      }, newPoint).wrap();\n      result.zoom += this.scaleZoom(scale);\n      return result;\n    }\n    if (this.latRange) {\n      const h2 = screenHeight / 2;\n      if (originalY - h2 < minY) modifiedY = minY + h2;\n      if (originalY + h2 > maxY) modifiedY = maxY - h2;\n    }\n    if (lngRange) {\n      const centerX = (minX + maxX) / 2;\n      let wrappedX = originalX;\n      if (this._renderWorldCopies) {\n        wrappedX = wrap(originalX, centerX - worldSize / 2, centerX + worldSize / 2);\n      }\n      const w2 = screenWidth / 2;\n      if (wrappedX - w2 < minX) modifiedX = minX + w2;\n      if (wrappedX + w2 > maxX) modifiedX = maxX - w2;\n    }\n\n    // pan the map if the screen goes off the range\n    if (modifiedX !== undefined || modifiedY !== undefined) {\n      var _modifiedX, _modifiedY;\n      const newPoint = new Point((_modifiedX = modifiedX) !== null && _modifiedX !== void 0 ? _modifiedX : originalX, (_modifiedY = modifiedY) !== null && _modifiedY !== void 0 ? _modifiedY : originalY);\n      result.center = this.unproject.call({\n        worldSize\n      }, newPoint).wrap();\n    }\n    return result;\n  }\n  _constrain() {\n    if (!this.center || !this.width || !this.height || this._constraining) return;\n    this._constraining = true;\n    const unmodified = this._unmodified;\n    const {\n      center,\n      zoom\n    } = this.getConstrained(this.center, this.zoom);\n    this.center = center;\n    this.zoom = zoom;\n    this._unmodified = unmodified;\n    this._constraining = false;\n  }\n  _calcMatrices() {\n    if (!this.height) return;\n    const halfFov = this._fov / 2;\n    const offset = this.centerOffset;\n    const x = this.point.x,\n      y = this.point.y;\n    this.cameraToCenterDistance = 0.5 / Math.tan(halfFov) * this.height;\n    this._pixelPerMeter = mercatorZfromAltitude(1, this.center.lat) * this.worldSize;\n    let m = mat4.identity(new Float64Array(16));\n    mat4.scale(m, m, [this.width / 2, -this.height / 2, 1]);\n    mat4.translate(m, m, [1, -1, 0]);\n    this.labelPlaneMatrix = m;\n    m = mat4.identity(new Float64Array(16));\n    mat4.scale(m, m, [1, -1, 1]);\n    mat4.translate(m, m, [-1, -1, 0]);\n    mat4.scale(m, m, [2 / this.width, 2 / this.height, 1]);\n    this.glCoordMatrix = m;\n\n    // Calculate the camera to sea-level distance in pixel in respect of terrain\n    const cameraToSeaLevelDistance = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch);\n    // In case of negative minimum elevation (e.g. the dead see, under the sea maps) use a lower plane for calculation\n    const minElevation = Math.min(this.elevation, this.minElevationForCurrentTile);\n    const cameraToLowestPointDistance = cameraToSeaLevelDistance - minElevation * this._pixelPerMeter / Math.cos(this._pitch);\n    const lowestPlane = minElevation < 0 ? cameraToLowestPointDistance : cameraToSeaLevelDistance;\n\n    // Find the distance from the center point [width/2 + offset.x, height/2 + offset.y] to the\n    // center top point [width/2 + offset.x, 0] in Z units, using the law of sines.\n    // 1 Z unit is equivalent to 1 horizontal px at the center of the map\n    // (the distance between[width/2, height/2] and [width/2 + 1, height/2])\n    const groundAngle = Math.PI / 2 + this._pitch;\n    const fovAboveCenter = this._fov * (0.5 + offset.y / this.height);\n    const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * lowestPlane / Math.sin(clamp(Math.PI - groundAngle - fovAboveCenter, 0.01, Math.PI - 0.01));\n\n    // Find the distance from the center point to the horizon\n    const horizon = this.getHorizon();\n    const horizonAngle = Math.atan(horizon / this.cameraToCenterDistance);\n    const fovCenterToHorizon = 2 * horizonAngle * (0.5 + offset.y / (horizon * 2));\n    const topHalfSurfaceDistanceHorizon = Math.sin(fovCenterToHorizon) * lowestPlane / Math.sin(clamp(Math.PI - groundAngle - fovCenterToHorizon, 0.01, Math.PI - 0.01));\n\n    // Calculate z distance of the farthest fragment that should be rendered.\n    // Add a bit extra to avoid precision problems when a fragment's distance is exactly `furthestDistance`\n    const topHalfMinDistance = Math.min(topHalfSurfaceDistance, topHalfSurfaceDistanceHorizon);\n    const farZ = (Math.cos(Math.PI / 2 - this._pitch) * topHalfMinDistance + lowestPlane) * 1.01;\n\n    // The larger the value of nearZ is\n    // - the more depth precision is available for features (good)\n    // - clipping starts appearing sooner when the camera is close to 3d features (bad)\n    //\n    // Other values work for mapbox-gl-js but deckgl was encountering precision issues\n    // when rendering custom layers. This value was experimentally chosen and\n    // seems to solve z-fighting issues in deckgl while not clipping buildings too close to the camera.\n    const nearZ = this.height / 50;\n\n    // matrix for conversion from location to clip space(-1 .. 1)\n    m = new Float64Array(16);\n    mat4.perspective(m, this._fov, this.width / this.height, nearZ, farZ);\n\n    // Apply center of perspective offset\n    m[8] = -offset.x * 2 / this.width;\n    m[9] = offset.y * 2 / this.height;\n    mat4.scale(m, m, [1, -1, 1]);\n    mat4.translate(m, m, [0, 0, -this.cameraToCenterDistance]);\n    mat4.rotateX(m, m, this._pitch);\n    mat4.rotateZ(m, m, this.angle);\n    mat4.translate(m, m, [-x, -y, 0]);\n\n    // The mercatorMatrix can be used to transform points from mercator coordinates\n    // ([0, 0] nw, [1, 1] se) to clip space.\n    this.mercatorMatrix = mat4.scale([], m, [this.worldSize, this.worldSize, this.worldSize]);\n\n    // scale vertically to meters per pixel (inverse of ground resolution):\n    mat4.scale(m, m, [1, 1, this._pixelPerMeter]);\n\n    // matrix for conversion from world space to screen coordinates in 2D\n    this.pixelMatrix = mat4.multiply(new Float64Array(16), this.labelPlaneMatrix, m);\n\n    // matrix for conversion from world space to clip space (-1 .. 1)\n    mat4.translate(m, m, [0, 0, -this.elevation]); // elevate camera over terrain\n    this.projMatrix = m;\n    this.invProjMatrix = mat4.invert([], m);\n\n    // matrix for conversion from world space to screen coordinates in 3D\n    this.pixelMatrix3D = mat4.multiply(new Float64Array(16), this.labelPlaneMatrix, m);\n\n    // Make a second projection matrix that is aligned to a pixel grid for rendering raster tiles.\n    // We're rounding the (floating point) x/y values to achieve to avoid rendering raster images to fractional\n    // coordinates. Additionally, we adjust by half a pixel in either direction in case that viewport dimension\n    // is an odd integer to preserve rendering to the pixel grid. We're rotating this shift based on the angle\n    // of the transformation so that 0°, 90°, 180°, and 270° rasters are crisp, and adjust the shift so that\n    // it is always <= 0.5 pixels.\n    const xShift = this.width % 2 / 2,\n      yShift = this.height % 2 / 2,\n      angleCos = Math.cos(this.angle),\n      angleSin = Math.sin(this.angle),\n      dx = x - Math.round(x) + angleCos * xShift + angleSin * yShift,\n      dy = y - Math.round(y) + angleCos * yShift + angleSin * xShift;\n    const alignedM = new Float64Array(m);\n    mat4.translate(alignedM, alignedM, [dx > 0.5 ? dx - 1 : dx, dy > 0.5 ? dy - 1 : dy, 0]);\n    this.alignedProjMatrix = alignedM;\n\n    // inverse matrix for conversion from screen coordinates to location\n    m = mat4.invert(new Float64Array(16), this.pixelMatrix);\n    if (!m) throw new Error('failed to invert matrix');\n    this.pixelMatrixInverse = m;\n    this._posMatrixCache = {};\n    this._alignedPosMatrixCache = {};\n  }\n  maxPitchScaleFactor() {\n    // calcMatrices hasn't run yet\n    if (!this.pixelMatrixInverse) return 1;\n    const coord = this.pointCoordinate(new Point(0, 0));\n    const p = [coord.x * this.worldSize, coord.y * this.worldSize, 0, 1];\n    const topPoint = vec4.transformMat4(p, p, this.pixelMatrix);\n    return topPoint[3] / this.cameraToCenterDistance;\n  }\n\n  /**\n   * The camera looks at the map from a 3D (lng, lat, altitude) location. Let's use `cameraLocation`\n   * as the name for the location under the camera and on the surface of the earth (lng, lat, 0).\n   * `cameraPoint` is the projected position of the `cameraLocation`.\n   *\n   * This point is useful to us because only fill-extrusions that are between `cameraPoint` and\n   * the query point on the surface of the earth can extend and intersect the query.\n   *\n   * When the map is not pitched the `cameraPoint` is equivalent to the center of the map because\n   * the camera is right above the center of the map.\n   */\n  getCameraPoint() {\n    const pitch = this._pitch;\n    const yOffset = Math.tan(pitch) * (this.cameraToCenterDistance || 1);\n    return this.centerPoint.add(new Point(0, yOffset));\n  }\n\n  /**\n   * When the map is pitched, some of the 3D features that intersect a query will not intersect\n   * the query at the surface of the earth. Instead the feature may be closer and only intersect\n   * the query because it extrudes into the air.\n   * @param queryGeometry - For point queries, the line from the query point to the \"camera point\",\n   * for other geometries, the envelope of the query geometry and the \"camera point\"\n   * @returns a geometry that includes all of the original query as well as all possible ares of the\n   * screen where the *base* of a visible extrusion could be.\n   *\n   */\n  getCameraQueryGeometry(queryGeometry) {\n    const c = this.getCameraPoint();\n    if (queryGeometry.length === 1) {\n      return [queryGeometry[0], c];\n    } else {\n      let minX = c.x;\n      let minY = c.y;\n      let maxX = c.x;\n      let maxY = c.y;\n      for (const p of queryGeometry) {\n        minX = Math.min(minX, p.x);\n        minY = Math.min(minY, p.y);\n        maxX = Math.max(maxX, p.x);\n        maxY = Math.max(maxY, p.y);\n      }\n      return [new Point(minX, minY), new Point(maxX, minY), new Point(maxX, maxY), new Point(minX, maxY), new Point(minX, minY)];\n    }\n  }\n  /**\n   * Return the distance to the camera in clip space from a LngLat.\n   * This can be compared to the value from the depth buffer (terrain.depthAtPoint)\n   * to determine whether a point is occluded.\n   * @param lngLat - the point\n   * @param elevation - the point's elevation\n   * @returns depth value in clip space (between 0 and 1)\n   */\n  lngLatToCameraDepth(lngLat, elevation) {\n    const coord = this.locationCoordinate(lngLat);\n    const p = [coord.x * this.worldSize, coord.y * this.worldSize, elevation, 1];\n    vec4.transformMat4(p, p, this.projMatrix);\n    return p[2] / p[3];\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}