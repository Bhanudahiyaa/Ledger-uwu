{"ast":null,"code":"import { clamp, squaredLength } from '../util';\nimport { Line } from '../line';\nimport { Point } from '../point';\nimport { Curve } from '../curve';\nimport { Polyline } from '../polyline';\nimport { Rectangle } from '../rectangle';\nimport { Geometry } from '../geometry';\nimport { Close } from './close';\nimport { LineTo } from './lineto';\nimport { MoveTo } from './moveto';\nimport { CurveTo } from './curveto';\nimport { normalizePathData } from './normalize';\nimport * as Util from './util';\nexport class Path extends Geometry {\n  constructor(args) {\n    super();\n    this.PRECISION = 3;\n    this.segments = [];\n    if (Array.isArray(args)) {\n      if (Line.isLine(args[0]) || Curve.isCurve(args[0])) {\n        let previousObj = null;\n        const arr = args;\n        arr.forEach((o, i) => {\n          if (i === 0) {\n            this.appendSegment(Path.createSegment('M', o.start));\n          }\n          if (previousObj != null && !previousObj.end.equals(o.start)) {\n            this.appendSegment(Path.createSegment('M', o.start));\n          }\n          if (Line.isLine(o)) {\n            this.appendSegment(Path.createSegment('L', o.end));\n          } else if (Curve.isCurve(o)) {\n            this.appendSegment(Path.createSegment('C', o.controlPoint1, o.controlPoint2, o.end));\n          }\n          previousObj = o;\n        });\n      } else {\n        const arr = args;\n        arr.forEach(s => {\n          if (s.isSegment) {\n            this.appendSegment(s);\n          }\n        });\n      }\n    } else if (args != null) {\n      if (Line.isLine(args)) {\n        this.appendSegment(Path.createSegment('M', args.start));\n        this.appendSegment(Path.createSegment('L', args.end));\n      } else if (Curve.isCurve(args)) {\n        this.appendSegment(Path.createSegment('M', args.start));\n        this.appendSegment(Path.createSegment('C', args.controlPoint1, args.controlPoint2, args.end));\n      } else if (Polyline.isPolyline(args)) {\n        if (args.points && args.points.length) {\n          args.points.forEach((point, index) => {\n            const segment = index === 0 ? Path.createSegment('M', point) : Path.createSegment('L', point);\n            this.appendSegment(segment);\n          });\n        }\n      } else if (args.isSegment) {\n        this.appendSegment(args);\n      }\n    }\n  }\n  get [Symbol.toStringTag]() {\n    return Path.toStringTag;\n  }\n  get start() {\n    const segments = this.segments;\n    const count = segments.length;\n    if (count === 0) {\n      return null;\n    }\n    for (let i = 0; i < count; i += 1) {\n      const segment = segments[i];\n      if (segment.isVisible) {\n        return segment.start;\n      }\n    }\n    // if no visible segment, return last segment end point\n    return segments[count - 1].end;\n  }\n  get end() {\n    const segments = this.segments;\n    const count = segments.length;\n    if (count === 0) {\n      return null;\n    }\n    for (let i = count - 1; i >= 0; i -= 1) {\n      const segment = segments[i];\n      if (segment.isVisible) {\n        return segment.end;\n      }\n    }\n    // if no visible segment, return last segment end point\n    return segments[count - 1].end;\n  }\n  moveTo(...args) {\n    return this.appendSegment(MoveTo.create.call(null, ...args));\n  }\n  lineTo(...args) {\n    return this.appendSegment(LineTo.create.call(null, ...args));\n  }\n  curveTo(...args) {\n    return this.appendSegment(CurveTo.create.call(null, ...args));\n  }\n  arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY) {\n    const start = this.end || new Point();\n    const points = typeof endX === 'number' ? Util.arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY) : Util.arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX.x, endX.y);\n    if (points != null) {\n      for (let i = 0, ii = points.length; i < ii; i += 6) {\n        this.curveTo(points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5]);\n      }\n    }\n    return this;\n  }\n  quadTo(x1, y1, x, y) {\n    const start = this.end || new Point();\n    const data = ['M', start.x, start.y];\n    if (typeof x1 === 'number') {\n      data.push('Q', x1, y1, x, y);\n    } else {\n      const p = y1;\n      data.push(`Q`, x1.x, x1.y, p.x, p.y);\n    }\n    const path = Path.parse(data.join(' '));\n    this.appendSegment(path.segments.slice(1));\n    return this;\n  }\n  close() {\n    return this.appendSegment(Close.create());\n  }\n  drawPoints(points, options = {}) {\n    const raw = Util.drawPoints(points, options);\n    const sub = Path.parse(raw);\n    if (sub && sub.segments) {\n      this.appendSegment(sub.segments);\n    }\n  }\n  bbox() {\n    const segments = this.segments;\n    const count = segments.length;\n    if (count === 0) {\n      return null;\n    }\n    let bbox;\n    for (let i = 0; i < count; i += 1) {\n      const segment = segments[i];\n      if (segment.isVisible) {\n        const segmentBBox = segment.bbox();\n        if (segmentBBox != null) {\n          bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;\n        }\n      }\n    }\n    if (bbox != null) {\n      return bbox;\n    }\n    // if the path has only invisible elements, return end point of last segment\n    const lastSegment = segments[count - 1];\n    return new Rectangle(lastSegment.end.x, lastSegment.end.y, 0, 0);\n  }\n  appendSegment(seg) {\n    const count = this.segments.length;\n    let previousSegment = count !== 0 ? this.segments[count - 1] : null;\n    let currentSegment;\n    const nextSegment = null;\n    if (Array.isArray(seg)) {\n      for (let i = 0, ii = seg.length; i < ii; i += 1) {\n        const segment = seg[i];\n        currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);\n        this.segments.push(currentSegment);\n        previousSegment = currentSegment;\n      }\n    } else if (seg != null && seg.isSegment) {\n      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);\n      this.segments.push(currentSegment);\n    }\n    return this;\n  }\n  insertSegment(index, seg) {\n    const count = this.segments.length;\n    if (index < 0) {\n      index = count + index + 1; // eslint-disable-line\n    }\n    if (index > count || index < 0) {\n      throw new Error('Index out of range.');\n    }\n    let currentSegment;\n    let previousSegment = null;\n    let nextSegment = null;\n    if (count !== 0) {\n      if (index >= 1) {\n        previousSegment = this.segments[index - 1];\n        nextSegment = previousSegment.nextSegment;\n      } else {\n        previousSegment = null;\n        nextSegment = this.segments[0];\n      }\n    }\n    if (!Array.isArray(seg)) {\n      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);\n      this.segments.splice(index, 0, currentSegment);\n    } else {\n      for (let i = 0, ii = seg.length; i < ii; i += 1) {\n        const segment = seg[i];\n        currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);\n        this.segments.splice(index + i, 0, currentSegment);\n        previousSegment = currentSegment;\n      }\n    }\n    return this;\n  }\n  removeSegment(index) {\n    const idx = this.fixIndex(index);\n    const removedSegment = this.segments.splice(idx, 1)[0];\n    const previousSegment = removedSegment.previousSegment;\n    const nextSegment = removedSegment.nextSegment;\n    // link the previous and next segments together (if present)\n    if (previousSegment) {\n      previousSegment.nextSegment = nextSegment;\n    }\n    if (nextSegment) {\n      nextSegment.previousSegment = previousSegment;\n    }\n    if (removedSegment.isSubpathStart && nextSegment) {\n      this.updateSubpathStartSegment(nextSegment);\n    }\n    return removedSegment;\n  }\n  replaceSegment(index, seg) {\n    const idx = this.fixIndex(index);\n    let currentSegment;\n    const replacedSegment = this.segments[idx];\n    let previousSegment = replacedSegment.previousSegment;\n    const nextSegment = replacedSegment.nextSegment;\n    let updateSubpathStart = replacedSegment.isSubpathStart;\n    if (!Array.isArray(seg)) {\n      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);\n      this.segments.splice(idx, 1, currentSegment);\n      if (updateSubpathStart && currentSegment.isSubpathStart) {\n        // already updated by `prepareSegment`\n        updateSubpathStart = false;\n      }\n    } else {\n      this.segments.splice(index, 1);\n      for (let i = 0, ii = seg.length; i < ii; i += 1) {\n        const segment = seg[i];\n        currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);\n        this.segments.splice(index + i, 0, currentSegment);\n        previousSegment = currentSegment;\n        if (updateSubpathStart && currentSegment.isSubpathStart) {\n          updateSubpathStart = false;\n        }\n      }\n    }\n    if (updateSubpathStart && nextSegment) {\n      this.updateSubpathStartSegment(nextSegment);\n    }\n  }\n  getSegment(index) {\n    const idx = this.fixIndex(index);\n    return this.segments[idx];\n  }\n  fixIndex(index) {\n    const length = this.segments.length;\n    if (length === 0) {\n      throw new Error('Path has no segments.');\n    }\n    let i = index;\n    while (i < 0) {\n      i = length + i;\n    }\n    if (i >= length || i < 0) {\n      throw new Error('Index out of range.');\n    }\n    return i;\n  }\n  segmentAt(ratio, options = {}) {\n    const index = this.segmentIndexAt(ratio, options);\n    if (!index) {\n      return null;\n    }\n    return this.getSegment(index);\n  }\n  segmentAtLength(length, options = {}) {\n    const index = this.segmentIndexAtLength(length, options);\n    if (!index) return null;\n    return this.getSegment(index);\n  }\n  segmentIndexAt(ratio, options = {}) {\n    if (this.segments.length === 0) {\n      return null;\n    }\n    const rate = clamp(ratio, 0, 1);\n    const opt = this.getOptions(options);\n    const len = this.length(opt);\n    const length = len * rate;\n    return this.segmentIndexAtLength(length, opt);\n  }\n  segmentIndexAtLength(length, options = {}) {\n    const count = this.segments.length;\n    if (count === 0) {\n      return null;\n    }\n    let fromStart = true;\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let memo = 0;\n    let lastVisibleIndex = null;\n    for (let i = 0; i < count; i += 1) {\n      const index = fromStart ? i : count - 1 - i;\n      const segment = this.segments[index];\n      const subdivisions = segmentSubdivisions[index];\n      const len = segment.length({\n        precision,\n        subdivisions\n      });\n      if (segment.isVisible) {\n        if (length <= memo + len) {\n          return index;\n        }\n        lastVisibleIndex = index;\n      }\n      memo += len;\n    }\n    // If length requested is higher than the length of the path, return\n    // last visible segment index. If no visible segment, return null.\n    return lastVisibleIndex;\n  }\n  getSegmentSubdivisions(options = {}) {\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = [];\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i];\n      const subdivisions = segment.getSubdivisions({\n        precision\n      });\n      segmentSubdivisions.push(subdivisions);\n    }\n    return segmentSubdivisions;\n  }\n  updateSubpathStartSegment(segment) {\n    let previous = segment.previousSegment;\n    let current = segment;\n    while (current && !current.isSubpathStart) {\n      // assign previous segment's subpath start segment to this segment\n      if (previous != null) {\n        current.subpathStartSegment = previous.subpathStartSegment;\n      } else {\n        current.subpathStartSegment = null;\n      }\n      previous = current;\n      current = current.nextSegment;\n    }\n  }\n  prepareSegment(segment, previousSegment, nextSegment) {\n    segment.previousSegment = previousSegment;\n    segment.nextSegment = nextSegment;\n    if (previousSegment != null) {\n      previousSegment.nextSegment = segment;\n    }\n    if (nextSegment != null) {\n      nextSegment.previousSegment = segment;\n    }\n    let updateSubpathStart = segment;\n    if (segment.isSubpathStart) {\n      // move to\n      segment.subpathStartSegment = segment;\n      updateSubpathStart = nextSegment;\n    }\n    // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n    if (updateSubpathStart != null) {\n      this.updateSubpathStartSegment(updateSubpathStart);\n    }\n    return segment;\n  }\n  closestPoint(p, options = {}) {\n    const t = this.closestPointT(p, options);\n    if (!t) {\n      return null;\n    }\n    return this.pointAtT(t);\n  }\n  closestPointLength(p, options = {}) {\n    const opts = this.getOptions(options);\n    const t = this.closestPointT(p, opts);\n    if (!t) {\n      return 0;\n    }\n    return this.lengthAtT(t, opts);\n  }\n  closestPointNormalizedLength(p, options = {}) {\n    const opts = this.getOptions(options);\n    const cpLength = this.closestPointLength(p, opts);\n    if (cpLength === 0) {\n      return 0;\n    }\n    const length = this.length(opts);\n    if (length === 0) {\n      return 0;\n    }\n    return cpLength / length;\n  }\n  closestPointT(p, options = {}) {\n    if (this.segments.length === 0) {\n      return null;\n    }\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let closestPointT;\n    let minSquaredDistance = Infinity;\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i];\n      const subdivisions = segmentSubdivisions[i];\n      if (segment.isVisible) {\n        const segmentClosestPointT = segment.closestPointT(p, {\n          precision,\n          subdivisions\n        });\n        const segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n        const squaredDistance = squaredLength(segmentClosestPoint, p);\n        if (squaredDistance < minSquaredDistance) {\n          closestPointT = {\n            segmentIndex: i,\n            value: segmentClosestPointT\n          };\n          minSquaredDistance = squaredDistance;\n        }\n      }\n    }\n    if (closestPointT) {\n      return closestPointT;\n    }\n    return {\n      segmentIndex: this.segments.length - 1,\n      value: 1\n    };\n  }\n  closestPointTangent(p, options = {}) {\n    if (this.segments.length === 0) {\n      return null;\n    }\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let closestPointTangent;\n    let minSquaredDistance = Infinity;\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i];\n      const subdivisions = segmentSubdivisions[i];\n      if (segment.isDifferentiable()) {\n        const segmentClosestPointT = segment.closestPointT(p, {\n          precision,\n          subdivisions\n        });\n        const segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n        const squaredDistance = squaredLength(segmentClosestPoint, p);\n        if (squaredDistance < minSquaredDistance) {\n          closestPointTangent = segment.tangentAtT(segmentClosestPointT);\n          minSquaredDistance = squaredDistance;\n        }\n      }\n    }\n    if (closestPointTangent) {\n      return closestPointTangent;\n    }\n    return null;\n  }\n  containsPoint(p, options = {}) {\n    const polylines = this.toPolylines(options);\n    if (!polylines) {\n      return false;\n    }\n    let numIntersections = 0;\n    for (let i = 0, ii = polylines.length; i < ii; i += 1) {\n      const polyline = polylines[i];\n      if (polyline.containsPoint(p)) {\n        numIntersections += 1;\n      }\n    }\n    // returns `true` for odd numbers of intersections (even-odd algorithm)\n    return numIntersections % 2 === 1;\n  }\n  pointAt(ratio, options = {}) {\n    if (this.segments.length === 0) {\n      return null;\n    }\n    if (ratio <= 0) {\n      return this.start.clone();\n    }\n    if (ratio >= 1) {\n      return this.end.clone();\n    }\n    const opts = this.getOptions(options);\n    const pathLength = this.length(opts);\n    const length = pathLength * ratio;\n    return this.pointAtLength(length, opts);\n  }\n  pointAtLength(length, options = {}) {\n    if (this.segments.length === 0) {\n      return null;\n    }\n    if (length === 0) {\n      return this.start.clone();\n    }\n    let fromStart = true;\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let lastVisibleSegment;\n    let memo = 0;\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i;\n      const segment = this.segments[index];\n      const subdivisions = segmentSubdivisions[index];\n      const d = segment.length({\n        precision,\n        subdivisions\n      });\n      if (segment.isVisible) {\n        if (length <= memo + d) {\n          return segment.pointAtLength((fromStart ? 1 : -1) * (length - memo), {\n            precision,\n            subdivisions\n          });\n        }\n        lastVisibleSegment = segment;\n      }\n      memo += d;\n    }\n    // if length requested is higher than the length of the path,\n    // return last visible segment endpoint\n    if (lastVisibleSegment) {\n      return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start;\n    }\n    // if no visible segment, return last segment end point\n    const lastSegment = this.segments[this.segments.length - 1];\n    return lastSegment.end.clone();\n  }\n  pointAtT(t) {\n    const segments = this.segments;\n    const numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n    const segmentIndex = t.segmentIndex;\n    if (segmentIndex < 0) return segments[0].pointAtT(0);\n    if (segmentIndex >= numSegments) {\n      return segments[numSegments - 1].pointAtT(1);\n    }\n    const tValue = clamp(t.value, 0, 1);\n    return segments[segmentIndex].pointAtT(tValue);\n  }\n  divideAt(ratio, options = {}) {\n    if (this.segments.length === 0) {\n      return null;\n    }\n    const rate = clamp(ratio, 0, 1);\n    const opts = this.getOptions(options);\n    const len = this.length(opts);\n    const length = len * rate;\n    return this.divideAtLength(length, opts);\n  }\n  divideAtLength(length, options = {}) {\n    if (this.segments.length === 0) {\n      return null;\n    }\n    let fromStart = true;\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let memo = 0;\n    let divided;\n    let dividedSegmentIndex;\n    let lastValidSegment;\n    let lastValidSegmentIndex;\n    let t;\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i;\n      const segment = this.getSegment(index);\n      const subdivisions = segmentSubdivisions[index];\n      const opts = {\n        precision,\n        subdivisions\n      };\n      const len = segment.length(opts);\n      if (segment.isDifferentiable()) {\n        lastValidSegment = segment;\n        lastValidSegmentIndex = index;\n        if (length <= memo + len) {\n          dividedSegmentIndex = index;\n          divided = segment.divideAtLength((fromStart ? 1 : -1) * (length - memo), opts);\n          break;\n        }\n      }\n      memo += len;\n    }\n    if (!lastValidSegment) {\n      return null;\n    }\n    if (!divided) {\n      dividedSegmentIndex = lastValidSegmentIndex;\n      t = fromStart ? 1 : 0;\n      divided = lastValidSegment.divideAtT(t);\n    }\n    // create a copy of this path and replace the identified segment with its two divided parts:\n    const pathCopy = this.clone();\n    const index = dividedSegmentIndex;\n    pathCopy.replaceSegment(index, divided);\n    const divisionStartIndex = index;\n    let divisionMidIndex = index + 1;\n    let divisionEndIndex = index + 2;\n    // do not insert the part if it looks like a point\n    if (!divided[0].isDifferentiable()) {\n      pathCopy.removeSegment(divisionStartIndex);\n      divisionMidIndex -= 1;\n      divisionEndIndex -= 1;\n    }\n    // insert a Moveto segment to ensure secondPath will be valid:\n    const movetoEnd = pathCopy.getSegment(divisionMidIndex).start;\n    pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd));\n    divisionEndIndex += 1;\n    // do not insert the part if it looks like a point\n    if (!divided[1].isDifferentiable()) {\n      pathCopy.removeSegment(divisionEndIndex - 1);\n      divisionEndIndex -= 1;\n    }\n    // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n    const secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;\n    for (let i = divisionEndIndex, ii = pathCopy.segments.length; i < ii; i += 1) {\n      const originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);\n      const segment = pathCopy.getSegment(i);\n      if (segment.type === 'Z' && !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {\n        // pathCopy segment's subpathStartSegment is different from original segment's one\n        // convert this Closepath segment to a Lineto and replace it in pathCopy\n        const convertedSegment = Path.createSegment('L', originalSegment.end);\n        pathCopy.replaceSegment(i, convertedSegment);\n      }\n    }\n    // distribute pathCopy segments into two paths and return those:\n    const firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));\n    const secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));\n    return [firstPath, secondPath];\n  }\n  intersectsWithLine(line, options = {}) {\n    const polylines = this.toPolylines(options);\n    if (polylines == null) {\n      return null;\n    }\n    let intersections = null;\n    for (let i = 0, ii = polylines.length; i < ii; i += 1) {\n      const polyline = polylines[i];\n      const intersection = line.intersect(polyline);\n      if (intersection) {\n        if (intersections == null) {\n          intersections = [];\n        }\n        if (Array.isArray(intersection)) {\n          intersections.push(...intersection);\n        } else {\n          intersections.push(intersection);\n        }\n      }\n    }\n    return intersections;\n  }\n  isDifferentiable() {\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i];\n      if (segment.isDifferentiable()) {\n        return true;\n      }\n    }\n    return false;\n  }\n  isValid() {\n    const segments = this.segments;\n    const isValid = segments.length === 0 || segments[0].type === 'M';\n    return isValid;\n  }\n  length(options = {}) {\n    if (this.segments.length === 0) {\n      return 0;\n    }\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let length = 0;\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i];\n      const subdivisions = segmentSubdivisions[i];\n      length += segment.length({\n        subdivisions\n      });\n    }\n    return length;\n  }\n  lengthAtT(t, options = {}) {\n    const count = this.segments.length;\n    if (count === 0) {\n      return 0;\n    }\n    let segmentIndex = t.segmentIndex;\n    if (segmentIndex < 0) {\n      return 0;\n    }\n    let tValue = clamp(t.value, 0, 1);\n    if (segmentIndex >= count) {\n      segmentIndex = count - 1;\n      tValue = 1;\n    }\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let length = 0;\n    for (let i = 0; i < segmentIndex; i += 1) {\n      const segment = this.segments[i];\n      const subdivisions = segmentSubdivisions[i];\n      length += segment.length({\n        precision,\n        subdivisions\n      });\n    }\n    const segment = this.segments[segmentIndex];\n    const subdivisions = segmentSubdivisions[segmentIndex];\n    length += segment.lengthAtT(tValue, {\n      precision,\n      subdivisions\n    });\n    return length;\n  }\n  tangentAt(ratio, options = {}) {\n    if (this.segments.length === 0) {\n      return null;\n    }\n    const rate = clamp(ratio, 0, 1);\n    const opts = this.getOptions(options);\n    const len = this.length(opts);\n    const length = len * rate;\n    return this.tangentAtLength(length, opts);\n  }\n  tangentAtLength(length, options = {}) {\n    if (this.segments.length === 0) {\n      return null;\n    }\n    let fromStart = true;\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let lastValidSegment;\n    let memo = 0;\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i;\n      const segment = this.segments[index];\n      const subdivisions = segmentSubdivisions[index];\n      const len = segment.length({\n        precision,\n        subdivisions\n      });\n      if (segment.isDifferentiable()) {\n        if (length <= memo + len) {\n          return segment.tangentAtLength((fromStart ? 1 : -1) * (length - memo), {\n            precision,\n            subdivisions\n          });\n        }\n        lastValidSegment = segment;\n      }\n      memo += len;\n    }\n    // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n    if (lastValidSegment) {\n      const t = fromStart ? 1 : 0;\n      return lastValidSegment.tangentAtT(t);\n    }\n    // if no valid segment, return null\n    return null;\n  }\n  tangentAtT(t) {\n    const count = this.segments.length;\n    if (count === 0) {\n      return null;\n    }\n    const segmentIndex = t.segmentIndex;\n    if (segmentIndex < 0) {\n      return this.segments[0].tangentAtT(0);\n    }\n    if (segmentIndex >= count) {\n      return this.segments[count - 1].tangentAtT(1);\n    }\n    const tValue = clamp(t.value, 0, 1);\n    return this.segments[segmentIndex].tangentAtT(tValue);\n  }\n  getPrecision(options = {}) {\n    return options.precision == null ? this.PRECISION : options.precision;\n  }\n  getSubdivisions(options = {}) {\n    if (options.segmentSubdivisions == null) {\n      const precision = this.getPrecision(options);\n      return this.getSegmentSubdivisions({\n        precision\n      });\n    }\n    return options.segmentSubdivisions;\n  }\n  getOptions(options = {}) {\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    return {\n      precision,\n      segmentSubdivisions\n    };\n  }\n  toPoints(options = {}) {\n    const segments = this.segments;\n    const count = segments.length;\n    if (count === 0) {\n      return null;\n    }\n    const segmentSubdivisions = this.getSubdivisions(options);\n    const points = [];\n    let partialPoints = [];\n    for (let i = 0; i < count; i += 1) {\n      const segment = segments[i];\n      if (segment.isVisible) {\n        const divisions = segmentSubdivisions[i];\n        if (divisions.length > 0) {\n          // eslint-disable-next-line no-loop-func\n          divisions.forEach(c => partialPoints.push(c.start));\n        } else {\n          partialPoints.push(segment.start);\n        }\n      } else if (partialPoints.length > 0) {\n        partialPoints.push(segments[i - 1].end);\n        points.push(partialPoints);\n        partialPoints = [];\n      }\n    }\n    if (partialPoints.length > 0) {\n      partialPoints.push(this.end);\n      points.push(partialPoints);\n    }\n    return points;\n  }\n  toPolylines(options = {}) {\n    const points = this.toPoints(options);\n    if (!points) {\n      return null;\n    }\n    return points.map(arr => new Polyline(arr));\n  }\n  scale(sx, sy, origin) {\n    this.segments.forEach(s => s.scale(sx, sy, origin));\n    return this;\n  }\n  rotate(angle, origin) {\n    this.segments.forEach(segment => segment.rotate(angle, origin));\n    return this;\n  }\n  translate(tx, ty) {\n    if (typeof tx === 'number') {\n      this.segments.forEach(s => s.translate(tx, ty));\n    } else {\n      this.segments.forEach(s => s.translate(tx));\n    }\n    return this;\n  }\n  clone() {\n    const path = new Path();\n    this.segments.forEach(s => path.appendSegment(s.clone()));\n    return path;\n  }\n  equals(p) {\n    if (p == null) {\n      return false;\n    }\n    const segments = this.segments;\n    const otherSegments = p.segments;\n    const count = segments.length;\n    if (otherSegments.length !== count) {\n      return false;\n    }\n    for (let i = 0; i < count; i += 1) {\n      const a = segments[i];\n      const b = otherSegments[i];\n      if (a.type !== b.type || !a.equals(b)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  toJSON() {\n    return this.segments.map(s => s.toJSON());\n  }\n  serialize() {\n    if (!this.isValid()) {\n      throw new Error('Invalid path segments.');\n    }\n    return this.segments.map(s => s.serialize()).join(' ');\n  }\n  toString() {\n    return this.serialize();\n  }\n}\n(function (Path) {\n  Path.toStringTag = `X6.Geometry.${Path.name}`;\n  function isPath(instance) {\n    if (instance == null) {\n      return false;\n    }\n    if (instance instanceof Path) {\n      return true;\n    }\n    const tag = instance[Symbol.toStringTag];\n    const path = instance;\n    if ((tag == null || tag === Path.toStringTag) && Array.isArray(path.segments) && typeof path.moveTo === 'function' && typeof path.lineTo === 'function' && typeof path.curveTo === 'function') {\n      return true;\n    }\n    return false;\n  }\n  Path.isPath = isPath;\n})(Path || (Path = {}));\n(function (Path) {\n  function parse(pathData) {\n    if (!pathData) {\n      return new Path();\n    }\n    const path = new Path();\n    const commandRe = /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g;\n    const commands = Path.normalize(pathData).match(commandRe);\n    if (commands != null) {\n      for (let i = 0, ii = commands.length; i < ii; i += 1) {\n        const command = commands[i];\n        const argRe = /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g;\n        // args = [type, coordinate1, coordinate2...]\n        const args = command.match(argRe);\n        if (args != null) {\n          const type = args[0];\n          const coords = args.slice(1).map(a => +a);\n          const segment = createSegment.call(null, type, ...coords);\n          path.appendSegment(segment);\n        }\n      }\n    }\n    return path;\n  }\n  Path.parse = parse;\n  function createSegment(type, ...args) {\n    if (type === 'M') {\n      return MoveTo.create.call(null, ...args);\n    }\n    if (type === 'L') {\n      return LineTo.create.call(null, ...args);\n    }\n    if (type === 'C') {\n      return CurveTo.create.call(null, ...args);\n    }\n    if (type === 'z' || type === 'Z') {\n      return Close.create();\n    }\n    throw new Error(`Invalid path segment type \"${type}\"`);\n  }\n  Path.createSegment = createSegment;\n})(Path || (Path = {}));\n(function (Path) {\n  Path.normalize = normalizePathData;\n  Path.isValid = Util.isValid;\n  Path.drawArc = Util.drawArc;\n  Path.drawPoints = Util.drawPoints;\n  Path.arcToCurves = Util.arcToCurves;\n})(Path || (Path = {}));","map":{"version":3,"names":["clamp","squaredLength","Line","Point","Curve","Polyline","Rectangle","Geometry","Close","LineTo","MoveTo","CurveTo","normalizePathData","Util","Path","constructor","args","PRECISION","segments","Array","isArray","isLine","isCurve","previousObj","arr","forEach","o","i","appendSegment","createSegment","start","end","equals","controlPoint1","controlPoint2","s","isSegment","isPolyline","points","length","point","index","segment","Symbol","toStringTag","count","isVisible","moveTo","create","call","lineTo","curveTo","arcTo","rx","ry","xAxisRotation","largeArcFlag","sweepFlag","endX","endY","arcToCurves","x","y","ii","quadTo","x1","y1","data","push","p","path","parse","join","slice","close","drawPoints","options","raw","sub","bbox","segmentBBox","union","lastSegment","seg","previousSegment","currentSegment","nextSegment","prepareSegment","insertSegment","Error","splice","removeSegment","idx","fixIndex","removedSegment","isSubpathStart","updateSubpathStartSegment","replaceSegment","replacedSegment","updateSubpathStart","getSegment","segmentAt","ratio","segmentIndexAt","segmentAtLength","segmentIndexAtLength","rate","opt","getOptions","len","fromStart","precision","getPrecision","segmentSubdivisions","getSubdivisions","memo","lastVisibleIndex","subdivisions","getSegmentSubdivisions","previous","current","subpathStartSegment","closestPoint","t","closestPointT","pointAtT","closestPointLength","opts","lengthAtT","closestPointNormalizedLength","cpLength","minSquaredDistance","Infinity","segmentClosestPointT","segmentClosestPoint","squaredDistance","segmentIndex","value","closestPointTangent","isDifferentiable","tangentAtT","containsPoint","polylines","toPolylines","numIntersections","polyline","pointAt","clone","pathLength","pointAtLength","lastVisibleSegment","d","numSegments","tValue","divideAt","divideAtLength","divided","dividedSegmentIndex","lastValidSegment","lastValidSegmentIndex","divideAtT","pathCopy","divisionStartIndex","divisionMidIndex","divisionEndIndex","movetoEnd","secondPathSegmentIndexConversion","originalSegment","type","convertedSegment","firstPath","secondPath","intersectsWithLine","line","intersections","intersection","intersect","isValid","tangentAt","tangentAtLength","toPoints","partialPoints","divisions","c","map","scale","sx","sy","origin","rotate","angle","translate","tx","ty","otherSegments","a","b","toJSON","serialize","toString","name","isPath","instance","tag","pathData","commandRe","commands","normalize","match","command","argRe","coords","drawArc"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/geometry/path/path.ts"],"sourcesContent":["import { clamp, squaredLength } from '../util'\nimport { Line } from '../line'\nimport { Point } from '../point'\nimport { Curve } from '../curve'\nimport { Polyline } from '../polyline'\nimport { Rectangle } from '../rectangle'\nimport { Geometry } from '../geometry'\nimport { Close } from './close'\nimport { LineTo } from './lineto'\nimport { MoveTo } from './moveto'\nimport { CurveTo } from './curveto'\nimport { Segment } from './segment'\nimport { normalizePathData } from './normalize'\nimport * as Util from './util'\n\nexport class Path extends Geometry {\n  protected readonly PRECISION: number = 3\n  public segments: Segment[]\n\n  protected get [Symbol.toStringTag]() {\n    return Path.toStringTag\n  }\n\n  constructor()\n  constructor(line: Line)\n  constructor(curve: Curve)\n  constructor(polyline: Polyline)\n  constructor(segment: Segment)\n  constructor(segments: Segment[])\n  constructor(lines: Line[])\n  constructor(curves: Curve[])\n  constructor(\n    args?: Line | Curve | Polyline | Segment | Segment[] | Line[] | Curve[],\n  ) {\n    super()\n    this.segments = []\n    if (Array.isArray(args)) {\n      if (Line.isLine(args[0]) || Curve.isCurve(args[0])) {\n        let previousObj: Line | Curve | null = null\n        const arr = args as Line[] | Curve[]\n        arr.forEach((o: Line | Curve, i: number) => {\n          if (i === 0) {\n            this.appendSegment(Path.createSegment('M', o.start))\n          }\n          if (previousObj != null && !previousObj.end.equals(o.start)) {\n            this.appendSegment(Path.createSegment('M', o.start))\n          }\n\n          if (Line.isLine(o)) {\n            this.appendSegment(Path.createSegment('L', o.end))\n          } else if (Curve.isCurve(o)) {\n            this.appendSegment(\n              Path.createSegment('C', o.controlPoint1, o.controlPoint2, o.end),\n            )\n          }\n\n          previousObj = o\n        })\n      } else {\n        const arr = args as Segment[]\n        arr.forEach((s) => {\n          if (s.isSegment) {\n            this.appendSegment(s)\n          }\n        })\n      }\n    } else if (args != null) {\n      if (Line.isLine(args)) {\n        this.appendSegment(Path.createSegment('M', args.start))\n        this.appendSegment(Path.createSegment('L', args.end))\n      } else if (Curve.isCurve(args)) {\n        this.appendSegment(Path.createSegment('M', args.start))\n        this.appendSegment(\n          Path.createSegment(\n            'C',\n            args.controlPoint1,\n            args.controlPoint2,\n            args.end,\n          ),\n        )\n      } else if (Polyline.isPolyline(args)) {\n        if (args.points && args.points.length) {\n          args.points.forEach((point, index) => {\n            const segment =\n              index === 0\n                ? Path.createSegment('M', point)\n                : Path.createSegment('L', point)\n            this.appendSegment(segment)\n          })\n        }\n      } else if (args.isSegment) {\n        this.appendSegment(args)\n      }\n    }\n  }\n\n  get start() {\n    const segments = this.segments\n    const count = segments.length\n    if (count === 0) {\n      return null\n    }\n\n    for (let i = 0; i < count; i += 1) {\n      const segment = segments[i]\n      if (segment.isVisible) {\n        return segment.start\n      }\n    }\n\n    // if no visible segment, return last segment end point\n    return segments[count - 1].end\n  }\n\n  get end() {\n    const segments = this.segments\n    const count = segments.length\n    if (count === 0) {\n      return null\n    }\n\n    for (let i = count - 1; i >= 0; i -= 1) {\n      const segment = segments[i]\n      if (segment.isVisible) {\n        return segment.end\n      }\n    }\n\n    // if no visible segment, return last segment end point\n    return segments[count - 1].end\n  }\n\n  moveTo(x: number, y: number): this\n  moveTo(point: Point.PointLike): this\n  moveTo(line: Line): this\n  moveTo(curve: Curve): this\n  moveTo(point: Point.PointLike, ...points: Point.PointLike[]): this\n  moveTo(x: number, y: number, ...coords: number[]): this\n  moveTo(...args: any[]) {\n    return this.appendSegment(MoveTo.create.call(null, ...args))\n  }\n\n  lineTo(x: number, y: number): this\n  lineTo(point: Point.PointLike): this\n  lineTo(line: Line): this\n  lineTo(x: number, y: number, ...coords: number[]): this\n  lineTo(point: Point.PointLike, ...points: Point.PointLike[]): this\n  lineTo(...args: any[]) {\n    return this.appendSegment(LineTo.create.call(null, ...args))\n  }\n\n  curveTo(\n    x0: number,\n    y0: number,\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n  ): this\n  curveTo(\n    x0: number,\n    y0: number,\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    ...coords: number[]\n  ): this\n  curveTo(p1: Point.PointLike, p2: Point.PointLike, p3: Point.PointLike): this\n  curveTo(\n    p1: Point.PointLike,\n    p2: Point.PointLike,\n    p3: Point.PointLike,\n    ...points: Point.PointLike[]\n  ): this\n  curveTo(...args: any[]) {\n    return this.appendSegment(CurveTo.create.call(null, ...args))\n  }\n\n  arcTo(\n    rx: number,\n    ry: number,\n    xAxisRotation: number,\n    largeArcFlag: 0 | 1,\n    sweepFlag: 0 | 1,\n    endX: number,\n    endY: number,\n  ): this\n  arcTo(\n    rx: number,\n    ry: number,\n    xAxisRotation: number,\n    largeArcFlag: 0 | 1,\n    sweepFlag: 0 | 1,\n    endPoint: Point.PointLike,\n  ): this\n  arcTo(\n    rx: number,\n    ry: number,\n    xAxisRotation: number,\n    largeArcFlag: 0 | 1,\n    sweepFlag: 0 | 1,\n    endX: number | Point.PointLike,\n    endY?: number,\n  ) {\n    const start = this.end || new Point()\n    const points =\n      typeof endX === 'number'\n        ? Util.arcToCurves(\n            start.x,\n            start.y,\n            rx,\n            ry,\n            xAxisRotation,\n            largeArcFlag,\n            sweepFlag,\n            endX,\n            endY as number,\n          )\n        : Util.arcToCurves(\n            start.x,\n            start.y,\n            rx,\n            ry,\n            xAxisRotation,\n            largeArcFlag,\n            sweepFlag,\n            endX.x,\n            endX.y,\n          )\n\n    if (points != null) {\n      for (let i = 0, ii = points.length; i < ii; i += 6) {\n        this.curveTo(\n          points[i],\n          points[i + 1],\n          points[i + 2],\n          points[i + 3],\n          points[i + 4],\n          points[i + 5],\n        )\n      }\n    }\n    return this\n  }\n\n  quadTo(controlPoint: Point.PointLike, endPoint: Point.PointLike): this\n  quadTo(\n    controlPointX: number,\n    controlPointY: number,\n    endPointX: number,\n    endPointY: number,\n  ): this\n  quadTo(\n    x1: number | Point.PointLike,\n    y1: number | Point.PointLike,\n    x?: number,\n    y?: number,\n  ) {\n    const start = this.end || new Point()\n    const data = ['M', start.x, start.y]\n    if (typeof x1 === 'number') {\n      data.push('Q', x1, y1 as number, x as number, y as number)\n    } else {\n      const p = y1 as Point.PointLike\n      data.push(`Q`, x1.x, x1.y, p.x, p.y)\n    }\n    const path = Path.parse(data.join(' '))\n    this.appendSegment(path.segments.slice(1))\n    return this\n  }\n\n  close() {\n    return this.appendSegment(Close.create())\n  }\n\n  drawPoints(\n    points: (Point.PointLike | Point.PointData)[],\n    options: Util.DrawPointsOptions = {},\n  ) {\n    const raw = Util.drawPoints(points, options)\n    const sub = Path.parse(raw)\n    if (sub && sub.segments) {\n      this.appendSegment(sub.segments)\n    }\n  }\n\n  bbox() {\n    const segments = this.segments\n    const count = segments.length\n    if (count === 0) {\n      return null\n    }\n\n    let bbox\n    for (let i = 0; i < count; i += 1) {\n      const segment = segments[i]\n      if (segment.isVisible) {\n        const segmentBBox = segment.bbox()\n        if (segmentBBox != null) {\n          bbox = bbox ? bbox.union(segmentBBox) : segmentBBox\n        }\n      }\n    }\n\n    if (bbox != null) {\n      return bbox\n    }\n\n    // if the path has only invisible elements, return end point of last segment\n    const lastSegment = segments[count - 1]\n    return new Rectangle(lastSegment.end.x, lastSegment.end.y, 0, 0)\n  }\n\n  appendSegment(seg: Segment | Segment[]) {\n    const count = this.segments.length\n    let previousSegment = count !== 0 ? this.segments[count - 1] : null\n    let currentSegment\n    const nextSegment = null\n\n    if (Array.isArray(seg)) {\n      for (let i = 0, ii = seg.length; i < ii; i += 1) {\n        const segment = seg[i]\n        currentSegment = this.prepareSegment(\n          segment,\n          previousSegment,\n          nextSegment,\n        )\n        this.segments.push(currentSegment)\n        previousSegment = currentSegment\n      }\n    } else if (seg != null && seg.isSegment) {\n      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment)\n      this.segments.push(currentSegment)\n    }\n    return this\n  }\n\n  insertSegment(index: number, seg: Segment | Segment[]) {\n    const count = this.segments.length\n    if (index < 0) {\n      index = count + index + 1 // eslint-disable-line\n    }\n\n    if (index > count || index < 0) {\n      throw new Error('Index out of range.')\n    }\n\n    let currentSegment\n    let previousSegment = null\n    let nextSegment = null\n\n    if (count !== 0) {\n      if (index >= 1) {\n        previousSegment = this.segments[index - 1]\n        nextSegment = previousSegment.nextSegment\n      } else {\n        previousSegment = null\n        nextSegment = this.segments[0]\n      }\n    }\n\n    if (!Array.isArray(seg)) {\n      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment)\n      this.segments.splice(index, 0, currentSegment)\n    } else {\n      for (let i = 0, ii = seg.length; i < ii; i += 1) {\n        const segment = seg[i]\n        currentSegment = this.prepareSegment(\n          segment,\n          previousSegment,\n          nextSegment,\n        )\n        this.segments.splice(index + i, 0, currentSegment)\n        previousSegment = currentSegment\n      }\n    }\n    return this\n  }\n\n  removeSegment(index: number) {\n    const idx = this.fixIndex(index)\n    const removedSegment = this.segments.splice(idx, 1)[0]\n    const previousSegment = removedSegment.previousSegment\n    const nextSegment = removedSegment.nextSegment\n\n    // link the previous and next segments together (if present)\n    if (previousSegment) {\n      previousSegment.nextSegment = nextSegment\n    }\n\n    if (nextSegment) {\n      nextSegment.previousSegment = previousSegment\n    }\n\n    if (removedSegment.isSubpathStart && nextSegment) {\n      this.updateSubpathStartSegment(nextSegment)\n    }\n    return removedSegment\n  }\n\n  replaceSegment(index: number, seg: Segment | Segment[]) {\n    const idx = this.fixIndex(index)\n\n    let currentSegment\n    const replacedSegment = this.segments[idx]\n    let previousSegment = replacedSegment.previousSegment\n    const nextSegment = replacedSegment.nextSegment\n\n    let updateSubpathStart = replacedSegment.isSubpathStart\n\n    if (!Array.isArray(seg)) {\n      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment)\n      this.segments.splice(idx, 1, currentSegment)\n      if (updateSubpathStart && currentSegment.isSubpathStart) {\n        // already updated by `prepareSegment`\n        updateSubpathStart = false\n      }\n    } else {\n      this.segments.splice(index, 1)\n\n      for (let i = 0, ii = seg.length; i < ii; i += 1) {\n        const segment = seg[i]\n        currentSegment = this.prepareSegment(\n          segment,\n          previousSegment,\n          nextSegment,\n        )\n        this.segments.splice(index + i, 0, currentSegment)\n        previousSegment = currentSegment\n\n        if (updateSubpathStart && currentSegment.isSubpathStart) {\n          updateSubpathStart = false\n        }\n      }\n    }\n\n    if (updateSubpathStart && nextSegment) {\n      this.updateSubpathStartSegment(nextSegment)\n    }\n  }\n\n  getSegment(index: number) {\n    const idx = this.fixIndex(index)\n    return this.segments[idx]\n  }\n\n  protected fixIndex(index: number) {\n    const length = this.segments.length\n\n    if (length === 0) {\n      throw new Error('Path has no segments.')\n    }\n\n    let i = index\n    while (i < 0) {\n      i = length + i\n    }\n\n    if (i >= length || i < 0) {\n      throw new Error('Index out of range.')\n    }\n\n    return i\n  }\n\n  segmentAt(ratio: number, options: Path.Options = {}) {\n    const index = this.segmentIndexAt(ratio, options)\n    if (!index) {\n      return null\n    }\n\n    return this.getSegment(index)\n  }\n\n  segmentAtLength(length: number, options: Path.Options = {}) {\n    const index = this.segmentIndexAtLength(length, options)\n    if (!index) return null\n\n    return this.getSegment(index)\n  }\n\n  segmentIndexAt(ratio: number, options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return null\n    }\n\n    const rate = clamp(ratio, 0, 1)\n    const opt = this.getOptions(options)\n    const len = this.length(opt)\n    const length = len * rate\n    return this.segmentIndexAtLength(length, opt)\n  }\n\n  segmentIndexAtLength(length: number, options: Path.Options = {}) {\n    const count = this.segments.length\n    if (count === 0) {\n      return null\n    }\n\n    let fromStart = true\n    if (length < 0) {\n      fromStart = false\n      length = -length // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options)\n    const segmentSubdivisions = this.getSubdivisions(options)\n\n    let memo = 0\n    let lastVisibleIndex = null\n\n    for (let i = 0; i < count; i += 1) {\n      const index = fromStart ? i : count - 1 - i\n\n      const segment = this.segments[index]\n      const subdivisions = segmentSubdivisions[index]\n      const len = segment.length({ precision, subdivisions })\n\n      if (segment.isVisible) {\n        if (length <= memo + len) {\n          return index\n        }\n        lastVisibleIndex = index\n      }\n\n      memo += len\n    }\n\n    // If length requested is higher than the length of the path, return\n    // last visible segment index. If no visible segment, return null.\n    return lastVisibleIndex\n  }\n\n  getSegmentSubdivisions(options: Path.Options = {}): Segment[][] {\n    const precision = this.getPrecision(options)\n    const segmentSubdivisions = []\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i]\n      const subdivisions = segment.getSubdivisions({ precision })\n      segmentSubdivisions.push(subdivisions)\n    }\n\n    return segmentSubdivisions\n  }\n\n  protected updateSubpathStartSegment(segment: Segment) {\n    let previous = segment.previousSegment\n    let current: Segment | null = segment\n\n    while (current && !current.isSubpathStart) {\n      // assign previous segment's subpath start segment to this segment\n      if (previous != null) {\n        current.subpathStartSegment = previous.subpathStartSegment\n      } else {\n        current.subpathStartSegment = null\n      }\n\n      previous = current\n      current = current.nextSegment\n    }\n  }\n\n  protected prepareSegment(\n    segment: Segment,\n    previousSegment: Segment | null,\n    nextSegment: Segment | null,\n  ) {\n    segment.previousSegment = previousSegment\n    segment.nextSegment = nextSegment\n\n    if (previousSegment != null) {\n      previousSegment.nextSegment = segment\n    }\n\n    if (nextSegment != null) {\n      nextSegment.previousSegment = segment\n    }\n\n    let updateSubpathStart: Segment | null = segment\n    if (segment.isSubpathStart) {\n      // move to\n      segment.subpathStartSegment = segment\n      updateSubpathStart = nextSegment\n    }\n\n    // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n    if (updateSubpathStart != null) {\n      this.updateSubpathStartSegment(updateSubpathStart)\n    }\n\n    return segment\n  }\n\n  closestPoint(p: Point.PointLike, options: Path.Options = {}) {\n    const t = this.closestPointT(p, options)\n    if (!t) {\n      return null\n    }\n\n    return this.pointAtT(t)\n  }\n\n  closestPointLength(p: Point.PointLike, options: Path.Options = {}) {\n    const opts = this.getOptions(options)\n    const t = this.closestPointT(p, opts)\n    if (!t) {\n      return 0\n    }\n\n    return this.lengthAtT(t, opts)\n  }\n\n  closestPointNormalizedLength(p: Point.PointLike, options: Path.Options = {}) {\n    const opts = this.getOptions(options)\n    const cpLength = this.closestPointLength(p, opts)\n    if (cpLength === 0) {\n      return 0\n    }\n\n    const length = this.length(opts)\n    if (length === 0) {\n      return 0\n    }\n\n    return cpLength / length\n  }\n\n  closestPointT(p: Point.PointLike, options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return null\n    }\n\n    const precision = this.getPrecision(options)\n    const segmentSubdivisions = this.getSubdivisions(options)\n\n    let closestPointT\n    let minSquaredDistance = Infinity\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i]\n      const subdivisions = segmentSubdivisions[i]\n\n      if (segment.isVisible) {\n        const segmentClosestPointT = segment.closestPointT(p, {\n          precision,\n          subdivisions,\n        })\n        const segmentClosestPoint = segment.pointAtT(segmentClosestPointT)\n        const squaredDistance = squaredLength(segmentClosestPoint, p)\n\n        if (squaredDistance < minSquaredDistance) {\n          closestPointT = { segmentIndex: i, value: segmentClosestPointT }\n          minSquaredDistance = squaredDistance\n        }\n      }\n    }\n\n    if (closestPointT) {\n      return closestPointT\n    }\n\n    return { segmentIndex: this.segments.length - 1, value: 1 }\n  }\n\n  closestPointTangent(p: Point.PointLike, options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return null\n    }\n\n    const precision = this.getPrecision(options)\n    const segmentSubdivisions = this.getSubdivisions(options)\n\n    let closestPointTangent\n    let minSquaredDistance = Infinity\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i]\n      const subdivisions = segmentSubdivisions[i]\n\n      if (segment.isDifferentiable()) {\n        const segmentClosestPointT = segment.closestPointT(p, {\n          precision,\n          subdivisions,\n        })\n        const segmentClosestPoint = segment.pointAtT(segmentClosestPointT)\n        const squaredDistance = squaredLength(segmentClosestPoint, p)\n\n        if (squaredDistance < minSquaredDistance) {\n          closestPointTangent = segment.tangentAtT(segmentClosestPointT)\n          minSquaredDistance = squaredDistance\n        }\n      }\n    }\n\n    if (closestPointTangent) {\n      return closestPointTangent\n    }\n\n    return null\n  }\n\n  containsPoint(p: Point.PointLike, options: Path.Options = {}) {\n    const polylines = this.toPolylines(options)\n    if (!polylines) {\n      return false\n    }\n\n    let numIntersections = 0\n    for (let i = 0, ii = polylines.length; i < ii; i += 1) {\n      const polyline = polylines[i]\n      if (polyline.containsPoint(p)) {\n        numIntersections += 1\n      }\n    }\n\n    // returns `true` for odd numbers of intersections (even-odd algorithm)\n    return numIntersections % 2 === 1\n  }\n\n  pointAt(ratio: number, options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return null\n    }\n\n    if (ratio <= 0) {\n      return this.start!.clone()\n    }\n\n    if (ratio >= 1) {\n      return this.end!.clone()\n    }\n\n    const opts = this.getOptions(options)\n    const pathLength = this.length(opts)\n    const length = pathLength * ratio\n\n    return this.pointAtLength(length, opts)\n  }\n\n  pointAtLength(length: number, options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return null\n    }\n\n    if (length === 0) {\n      return this.start!.clone()\n    }\n\n    let fromStart = true\n    if (length < 0) {\n      fromStart = false\n      length = -length // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options)\n    const segmentSubdivisions = this.getSubdivisions(options)\n\n    let lastVisibleSegment\n    let memo = 0\n\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i\n\n      const segment = this.segments[index]\n      const subdivisions = segmentSubdivisions[index]\n      const d = segment.length({\n        precision,\n        subdivisions,\n      })\n\n      if (segment.isVisible) {\n        if (length <= memo + d) {\n          return segment.pointAtLength((fromStart ? 1 : -1) * (length - memo), {\n            precision,\n            subdivisions,\n          })\n        }\n\n        lastVisibleSegment = segment\n      }\n\n      memo += d\n    }\n\n    // if length requested is higher than the length of the path,\n    // return last visible segment endpoint\n    if (lastVisibleSegment) {\n      return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start\n    }\n\n    // if no visible segment, return last segment end point\n    const lastSegment = this.segments[this.segments.length - 1]\n    return lastSegment.end.clone()\n  }\n\n  pointAtT(t: { segmentIndex: number; value: number }) {\n    const segments = this.segments\n    const numSegments = segments.length\n    if (numSegments === 0) return null // if segments is an empty array\n\n    const segmentIndex = t.segmentIndex\n    if (segmentIndex < 0) return segments[0].pointAtT(0)\n    if (segmentIndex >= numSegments) {\n      return segments[numSegments - 1].pointAtT(1)\n    }\n\n    const tValue = clamp(t.value, 0, 1)\n    return segments[segmentIndex].pointAtT(tValue)\n  }\n\n  divideAt(ratio: number, options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return null\n    }\n\n    const rate = clamp(ratio, 0, 1)\n    const opts = this.getOptions(options)\n    const len = this.length(opts)\n    const length = len * rate\n    return this.divideAtLength(length, opts)\n  }\n\n  divideAtLength(length: number, options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return null\n    }\n\n    let fromStart = true\n    if (length < 0) {\n      fromStart = false\n      length = -length // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options)\n    const segmentSubdivisions = this.getSubdivisions(options)\n\n    let memo = 0\n    let divided\n    let dividedSegmentIndex\n    let lastValidSegment\n    let lastValidSegmentIndex\n    let t\n\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i\n      const segment = this.getSegment(index)\n      const subdivisions = segmentSubdivisions[index]\n      const opts = { precision, subdivisions }\n      const len = segment.length(opts)\n\n      if (segment.isDifferentiable()) {\n        lastValidSegment = segment\n        lastValidSegmentIndex = index\n\n        if (length <= memo + len) {\n          dividedSegmentIndex = index\n          divided = segment.divideAtLength(\n            (fromStart ? 1 : -1) * (length - memo),\n            opts,\n          )\n          break\n        }\n      }\n\n      memo += len\n    }\n\n    if (!lastValidSegment) {\n      return null\n    }\n\n    if (!divided) {\n      dividedSegmentIndex = lastValidSegmentIndex\n      t = fromStart ? 1 : 0\n      divided = lastValidSegment.divideAtT(t)\n    }\n\n    // create a copy of this path and replace the identified segment with its two divided parts:\n\n    const pathCopy = this.clone()\n    const index = dividedSegmentIndex as number\n    pathCopy.replaceSegment(index, divided)\n\n    const divisionStartIndex = index\n    let divisionMidIndex = index + 1\n    let divisionEndIndex = index + 2\n\n    // do not insert the part if it looks like a point\n    if (!divided[0].isDifferentiable()) {\n      pathCopy.removeSegment(divisionStartIndex)\n      divisionMidIndex -= 1\n      divisionEndIndex -= 1\n    }\n\n    // insert a Moveto segment to ensure secondPath will be valid:\n    const movetoEnd = pathCopy.getSegment(divisionMidIndex).start\n    pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd))\n    divisionEndIndex += 1\n\n    // do not insert the part if it looks like a point\n    if (!divided[1].isDifferentiable()) {\n      pathCopy.removeSegment(divisionEndIndex - 1)\n      divisionEndIndex -= 1\n    }\n\n    // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n\n    const secondPathSegmentIndexConversion =\n      divisionEndIndex - divisionStartIndex - 1\n\n    for (\n      let i = divisionEndIndex, ii = pathCopy.segments.length;\n      i < ii;\n      i += 1\n    ) {\n      const originalSegment = this.getSegment(\n        i - secondPathSegmentIndexConversion,\n      )\n      const segment = pathCopy.getSegment(i)\n\n      if (\n        segment.type === 'Z' &&\n        !originalSegment.subpathStartSegment!.end.equals(\n          segment.subpathStartSegment!.end,\n        )\n      ) {\n        // pathCopy segment's subpathStartSegment is different from original segment's one\n        // convert this Closepath segment to a Lineto and replace it in pathCopy\n        const convertedSegment = Path.createSegment('L', originalSegment.end)\n        pathCopy.replaceSegment(i, convertedSegment)\n      }\n    }\n\n    // distribute pathCopy segments into two paths and return those:\n    const firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex))\n    const secondPath = new Path(pathCopy.segments.slice(divisionMidIndex))\n\n    return [firstPath, secondPath]\n  }\n\n  intersectsWithLine(line: Line, options: Path.Options = {}) {\n    const polylines = this.toPolylines(options)\n    if (polylines == null) {\n      return null\n    }\n\n    let intersections: Point[] | null = null\n    for (let i = 0, ii = polylines.length; i < ii; i += 1) {\n      const polyline = polylines[i]\n      const intersection = line.intersect(polyline)\n      if (intersection) {\n        if (intersections == null) {\n          intersections = []\n        }\n        if (Array.isArray(intersection)) {\n          intersections.push(...intersection)\n        } else {\n          intersections.push(intersection)\n        }\n      }\n    }\n\n    return intersections\n  }\n\n  isDifferentiable() {\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i]\n      if (segment.isDifferentiable()) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  isValid() {\n    const segments = this.segments\n    const isValid = segments.length === 0 || segments[0].type === 'M'\n    return isValid\n  }\n\n  length(options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return 0\n    }\n\n    const segmentSubdivisions = this.getSubdivisions(options)\n\n    let length = 0\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i]\n      const subdivisions = segmentSubdivisions[i]\n      length += segment.length({ subdivisions })\n    }\n\n    return length\n  }\n\n  lengthAtT(\n    t: { segmentIndex: number; value: number },\n    options: Path.Options = {},\n  ) {\n    const count = this.segments.length\n    if (count === 0) {\n      return 0\n    }\n\n    let segmentIndex = t.segmentIndex\n    if (segmentIndex < 0) {\n      return 0\n    }\n\n    let tValue = clamp(t.value, 0, 1)\n    if (segmentIndex >= count) {\n      segmentIndex = count - 1\n      tValue = 1\n    }\n\n    const precision = this.getPrecision(options)\n    const segmentSubdivisions = this.getSubdivisions(options)\n\n    let length = 0\n    for (let i = 0; i < segmentIndex; i += 1) {\n      const segment = this.segments[i]\n      const subdivisions = segmentSubdivisions[i]\n      length += segment.length({ precision, subdivisions })\n    }\n\n    const segment = this.segments[segmentIndex]\n    const subdivisions = segmentSubdivisions[segmentIndex]\n    length += segment.lengthAtT(tValue, { precision, subdivisions })\n\n    return length\n  }\n\n  tangentAt(ratio: number, options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return null\n    }\n\n    const rate = clamp(ratio, 0, 1)\n    const opts = this.getOptions(options)\n    const len = this.length(opts)\n    const length = len * rate\n    return this.tangentAtLength(length, opts)\n  }\n\n  tangentAtLength(length: number, options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return null\n    }\n\n    let fromStart = true\n    if (length < 0) {\n      fromStart = false\n      length = -length // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options)\n    const segmentSubdivisions = this.getSubdivisions(options)\n\n    let lastValidSegment\n    let memo = 0\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i\n      const segment = this.segments[index]\n      const subdivisions = segmentSubdivisions[index]\n      const len = segment.length({ precision, subdivisions })\n\n      if (segment.isDifferentiable()) {\n        if (length <= memo + len) {\n          return segment.tangentAtLength(\n            (fromStart ? 1 : -1) * (length - memo),\n            {\n              precision,\n              subdivisions,\n            },\n          )\n        }\n\n        lastValidSegment = segment\n      }\n\n      memo += len\n    }\n\n    // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n    if (lastValidSegment) {\n      const t = fromStart ? 1 : 0\n      return lastValidSegment.tangentAtT(t)\n    }\n\n    // if no valid segment, return null\n    return null\n  }\n\n  tangentAtT(t: { segmentIndex: number; value: number }) {\n    const count = this.segments.length\n    if (count === 0) {\n      return null\n    }\n\n    const segmentIndex = t.segmentIndex\n    if (segmentIndex < 0) {\n      return this.segments[0].tangentAtT(0)\n    }\n\n    if (segmentIndex >= count) {\n      return this.segments[count - 1].tangentAtT(1)\n    }\n\n    const tValue = clamp(t.value, 0, 1)\n    return this.segments[segmentIndex].tangentAtT(tValue)\n  }\n\n  protected getPrecision(options: Path.Options = {}) {\n    return options.precision == null ? this.PRECISION : options.precision\n  }\n\n  protected getSubdivisions(options: Path.Options = {}) {\n    if (options.segmentSubdivisions == null) {\n      const precision = this.getPrecision(options)\n      return this.getSegmentSubdivisions({ precision })\n    }\n    return options.segmentSubdivisions\n  }\n\n  protected getOptions(options: Path.Options = {}) {\n    const precision = this.getPrecision(options)\n    const segmentSubdivisions = this.getSubdivisions(options)\n    return { precision, segmentSubdivisions }\n  }\n\n  toPoints(options: Path.Options = {}) {\n    const segments = this.segments\n    const count = segments.length\n    if (count === 0) {\n      return null\n    }\n\n    const segmentSubdivisions = this.getSubdivisions(options)\n    const points = []\n    let partialPoints = []\n\n    for (let i = 0; i < count; i += 1) {\n      const segment = segments[i]\n      if (segment.isVisible) {\n        const divisions = segmentSubdivisions[i]\n        if (divisions.length > 0) {\n          // eslint-disable-next-line no-loop-func\n          divisions.forEach((c) => partialPoints.push(c.start))\n        } else {\n          partialPoints.push(segment.start)\n        }\n      } else if (partialPoints.length > 0) {\n        partialPoints.push(segments[i - 1].end)\n        points.push(partialPoints)\n        partialPoints = []\n      }\n    }\n\n    if (partialPoints.length > 0) {\n      partialPoints.push(this.end!)\n      points.push(partialPoints)\n    }\n\n    return points\n  }\n\n  toPolylines(options: Path.Options = {}) {\n    const points = this.toPoints(options)\n    if (!points) {\n      return null\n    }\n\n    return points.map((arr) => new Polyline(arr))\n  }\n\n  scale(sx: number, sy: number, origin?: Point.PointLike) {\n    this.segments.forEach((s) => s.scale(sx, sy, origin))\n    return this\n  }\n\n  rotate(angle: number, origin?: Point.PointLike | Point.PointData) {\n    this.segments.forEach((segment) => segment.rotate(angle, origin))\n    return this\n  }\n\n  translate(tx: number, ty: number): this\n  translate(p: Point.PointLike): this\n  translate(tx: number | Point.PointLike, ty?: number) {\n    if (typeof tx === 'number') {\n      this.segments.forEach((s) => s.translate(tx, ty as number))\n    } else {\n      this.segments.forEach((s) => s.translate(tx))\n    }\n    return this\n  }\n\n  clone() {\n    const path = new Path()\n    this.segments.forEach((s) => path.appendSegment(s.clone()))\n    return path\n  }\n\n  equals(p: Path) {\n    if (p == null) {\n      return false\n    }\n\n    const segments = this.segments\n    const otherSegments = p.segments\n\n    const count = segments.length\n    if (otherSegments.length !== count) {\n      return false\n    }\n\n    for (let i = 0; i < count; i += 1) {\n      const a = segments[i]\n      const b = otherSegments[i]\n      if (a.type !== b.type || !a.equals(b)) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  toJSON() {\n    return this.segments.map((s) => s.toJSON())\n  }\n\n  serialize() {\n    if (!this.isValid()) {\n      throw new Error('Invalid path segments.')\n    }\n\n    return this.segments.map((s) => s.serialize()).join(' ')\n  }\n\n  toString() {\n    return this.serialize()\n  }\n}\n\nexport namespace Path {\n  export const toStringTag = `X6.Geometry.${Path.name}`\n\n  export function isPath(instance: any): instance is Path {\n    if (instance == null) {\n      return false\n    }\n\n    if (instance instanceof Path) {\n      return true\n    }\n\n    const tag = instance[Symbol.toStringTag]\n    const path = instance as Path\n\n    if (\n      (tag == null || tag === toStringTag) &&\n      Array.isArray(path.segments) &&\n      typeof path.moveTo === 'function' &&\n      typeof path.lineTo === 'function' &&\n      typeof path.curveTo === 'function'\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n\nexport namespace Path {\n  export interface Options {\n    precision?: number | null\n    segmentSubdivisions?: Segment[][] | null\n  }\n}\n\nexport namespace Path {\n  export function parse(pathData: string) {\n    if (!pathData) {\n      return new Path()\n    }\n\n    const path = new Path()\n\n    const commandRe =\n      /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g\n    const commands = normalize(pathData).match(commandRe)\n    if (commands != null) {\n      for (let i = 0, ii = commands.length; i < ii; i += 1) {\n        const command = commands[i]\n        const argRe =\n          /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g\n        // args = [type, coordinate1, coordinate2...]\n        const args = command.match(argRe)\n        if (args != null) {\n          const type = args[0]\n          const coords = args.slice(1).map((a) => +a)\n          const segment = createSegment.call(null, type, ...coords)\n          path.appendSegment(segment)\n        }\n      }\n    }\n\n    return path\n  }\n\n  export function createSegment(type: 'M', x: number, y: number): MoveTo\n  export function createSegment(type: 'M', point: Point.PointLike): MoveTo\n  export function createSegment(type: 'M', line: Line): MoveTo\n  export function createSegment(type: 'M', curve: Curve): MoveTo\n  export function createSegment(\n    type: 'M',\n    point: Point.PointLike,\n    ...points: Point.PointLike[]\n  ): Segment[]\n  export function createSegment(\n    type: 'M',\n    x: number,\n    y: number,\n    ...coords: number[]\n  ): Segment[]\n  export function createSegment(type: 'L', x: number, y: number): LineTo\n  export function createSegment(type: 'L', point: Point.PointLike): LineTo\n  export function createSegment(type: 'L', line: Line): LineTo\n  export function createSegment(\n    type: 'L',\n    point: Point.PointLike,\n    ...points: Point.PointLike[]\n  ): LineTo[]\n  export function createSegment(\n    type: 'L',\n    x: number,\n    y: number,\n    ...coords: number[]\n  ): LineTo[]\n  export function createSegment(\n    type: 'C',\n    x0: number,\n    y0: number,\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n  ): CurveTo\n  export function createSegment(\n    type: 'C',\n    x0: number,\n    y0: number,\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    ...coords: number[]\n  ): CurveTo[]\n  export function createSegment(\n    type: 'C',\n    p1: Point.PointLike,\n    p2: Point.PointLike,\n    p3: Point.PointLike,\n  ): CurveTo\n  export function createSegment(\n    type: 'C',\n    p1: Point.PointLike,\n    p2: Point.PointLike,\n    p3: Point.PointLike,\n    ...points: Point.PointLike[]\n  ): CurveTo[]\n  export function createSegment(type: 'Z' | 'z'): Close\n  export function createSegment(\n    type: 'M' | 'L' | 'C' | 'Z' | 'z',\n    ...args: any[]\n  ):\n    | MoveTo\n    | MoveTo[]\n    | LineTo\n    | LineTo[]\n    | CurveTo\n    | CurveTo[]\n    | Close\n    | Segment\n    | Segment[] {\n    if (type === 'M') {\n      return MoveTo.create.call(null, ...args)\n    }\n\n    if (type === 'L') {\n      return LineTo.create.call(null, ...args)\n    }\n\n    if (type === 'C') {\n      return CurveTo.create.call(null, ...args)\n    }\n\n    if (type === 'z' || type === 'Z') {\n      return Close.create()\n    }\n\n    throw new Error(`Invalid path segment type \"${type}\"`)\n  }\n}\n\nexport namespace Path {\n  export const normalize = normalizePathData\n  export const isValid = Util.isValid\n  export const drawArc = Util.drawArc\n  export const drawPoints = Util.drawPoints\n  export const arcToCurves = Util.arcToCurves\n}\n"],"mappings":"AAAA,SAASA,KAAK,EAAEC,aAAa,QAAQ,SAAS;AAC9C,SAASC,IAAI,QAAQ,SAAS;AAC9B,SAASC,KAAK,QAAQ,UAAU;AAChC,SAASC,KAAK,QAAQ,UAAU;AAChC,SAASC,QAAQ,QAAQ,aAAa;AACtC,SAASC,SAAS,QAAQ,cAAc;AACxC,SAASC,QAAQ,QAAQ,aAAa;AACtC,SAASC,KAAK,QAAQ,SAAS;AAC/B,SAASC,MAAM,QAAQ,UAAU;AACjC,SAASC,MAAM,QAAQ,UAAU;AACjC,SAASC,OAAO,QAAQ,WAAW;AAEnC,SAASC,iBAAiB,QAAQ,aAAa;AAC/C,OAAO,KAAKC,IAAI,MAAM,QAAQ;AAE9B,OAAM,MAAOC,IAAK,SAAQP,QAAQ;EAgBhCQ,YACEC,IAAuE;IAEvE,KAAK,EAAE;IAlBU,KAAAC,SAAS,GAAW,CAAC;IAmBtC,IAAI,CAACC,QAAQ,GAAG,EAAE;IAClB,IAAIC,KAAK,CAACC,OAAO,CAACJ,IAAI,CAAC,EAAE;MACvB,IAAId,IAAI,CAACmB,MAAM,CAACL,IAAI,CAAC,CAAC,CAAC,CAAC,IAAIZ,KAAK,CAACkB,OAAO,CAACN,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;QAClD,IAAIO,WAAW,GAAwB,IAAI;QAC3C,MAAMC,GAAG,GAAGR,IAAwB;QACpCQ,GAAG,CAACC,OAAO,CAAC,CAACC,CAAe,EAAEC,CAAS,KAAI;UACzC,IAAIA,CAAC,KAAK,CAAC,EAAE;YACX,IAAI,CAACC,aAAa,CAACd,IAAI,CAACe,aAAa,CAAC,GAAG,EAAEH,CAAC,CAACI,KAAK,CAAC,CAAC;;UAEtD,IAAIP,WAAW,IAAI,IAAI,IAAI,CAACA,WAAW,CAACQ,GAAG,CAACC,MAAM,CAACN,CAAC,CAACI,KAAK,CAAC,EAAE;YAC3D,IAAI,CAACF,aAAa,CAACd,IAAI,CAACe,aAAa,CAAC,GAAG,EAAEH,CAAC,CAACI,KAAK,CAAC,CAAC;;UAGtD,IAAI5B,IAAI,CAACmB,MAAM,CAACK,CAAC,CAAC,EAAE;YAClB,IAAI,CAACE,aAAa,CAACd,IAAI,CAACe,aAAa,CAAC,GAAG,EAAEH,CAAC,CAACK,GAAG,CAAC,CAAC;WACnD,MAAM,IAAI3B,KAAK,CAACkB,OAAO,CAACI,CAAC,CAAC,EAAE;YAC3B,IAAI,CAACE,aAAa,CAChBd,IAAI,CAACe,aAAa,CAAC,GAAG,EAAEH,CAAC,CAACO,aAAa,EAAEP,CAAC,CAACQ,aAAa,EAAER,CAAC,CAACK,GAAG,CAAC,CACjE;;UAGHR,WAAW,GAAGG,CAAC;QACjB,CAAC,CAAC;OACH,MAAM;QACL,MAAMF,GAAG,GAAGR,IAAiB;QAC7BQ,GAAG,CAACC,OAAO,CAAEU,CAAC,IAAI;UAChB,IAAIA,CAAC,CAACC,SAAS,EAAE;YACf,IAAI,CAACR,aAAa,CAACO,CAAC,CAAC;;QAEzB,CAAC,CAAC;;KAEL,MAAM,IAAInB,IAAI,IAAI,IAAI,EAAE;MACvB,IAAId,IAAI,CAACmB,MAAM,CAACL,IAAI,CAAC,EAAE;QACrB,IAAI,CAACY,aAAa,CAACd,IAAI,CAACe,aAAa,CAAC,GAAG,EAAEb,IAAI,CAACc,KAAK,CAAC,CAAC;QACvD,IAAI,CAACF,aAAa,CAACd,IAAI,CAACe,aAAa,CAAC,GAAG,EAAEb,IAAI,CAACe,GAAG,CAAC,CAAC;OACtD,MAAM,IAAI3B,KAAK,CAACkB,OAAO,CAACN,IAAI,CAAC,EAAE;QAC9B,IAAI,CAACY,aAAa,CAACd,IAAI,CAACe,aAAa,CAAC,GAAG,EAAEb,IAAI,CAACc,KAAK,CAAC,CAAC;QACvD,IAAI,CAACF,aAAa,CAChBd,IAAI,CAACe,aAAa,CAChB,GAAG,EACHb,IAAI,CAACiB,aAAa,EAClBjB,IAAI,CAACkB,aAAa,EAClBlB,IAAI,CAACe,GAAG,CACT,CACF;OACF,MAAM,IAAI1B,QAAQ,CAACgC,UAAU,CAACrB,IAAI,CAAC,EAAE;QACpC,IAAIA,IAAI,CAACsB,MAAM,IAAItB,IAAI,CAACsB,MAAM,CAACC,MAAM,EAAE;UACrCvB,IAAI,CAACsB,MAAM,CAACb,OAAO,CAAC,CAACe,KAAK,EAAEC,KAAK,KAAI;YACnC,MAAMC,OAAO,GACXD,KAAK,KAAK,CAAC,GACP3B,IAAI,CAACe,aAAa,CAAC,GAAG,EAAEW,KAAK,CAAC,GAC9B1B,IAAI,CAACe,aAAa,CAAC,GAAG,EAAEW,KAAK,CAAC;YACpC,IAAI,CAACZ,aAAa,CAACc,OAAO,CAAC;UAC7B,CAAC,CAAC;;OAEL,MAAM,IAAI1B,IAAI,CAACoB,SAAS,EAAE;QACzB,IAAI,CAACR,aAAa,CAACZ,IAAI,CAAC;;;EAG9B;EA3EA,KAAe2B,MAAM,CAACC,WAAW,IAAC;IAChC,OAAO9B,IAAI,CAAC8B,WAAW;EACzB;EA2EA,IAAId,KAAKA,CAAA;IACP,MAAMZ,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC9B,MAAM2B,KAAK,GAAG3B,QAAQ,CAACqB,MAAM;IAC7B,IAAIM,KAAK,KAAK,CAAC,EAAE;MACf,OAAO,IAAI;;IAGb,KAAK,IAAIlB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkB,KAAK,EAAElB,CAAC,IAAI,CAAC,EAAE;MACjC,MAAMe,OAAO,GAAGxB,QAAQ,CAACS,CAAC,CAAC;MAC3B,IAAIe,OAAO,CAACI,SAAS,EAAE;QACrB,OAAOJ,OAAO,CAACZ,KAAK;;;IAIxB;IACA,OAAOZ,QAAQ,CAAC2B,KAAK,GAAG,CAAC,CAAC,CAACd,GAAG;EAChC;EAEA,IAAIA,GAAGA,CAAA;IACL,MAAMb,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC9B,MAAM2B,KAAK,GAAG3B,QAAQ,CAACqB,MAAM;IAC7B,IAAIM,KAAK,KAAK,CAAC,EAAE;MACf,OAAO,IAAI;;IAGb,KAAK,IAAIlB,CAAC,GAAGkB,KAAK,GAAG,CAAC,EAAElB,CAAC,IAAI,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;MACtC,MAAMe,OAAO,GAAGxB,QAAQ,CAACS,CAAC,CAAC;MAC3B,IAAIe,OAAO,CAACI,SAAS,EAAE;QACrB,OAAOJ,OAAO,CAACX,GAAG;;;IAItB;IACA,OAAOb,QAAQ,CAAC2B,KAAK,GAAG,CAAC,CAAC,CAACd,GAAG;EAChC;EAQAgB,MAAMA,CAAC,GAAG/B,IAAW;IACnB,OAAO,IAAI,CAACY,aAAa,CAAClB,MAAM,CAACsC,MAAM,CAACC,IAAI,CAAC,IAAI,EAAE,GAAGjC,IAAI,CAAC,CAAC;EAC9D;EAOAkC,MAAMA,CAAC,GAAGlC,IAAW;IACnB,OAAO,IAAI,CAACY,aAAa,CAACnB,MAAM,CAACuC,MAAM,CAACC,IAAI,CAAC,IAAI,EAAE,GAAGjC,IAAI,CAAC,CAAC;EAC9D;EA0BAmC,OAAOA,CAAC,GAAGnC,IAAW;IACpB,OAAO,IAAI,CAACY,aAAa,CAACjB,OAAO,CAACqC,MAAM,CAACC,IAAI,CAAC,IAAI,EAAE,GAAGjC,IAAI,CAAC,CAAC;EAC/D;EAmBAoC,KAAKA,CACHC,EAAU,EACVC,EAAU,EACVC,aAAqB,EACrBC,YAAmB,EACnBC,SAAgB,EAChBC,IAA8B,EAC9BC,IAAa;IAEb,MAAM7B,KAAK,GAAG,IAAI,CAACC,GAAG,IAAI,IAAI5B,KAAK,EAAE;IACrC,MAAMmC,MAAM,GACV,OAAOoB,IAAI,KAAK,QAAQ,GACpB7C,IAAI,CAAC+C,WAAW,CACd9B,KAAK,CAAC+B,CAAC,EACP/B,KAAK,CAACgC,CAAC,EACPT,EAAE,EACFC,EAAE,EACFC,aAAa,EACbC,YAAY,EACZC,SAAS,EACTC,IAAI,EACJC,IAAc,CACf,GACD9C,IAAI,CAAC+C,WAAW,CACd9B,KAAK,CAAC+B,CAAC,EACP/B,KAAK,CAACgC,CAAC,EACPT,EAAE,EACFC,EAAE,EACFC,aAAa,EACbC,YAAY,EACZC,SAAS,EACTC,IAAI,CAACG,CAAC,EACNH,IAAI,CAACI,CAAC,CACP;IAEP,IAAIxB,MAAM,IAAI,IAAI,EAAE;MAClB,KAAK,IAAIX,CAAC,GAAG,CAAC,EAAEoC,EAAE,GAAGzB,MAAM,CAACC,MAAM,EAAEZ,CAAC,GAAGoC,EAAE,EAAEpC,CAAC,IAAI,CAAC,EAAE;QAClD,IAAI,CAACwB,OAAO,CACVb,MAAM,CAACX,CAAC,CAAC,EACTW,MAAM,CAACX,CAAC,GAAG,CAAC,CAAC,EACbW,MAAM,CAACX,CAAC,GAAG,CAAC,CAAC,EACbW,MAAM,CAACX,CAAC,GAAG,CAAC,CAAC,EACbW,MAAM,CAACX,CAAC,GAAG,CAAC,CAAC,EACbW,MAAM,CAACX,CAAC,GAAG,CAAC,CAAC,CACd;;;IAGL,OAAO,IAAI;EACb;EASAqC,MAAMA,CACJC,EAA4B,EAC5BC,EAA4B,EAC5BL,CAAU,EACVC,CAAU;IAEV,MAAMhC,KAAK,GAAG,IAAI,CAACC,GAAG,IAAI,IAAI5B,KAAK,EAAE;IACrC,MAAMgE,IAAI,GAAG,CAAC,GAAG,EAAErC,KAAK,CAAC+B,CAAC,EAAE/B,KAAK,CAACgC,CAAC,CAAC;IACpC,IAAI,OAAOG,EAAE,KAAK,QAAQ,EAAE;MAC1BE,IAAI,CAACC,IAAI,CAAC,GAAG,EAAEH,EAAE,EAAEC,EAAY,EAAEL,CAAW,EAAEC,CAAW,CAAC;KAC3D,MAAM;MACL,MAAMO,CAAC,GAAGH,EAAqB;MAC/BC,IAAI,CAACC,IAAI,CAAC,GAAG,EAAEH,EAAE,CAACJ,CAAC,EAAEI,EAAE,CAACH,CAAC,EAAEO,CAAC,CAACR,CAAC,EAAEQ,CAAC,CAACP,CAAC,CAAC;;IAEtC,MAAMQ,IAAI,GAAGxD,IAAI,CAACyD,KAAK,CAACJ,IAAI,CAACK,IAAI,CAAC,GAAG,CAAC,CAAC;IACvC,IAAI,CAAC5C,aAAa,CAAC0C,IAAI,CAACpD,QAAQ,CAACuD,KAAK,CAAC,CAAC,CAAC,CAAC;IAC1C,OAAO,IAAI;EACb;EAEAC,KAAKA,CAAA;IACH,OAAO,IAAI,CAAC9C,aAAa,CAACpB,KAAK,CAACwC,MAAM,EAAE,CAAC;EAC3C;EAEA2B,UAAUA,CACRrC,MAA6C,EAC7CsC,OAAA,GAAkC,EAAE;IAEpC,MAAMC,GAAG,GAAGhE,IAAI,CAAC8D,UAAU,CAACrC,MAAM,EAAEsC,OAAO,CAAC;IAC5C,MAAME,GAAG,GAAGhE,IAAI,CAACyD,KAAK,CAACM,GAAG,CAAC;IAC3B,IAAIC,GAAG,IAAIA,GAAG,CAAC5D,QAAQ,EAAE;MACvB,IAAI,CAACU,aAAa,CAACkD,GAAG,CAAC5D,QAAQ,CAAC;;EAEpC;EAEA6D,IAAIA,CAAA;IACF,MAAM7D,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC9B,MAAM2B,KAAK,GAAG3B,QAAQ,CAACqB,MAAM;IAC7B,IAAIM,KAAK,KAAK,CAAC,EAAE;MACf,OAAO,IAAI;;IAGb,IAAIkC,IAAI;IACR,KAAK,IAAIpD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkB,KAAK,EAAElB,CAAC,IAAI,CAAC,EAAE;MACjC,MAAMe,OAAO,GAAGxB,QAAQ,CAACS,CAAC,CAAC;MAC3B,IAAIe,OAAO,CAACI,SAAS,EAAE;QACrB,MAAMkC,WAAW,GAAGtC,OAAO,CAACqC,IAAI,EAAE;QAClC,IAAIC,WAAW,IAAI,IAAI,EAAE;UACvBD,IAAI,GAAGA,IAAI,GAAGA,IAAI,CAACE,KAAK,CAACD,WAAW,CAAC,GAAGA,WAAW;;;;IAKzD,IAAID,IAAI,IAAI,IAAI,EAAE;MAChB,OAAOA,IAAI;;IAGb;IACA,MAAMG,WAAW,GAAGhE,QAAQ,CAAC2B,KAAK,GAAG,CAAC,CAAC;IACvC,OAAO,IAAIvC,SAAS,CAAC4E,WAAW,CAACnD,GAAG,CAAC8B,CAAC,EAAEqB,WAAW,CAACnD,GAAG,CAAC+B,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAClE;EAEAlC,aAAaA,CAACuD,GAAwB;IACpC,MAAMtC,KAAK,GAAG,IAAI,CAAC3B,QAAQ,CAACqB,MAAM;IAClC,IAAI6C,eAAe,GAAGvC,KAAK,KAAK,CAAC,GAAG,IAAI,CAAC3B,QAAQ,CAAC2B,KAAK,GAAG,CAAC,CAAC,GAAG,IAAI;IACnE,IAAIwC,cAAc;IAClB,MAAMC,WAAW,GAAG,IAAI;IAExB,IAAInE,KAAK,CAACC,OAAO,CAAC+D,GAAG,CAAC,EAAE;MACtB,KAAK,IAAIxD,CAAC,GAAG,CAAC,EAAEoC,EAAE,GAAGoB,GAAG,CAAC5C,MAAM,EAAEZ,CAAC,GAAGoC,EAAE,EAAEpC,CAAC,IAAI,CAAC,EAAE;QAC/C,MAAMe,OAAO,GAAGyC,GAAG,CAACxD,CAAC,CAAC;QACtB0D,cAAc,GAAG,IAAI,CAACE,cAAc,CAClC7C,OAAO,EACP0C,eAAe,EACfE,WAAW,CACZ;QACD,IAAI,CAACpE,QAAQ,CAACkD,IAAI,CAACiB,cAAc,CAAC;QAClCD,eAAe,GAAGC,cAAc;;KAEnC,MAAM,IAAIF,GAAG,IAAI,IAAI,IAAIA,GAAG,CAAC/C,SAAS,EAAE;MACvCiD,cAAc,GAAG,IAAI,CAACE,cAAc,CAACJ,GAAG,EAAEC,eAAe,EAAEE,WAAW,CAAC;MACvE,IAAI,CAACpE,QAAQ,CAACkD,IAAI,CAACiB,cAAc,CAAC;;IAEpC,OAAO,IAAI;EACb;EAEAG,aAAaA,CAAC/C,KAAa,EAAE0C,GAAwB;IACnD,MAAMtC,KAAK,GAAG,IAAI,CAAC3B,QAAQ,CAACqB,MAAM;IAClC,IAAIE,KAAK,GAAG,CAAC,EAAE;MACbA,KAAK,GAAGI,KAAK,GAAGJ,KAAK,GAAG,CAAC,EAAC;;IAG5B,IAAIA,KAAK,GAAGI,KAAK,IAAIJ,KAAK,GAAG,CAAC,EAAE;MAC9B,MAAM,IAAIgD,KAAK,CAAC,qBAAqB,CAAC;;IAGxC,IAAIJ,cAAc;IAClB,IAAID,eAAe,GAAG,IAAI;IAC1B,IAAIE,WAAW,GAAG,IAAI;IAEtB,IAAIzC,KAAK,KAAK,CAAC,EAAE;MACf,IAAIJ,KAAK,IAAI,CAAC,EAAE;QACd2C,eAAe,GAAG,IAAI,CAAClE,QAAQ,CAACuB,KAAK,GAAG,CAAC,CAAC;QAC1C6C,WAAW,GAAGF,eAAe,CAACE,WAAW;OAC1C,MAAM;QACLF,eAAe,GAAG,IAAI;QACtBE,WAAW,GAAG,IAAI,CAACpE,QAAQ,CAAC,CAAC,CAAC;;;IAIlC,IAAI,CAACC,KAAK,CAACC,OAAO,CAAC+D,GAAG,CAAC,EAAE;MACvBE,cAAc,GAAG,IAAI,CAACE,cAAc,CAACJ,GAAG,EAAEC,eAAe,EAAEE,WAAW,CAAC;MACvE,IAAI,CAACpE,QAAQ,CAACwE,MAAM,CAACjD,KAAK,EAAE,CAAC,EAAE4C,cAAc,CAAC;KAC/C,MAAM;MACL,KAAK,IAAI1D,CAAC,GAAG,CAAC,EAAEoC,EAAE,GAAGoB,GAAG,CAAC5C,MAAM,EAAEZ,CAAC,GAAGoC,EAAE,EAAEpC,CAAC,IAAI,CAAC,EAAE;QAC/C,MAAMe,OAAO,GAAGyC,GAAG,CAACxD,CAAC,CAAC;QACtB0D,cAAc,GAAG,IAAI,CAACE,cAAc,CAClC7C,OAAO,EACP0C,eAAe,EACfE,WAAW,CACZ;QACD,IAAI,CAACpE,QAAQ,CAACwE,MAAM,CAACjD,KAAK,GAAGd,CAAC,EAAE,CAAC,EAAE0D,cAAc,CAAC;QAClDD,eAAe,GAAGC,cAAc;;;IAGpC,OAAO,IAAI;EACb;EAEAM,aAAaA,CAAClD,KAAa;IACzB,MAAMmD,GAAG,GAAG,IAAI,CAACC,QAAQ,CAACpD,KAAK,CAAC;IAChC,MAAMqD,cAAc,GAAG,IAAI,CAAC5E,QAAQ,CAACwE,MAAM,CAACE,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IACtD,MAAMR,eAAe,GAAGU,cAAc,CAACV,eAAe;IACtD,MAAME,WAAW,GAAGQ,cAAc,CAACR,WAAW;IAE9C;IACA,IAAIF,eAAe,EAAE;MACnBA,eAAe,CAACE,WAAW,GAAGA,WAAW;;IAG3C,IAAIA,WAAW,EAAE;MACfA,WAAW,CAACF,eAAe,GAAGA,eAAe;;IAG/C,IAAIU,cAAc,CAACC,cAAc,IAAIT,WAAW,EAAE;MAChD,IAAI,CAACU,yBAAyB,CAACV,WAAW,CAAC;;IAE7C,OAAOQ,cAAc;EACvB;EAEAG,cAAcA,CAACxD,KAAa,EAAE0C,GAAwB;IACpD,MAAMS,GAAG,GAAG,IAAI,CAACC,QAAQ,CAACpD,KAAK,CAAC;IAEhC,IAAI4C,cAAc;IAClB,MAAMa,eAAe,GAAG,IAAI,CAAChF,QAAQ,CAAC0E,GAAG,CAAC;IAC1C,IAAIR,eAAe,GAAGc,eAAe,CAACd,eAAe;IACrD,MAAME,WAAW,GAAGY,eAAe,CAACZ,WAAW;IAE/C,IAAIa,kBAAkB,GAAGD,eAAe,CAACH,cAAc;IAEvD,IAAI,CAAC5E,KAAK,CAACC,OAAO,CAAC+D,GAAG,CAAC,EAAE;MACvBE,cAAc,GAAG,IAAI,CAACE,cAAc,CAACJ,GAAG,EAAEC,eAAe,EAAEE,WAAW,CAAC;MACvE,IAAI,CAACpE,QAAQ,CAACwE,MAAM,CAACE,GAAG,EAAE,CAAC,EAAEP,cAAc,CAAC;MAC5C,IAAIc,kBAAkB,IAAId,cAAc,CAACU,cAAc,EAAE;QACvD;QACAI,kBAAkB,GAAG,KAAK;;KAE7B,MAAM;MACL,IAAI,CAACjF,QAAQ,CAACwE,MAAM,CAACjD,KAAK,EAAE,CAAC,CAAC;MAE9B,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEoC,EAAE,GAAGoB,GAAG,CAAC5C,MAAM,EAAEZ,CAAC,GAAGoC,EAAE,EAAEpC,CAAC,IAAI,CAAC,EAAE;QAC/C,MAAMe,OAAO,GAAGyC,GAAG,CAACxD,CAAC,CAAC;QACtB0D,cAAc,GAAG,IAAI,CAACE,cAAc,CAClC7C,OAAO,EACP0C,eAAe,EACfE,WAAW,CACZ;QACD,IAAI,CAACpE,QAAQ,CAACwE,MAAM,CAACjD,KAAK,GAAGd,CAAC,EAAE,CAAC,EAAE0D,cAAc,CAAC;QAClDD,eAAe,GAAGC,cAAc;QAEhC,IAAIc,kBAAkB,IAAId,cAAc,CAACU,cAAc,EAAE;UACvDI,kBAAkB,GAAG,KAAK;;;;IAKhC,IAAIA,kBAAkB,IAAIb,WAAW,EAAE;MACrC,IAAI,CAACU,yBAAyB,CAACV,WAAW,CAAC;;EAE/C;EAEAc,UAAUA,CAAC3D,KAAa;IACtB,MAAMmD,GAAG,GAAG,IAAI,CAACC,QAAQ,CAACpD,KAAK,CAAC;IAChC,OAAO,IAAI,CAACvB,QAAQ,CAAC0E,GAAG,CAAC;EAC3B;EAEUC,QAAQA,CAACpD,KAAa;IAC9B,MAAMF,MAAM,GAAG,IAAI,CAACrB,QAAQ,CAACqB,MAAM;IAEnC,IAAIA,MAAM,KAAK,CAAC,EAAE;MAChB,MAAM,IAAIkD,KAAK,CAAC,uBAAuB,CAAC;;IAG1C,IAAI9D,CAAC,GAAGc,KAAK;IACb,OAAOd,CAAC,GAAG,CAAC,EAAE;MACZA,CAAC,GAAGY,MAAM,GAAGZ,CAAC;;IAGhB,IAAIA,CAAC,IAAIY,MAAM,IAAIZ,CAAC,GAAG,CAAC,EAAE;MACxB,MAAM,IAAI8D,KAAK,CAAC,qBAAqB,CAAC;;IAGxC,OAAO9D,CAAC;EACV;EAEA0E,SAASA,CAACC,KAAa,EAAE1B,OAAA,GAAwB,EAAE;IACjD,MAAMnC,KAAK,GAAG,IAAI,CAAC8D,cAAc,CAACD,KAAK,EAAE1B,OAAO,CAAC;IACjD,IAAI,CAACnC,KAAK,EAAE;MACV,OAAO,IAAI;;IAGb,OAAO,IAAI,CAAC2D,UAAU,CAAC3D,KAAK,CAAC;EAC/B;EAEA+D,eAAeA,CAACjE,MAAc,EAAEqC,OAAA,GAAwB,EAAE;IACxD,MAAMnC,KAAK,GAAG,IAAI,CAACgE,oBAAoB,CAAClE,MAAM,EAAEqC,OAAO,CAAC;IACxD,IAAI,CAACnC,KAAK,EAAE,OAAO,IAAI;IAEvB,OAAO,IAAI,CAAC2D,UAAU,CAAC3D,KAAK,CAAC;EAC/B;EAEA8D,cAAcA,CAACD,KAAa,EAAE1B,OAAA,GAAwB,EAAE;IACtD,IAAI,IAAI,CAAC1D,QAAQ,CAACqB,MAAM,KAAK,CAAC,EAAE;MAC9B,OAAO,IAAI;;IAGb,MAAMmE,IAAI,GAAG1G,KAAK,CAACsG,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC;IAC/B,MAAMK,GAAG,GAAG,IAAI,CAACC,UAAU,CAAChC,OAAO,CAAC;IACpC,MAAMiC,GAAG,GAAG,IAAI,CAACtE,MAAM,CAACoE,GAAG,CAAC;IAC5B,MAAMpE,MAAM,GAAGsE,GAAG,GAAGH,IAAI;IACzB,OAAO,IAAI,CAACD,oBAAoB,CAAClE,MAAM,EAAEoE,GAAG,CAAC;EAC/C;EAEAF,oBAAoBA,CAAClE,MAAc,EAAEqC,OAAA,GAAwB,EAAE;IAC7D,MAAM/B,KAAK,GAAG,IAAI,CAAC3B,QAAQ,CAACqB,MAAM;IAClC,IAAIM,KAAK,KAAK,CAAC,EAAE;MACf,OAAO,IAAI;;IAGb,IAAIiE,SAAS,GAAG,IAAI;IACpB,IAAIvE,MAAM,GAAG,CAAC,EAAE;MACduE,SAAS,GAAG,KAAK;MACjBvE,MAAM,GAAG,CAACA,MAAM,EAAC;;IAGnB,MAAMwE,SAAS,GAAG,IAAI,CAACC,YAAY,CAACpC,OAAO,CAAC;IAC5C,MAAMqC,mBAAmB,GAAG,IAAI,CAACC,eAAe,CAACtC,OAAO,CAAC;IAEzD,IAAIuC,IAAI,GAAG,CAAC;IACZ,IAAIC,gBAAgB,GAAG,IAAI;IAE3B,KAAK,IAAIzF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkB,KAAK,EAAElB,CAAC,IAAI,CAAC,EAAE;MACjC,MAAMc,KAAK,GAAGqE,SAAS,GAAGnF,CAAC,GAAGkB,KAAK,GAAG,CAAC,GAAGlB,CAAC;MAE3C,MAAMe,OAAO,GAAG,IAAI,CAACxB,QAAQ,CAACuB,KAAK,CAAC;MACpC,MAAM4E,YAAY,GAAGJ,mBAAmB,CAACxE,KAAK,CAAC;MAC/C,MAAMoE,GAAG,GAAGnE,OAAO,CAACH,MAAM,CAAC;QAAEwE,SAAS;QAAEM;MAAY,CAAE,CAAC;MAEvD,IAAI3E,OAAO,CAACI,SAAS,EAAE;QACrB,IAAIP,MAAM,IAAI4E,IAAI,GAAGN,GAAG,EAAE;UACxB,OAAOpE,KAAK;;QAEd2E,gBAAgB,GAAG3E,KAAK;;MAG1B0E,IAAI,IAAIN,GAAG;;IAGb;IACA;IACA,OAAOO,gBAAgB;EACzB;EAEAE,sBAAsBA,CAAC1C,OAAA,GAAwB,EAAE;IAC/C,MAAMmC,SAAS,GAAG,IAAI,CAACC,YAAY,CAACpC,OAAO,CAAC;IAC5C,MAAMqC,mBAAmB,GAAG,EAAE;IAC9B,KAAK,IAAItF,CAAC,GAAG,CAAC,EAAEoC,EAAE,GAAG,IAAI,CAAC7C,QAAQ,CAACqB,MAAM,EAAEZ,CAAC,GAAGoC,EAAE,EAAEpC,CAAC,IAAI,CAAC,EAAE;MACzD,MAAMe,OAAO,GAAG,IAAI,CAACxB,QAAQ,CAACS,CAAC,CAAC;MAChC,MAAM0F,YAAY,GAAG3E,OAAO,CAACwE,eAAe,CAAC;QAAEH;MAAS,CAAE,CAAC;MAC3DE,mBAAmB,CAAC7C,IAAI,CAACiD,YAAY,CAAC;;IAGxC,OAAOJ,mBAAmB;EAC5B;EAEUjB,yBAAyBA,CAACtD,OAAgB;IAClD,IAAI6E,QAAQ,GAAG7E,OAAO,CAAC0C,eAAe;IACtC,IAAIoC,OAAO,GAAmB9E,OAAO;IAErC,OAAO8E,OAAO,IAAI,CAACA,OAAO,CAACzB,cAAc,EAAE;MACzC;MACA,IAAIwB,QAAQ,IAAI,IAAI,EAAE;QACpBC,OAAO,CAACC,mBAAmB,GAAGF,QAAQ,CAACE,mBAAmB;OAC3D,MAAM;QACLD,OAAO,CAACC,mBAAmB,GAAG,IAAI;;MAGpCF,QAAQ,GAAGC,OAAO;MAClBA,OAAO,GAAGA,OAAO,CAAClC,WAAW;;EAEjC;EAEUC,cAAcA,CACtB7C,OAAgB,EAChB0C,eAA+B,EAC/BE,WAA2B;IAE3B5C,OAAO,CAAC0C,eAAe,GAAGA,eAAe;IACzC1C,OAAO,CAAC4C,WAAW,GAAGA,WAAW;IAEjC,IAAIF,eAAe,IAAI,IAAI,EAAE;MAC3BA,eAAe,CAACE,WAAW,GAAG5C,OAAO;;IAGvC,IAAI4C,WAAW,IAAI,IAAI,EAAE;MACvBA,WAAW,CAACF,eAAe,GAAG1C,OAAO;;IAGvC,IAAIyD,kBAAkB,GAAmBzD,OAAO;IAChD,IAAIA,OAAO,CAACqD,cAAc,EAAE;MAC1B;MACArD,OAAO,CAAC+E,mBAAmB,GAAG/E,OAAO;MACrCyD,kBAAkB,GAAGb,WAAW;;IAGlC;IACA,IAAIa,kBAAkB,IAAI,IAAI,EAAE;MAC9B,IAAI,CAACH,yBAAyB,CAACG,kBAAkB,CAAC;;IAGpD,OAAOzD,OAAO;EAChB;EAEAgF,YAAYA,CAACrD,CAAkB,EAAEO,OAAA,GAAwB,EAAE;IACzD,MAAM+C,CAAC,GAAG,IAAI,CAACC,aAAa,CAACvD,CAAC,EAAEO,OAAO,CAAC;IACxC,IAAI,CAAC+C,CAAC,EAAE;MACN,OAAO,IAAI;;IAGb,OAAO,IAAI,CAACE,QAAQ,CAACF,CAAC,CAAC;EACzB;EAEAG,kBAAkBA,CAACzD,CAAkB,EAAEO,OAAA,GAAwB,EAAE;IAC/D,MAAMmD,IAAI,GAAG,IAAI,CAACnB,UAAU,CAAChC,OAAO,CAAC;IACrC,MAAM+C,CAAC,GAAG,IAAI,CAACC,aAAa,CAACvD,CAAC,EAAE0D,IAAI,CAAC;IACrC,IAAI,CAACJ,CAAC,EAAE;MACN,OAAO,CAAC;;IAGV,OAAO,IAAI,CAACK,SAAS,CAACL,CAAC,EAAEI,IAAI,CAAC;EAChC;EAEAE,4BAA4BA,CAAC5D,CAAkB,EAAEO,OAAA,GAAwB,EAAE;IACzE,MAAMmD,IAAI,GAAG,IAAI,CAACnB,UAAU,CAAChC,OAAO,CAAC;IACrC,MAAMsD,QAAQ,GAAG,IAAI,CAACJ,kBAAkB,CAACzD,CAAC,EAAE0D,IAAI,CAAC;IACjD,IAAIG,QAAQ,KAAK,CAAC,EAAE;MAClB,OAAO,CAAC;;IAGV,MAAM3F,MAAM,GAAG,IAAI,CAACA,MAAM,CAACwF,IAAI,CAAC;IAChC,IAAIxF,MAAM,KAAK,CAAC,EAAE;MAChB,OAAO,CAAC;;IAGV,OAAO2F,QAAQ,GAAG3F,MAAM;EAC1B;EAEAqF,aAAaA,CAACvD,CAAkB,EAAEO,OAAA,GAAwB,EAAE;IAC1D,IAAI,IAAI,CAAC1D,QAAQ,CAACqB,MAAM,KAAK,CAAC,EAAE;MAC9B,OAAO,IAAI;;IAGb,MAAMwE,SAAS,GAAG,IAAI,CAACC,YAAY,CAACpC,OAAO,CAAC;IAC5C,MAAMqC,mBAAmB,GAAG,IAAI,CAACC,eAAe,CAACtC,OAAO,CAAC;IAEzD,IAAIgD,aAAa;IACjB,IAAIO,kBAAkB,GAAGC,QAAQ;IACjC,KAAK,IAAIzG,CAAC,GAAG,CAAC,EAAEoC,EAAE,GAAG,IAAI,CAAC7C,QAAQ,CAACqB,MAAM,EAAEZ,CAAC,GAAGoC,EAAE,EAAEpC,CAAC,IAAI,CAAC,EAAE;MACzD,MAAMe,OAAO,GAAG,IAAI,CAACxB,QAAQ,CAACS,CAAC,CAAC;MAChC,MAAM0F,YAAY,GAAGJ,mBAAmB,CAACtF,CAAC,CAAC;MAE3C,IAAIe,OAAO,CAACI,SAAS,EAAE;QACrB,MAAMuF,oBAAoB,GAAG3F,OAAO,CAACkF,aAAa,CAACvD,CAAC,EAAE;UACpD0C,SAAS;UACTM;SACD,CAAC;QACF,MAAMiB,mBAAmB,GAAG5F,OAAO,CAACmF,QAAQ,CAACQ,oBAAoB,CAAC;QAClE,MAAME,eAAe,GAAGtI,aAAa,CAACqI,mBAAmB,EAAEjE,CAAC,CAAC;QAE7D,IAAIkE,eAAe,GAAGJ,kBAAkB,EAAE;UACxCP,aAAa,GAAG;YAAEY,YAAY,EAAE7G,CAAC;YAAE8G,KAAK,EAAEJ;UAAoB,CAAE;UAChEF,kBAAkB,GAAGI,eAAe;;;;IAK1C,IAAIX,aAAa,EAAE;MACjB,OAAOA,aAAa;;IAGtB,OAAO;MAAEY,YAAY,EAAE,IAAI,CAACtH,QAAQ,CAACqB,MAAM,GAAG,CAAC;MAAEkG,KAAK,EAAE;IAAC,CAAE;EAC7D;EAEAC,mBAAmBA,CAACrE,CAAkB,EAAEO,OAAA,GAAwB,EAAE;IAChE,IAAI,IAAI,CAAC1D,QAAQ,CAACqB,MAAM,KAAK,CAAC,EAAE;MAC9B,OAAO,IAAI;;IAGb,MAAMwE,SAAS,GAAG,IAAI,CAACC,YAAY,CAACpC,OAAO,CAAC;IAC5C,MAAMqC,mBAAmB,GAAG,IAAI,CAACC,eAAe,CAACtC,OAAO,CAAC;IAEzD,IAAI8D,mBAAmB;IACvB,IAAIP,kBAAkB,GAAGC,QAAQ;IACjC,KAAK,IAAIzG,CAAC,GAAG,CAAC,EAAEoC,EAAE,GAAG,IAAI,CAAC7C,QAAQ,CAACqB,MAAM,EAAEZ,CAAC,GAAGoC,EAAE,EAAEpC,CAAC,IAAI,CAAC,EAAE;MACzD,MAAMe,OAAO,GAAG,IAAI,CAACxB,QAAQ,CAACS,CAAC,CAAC;MAChC,MAAM0F,YAAY,GAAGJ,mBAAmB,CAACtF,CAAC,CAAC;MAE3C,IAAIe,OAAO,CAACiG,gBAAgB,EAAE,EAAE;QAC9B,MAAMN,oBAAoB,GAAG3F,OAAO,CAACkF,aAAa,CAACvD,CAAC,EAAE;UACpD0C,SAAS;UACTM;SACD,CAAC;QACF,MAAMiB,mBAAmB,GAAG5F,OAAO,CAACmF,QAAQ,CAACQ,oBAAoB,CAAC;QAClE,MAAME,eAAe,GAAGtI,aAAa,CAACqI,mBAAmB,EAAEjE,CAAC,CAAC;QAE7D,IAAIkE,eAAe,GAAGJ,kBAAkB,EAAE;UACxCO,mBAAmB,GAAGhG,OAAO,CAACkG,UAAU,CAACP,oBAAoB,CAAC;UAC9DF,kBAAkB,GAAGI,eAAe;;;;IAK1C,IAAIG,mBAAmB,EAAE;MACvB,OAAOA,mBAAmB;;IAG5B,OAAO,IAAI;EACb;EAEAG,aAAaA,CAACxE,CAAkB,EAAEO,OAAA,GAAwB,EAAE;IAC1D,MAAMkE,SAAS,GAAG,IAAI,CAACC,WAAW,CAACnE,OAAO,CAAC;IAC3C,IAAI,CAACkE,SAAS,EAAE;MACd,OAAO,KAAK;;IAGd,IAAIE,gBAAgB,GAAG,CAAC;IACxB,KAAK,IAAIrH,CAAC,GAAG,CAAC,EAAEoC,EAAE,GAAG+E,SAAS,CAACvG,MAAM,EAAEZ,CAAC,GAAGoC,EAAE,EAAEpC,CAAC,IAAI,CAAC,EAAE;MACrD,MAAMsH,QAAQ,GAAGH,SAAS,CAACnH,CAAC,CAAC;MAC7B,IAAIsH,QAAQ,CAACJ,aAAa,CAACxE,CAAC,CAAC,EAAE;QAC7B2E,gBAAgB,IAAI,CAAC;;;IAIzB;IACA,OAAOA,gBAAgB,GAAG,CAAC,KAAK,CAAC;EACnC;EAEAE,OAAOA,CAAC5C,KAAa,EAAE1B,OAAA,GAAwB,EAAE;IAC/C,IAAI,IAAI,CAAC1D,QAAQ,CAACqB,MAAM,KAAK,CAAC,EAAE;MAC9B,OAAO,IAAI;;IAGb,IAAI+D,KAAK,IAAI,CAAC,EAAE;MACd,OAAO,IAAI,CAACxE,KAAM,CAACqH,KAAK,EAAE;;IAG5B,IAAI7C,KAAK,IAAI,CAAC,EAAE;MACd,OAAO,IAAI,CAACvE,GAAI,CAACoH,KAAK,EAAE;;IAG1B,MAAMpB,IAAI,GAAG,IAAI,CAACnB,UAAU,CAAChC,OAAO,CAAC;IACrC,MAAMwE,UAAU,GAAG,IAAI,CAAC7G,MAAM,CAACwF,IAAI,CAAC;IACpC,MAAMxF,MAAM,GAAG6G,UAAU,GAAG9C,KAAK;IAEjC,OAAO,IAAI,CAAC+C,aAAa,CAAC9G,MAAM,EAAEwF,IAAI,CAAC;EACzC;EAEAsB,aAAaA,CAAC9G,MAAc,EAAEqC,OAAA,GAAwB,EAAE;IACtD,IAAI,IAAI,CAAC1D,QAAQ,CAACqB,MAAM,KAAK,CAAC,EAAE;MAC9B,OAAO,IAAI;;IAGb,IAAIA,MAAM,KAAK,CAAC,EAAE;MAChB,OAAO,IAAI,CAACT,KAAM,CAACqH,KAAK,EAAE;;IAG5B,IAAIrC,SAAS,GAAG,IAAI;IACpB,IAAIvE,MAAM,GAAG,CAAC,EAAE;MACduE,SAAS,GAAG,KAAK;MACjBvE,MAAM,GAAG,CAACA,MAAM,EAAC;;IAGnB,MAAMwE,SAAS,GAAG,IAAI,CAACC,YAAY,CAACpC,OAAO,CAAC;IAC5C,MAAMqC,mBAAmB,GAAG,IAAI,CAACC,eAAe,CAACtC,OAAO,CAAC;IAEzD,IAAI0E,kBAAkB;IACtB,IAAInC,IAAI,GAAG,CAAC;IAEZ,KAAK,IAAIxF,CAAC,GAAG,CAAC,EAAEoC,EAAE,GAAG,IAAI,CAAC7C,QAAQ,CAACqB,MAAM,EAAEZ,CAAC,GAAGoC,EAAE,EAAEpC,CAAC,IAAI,CAAC,EAAE;MACzD,MAAMc,KAAK,GAAGqE,SAAS,GAAGnF,CAAC,GAAGoC,EAAE,GAAG,CAAC,GAAGpC,CAAC;MAExC,MAAMe,OAAO,GAAG,IAAI,CAACxB,QAAQ,CAACuB,KAAK,CAAC;MACpC,MAAM4E,YAAY,GAAGJ,mBAAmB,CAACxE,KAAK,CAAC;MAC/C,MAAM8G,CAAC,GAAG7G,OAAO,CAACH,MAAM,CAAC;QACvBwE,SAAS;QACTM;OACD,CAAC;MAEF,IAAI3E,OAAO,CAACI,SAAS,EAAE;QACrB,IAAIP,MAAM,IAAI4E,IAAI,GAAGoC,CAAC,EAAE;UACtB,OAAO7G,OAAO,CAAC2G,aAAa,CAAC,CAACvC,SAAS,GAAG,CAAC,GAAG,CAAC,CAAC,KAAKvE,MAAM,GAAG4E,IAAI,CAAC,EAAE;YACnEJ,SAAS;YACTM;WACD,CAAC;;QAGJiC,kBAAkB,GAAG5G,OAAO;;MAG9ByE,IAAI,IAAIoC,CAAC;;IAGX;IACA;IACA,IAAID,kBAAkB,EAAE;MACtB,OAAOxC,SAAS,GAAGwC,kBAAkB,CAACvH,GAAG,GAAGuH,kBAAkB,CAACxH,KAAK;;IAGtE;IACA,MAAMoD,WAAW,GAAG,IAAI,CAAChE,QAAQ,CAAC,IAAI,CAACA,QAAQ,CAACqB,MAAM,GAAG,CAAC,CAAC;IAC3D,OAAO2C,WAAW,CAACnD,GAAG,CAACoH,KAAK,EAAE;EAChC;EAEAtB,QAAQA,CAACF,CAA0C;IACjD,MAAMzG,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC9B,MAAMsI,WAAW,GAAGtI,QAAQ,CAACqB,MAAM;IACnC,IAAIiH,WAAW,KAAK,CAAC,EAAE,OAAO,IAAI,EAAC;IAEnC,MAAMhB,YAAY,GAAGb,CAAC,CAACa,YAAY;IACnC,IAAIA,YAAY,GAAG,CAAC,EAAE,OAAOtH,QAAQ,CAAC,CAAC,CAAC,CAAC2G,QAAQ,CAAC,CAAC,CAAC;IACpD,IAAIW,YAAY,IAAIgB,WAAW,EAAE;MAC/B,OAAOtI,QAAQ,CAACsI,WAAW,GAAG,CAAC,CAAC,CAAC3B,QAAQ,CAAC,CAAC,CAAC;;IAG9C,MAAM4B,MAAM,GAAGzJ,KAAK,CAAC2H,CAAC,CAACc,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC;IACnC,OAAOvH,QAAQ,CAACsH,YAAY,CAAC,CAACX,QAAQ,CAAC4B,MAAM,CAAC;EAChD;EAEAC,QAAQA,CAACpD,KAAa,EAAE1B,OAAA,GAAwB,EAAE;IAChD,IAAI,IAAI,CAAC1D,QAAQ,CAACqB,MAAM,KAAK,CAAC,EAAE;MAC9B,OAAO,IAAI;;IAGb,MAAMmE,IAAI,GAAG1G,KAAK,CAACsG,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC;IAC/B,MAAMyB,IAAI,GAAG,IAAI,CAACnB,UAAU,CAAChC,OAAO,CAAC;IACrC,MAAMiC,GAAG,GAAG,IAAI,CAACtE,MAAM,CAACwF,IAAI,CAAC;IAC7B,MAAMxF,MAAM,GAAGsE,GAAG,GAAGH,IAAI;IACzB,OAAO,IAAI,CAACiD,cAAc,CAACpH,MAAM,EAAEwF,IAAI,CAAC;EAC1C;EAEA4B,cAAcA,CAACpH,MAAc,EAAEqC,OAAA,GAAwB,EAAE;IACvD,IAAI,IAAI,CAAC1D,QAAQ,CAACqB,MAAM,KAAK,CAAC,EAAE;MAC9B,OAAO,IAAI;;IAGb,IAAIuE,SAAS,GAAG,IAAI;IACpB,IAAIvE,MAAM,GAAG,CAAC,EAAE;MACduE,SAAS,GAAG,KAAK;MACjBvE,MAAM,GAAG,CAACA,MAAM,EAAC;;IAGnB,MAAMwE,SAAS,GAAG,IAAI,CAACC,YAAY,CAACpC,OAAO,CAAC;IAC5C,MAAMqC,mBAAmB,GAAG,IAAI,CAACC,eAAe,CAACtC,OAAO,CAAC;IAEzD,IAAIuC,IAAI,GAAG,CAAC;IACZ,IAAIyC,OAAO;IACX,IAAIC,mBAAmB;IACvB,IAAIC,gBAAgB;IACpB,IAAIC,qBAAqB;IACzB,IAAIpC,CAAC;IAEL,KAAK,IAAIhG,CAAC,GAAG,CAAC,EAAEoC,EAAE,GAAG,IAAI,CAAC7C,QAAQ,CAACqB,MAAM,EAAEZ,CAAC,GAAGoC,EAAE,EAAEpC,CAAC,IAAI,CAAC,EAAE;MACzD,MAAMc,KAAK,GAAGqE,SAAS,GAAGnF,CAAC,GAAGoC,EAAE,GAAG,CAAC,GAAGpC,CAAC;MACxC,MAAMe,OAAO,GAAG,IAAI,CAAC0D,UAAU,CAAC3D,KAAK,CAAC;MACtC,MAAM4E,YAAY,GAAGJ,mBAAmB,CAACxE,KAAK,CAAC;MAC/C,MAAMsF,IAAI,GAAG;QAAEhB,SAAS;QAAEM;MAAY,CAAE;MACxC,MAAMR,GAAG,GAAGnE,OAAO,CAACH,MAAM,CAACwF,IAAI,CAAC;MAEhC,IAAIrF,OAAO,CAACiG,gBAAgB,EAAE,EAAE;QAC9BmB,gBAAgB,GAAGpH,OAAO;QAC1BqH,qBAAqB,GAAGtH,KAAK;QAE7B,IAAIF,MAAM,IAAI4E,IAAI,GAAGN,GAAG,EAAE;UACxBgD,mBAAmB,GAAGpH,KAAK;UAC3BmH,OAAO,GAAGlH,OAAO,CAACiH,cAAc,CAC9B,CAAC7C,SAAS,GAAG,CAAC,GAAG,CAAC,CAAC,KAAKvE,MAAM,GAAG4E,IAAI,CAAC,EACtCY,IAAI,CACL;UACD;;;MAIJZ,IAAI,IAAIN,GAAG;;IAGb,IAAI,CAACiD,gBAAgB,EAAE;MACrB,OAAO,IAAI;;IAGb,IAAI,CAACF,OAAO,EAAE;MACZC,mBAAmB,GAAGE,qBAAqB;MAC3CpC,CAAC,GAAGb,SAAS,GAAG,CAAC,GAAG,CAAC;MACrB8C,OAAO,GAAGE,gBAAgB,CAACE,SAAS,CAACrC,CAAC,CAAC;;IAGzC;IAEA,MAAMsC,QAAQ,GAAG,IAAI,CAACd,KAAK,EAAE;IAC7B,MAAM1G,KAAK,GAAGoH,mBAA6B;IAC3CI,QAAQ,CAAChE,cAAc,CAACxD,KAAK,EAAEmH,OAAO,CAAC;IAEvC,MAAMM,kBAAkB,GAAGzH,KAAK;IAChC,IAAI0H,gBAAgB,GAAG1H,KAAK,GAAG,CAAC;IAChC,IAAI2H,gBAAgB,GAAG3H,KAAK,GAAG,CAAC;IAEhC;IACA,IAAI,CAACmH,OAAO,CAAC,CAAC,CAAC,CAACjB,gBAAgB,EAAE,EAAE;MAClCsB,QAAQ,CAACtE,aAAa,CAACuE,kBAAkB,CAAC;MAC1CC,gBAAgB,IAAI,CAAC;MACrBC,gBAAgB,IAAI,CAAC;;IAGvB;IACA,MAAMC,SAAS,GAAGJ,QAAQ,CAAC7D,UAAU,CAAC+D,gBAAgB,CAAC,CAACrI,KAAK;IAC7DmI,QAAQ,CAACzE,aAAa,CAAC2E,gBAAgB,EAAErJ,IAAI,CAACe,aAAa,CAAC,GAAG,EAAEwI,SAAS,CAAC,CAAC;IAC5ED,gBAAgB,IAAI,CAAC;IAErB;IACA,IAAI,CAACR,OAAO,CAAC,CAAC,CAAC,CAACjB,gBAAgB,EAAE,EAAE;MAClCsB,QAAQ,CAACtE,aAAa,CAACyE,gBAAgB,GAAG,CAAC,CAAC;MAC5CA,gBAAgB,IAAI,CAAC;;IAGvB;IAEA,MAAME,gCAAgC,GACpCF,gBAAgB,GAAGF,kBAAkB,GAAG,CAAC;IAE3C,KACE,IAAIvI,CAAC,GAAGyI,gBAAgB,EAAErG,EAAE,GAAGkG,QAAQ,CAAC/I,QAAQ,CAACqB,MAAM,EACvDZ,CAAC,GAAGoC,EAAE,EACNpC,CAAC,IAAI,CAAC,EACN;MACA,MAAM4I,eAAe,GAAG,IAAI,CAACnE,UAAU,CACrCzE,CAAC,GAAG2I,gCAAgC,CACrC;MACD,MAAM5H,OAAO,GAAGuH,QAAQ,CAAC7D,UAAU,CAACzE,CAAC,CAAC;MAEtC,IACEe,OAAO,CAAC8H,IAAI,KAAK,GAAG,IACpB,CAACD,eAAe,CAAC9C,mBAAoB,CAAC1F,GAAG,CAACC,MAAM,CAC9CU,OAAO,CAAC+E,mBAAoB,CAAC1F,GAAG,CACjC,EACD;QACA;QACA;QACA,MAAM0I,gBAAgB,GAAG3J,IAAI,CAACe,aAAa,CAAC,GAAG,EAAE0I,eAAe,CAACxI,GAAG,CAAC;QACrEkI,QAAQ,CAAChE,cAAc,CAACtE,CAAC,EAAE8I,gBAAgB,CAAC;;;IAIhD;IACA,MAAMC,SAAS,GAAG,IAAI5J,IAAI,CAACmJ,QAAQ,CAAC/I,QAAQ,CAACuD,KAAK,CAAC,CAAC,EAAE0F,gBAAgB,CAAC,CAAC;IACxE,MAAMQ,UAAU,GAAG,IAAI7J,IAAI,CAACmJ,QAAQ,CAAC/I,QAAQ,CAACuD,KAAK,CAAC0F,gBAAgB,CAAC,CAAC;IAEtE,OAAO,CAACO,SAAS,EAAEC,UAAU,CAAC;EAChC;EAEAC,kBAAkBA,CAACC,IAAU,EAAEjG,OAAA,GAAwB,EAAE;IACvD,MAAMkE,SAAS,GAAG,IAAI,CAACC,WAAW,CAACnE,OAAO,CAAC;IAC3C,IAAIkE,SAAS,IAAI,IAAI,EAAE;MACrB,OAAO,IAAI;;IAGb,IAAIgC,aAAa,GAAmB,IAAI;IACxC,KAAK,IAAInJ,CAAC,GAAG,CAAC,EAAEoC,EAAE,GAAG+E,SAAS,CAACvG,MAAM,EAAEZ,CAAC,GAAGoC,EAAE,EAAEpC,CAAC,IAAI,CAAC,EAAE;MACrD,MAAMsH,QAAQ,GAAGH,SAAS,CAACnH,CAAC,CAAC;MAC7B,MAAMoJ,YAAY,GAAGF,IAAI,CAACG,SAAS,CAAC/B,QAAQ,CAAC;MAC7C,IAAI8B,YAAY,EAAE;QAChB,IAAID,aAAa,IAAI,IAAI,EAAE;UACzBA,aAAa,GAAG,EAAE;;QAEpB,IAAI3J,KAAK,CAACC,OAAO,CAAC2J,YAAY,CAAC,EAAE;UAC/BD,aAAa,CAAC1G,IAAI,CAAC,GAAG2G,YAAY,CAAC;SACpC,MAAM;UACLD,aAAa,CAAC1G,IAAI,CAAC2G,YAAY,CAAC;;;;IAKtC,OAAOD,aAAa;EACtB;EAEAnC,gBAAgBA,CAAA;IACd,KAAK,IAAIhH,CAAC,GAAG,CAAC,EAAEoC,EAAE,GAAG,IAAI,CAAC7C,QAAQ,CAACqB,MAAM,EAAEZ,CAAC,GAAGoC,EAAE,EAAEpC,CAAC,IAAI,CAAC,EAAE;MACzD,MAAMe,OAAO,GAAG,IAAI,CAACxB,QAAQ,CAACS,CAAC,CAAC;MAChC,IAAIe,OAAO,CAACiG,gBAAgB,EAAE,EAAE;QAC9B,OAAO,IAAI;;;IAIf,OAAO,KAAK;EACd;EAEAsC,OAAOA,CAAA;IACL,MAAM/J,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC9B,MAAM+J,OAAO,GAAG/J,QAAQ,CAACqB,MAAM,KAAK,CAAC,IAAIrB,QAAQ,CAAC,CAAC,CAAC,CAACsJ,IAAI,KAAK,GAAG;IACjE,OAAOS,OAAO;EAChB;EAEA1I,MAAMA,CAACqC,OAAA,GAAwB,EAAE;IAC/B,IAAI,IAAI,CAAC1D,QAAQ,CAACqB,MAAM,KAAK,CAAC,EAAE;MAC9B,OAAO,CAAC;;IAGV,MAAM0E,mBAAmB,GAAG,IAAI,CAACC,eAAe,CAACtC,OAAO,CAAC;IAEzD,IAAIrC,MAAM,GAAG,CAAC;IACd,KAAK,IAAIZ,CAAC,GAAG,CAAC,EAAEoC,EAAE,GAAG,IAAI,CAAC7C,QAAQ,CAACqB,MAAM,EAAEZ,CAAC,GAAGoC,EAAE,EAAEpC,CAAC,IAAI,CAAC,EAAE;MACzD,MAAMe,OAAO,GAAG,IAAI,CAACxB,QAAQ,CAACS,CAAC,CAAC;MAChC,MAAM0F,YAAY,GAAGJ,mBAAmB,CAACtF,CAAC,CAAC;MAC3CY,MAAM,IAAIG,OAAO,CAACH,MAAM,CAAC;QAAE8E;MAAY,CAAE,CAAC;;IAG5C,OAAO9E,MAAM;EACf;EAEAyF,SAASA,CACPL,CAA0C,EAC1C/C,OAAA,GAAwB,EAAE;IAE1B,MAAM/B,KAAK,GAAG,IAAI,CAAC3B,QAAQ,CAACqB,MAAM;IAClC,IAAIM,KAAK,KAAK,CAAC,EAAE;MACf,OAAO,CAAC;;IAGV,IAAI2F,YAAY,GAAGb,CAAC,CAACa,YAAY;IACjC,IAAIA,YAAY,GAAG,CAAC,EAAE;MACpB,OAAO,CAAC;;IAGV,IAAIiB,MAAM,GAAGzJ,KAAK,CAAC2H,CAAC,CAACc,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC;IACjC,IAAID,YAAY,IAAI3F,KAAK,EAAE;MACzB2F,YAAY,GAAG3F,KAAK,GAAG,CAAC;MACxB4G,MAAM,GAAG,CAAC;;IAGZ,MAAM1C,SAAS,GAAG,IAAI,CAACC,YAAY,CAACpC,OAAO,CAAC;IAC5C,MAAMqC,mBAAmB,GAAG,IAAI,CAACC,eAAe,CAACtC,OAAO,CAAC;IAEzD,IAAIrC,MAAM,GAAG,CAAC;IACd,KAAK,IAAIZ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6G,YAAY,EAAE7G,CAAC,IAAI,CAAC,EAAE;MACxC,MAAMe,OAAO,GAAG,IAAI,CAACxB,QAAQ,CAACS,CAAC,CAAC;MAChC,MAAM0F,YAAY,GAAGJ,mBAAmB,CAACtF,CAAC,CAAC;MAC3CY,MAAM,IAAIG,OAAO,CAACH,MAAM,CAAC;QAAEwE,SAAS;QAAEM;MAAY,CAAE,CAAC;;IAGvD,MAAM3E,OAAO,GAAG,IAAI,CAACxB,QAAQ,CAACsH,YAAY,CAAC;IAC3C,MAAMnB,YAAY,GAAGJ,mBAAmB,CAACuB,YAAY,CAAC;IACtDjG,MAAM,IAAIG,OAAO,CAACsF,SAAS,CAACyB,MAAM,EAAE;MAAE1C,SAAS;MAAEM;IAAY,CAAE,CAAC;IAEhE,OAAO9E,MAAM;EACf;EAEA2I,SAASA,CAAC5E,KAAa,EAAE1B,OAAA,GAAwB,EAAE;IACjD,IAAI,IAAI,CAAC1D,QAAQ,CAACqB,MAAM,KAAK,CAAC,EAAE;MAC9B,OAAO,IAAI;;IAGb,MAAMmE,IAAI,GAAG1G,KAAK,CAACsG,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC;IAC/B,MAAMyB,IAAI,GAAG,IAAI,CAACnB,UAAU,CAAChC,OAAO,CAAC;IACrC,MAAMiC,GAAG,GAAG,IAAI,CAACtE,MAAM,CAACwF,IAAI,CAAC;IAC7B,MAAMxF,MAAM,GAAGsE,GAAG,GAAGH,IAAI;IACzB,OAAO,IAAI,CAACyE,eAAe,CAAC5I,MAAM,EAAEwF,IAAI,CAAC;EAC3C;EAEAoD,eAAeA,CAAC5I,MAAc,EAAEqC,OAAA,GAAwB,EAAE;IACxD,IAAI,IAAI,CAAC1D,QAAQ,CAACqB,MAAM,KAAK,CAAC,EAAE;MAC9B,OAAO,IAAI;;IAGb,IAAIuE,SAAS,GAAG,IAAI;IACpB,IAAIvE,MAAM,GAAG,CAAC,EAAE;MACduE,SAAS,GAAG,KAAK;MACjBvE,MAAM,GAAG,CAACA,MAAM,EAAC;;IAGnB,MAAMwE,SAAS,GAAG,IAAI,CAACC,YAAY,CAACpC,OAAO,CAAC;IAC5C,MAAMqC,mBAAmB,GAAG,IAAI,CAACC,eAAe,CAACtC,OAAO,CAAC;IAEzD,IAAIkF,gBAAgB;IACpB,IAAI3C,IAAI,GAAG,CAAC;IACZ,KAAK,IAAIxF,CAAC,GAAG,CAAC,EAAEoC,EAAE,GAAG,IAAI,CAAC7C,QAAQ,CAACqB,MAAM,EAAEZ,CAAC,GAAGoC,EAAE,EAAEpC,CAAC,IAAI,CAAC,EAAE;MACzD,MAAMc,KAAK,GAAGqE,SAAS,GAAGnF,CAAC,GAAGoC,EAAE,GAAG,CAAC,GAAGpC,CAAC;MACxC,MAAMe,OAAO,GAAG,IAAI,CAACxB,QAAQ,CAACuB,KAAK,CAAC;MACpC,MAAM4E,YAAY,GAAGJ,mBAAmB,CAACxE,KAAK,CAAC;MAC/C,MAAMoE,GAAG,GAAGnE,OAAO,CAACH,MAAM,CAAC;QAAEwE,SAAS;QAAEM;MAAY,CAAE,CAAC;MAEvD,IAAI3E,OAAO,CAACiG,gBAAgB,EAAE,EAAE;QAC9B,IAAIpG,MAAM,IAAI4E,IAAI,GAAGN,GAAG,EAAE;UACxB,OAAOnE,OAAO,CAACyI,eAAe,CAC5B,CAACrE,SAAS,GAAG,CAAC,GAAG,CAAC,CAAC,KAAKvE,MAAM,GAAG4E,IAAI,CAAC,EACtC;YACEJ,SAAS;YACTM;WACD,CACF;;QAGHyC,gBAAgB,GAAGpH,OAAO;;MAG5ByE,IAAI,IAAIN,GAAG;;IAGb;IACA,IAAIiD,gBAAgB,EAAE;MACpB,MAAMnC,CAAC,GAAGb,SAAS,GAAG,CAAC,GAAG,CAAC;MAC3B,OAAOgD,gBAAgB,CAAClB,UAAU,CAACjB,CAAC,CAAC;;IAGvC;IACA,OAAO,IAAI;EACb;EAEAiB,UAAUA,CAACjB,CAA0C;IACnD,MAAM9E,KAAK,GAAG,IAAI,CAAC3B,QAAQ,CAACqB,MAAM;IAClC,IAAIM,KAAK,KAAK,CAAC,EAAE;MACf,OAAO,IAAI;;IAGb,MAAM2F,YAAY,GAAGb,CAAC,CAACa,YAAY;IACnC,IAAIA,YAAY,GAAG,CAAC,EAAE;MACpB,OAAO,IAAI,CAACtH,QAAQ,CAAC,CAAC,CAAC,CAAC0H,UAAU,CAAC,CAAC,CAAC;;IAGvC,IAAIJ,YAAY,IAAI3F,KAAK,EAAE;MACzB,OAAO,IAAI,CAAC3B,QAAQ,CAAC2B,KAAK,GAAG,CAAC,CAAC,CAAC+F,UAAU,CAAC,CAAC,CAAC;;IAG/C,MAAMa,MAAM,GAAGzJ,KAAK,CAAC2H,CAAC,CAACc,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC;IACnC,OAAO,IAAI,CAACvH,QAAQ,CAACsH,YAAY,CAAC,CAACI,UAAU,CAACa,MAAM,CAAC;EACvD;EAEUzC,YAAYA,CAACpC,OAAA,GAAwB,EAAE;IAC/C,OAAOA,OAAO,CAACmC,SAAS,IAAI,IAAI,GAAG,IAAI,CAAC9F,SAAS,GAAG2D,OAAO,CAACmC,SAAS;EACvE;EAEUG,eAAeA,CAACtC,OAAA,GAAwB,EAAE;IAClD,IAAIA,OAAO,CAACqC,mBAAmB,IAAI,IAAI,EAAE;MACvC,MAAMF,SAAS,GAAG,IAAI,CAACC,YAAY,CAACpC,OAAO,CAAC;MAC5C,OAAO,IAAI,CAAC0C,sBAAsB,CAAC;QAAEP;MAAS,CAAE,CAAC;;IAEnD,OAAOnC,OAAO,CAACqC,mBAAmB;EACpC;EAEUL,UAAUA,CAAChC,OAAA,GAAwB,EAAE;IAC7C,MAAMmC,SAAS,GAAG,IAAI,CAACC,YAAY,CAACpC,OAAO,CAAC;IAC5C,MAAMqC,mBAAmB,GAAG,IAAI,CAACC,eAAe,CAACtC,OAAO,CAAC;IACzD,OAAO;MAAEmC,SAAS;MAAEE;IAAmB,CAAE;EAC3C;EAEAmE,QAAQA,CAACxG,OAAA,GAAwB,EAAE;IACjC,MAAM1D,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC9B,MAAM2B,KAAK,GAAG3B,QAAQ,CAACqB,MAAM;IAC7B,IAAIM,KAAK,KAAK,CAAC,EAAE;MACf,OAAO,IAAI;;IAGb,MAAMoE,mBAAmB,GAAG,IAAI,CAACC,eAAe,CAACtC,OAAO,CAAC;IACzD,MAAMtC,MAAM,GAAG,EAAE;IACjB,IAAI+I,aAAa,GAAG,EAAE;IAEtB,KAAK,IAAI1J,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkB,KAAK,EAAElB,CAAC,IAAI,CAAC,EAAE;MACjC,MAAMe,OAAO,GAAGxB,QAAQ,CAACS,CAAC,CAAC;MAC3B,IAAIe,OAAO,CAACI,SAAS,EAAE;QACrB,MAAMwI,SAAS,GAAGrE,mBAAmB,CAACtF,CAAC,CAAC;QACxC,IAAI2J,SAAS,CAAC/I,MAAM,GAAG,CAAC,EAAE;UACxB;UACA+I,SAAS,CAAC7J,OAAO,CAAE8J,CAAC,IAAKF,aAAa,CAACjH,IAAI,CAACmH,CAAC,CAACzJ,KAAK,CAAC,CAAC;SACtD,MAAM;UACLuJ,aAAa,CAACjH,IAAI,CAAC1B,OAAO,CAACZ,KAAK,CAAC;;OAEpC,MAAM,IAAIuJ,aAAa,CAAC9I,MAAM,GAAG,CAAC,EAAE;QACnC8I,aAAa,CAACjH,IAAI,CAAClD,QAAQ,CAACS,CAAC,GAAG,CAAC,CAAC,CAACI,GAAG,CAAC;QACvCO,MAAM,CAAC8B,IAAI,CAACiH,aAAa,CAAC;QAC1BA,aAAa,GAAG,EAAE;;;IAItB,IAAIA,aAAa,CAAC9I,MAAM,GAAG,CAAC,EAAE;MAC5B8I,aAAa,CAACjH,IAAI,CAAC,IAAI,CAACrC,GAAI,CAAC;MAC7BO,MAAM,CAAC8B,IAAI,CAACiH,aAAa,CAAC;;IAG5B,OAAO/I,MAAM;EACf;EAEAyG,WAAWA,CAACnE,OAAA,GAAwB,EAAE;IACpC,MAAMtC,MAAM,GAAG,IAAI,CAAC8I,QAAQ,CAACxG,OAAO,CAAC;IACrC,IAAI,CAACtC,MAAM,EAAE;MACX,OAAO,IAAI;;IAGb,OAAOA,MAAM,CAACkJ,GAAG,CAAEhK,GAAG,IAAK,IAAInB,QAAQ,CAACmB,GAAG,CAAC,CAAC;EAC/C;EAEAiK,KAAKA,CAACC,EAAU,EAAEC,EAAU,EAAEC,MAAwB;IACpD,IAAI,CAAC1K,QAAQ,CAACO,OAAO,CAAEU,CAAC,IAAKA,CAAC,CAACsJ,KAAK,CAACC,EAAE,EAAEC,EAAE,EAAEC,MAAM,CAAC,CAAC;IACrD,OAAO,IAAI;EACb;EAEAC,MAAMA,CAACC,KAAa,EAAEF,MAA0C;IAC9D,IAAI,CAAC1K,QAAQ,CAACO,OAAO,CAAEiB,OAAO,IAAKA,OAAO,CAACmJ,MAAM,CAACC,KAAK,EAAEF,MAAM,CAAC,CAAC;IACjE,OAAO,IAAI;EACb;EAIAG,SAASA,CAACC,EAA4B,EAAEC,EAAW;IACjD,IAAI,OAAOD,EAAE,KAAK,QAAQ,EAAE;MAC1B,IAAI,CAAC9K,QAAQ,CAACO,OAAO,CAAEU,CAAC,IAAKA,CAAC,CAAC4J,SAAS,CAACC,EAAE,EAAEC,EAAY,CAAC,CAAC;KAC5D,MAAM;MACL,IAAI,CAAC/K,QAAQ,CAACO,OAAO,CAAEU,CAAC,IAAKA,CAAC,CAAC4J,SAAS,CAACC,EAAE,CAAC,CAAC;;IAE/C,OAAO,IAAI;EACb;EAEA7C,KAAKA,CAAA;IACH,MAAM7E,IAAI,GAAG,IAAIxD,IAAI,EAAE;IACvB,IAAI,CAACI,QAAQ,CAACO,OAAO,CAAEU,CAAC,IAAKmC,IAAI,CAAC1C,aAAa,CAACO,CAAC,CAACgH,KAAK,EAAE,CAAC,CAAC;IAC3D,OAAO7E,IAAI;EACb;EAEAtC,MAAMA,CAACqC,CAAO;IACZ,IAAIA,CAAC,IAAI,IAAI,EAAE;MACb,OAAO,KAAK;;IAGd,MAAMnD,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC9B,MAAMgL,aAAa,GAAG7H,CAAC,CAACnD,QAAQ;IAEhC,MAAM2B,KAAK,GAAG3B,QAAQ,CAACqB,MAAM;IAC7B,IAAI2J,aAAa,CAAC3J,MAAM,KAAKM,KAAK,EAAE;MAClC,OAAO,KAAK;;IAGd,KAAK,IAAIlB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkB,KAAK,EAAElB,CAAC,IAAI,CAAC,EAAE;MACjC,MAAMwK,CAAC,GAAGjL,QAAQ,CAACS,CAAC,CAAC;MACrB,MAAMyK,CAAC,GAAGF,aAAa,CAACvK,CAAC,CAAC;MAC1B,IAAIwK,CAAC,CAAC3B,IAAI,KAAK4B,CAAC,CAAC5B,IAAI,IAAI,CAAC2B,CAAC,CAACnK,MAAM,CAACoK,CAAC,CAAC,EAAE;QACrC,OAAO,KAAK;;;IAIhB,OAAO,IAAI;EACb;EAEAC,MAAMA,CAAA;IACJ,OAAO,IAAI,CAACnL,QAAQ,CAACsK,GAAG,CAAErJ,CAAC,IAAKA,CAAC,CAACkK,MAAM,EAAE,CAAC;EAC7C;EAEAC,SAASA,CAAA;IACP,IAAI,CAAC,IAAI,CAACrB,OAAO,EAAE,EAAE;MACnB,MAAM,IAAIxF,KAAK,CAAC,wBAAwB,CAAC;;IAG3C,OAAO,IAAI,CAACvE,QAAQ,CAACsK,GAAG,CAAErJ,CAAC,IAAKA,CAAC,CAACmK,SAAS,EAAE,CAAC,CAAC9H,IAAI,CAAC,GAAG,CAAC;EAC1D;EAEA+H,QAAQA,CAAA;IACN,OAAO,IAAI,CAACD,SAAS,EAAE;EACzB;;AAGF,WAAiBxL,IAAI;EACNA,IAAA,CAAA8B,WAAW,GAAG,eAAe9B,IAAI,CAAC0L,IAAI,EAAE;EAErD,SAAgBC,MAAMA,CAACC,QAAa;IAClC,IAAIA,QAAQ,IAAI,IAAI,EAAE;MACpB,OAAO,KAAK;;IAGd,IAAIA,QAAQ,YAAY5L,IAAI,EAAE;MAC5B,OAAO,IAAI;;IAGb,MAAM6L,GAAG,GAAGD,QAAQ,CAAC/J,MAAM,CAACC,WAAW,CAAC;IACxC,MAAM0B,IAAI,GAAGoI,QAAgB;IAE7B,IACE,CAACC,GAAG,IAAI,IAAI,IAAIA,GAAG,KAAK7L,IAAA,CAAA8B,WAAW,KACnCzB,KAAK,CAACC,OAAO,CAACkD,IAAI,CAACpD,QAAQ,CAAC,IAC5B,OAAOoD,IAAI,CAACvB,MAAM,KAAK,UAAU,IACjC,OAAOuB,IAAI,CAACpB,MAAM,KAAK,UAAU,IACjC,OAAOoB,IAAI,CAACnB,OAAO,KAAK,UAAU,EAClC;MACA,OAAO,IAAI;;IAGb,OAAO,KAAK;EACd;EAvBgBrC,IAAA,CAAA2L,MAAM,GAAAA,MAuBrB;AACH,CAAC,EA3BgB3L,IAAI,KAAJA,IAAI;AAoCrB,WAAiBA,IAAI;EACnB,SAAgByD,KAAKA,CAACqI,QAAgB;IACpC,IAAI,CAACA,QAAQ,EAAE;MACb,OAAO,IAAI9L,IAAI,EAAE;;IAGnB,MAAMwD,IAAI,GAAG,IAAIxD,IAAI,EAAE;IAEvB,MAAM+L,SAAS,GACb,2GAA2G;IAC7G,MAAMC,QAAQ,GAAGhM,IAAA,CAAAiM,SAAS,CAACH,QAAQ,CAAC,CAACI,KAAK,CAACH,SAAS,CAAC;IACrD,IAAIC,QAAQ,IAAI,IAAI,EAAE;MACpB,KAAK,IAAInL,CAAC,GAAG,CAAC,EAAEoC,EAAE,GAAG+I,QAAQ,CAACvK,MAAM,EAAEZ,CAAC,GAAGoC,EAAE,EAAEpC,CAAC,IAAI,CAAC,EAAE;QACpD,MAAMsL,OAAO,GAAGH,QAAQ,CAACnL,CAAC,CAAC;QAC3B,MAAMuL,KAAK,GACT,qEAAqE;QACvE;QACA,MAAMlM,IAAI,GAAGiM,OAAO,CAACD,KAAK,CAACE,KAAK,CAAC;QACjC,IAAIlM,IAAI,IAAI,IAAI,EAAE;UAChB,MAAMwJ,IAAI,GAAGxJ,IAAI,CAAC,CAAC,CAAC;UACpB,MAAMmM,MAAM,GAAGnM,IAAI,CAACyD,KAAK,CAAC,CAAC,CAAC,CAAC+G,GAAG,CAAEW,CAAC,IAAK,CAACA,CAAC,CAAC;UAC3C,MAAMzJ,OAAO,GAAGb,aAAa,CAACoB,IAAI,CAAC,IAAI,EAAEuH,IAAI,EAAE,GAAG2C,MAAM,CAAC;UACzD7I,IAAI,CAAC1C,aAAa,CAACc,OAAO,CAAC;;;;IAKjC,OAAO4B,IAAI;EACb;EA3BgBxD,IAAA,CAAAyD,KAAK,GAAAA,KA2BpB;EAgED,SAAgB1C,aAAaA,CAC3B2I,IAAiC,EACjC,GAAGxJ,IAAW;IAWd,IAAIwJ,IAAI,KAAK,GAAG,EAAE;MAChB,OAAO9J,MAAM,CAACsC,MAAM,CAACC,IAAI,CAAC,IAAI,EAAE,GAAGjC,IAAI,CAAC;;IAG1C,IAAIwJ,IAAI,KAAK,GAAG,EAAE;MAChB,OAAO/J,MAAM,CAACuC,MAAM,CAACC,IAAI,CAAC,IAAI,EAAE,GAAGjC,IAAI,CAAC;;IAG1C,IAAIwJ,IAAI,KAAK,GAAG,EAAE;MAChB,OAAO7J,OAAO,CAACqC,MAAM,CAACC,IAAI,CAAC,IAAI,EAAE,GAAGjC,IAAI,CAAC;;IAG3C,IAAIwJ,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,GAAG,EAAE;MAChC,OAAOhK,KAAK,CAACwC,MAAM,EAAE;;IAGvB,MAAM,IAAIyC,KAAK,CAAC,8BAA8B+E,IAAI,GAAG,CAAC;EACxD;EA9BgB1J,IAAA,CAAAe,aAAa,GAAAA,aA8B5B;AACH,CAAC,EA3HgBf,IAAI,KAAJA,IAAI;AA6HrB,WAAiBA,IAAI;EACNA,IAAA,CAAAiM,SAAS,GAAGnM,iBAAiB;EAC7BE,IAAA,CAAAmK,OAAO,GAAGpK,IAAI,CAACoK,OAAO;EACtBnK,IAAA,CAAAsM,OAAO,GAAGvM,IAAI,CAACuM,OAAO;EACtBtM,IAAA,CAAA6D,UAAU,GAAG9D,IAAI,CAAC8D,UAAU;EAC5B7D,IAAA,CAAA8C,WAAW,GAAG/C,IAAI,CAAC+C,WAAW;AAC7C,CAAC,EANgB9C,IAAI,KAAJA,IAAI","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}