{"ast":null,"code":"import { zipObject } from '../util';\n/*\n * A function that takes a layering (an array of layers, each with an array of\n * ordererd nodes) and a graph and returns a weighted crossing count.\n *\n * Pre-conditions:\n *\n *    1. Input graph must be simple (not a multigraph), directed, and include\n *       only simple edges.\n *    2. Edges in the input graph must have assigned weights.\n *\n * Post-conditions:\n *\n *    1. The graph and layering matrix are left unchanged.\n *\n * This algorithm is derived from Barth, et al., \"Bilayer Cross Counting.\"\n */\nconst twoLayerCrossCount = (g, northLayer, southLayer) => {\n  // Sort all of the edges between the north and south layers by their position\n  // in the north layer and then the south. Map these edges to the position of\n  // their head in the south layer.\n  const southPos = zipObject(southLayer, southLayer.map((v, i) => i));\n  const unflat = northLayer.map(v => {\n    var _a;\n    const unsort = (_a = g.outEdges(v)) === null || _a === void 0 ? void 0 : _a.map(e => {\n      return {\n        pos: southPos[e.w] || 0,\n        weight: g.edge(e).weight\n      };\n    });\n    return unsort === null || unsort === void 0 ? void 0 : unsort.sort((a, b) => a.pos - b.pos);\n  });\n  // @ts-ignore\n  const southEntries = unflat.flat().filter(entry => entry !== undefined);\n  // Build the accumulator tree\n  let firstIndex = 1;\n  while (firstIndex < southLayer.length) firstIndex <<= 1;\n  const treeSize = 2 * firstIndex - 1;\n  firstIndex -= 1;\n  const tree = Array(treeSize).fill(0, 0, treeSize);\n  // Calculate the weighted crossings\n  let cc = 0;\n  southEntries === null || southEntries === void 0 ? void 0 : southEntries.forEach(entry => {\n    let index = entry.pos + firstIndex;\n    tree[index] += entry.weight;\n    let weightSum = 0;\n    while (index > 0) {\n      if (index % 2) {\n        weightSum += tree[index + 1];\n      }\n      index = index - 1 >> 1;\n      tree[index] += entry.weight;\n    }\n    cc += entry.weight * weightSum;\n  });\n  return cc;\n};\nconst crossCount = (g, layering) => {\n  let cc = 0;\n  for (let i = 1; i < (layering === null || layering === void 0 ? void 0 : layering.length); ++i) {\n    cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);\n  }\n  return cc;\n};\nexport default crossCount;","map":{"version":3,"names":["zipObject","twoLayerCrossCount","g","northLayer","southLayer","southPos","map","v","i","unflat","unsort","_a","outEdges","e","pos","w","weight","edge","sort","a","b","southEntries","flat","filter","entry","undefined","firstIndex","length","treeSize","tree","Array","fill","cc","forEach","index","weightSum","crossCount","layering"],"sources":["../../../../../src/layout/dagre/src/order/cross-count.ts"],"sourcesContent":[null],"mappings":"AACA,SAASA,SAAS,QAAQ,SAAS;AAInC;;;;;;;;;;;;;;;;AAiBA,MAAMC,kBAAkB,GAAGA,CAACC,CAAQ,EAAEC,UAAoB,EAAEC,UAAoB,KAAI;EAClF;EACA;EACA;EACA,MAAMC,QAAQ,GAAGL,SAAS,CAACI,UAAU,EACnCA,UAAU,CAACE,GAAG,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAAC,CAAC;EAC9B,MAAMC,MAAM,GAAGN,UAAU,CAACG,GAAG,CAAEC,CAAC,IAAI;;IAClC,MAAMG,MAAM,GAAG,CAAAC,EAAA,GAAAT,CAAC,CAACU,QAAQ,CAACL,CAAC,CAAC,cAAAI,EAAA,uBAAAA,EAAA,CAAEL,GAAG,CAAEO,CAAC,IAAI;MACtC,OAAO;QAAEC,GAAG,EAAET,QAAQ,CAACQ,CAAC,CAACE,CAAC,CAAC,IAAI,CAAC;QAAEC,MAAM,EAAEd,CAAC,CAACe,IAAI,CAACJ,CAAC,CAAC,CAACG;MAAM,CAAE;IAC9D,CAAC,CAAC;IACF,OAAON,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEQ,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACL,GAAG,GAAGM,CAAC,CAACN,GAAG,CAAC;EAC9C,CAAC,CAAC;EACF;EACA,MAAMO,YAAY,GAAGZ,MAAM,CAACa,IAAI,EAAE,CAACC,MAAM,CAACC,KAAK,IAAIA,KAAK,KAAKC,SAAS,CAAC;EAEvE;EACA,IAAIC,UAAU,GAAG,CAAC;EAClB,OAAOA,UAAU,GAAGtB,UAAU,CAACuB,MAAM,EAAED,UAAU,KAAK,CAAC;EACvD,MAAME,QAAQ,GAAG,CAAC,GAAGF,UAAU,GAAG,CAAC;EACnCA,UAAU,IAAI,CAAC;EACf,MAAMG,IAAI,GAAGC,KAAK,CAACF,QAAQ,CAAC,CAACG,IAAI,CAAC,CAAC,EAAE,CAAC,EAAEH,QAAQ,CAAC;EAEjD;EACA,IAAII,EAAE,GAAG,CAAC;EACVX,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAEY,OAAO,CAAET,KAAU,IAAI;IACnC,IAAIU,KAAK,GAAGV,KAAK,CAACV,GAAG,GAAGY,UAAU;IAClCG,IAAI,CAACK,KAAK,CAAC,IAAIV,KAAK,CAACR,MAAM;IAC3B,IAAImB,SAAS,GAAG,CAAC;IACjB,OAAOD,KAAK,GAAG,CAAC,EAAE;MAChB,IAAIA,KAAK,GAAG,CAAC,EAAE;QACbC,SAAS,IAAIN,IAAI,CAACK,KAAK,GAAG,CAAC,CAAC;;MAE9BA,KAAK,GAAIA,KAAK,GAAG,CAAC,IAAK,CAAC;MACxBL,IAAI,CAACK,KAAK,CAAC,IAAIV,KAAK,CAACR,MAAM;;IAE7BgB,EAAE,IAAIR,KAAK,CAACR,MAAM,GAAGmB,SAAS;EAChC,CAAC,CAAC;EAEF,OAAOH,EAAE;AACX,CAAC;AAED,MAAMI,UAAU,GAAGA,CAAClC,CAAQ,EAAEmC,QAAa,KAAI;EAC7C,IAAIL,EAAE,GAAG,CAAC;EACV,KAAK,IAAIxB,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAG6B,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEV,MAAM,GAAE,EAAEnB,CAAC,EAAE;IACzCwB,EAAE,IAAI/B,kBAAkB,CAACC,CAAC,EAAEmC,QAAQ,CAAC7B,CAAC,GAAC,CAAC,CAAC,EAAE6B,QAAQ,CAAC7B,CAAC,CAAC,CAAC;;EAEzD,OAAOwB,EAAE;AACX,CAAC;AAED,eAAeI,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}