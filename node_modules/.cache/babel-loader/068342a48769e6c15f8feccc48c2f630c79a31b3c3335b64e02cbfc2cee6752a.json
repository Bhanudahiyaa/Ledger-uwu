{"ast":null,"code":"/**\n * @fileOverview concentric layout\n * @author shiwu.wyy@antfin.com\n * this algorithm refers to <cytoscape.js> - https://github.com/cytoscape/cytoscape.js/\n */\nimport { isString, isArray, isNumber, getDegree, isObject } from \"../util\";\nimport { Base } from \"./base\";\n/**\n * 同心圆布局\n */\nexport class ConcentricLayout extends Base {\n  constructor(options) {\n    super();\n    this.nodeSize = 30;\n    /** min spacing between outside of nodes (used for radius adjustment) */\n    this.minNodeSpacing = 10;\n    /** prevents node overlap, may overflow boundingBox if not enough space */\n    this.preventOverlap = false;\n    /** whether levels have an equal radial distance betwen them, may cause bounding box overflow */\n    this.equidistant = false;\n    /** where nodes start in radians */\n    this.startAngle = 3 / 2 * Math.PI;\n    /** whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false) */\n    this.clockwise = true;\n    /** 根据 sortBy 指定的属性进行排布，数值高的放在中心，如果是 sortBy 则会计算节点度数，度数最高的放在中心 */\n    this.sortBy = \"degree\";\n    this.nodes = [];\n    this.edges = [];\n    this.width = 300;\n    this.height = 300;\n    /** 迭代结束的回调函数 */\n    this.onLayoutEnd = () => {};\n    this.updateCfg(options);\n  }\n  getDefaultCfg() {\n    return {\n      nodeSize: 30,\n      minNodeSpacing: 10,\n      preventOverlap: false,\n      sweep: undefined,\n      equidistant: false,\n      startAngle: 3 / 2 * Math.PI,\n      clockwise: true,\n      maxLevelDiff: undefined,\n      sortBy: \"degree\"\n    };\n  }\n  /**\n   * 执行布局\n   */\n  execute() {\n    const self = this;\n    const nodes = self.nodes;\n    const edges = self.edges;\n    const n = nodes.length;\n    if (n === 0) {\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n    if (!self.width && typeof window !== \"undefined\") {\n      self.width = window.innerWidth;\n    }\n    if (!self.height && typeof window !== \"undefined\") {\n      self.height = window.innerHeight;\n    }\n    if (!self.center) {\n      self.center = [self.width / 2, self.height / 2];\n    }\n    const center = self.center;\n    if (n === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n    const layoutNodes = [];\n    let maxNodeSize;\n    if (isArray(self.nodeSize)) {\n      maxNodeSize = Math.max(self.nodeSize[0], self.nodeSize[1]);\n    } else {\n      maxNodeSize = self.nodeSize;\n    }\n    nodes.forEach(node => {\n      layoutNodes.push(node);\n      let nodeSize = maxNodeSize;\n      if (isArray(node.size)) {\n        nodeSize = Math.max(node.size[0], node.size[1]);\n      } else if (isNumber(node.size)) {\n        nodeSize = node.size;\n      } else if (isObject(node.size)) {\n        nodeSize = Math.max(node.size.width, node.size.height);\n      }\n      maxNodeSize = Math.max(maxNodeSize, nodeSize);\n    });\n    self.clockwise = self.counterclockwise !== undefined ? !self.counterclockwise : self.clockwise;\n    // layout\n    const nodeMap = {};\n    const indexMap = {};\n    layoutNodes.forEach((node, i) => {\n      nodeMap[node.id] = node;\n      indexMap[node.id] = i;\n    });\n    // get the node degrees\n    if (self.sortBy === \"degree\" || !isString(self.sortBy) || layoutNodes[0][self.sortBy] === undefined) {\n      self.sortBy = \"degree\";\n      if (!isNumber(nodes[0].degree)) {\n        const values = getDegree(nodes.length, indexMap, edges);\n        layoutNodes.forEach((node, i) => {\n          node.degree = values[i];\n        });\n      }\n    }\n    // sort nodes by value\n    layoutNodes.sort((n1, n2) => n2[self.sortBy] - n1[self.sortBy]);\n    self.maxValueNode = layoutNodes[0];\n    self.maxLevelDiff = self.maxLevelDiff || self.maxValueNode[self.sortBy] / 4;\n    // put the values into levels\n    const levels = [[]];\n    let currentLevel = levels[0];\n    layoutNodes.forEach(node => {\n      if (currentLevel.length > 0) {\n        const diff = Math.abs(currentLevel[0][self.sortBy] - node[self.sortBy]);\n        if (self.maxLevelDiff && diff >= self.maxLevelDiff) {\n          currentLevel = [];\n          levels.push(currentLevel);\n        }\n      }\n      currentLevel.push(node);\n    });\n    // create positions for levels\n    let minDist = maxNodeSize + self.minNodeSpacing; // min dist between nodes\n    if (!self.preventOverlap) {\n      // then strictly constrain to bb\n      const firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;\n      const maxR = Math.min(self.width, self.height) / 2 - minDist;\n      const rStep = maxR / (levels.length + (firstLvlHasMulti ? 1 : 0));\n      minDist = Math.min(minDist, rStep);\n    }\n    // find the metrics for each level\n    let r = 0;\n    levels.forEach(level => {\n      let sweep = self.sweep;\n      if (sweep === undefined) {\n        sweep = 2 * Math.PI - 2 * Math.PI / level.length;\n      }\n      const dTheta = level.dTheta = sweep / Math.max(1, level.length - 1);\n      // calculate the radius\n      if (level.length > 1 && self.preventOverlap) {\n        // but only if more than one node (can't overlap)\n        const dcos = Math.cos(dTheta) - Math.cos(0);\n        const dsin = Math.sin(dTheta) - Math.sin(0);\n        const rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n        r = Math.max(rMin, r);\n      }\n      level.r = r;\n      r += minDist;\n    });\n    if (self.equidistant) {\n      let rDeltaMax = 0;\n      let rr = 0;\n      for (let i = 0; i < levels.length; i++) {\n        const level = levels[i];\n        const rDelta = level.r - rr;\n        rDeltaMax = Math.max(rDeltaMax, rDelta);\n      }\n      rr = 0;\n      levels.forEach((level, i) => {\n        if (i === 0) {\n          rr = level.r;\n        }\n        level.r = rr;\n        rr += rDeltaMax;\n      });\n    }\n    // calculate the node positions\n    levels.forEach(level => {\n      const dTheta = level.dTheta;\n      const rr = level.r;\n      level.forEach((node, j) => {\n        const theta = self.startAngle + (self.clockwise ? 1 : -1) * dTheta * j;\n        node.x = center[0] + rr * Math.cos(theta);\n        node.y = center[1] + rr * Math.sin(theta);\n      });\n    });\n    if (self.onLayoutEnd) self.onLayoutEnd();\n    return {\n      nodes,\n      edges\n    };\n  }\n  getType() {\n    return \"concentric\";\n  }\n}","map":{"version":3,"names":["isString","isArray","isNumber","getDegree","isObject","Base","ConcentricLayout","constructor","options","nodeSize","minNodeSpacing","preventOverlap","equidistant","startAngle","Math","PI","clockwise","sortBy","nodes","edges","width","height","onLayoutEnd","updateCfg","getDefaultCfg","sweep","undefined","maxLevelDiff","execute","self","n","length","window","innerWidth","innerHeight","center","x","y","layoutNodes","maxNodeSize","max","forEach","node","push","size","counterclockwise","nodeMap","indexMap","i","id","degree","values","sort","n1","n2","maxValueNode","levels","currentLevel","diff","abs","minDist","firstLvlHasMulti","maxR","min","rStep","r","level","dTheta","dcos","cos","dsin","sin","rMin","sqrt","rDeltaMax","rr","rDelta","j","theta","getType"],"sources":["../../src/layout/concentric.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}