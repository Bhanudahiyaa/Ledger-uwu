{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport BaseModel from \"../../core/BaseModel\";\nimport { SizeUnitType } from \"../../core/interface\";\nimport { PointFillTriangulation } from \"../../core/triangulation\";\n/* babel-plugin-inline-import '../shaders/radar/radar_frag.glsl' */\nconst pointFillFrag = \"\\nlayout(std140) uniform commonUniorm{\\n  float u_additive;\\n  float u_size_unit;\\n  float u_speed: 1.0;\\n  float u_time;\\n};\\nin vec4 v_data;\\nin vec4 v_color;\\nin float v_radius;\\nin vec2 v_extrude;\\n#pragma include \\\"sdf_2d\\\"\\n#pragma include \\\"picking\\\"\\n\\nout vec4 outputColor;\\n\\nvoid main() {\\n\\n  lowp float antialiasblur = v_data.z;\\n  float r = v_radius / (v_radius);\\n\\n  float outer_df = sdCircle(v_data.xy, 1.0);\\n  float inner_df = sdCircle(v_data.xy, r);\\n\\n  float opacity_t = smoothstep(0.0, antialiasblur, outer_df);\\n\\n  outputColor = vec4(v_color.rgb, v_color.a);\\n\\n  if(u_additive > 0.0) {\\n    outputColor *= opacity_t;\\n  } else {\\n    outputColor.a *= opacity_t;\\n  }\\n\\n  if(outputColor.a > 0.0) {\\n    outputColor = filterColor(outputColor);\\n  }\\n\\n  vec2 extrude =  v_extrude;\\n  vec2 dir = normalize(extrude);\\n  vec2 baseDir = vec2(1.0, 0.0);\\n  float pi = 3.14159265359;\\n  float flag = sign(dir.y);\\n  float rades = dot(dir, baseDir);\\n  float radar_v = (flag - 1.0) * -0.5 * acos(rades)/pi;\\n  // simple AA\\n  if(radar_v > 0.99) {\\n    radar_v = 1.0 - (radar_v - 0.99)/0.01;\\n  }\\n\\n  outputColor.a *= radar_v;\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/radar/radar_vert.glsl' */\nconst pointFillVert = \"layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\\nlayout(location = ATTRIBUTE_LOCATION_EXTRUDE) in vec3 a_Extrude;\\n\\nlayout(std140) uniform commonUniorm {\\n  float u_additive;\\n  float u_size_unit;\\n  float u_speed: 1.0;\\n  float u_time;\\n};\\n\\nout vec4 v_data;\\nout vec4 v_color;\\nout float v_radius;\\nout vec2 v_extrude;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  float newSize = setPickingSize(a_Size);\\n\\n  float time = u_time * u_speed;\\n  mat2 rotateMatrix = mat2(\\n    cos(time), sin(time),\\n    -sin(time), cos(time)\\n  );\\n  v_extrude = rotateMatrix * a_Extrude.xy;\\n\\n  v_color = a_Color;\\n  v_color.a *= opacity;\\n\\n  float blur = 0.0;\\n  float antialiasblur = -max(2.0 / u_DevicePixelRatio / a_Size, blur);\\n\\n  if(u_size_unit == 1.) {\\n    newSize = newSize  * u_PixelsPerMeter.z;\\n  }\\n  v_radius = newSize;\\n\\n  vec2 offset = (a_Extrude.xy * (newSize));\\n\\n  offset = project_pixel(offset);\\n\\n  v_data = vec4(a_Extrude.x, a_Extrude.y, antialiasblur, -1.0);\\n\\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0.0, 1.0), a_Position64Low);\\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, project_pixel(setPickingOrder(0.0)), 1.0));\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\nexport default class RadarModel extends BaseModel {\n  get attributeLocation() {\n    return Object.assign(super.attributeLocation, {\n      MAX: super.attributeLocation.MAX,\n      SIZE: 9,\n      EXTRUDE: 10\n    });\n  }\n  getCommonUniformsInfo() {\n    const {\n      blend,\n      speed = 1,\n      unit = 'pixel'\n    } = this.layer.getLayerConfig();\n    const commonOptions = {\n      u_additive: blend === 'additive' ? 1.0 : 0.0,\n      u_size_unit: SizeUnitType[unit],\n      u_speed: speed,\n      u_time: this.layer.getLayerAnimateTime()\n    }; //1+1+1+1\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  getAnimateUniforms() {\n    return {};\n  }\n  getAttribute() {\n    return this.styleAttributeService.createAttributesAndIndices(this.layer.getEncodedData(), PointFillTriangulation);\n  }\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return _this.buildModels();\n    })();\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.initUniformsBuffer();\n      const model = yield _this2.layer.buildLayerModel({\n        moduleName: 'pointRadar',\n        vertexShader: pointFillVert,\n        fragmentShader: pointFillFrag,\n        triangulation: PointFillTriangulation,\n        defines: _this2.getDefines(),\n        inject: _this2.getInject(),\n        depth: {\n          enable: false\n        }\n      });\n      return [model];\n    })();\n  }\n\n  // overwrite baseModel func\n  animateOption2Array(option) {\n    return [option.enable ? 0 : 1.0, option.speed || 1, option.rings || 3, 0];\n  }\n  registerBuiltinAttributes() {\n    // 注册 Position 属性 64 位地位部分，经纬度数据开启双精度，避免大于 20层级以上出现数据偏移\n    this.registerPosition64LowAttribute();\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'extrude',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Extrude',\n        shaderLocation: this.attributeLocation.EXTRUDE,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        update: (feature, featureIdx, vertex, attributeIdx) => {\n          const extrude = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0];\n          const extrudeIndex = attributeIdx % 4 * 3;\n          return [extrude[extrudeIndex], extrude[extrudeIndex + 1], extrude[extrudeIndex + 2]];\n        }\n      }\n    });\n\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        shaderLocation: this.attributeLocation.SIZE,\n        name: 'a_Size',\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 1,\n        update: feature => {\n          const {\n            size = 5\n          } = feature;\n          return Array.isArray(size) ? [size[0]] : [size];\n        }\n      }\n    });\n  }\n}","map":{"version":3,"names":["_asyncToGenerator","AttributeType","gl","BaseModel","SizeUnitType","PointFillTriangulation","pointFillFrag","pointFillVert","RadarModel","attributeLocation","Object","assign","MAX","SIZE","EXTRUDE","getCommonUniformsInfo","blend","speed","unit","layer","getLayerConfig","commonOptions","u_additive","u_size_unit","u_speed","u_time","getLayerAnimateTime","commonBufferInfo","getUniformsBufferInfo","getAnimateUniforms","getAttribute","styleAttributeService","createAttributesAndIndices","getEncodedData","initModels","_this","buildModels","_this2","initUniformsBuffer","model","buildLayerModel","moduleName","vertexShader","fragmentShader","triangulation","defines","getDefines","inject","getInject","depth","enable","animateOption2Array","option","rings","registerBuiltinAttributes","registerPosition64LowAttribute","registerStyleAttribute","name","type","Attribute","descriptor","shaderLocation","buffer","usage","DYNAMIC_DRAW","data","FLOAT","size","update","feature","featureIdx","vertex","attributeIdx","extrude","extrudeIndex","Array","isArray"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/l7-layers/es/point/models/radar.js"],"sourcesContent":["import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport BaseModel from \"../../core/BaseModel\";\nimport { SizeUnitType } from \"../../core/interface\";\nimport { PointFillTriangulation } from \"../../core/triangulation\";\n/* babel-plugin-inline-import '../shaders/radar/radar_frag.glsl' */\nconst pointFillFrag = \"\\nlayout(std140) uniform commonUniorm{\\n  float u_additive;\\n  float u_size_unit;\\n  float u_speed: 1.0;\\n  float u_time;\\n};\\nin vec4 v_data;\\nin vec4 v_color;\\nin float v_radius;\\nin vec2 v_extrude;\\n#pragma include \\\"sdf_2d\\\"\\n#pragma include \\\"picking\\\"\\n\\nout vec4 outputColor;\\n\\nvoid main() {\\n\\n  lowp float antialiasblur = v_data.z;\\n  float r = v_radius / (v_radius);\\n\\n  float outer_df = sdCircle(v_data.xy, 1.0);\\n  float inner_df = sdCircle(v_data.xy, r);\\n\\n  float opacity_t = smoothstep(0.0, antialiasblur, outer_df);\\n\\n  outputColor = vec4(v_color.rgb, v_color.a);\\n\\n  if(u_additive > 0.0) {\\n    outputColor *= opacity_t;\\n  } else {\\n    outputColor.a *= opacity_t;\\n  }\\n\\n  if(outputColor.a > 0.0) {\\n    outputColor = filterColor(outputColor);\\n  }\\n\\n  vec2 extrude =  v_extrude;\\n  vec2 dir = normalize(extrude);\\n  vec2 baseDir = vec2(1.0, 0.0);\\n  float pi = 3.14159265359;\\n  float flag = sign(dir.y);\\n  float rades = dot(dir, baseDir);\\n  float radar_v = (flag - 1.0) * -0.5 * acos(rades)/pi;\\n  // simple AA\\n  if(radar_v > 0.99) {\\n    radar_v = 1.0 - (radar_v - 0.99)/0.01;\\n  }\\n\\n  outputColor.a *= radar_v;\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/radar/radar_vert.glsl' */\nconst pointFillVert = \"layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\\nlayout(location = ATTRIBUTE_LOCATION_EXTRUDE) in vec3 a_Extrude;\\n\\nlayout(std140) uniform commonUniorm {\\n  float u_additive;\\n  float u_size_unit;\\n  float u_speed: 1.0;\\n  float u_time;\\n};\\n\\nout vec4 v_data;\\nout vec4 v_color;\\nout float v_radius;\\nout vec2 v_extrude;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  float newSize = setPickingSize(a_Size);\\n\\n  float time = u_time * u_speed;\\n  mat2 rotateMatrix = mat2(\\n    cos(time), sin(time),\\n    -sin(time), cos(time)\\n  );\\n  v_extrude = rotateMatrix * a_Extrude.xy;\\n\\n  v_color = a_Color;\\n  v_color.a *= opacity;\\n\\n  float blur = 0.0;\\n  float antialiasblur = -max(2.0 / u_DevicePixelRatio / a_Size, blur);\\n\\n  if(u_size_unit == 1.) {\\n    newSize = newSize  * u_PixelsPerMeter.z;\\n  }\\n  v_radius = newSize;\\n\\n  vec2 offset = (a_Extrude.xy * (newSize));\\n\\n  offset = project_pixel(offset);\\n\\n  v_data = vec4(a_Extrude.x, a_Extrude.y, antialiasblur, -1.0);\\n\\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0.0, 1.0), a_Position64Low);\\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, project_pixel(setPickingOrder(0.0)), 1.0));\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\nexport default class RadarModel extends BaseModel {\n  get attributeLocation() {\n    return Object.assign(super.attributeLocation, {\n      MAX: super.attributeLocation.MAX,\n      SIZE: 9,\n      EXTRUDE: 10\n    });\n  }\n  getCommonUniformsInfo() {\n    const {\n      blend,\n      speed = 1,\n      unit = 'pixel'\n    } = this.layer.getLayerConfig();\n    const commonOptions = {\n      u_additive: blend === 'additive' ? 1.0 : 0.0,\n      u_size_unit: SizeUnitType[unit],\n      u_speed: speed,\n      u_time: this.layer.getLayerAnimateTime()\n    }; //1+1+1+1\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  getAnimateUniforms() {\n    return {};\n  }\n  getAttribute() {\n    return this.styleAttributeService.createAttributesAndIndices(this.layer.getEncodedData(), PointFillTriangulation);\n  }\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return _this.buildModels();\n    })();\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.initUniformsBuffer();\n      const model = yield _this2.layer.buildLayerModel({\n        moduleName: 'pointRadar',\n        vertexShader: pointFillVert,\n        fragmentShader: pointFillFrag,\n        triangulation: PointFillTriangulation,\n        defines: _this2.getDefines(),\n        inject: _this2.getInject(),\n        depth: {\n          enable: false\n        }\n      });\n      return [model];\n    })();\n  }\n\n  // overwrite baseModel func\n  animateOption2Array(option) {\n    return [option.enable ? 0 : 1.0, option.speed || 1, option.rings || 3, 0];\n  }\n  registerBuiltinAttributes() {\n    // 注册 Position 属性 64 位地位部分，经纬度数据开启双精度，避免大于 20层级以上出现数据偏移\n    this.registerPosition64LowAttribute();\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'extrude',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Extrude',\n        shaderLocation: this.attributeLocation.EXTRUDE,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        update: (feature, featureIdx, vertex, attributeIdx) => {\n          const extrude = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0];\n          const extrudeIndex = attributeIdx % 4 * 3;\n          return [extrude[extrudeIndex], extrude[extrudeIndex + 1], extrude[extrudeIndex + 2]];\n        }\n      }\n    });\n\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        shaderLocation: this.attributeLocation.SIZE,\n        name: 'a_Size',\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 1,\n        update: feature => {\n          const {\n            size = 5\n          } = feature;\n          return Array.isArray(size) ? [size[0]] : [size];\n        }\n      }\n    });\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}