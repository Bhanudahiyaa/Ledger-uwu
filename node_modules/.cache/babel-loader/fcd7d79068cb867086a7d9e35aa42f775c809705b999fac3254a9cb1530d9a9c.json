{"ast":null,"code":"import { StringExt, FunctionExt, Platform } from '../util';\nexport class Registry {\n  constructor(options) {\n    this.options = Object.assign({}, options);\n    this.data = this.options.data || {};\n    this.register = this.register.bind(this);\n    this.unregister = this.unregister.bind(this);\n  }\n  get names() {\n    return Object.keys(this.data);\n  }\n  register(name, options, force = false) {\n    if (typeof name === 'object') {\n      Object.keys(name).forEach(key => {\n        this.register(key, name[key], options);\n      });\n      return;\n    }\n    if (this.exist(name) && !force && !Platform.isApplyingHMR()) {\n      this.onDuplicated(name);\n    }\n    const process = this.options.process;\n    const entity = process ? FunctionExt.call(process, this, name, options) : options;\n    this.data[name] = entity;\n    return entity;\n  }\n  unregister(name) {\n    const entity = name ? this.data[name] : null;\n    delete this.data[name];\n    return entity;\n  }\n  get(name) {\n    return name ? this.data[name] : null;\n  }\n  exist(name) {\n    return name ? this.data[name] != null : false;\n  }\n  onDuplicated(name) {\n    // eslint-disable-next-line no-useless-catch\n    try {\n      // race\n      if (this.options.onConflict) {\n        FunctionExt.call(this.options.onConflict, this, name);\n      }\n      throw new Error(`${StringExt.upperFirst(this.options.type)} with name '${name}' already registered.`);\n    } catch (err) {\n      throw err;\n    }\n  }\n  onNotFound(name, prefix) {\n    throw new Error(this.getSpellingSuggestion(name, prefix));\n  }\n  getSpellingSuggestion(name, prefix) {\n    const suggestion = this.getSpellingSuggestionForName(name);\n    const prefixed = prefix ? `${prefix} ${StringExt.lowerFirst(this.options.type)}` : this.options.type;\n    return (\n      // eslint-disable-next-line\n      `${StringExt.upperFirst(prefixed)} with name '${name}' does not exist.${suggestion ? ` Did you mean '${suggestion}'?` : ''}`\n    );\n  }\n  getSpellingSuggestionForName(name) {\n    return StringExt.getSpellingSuggestion(name, Object.keys(this.data), candidate => candidate);\n  }\n}\n(function (Registry) {\n  function create(options) {\n    return new Registry(options);\n  }\n  Registry.create = create;\n})(Registry || (Registry = {}));","map":{"version":3,"names":["StringExt","FunctionExt","Platform","Registry","constructor","options","Object","assign","data","register","bind","unregister","names","keys","name","force","forEach","key","exist","isApplyingHMR","onDuplicated","process","entity","call","get","onConflict","Error","upperFirst","type","err","onNotFound","prefix","getSpellingSuggestion","suggestion","getSpellingSuggestionForName","prefixed","lowerFirst","candidate","create"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/registry/registry.ts"],"sourcesContent":["import { KeyValue } from '../types'\nimport { StringExt, FunctionExt, Platform } from '../util'\n\nexport class Registry<\n  Entity,\n  Presets = KeyValue<Entity>,\n  OptionalType = never,\n> {\n  public readonly data: KeyValue<Entity>\n  public readonly options: Registry.Options<Entity | OptionalType>\n\n  constructor(options: Registry.Options<Entity | OptionalType>) {\n    this.options = { ...options }\n    this.data = (this.options.data as KeyValue<Entity>) || {}\n    this.register = this.register.bind(this)\n    this.unregister = this.unregister.bind(this)\n  }\n\n  get names() {\n    return Object.keys(this.data)\n  }\n\n  register(\n    entities: { [name: string]: Entity | OptionalType },\n    force?: boolean,\n  ): void\n  register<K extends keyof Presets>(\n    name: K,\n    entity: Presets[K],\n    force?: boolean,\n  ): Entity\n  register(name: string, entity: Entity | OptionalType, force?: boolean): Entity\n  register(\n    name: string | { [name: string]: Entity | OptionalType },\n    options: any,\n    force = false,\n  ) {\n    if (typeof name === 'object') {\n      Object.keys(name).forEach((key) => {\n        this.register(key, name[key], options)\n      })\n      return\n    }\n\n    if (this.exist(name) && !force && !Platform.isApplyingHMR()) {\n      this.onDuplicated(name)\n    }\n\n    const process = this.options.process\n    const entity = process\n      ? FunctionExt.call(process, this as any, name, options)\n      : options\n\n    this.data[name] = entity\n\n    return entity\n  }\n\n  unregister<K extends keyof Presets>(name: K): Entity | null\n  unregister(name: string): Entity | null\n  unregister(name: string): Entity | null {\n    const entity = name ? this.data[name] : null\n    delete this.data[name]\n    return entity\n  }\n\n  get<K extends keyof Presets>(name: K): Entity | null\n  get(name: string): Entity | null\n  get(name: string): Entity | null {\n    return name ? this.data[name] : null\n  }\n\n  exist<K extends keyof Presets>(name: K): boolean\n  exist(name: string): boolean\n  exist(name: string): boolean {\n    return name ? this.data[name] != null : false\n  }\n\n  onDuplicated(name: string) {\n    // eslint-disable-next-line no-useless-catch\n    try {\n      // race\n      if (this.options.onConflict) {\n        FunctionExt.call(this.options.onConflict, this as any, name)\n      }\n      throw new Error(\n        `${StringExt.upperFirst(\n          this.options.type,\n        )} with name '${name}' already registered.`,\n      )\n    } catch (err) {\n      throw err\n    }\n  }\n\n  onNotFound(name: string, prefix?: string): never {\n    throw new Error(this.getSpellingSuggestion(name, prefix))\n  }\n\n  getSpellingSuggestion(name: string, prefix?: string) {\n    const suggestion = this.getSpellingSuggestionForName(name)\n    const prefixed = prefix\n      ? `${prefix} ${StringExt.lowerFirst(this.options.type)}`\n      : this.options.type\n\n    return (\n      // eslint-disable-next-line\n      `${StringExt.upperFirst(prefixed)} with name '${name}' does not exist.${\n        suggestion ? ` Did you mean '${suggestion}'?` : ''\n      }`\n    )\n  }\n\n  protected getSpellingSuggestionForName(name: string) {\n    return StringExt.getSpellingSuggestion(\n      name,\n      Object.keys(this.data),\n      (candidate) => candidate,\n    )\n  }\n}\n\nexport namespace Registry {\n  export interface Options<Entity> {\n    type: string\n    data?: KeyValue<Entity>\n    process?: <T, Context extends Registry<any>>(\n      this: Context,\n      name: string,\n      entity: Entity,\n    ) => T\n    onConflict?: <Context extends Registry<any>>(\n      this: Context,\n      name: string,\n    ) => void\n  }\n}\n\nexport namespace Registry {\n  export function create<\n    Entity,\n    Presets = KeyValue<Entity>,\n    OptionalType = never,\n  >(options: Options<Entity | OptionalType>) {\n    return new Registry<Entity, Presets, OptionalType>(options)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}