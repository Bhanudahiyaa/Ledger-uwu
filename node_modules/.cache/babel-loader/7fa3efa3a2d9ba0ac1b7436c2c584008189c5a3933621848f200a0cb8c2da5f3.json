{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Util } from '../global';\nimport { ObjectExt } from '../util';\nimport { Edge as StandardEdge } from '../shape/standard/edge';\nexport var Options;\n(function (Options) {\n  function parseOptionGroup(graph, arg, options) {\n    const result = {};\n    Object.keys(options || {}).forEach(key => {\n      const val = options[key];\n      result[key] = typeof val === 'function' ? val.call(graph, arg) : val;\n    });\n    return result;\n  }\n  Options.parseOptionGroup = parseOptionGroup;\n})(Options || (Options = {}));\n(function (Options) {\n  function get(options) {\n    const {\n        grid,\n        panning,\n        selecting,\n        embedding,\n        snapline,\n        resizing,\n        rotating,\n        knob,\n        clipboard,\n        history,\n        scroller,\n        minimap,\n        keyboard,\n        mousewheel\n      } = options,\n      others = __rest(options\n      // size\n      // ----\n      , [\"grid\", \"panning\", \"selecting\", \"embedding\", \"snapline\", \"resizing\", \"rotating\", \"knob\", \"clipboard\", \"history\", \"scroller\", \"minimap\", \"keyboard\", \"mousewheel\"]);\n    // size\n    // ----\n    const container = options.container;\n    if (container != null) {\n      if (others.width == null) {\n        others.width = container.clientWidth;\n      }\n      if (others.height == null) {\n        others.height = container.clientHeight;\n      }\n    } else {\n      throw new Error(`Ensure the container of the graph is specified and valid`);\n    }\n    const result = ObjectExt.merge({}, Options.defaults, others);\n    // grid\n    // ----\n    const defaultGrid = {\n      size: 10,\n      visible: false\n    };\n    if (typeof grid === 'number') {\n      result.grid = {\n        size: grid,\n        visible: false\n      };\n    } else if (typeof grid === 'boolean') {\n      result.grid = Object.assign(Object.assign({}, defaultGrid), {\n        visible: grid\n      });\n    } else {\n      result.grid = Object.assign(Object.assign({}, defaultGrid), grid);\n    }\n    // booleas\n    // -------\n    const booleas = ['panning', 'selecting', 'embedding', 'snapline', 'resizing', 'rotating', 'knob', 'clipboard', 'history', 'scroller', 'minimap', 'keyboard', 'mousewheel'];\n    booleas.forEach(key => {\n      const val = options[key];\n      if (typeof val === 'boolean') {\n        result[key].enabled = val;\n      } else {\n        result[key] = Object.assign(Object.assign({}, result[key]), val);\n      }\n    });\n    // background\n    // ----------\n    if (result.background && result.scroller.enabled && result.scroller.background == null) {\n      result.scroller.background = result.background;\n      delete result.background;\n    }\n    return result;\n  }\n  Options.get = get;\n})(Options || (Options = {}));\n(function (Options) {\n  Options.defaults = {\n    x: 0,\n    y: 0,\n    grid: {\n      size: 10,\n      visible: false\n    },\n    scaling: {\n      min: 0.01,\n      max: 16\n    },\n    background: false,\n    highlighting: {\n      default: {\n        name: 'stroke',\n        args: {\n          padding: 3\n        }\n      },\n      nodeAvailable: {\n        name: 'className',\n        args: {\n          className: Util.prefix('available-node')\n        }\n      },\n      magnetAvailable: {\n        name: 'className',\n        args: {\n          className: Util.prefix('available-magnet')\n        }\n      }\n    },\n    connecting: {\n      snap: false,\n      multi: true,\n      // TODO: Unannotation the next line when the `multi` option was removed in the next major version.\n      // allowMulti: true,\n      dangling: true,\n      // TODO: Unannotation the next line when the `dangling` option was removed in the next major version.\n      // allowBlank: true,\n      allowLoop: true,\n      allowNode: true,\n      allowEdge: false,\n      allowPort: true,\n      highlight: false,\n      anchor: 'center',\n      edgeAnchor: 'ratio',\n      connectionPoint: 'boundary',\n      strategy: null,\n      router: 'normal',\n      connector: 'normal',\n      validateConnection({\n        type,\n        sourceView,\n        targetView\n      }) {\n        const view = type === 'target' ? targetView : sourceView;\n        return view != null;\n      },\n      createEdge() {\n        return new StandardEdge();\n      }\n    },\n    transforming: {\n      clearAll: true,\n      clearOnBlankMouseDown: true\n    },\n    resizing: {\n      enabled: false,\n      minWidth: 0,\n      minHeight: 0,\n      maxWidth: Number.MAX_SAFE_INTEGER,\n      maxHeight: Number.MAX_SAFE_INTEGER,\n      orthogonal: true,\n      restricted: false,\n      autoScroll: true,\n      preserveAspectRatio: false,\n      allowReverse: true\n    },\n    rotating: {\n      enabled: false,\n      grid: 15\n    },\n    translating: {\n      restrict: false\n    },\n    knob: {\n      enabled: false,\n      clearAll: true,\n      clearOnBlankMouseDown: true\n    },\n    embedding: {\n      enabled: false,\n      findParent: 'bbox',\n      frontOnly: true,\n      validate: () => true\n    },\n    selecting: {\n      enabled: false,\n      rubberband: false,\n      rubberNode: true,\n      rubberEdge: false,\n      pointerEvents: 'auto',\n      multiple: true,\n      multipleSelectionModifiers: ['ctrl', 'meta'],\n      movable: true,\n      strict: false,\n      useCellGeometry: false,\n      selectCellOnMoved: false,\n      selectNodeOnMoved: false,\n      selectEdgeOnMoved: false,\n      content: null,\n      handles: null\n    },\n    panning: {\n      enabled: false,\n      eventTypes: ['leftMouseDown']\n    },\n    snapline: {\n      enabled: false\n    },\n    clipboard: {\n      enabled: false\n    },\n    history: {\n      enabled: false\n    },\n    scroller: {\n      enabled: false\n    },\n    keyboard: {\n      enabled: false\n    },\n    mousewheel: {\n      enabled: false,\n      factor: 1.2,\n      zoomAtMousePosition: true\n    },\n    async: false,\n    frozen: false,\n    sorting: 'exact',\n    moveThreshold: 0,\n    clickThreshold: 0,\n    magnetThreshold: 0,\n    preventDefaultDblClick: true,\n    preventDefaultMouseDown: false,\n    preventDefaultContextMenu: true,\n    preventDefaultBlankAction: true,\n    interacting: {\n      edgeLabelMovable: false\n    },\n    guard: () => false\n  };\n})(Options || (Options = {}));","map":{"version":3,"names":["Util","ObjectExt","Edge","StandardEdge","Options","parseOptionGroup","graph","arg","options","result","Object","keys","forEach","key","val","call","get","grid","panning","selecting","embedding","snapline","resizing","rotating","knob","clipboard","history","scroller","minimap","keyboard","mousewheel","others","__rest","container","width","clientWidth","height","clientHeight","Error","merge","defaults","defaultGrid","size","visible","assign","booleas","enabled","background","x","y","scaling","min","max","highlighting","default","name","args","padding","nodeAvailable","className","prefix","magnetAvailable","connecting","snap","multi","dangling","allowLoop","allowNode","allowEdge","allowPort","highlight","anchor","edgeAnchor","connectionPoint","strategy","router","connector","validateConnection","type","sourceView","targetView","view","createEdge","transforming","clearAll","clearOnBlankMouseDown","minWidth","minHeight","maxWidth","Number","MAX_SAFE_INTEGER","maxHeight","orthogonal","restricted","autoScroll","preserveAspectRatio","allowReverse","translating","restrict","findParent","frontOnly","validate","rubberband","rubberNode","rubberEdge","pointerEvents","multiple","multipleSelectionModifiers","movable","strict","useCellGeometry","selectCellOnMoved","selectNodeOnMoved","selectEdgeOnMoved","content","handles","eventTypes","factor","zoomAtMousePosition","async","frozen","sorting","moveThreshold","clickThreshold","magnetThreshold","preventDefaultDblClick","preventDefaultMouseDown","preventDefaultContextMenu","preventDefaultBlankAction","interacting","edgeLabelMovable","guard"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/graph/options.ts"],"sourcesContent":["import { Util } from '../global'\nimport { ObjectExt } from '../util'\nimport { Rectangle } from '../geometry'\nimport { Nilable, KeyValue } from '../types'\nimport { Cell, Edge, Node, Model } from '../model'\nimport { CellView, NodeView, EdgeView } from '../view'\nimport { Edge as StandardEdge } from '../shape/standard/edge'\nimport {\n  Router,\n  Connector,\n  NodeAnchor,\n  EdgeAnchor,\n  ConnectionPoint,\n  ConnectionStrategy,\n} from '../registry'\nimport { Widget } from '../addon/common'\nimport { Hook } from './hook'\nimport { Graph } from './graph'\nimport { GraphView } from './view'\nimport { GridManager } from './grid'\nimport { HistoryManager } from './history'\nimport { PanningManager } from './panning'\nimport { SnaplineManager } from './snapline'\nimport { ScrollerManager } from './scroller'\nimport { SelectionManager } from './selection'\nimport { ClipboardManager } from './clipboard'\nimport { HighlightManager } from './highlight'\nimport { BackgroundManager } from './background'\nimport { MiniMapManager } from './minimap'\nimport { Keyboard } from './keyboard'\nimport { MouseWheel } from './mousewheel'\nimport { Renderer } from './renderer'\n\nexport namespace Options {\n  interface Common extends Partial<Hook.IHook> {\n    container: HTMLElement\n    model?: Model\n\n    x: number\n    y: number\n    width: number\n    height: number\n    autoResize?: boolean | Element | Document\n\n    background?: false | BackgroundManager.Options\n\n    scaling: {\n      min?: number\n      max?: number\n    }\n\n    /**\n     * The sorting type to use when rendering the views in this graph.\n     *\n     * - `exact` - render views according to their z-index. Views with\n     *   different z-index are rendered in order, and views with the\n     *   same z-index are rendered in the order in which they were added.\n     *   This is by far the slowest option, present mainly for backwards\n     *   compatibility.\n     *\n     * - `approx` - render views according to their z-index. Views with\n     *   different z-index are rendered in order, but the ordering of views\n     *   with the same z-index is indeterminate. Similar in functionality\n     *   to the `exact` option, but much faster.\n     *\n     * - `none` - render views in an indeterminate order. (Note that this\n     *   setting disables `toFront`/`toBack` methods.)\n     */\n    sorting: GraphView.SortType\n\n    /**\n     * Specify if the grapg uses asynchronous rendering to display cells.\n     * This is very useful for adding a large number of cells into the graph.\n     * The rendering performance boost is significant and it doesn't block\n     * the UI. However, asynchronous rendering brings about some caveats:\n     *\n     * - The views of freshly added cells may not have yet been added to\n     *   this graph's DOM.\n     * - Some views may have been removed from the DOM by\n     *   `graph.options.checkView` function.\n     * - Views already present in the DOM may not have been updated to\n     *   reflect changes made in this graph since the last render.\n     *\n     * For the methods that truly need a to refer to a CellView, one way to\n     * prevent inconsistencies is to rely on the 'render:done' graph event.\n     * This event signals that all scheduled updates are done and that the\n     * state of cell views is consistent with the state of the cell models.\n     *\n     * Alternatively, you may trigger a manual update immediately before a\n     * sensitive function call:\n     *\n     * - `graph.renderer.requireView()` - bring a single view into the DOM\n     *    and update it.\n     * - `graph.renderer.dumpViews()` - bring all views into the DOM and\n     *    update them.\n     * - `graph.renderer.updateViews()` - update all views.\n     */\n    async: boolean\n\n    frozen: boolean\n\n    /**\n     * A callback function that is used to determine whether a given view\n     * should be shown in an `async` graph. If the function returns `true`,\n     * the view is attached to the DOM; if it returns `false`, the view is\n     * detached from the DOM.\n     */\n    checkView?: Nilable<Renderer.CheckViewFn>\n\n    /**\n     * When defined as a number, it denotes the required mousemove events\n     * before a new edge is created from a magnet. When defined as keyword\n     * 'onleave', the edge is created when the pointer leaves the magnet\n     * DOM element.\n     */\n    magnetThreshold: number | 'onleave'\n\n    /**\n     * Number of required mousemove events before the first mousemove\n     * event will be triggered.\n     */\n    moveThreshold: number\n\n    /**\n     * Allowed number of mousemove events after which the click event\n     * will be still triggered.\n     */\n    clickThreshold: number\n\n    /**\n     * Prevent the default context menu from being displayed.\n     */\n    preventDefaultContextMenu:\n      | boolean\n      | ((this: Graph, { view }: { view: CellView | null }) => boolean)\n\n    preventDefaultDblClick: boolean\n\n    preventDefaultMouseDown: boolean\n\n    /**\n     * Prevents default action when an empty graph area is clicked.\n     * Setting the option to `false` will make the graph pannable\n     * inside a container on touch devices.\n     *\n     * It defaults to `true`.\n     */\n    preventDefaultBlankAction: boolean\n\n    interacting: CellView.Interacting\n\n    /**\n     * Guard the graph from handling a UI event. Returns `true` if you want\n     * to prevent the graph from handling the event evt, `false` otherwise.\n     * This is an advanced option that can be useful if you have your own\n     * logic for handling events.\n     */\n    guard: (e: JQuery.TriggeredEvent, view?: CellView | null) => boolean\n  }\n\n  export interface ManualBooleans {\n    rotating: boolean | Partial<Rotating>\n    resizing: boolean | Partial<Resizing>\n    embedding: boolean | Partial<Embedding>\n    selecting: boolean | Partial<SelectionManager.Options>\n    snapline: boolean | Partial<SnaplineManager.Options>\n    panning: boolean | Partial<PanningManager.Options>\n    clipboard: boolean | Partial<ClipboardManager.Options>\n    history: boolean | Partial<HistoryManager.CommonOptions>\n    scroller: boolean | Partial<ScrollerManager.Options>\n    minimap: boolean | Partial<MiniMapManager.Options>\n    keyboard: boolean | Partial<Omit<Keyboard.Options, 'graph'>>\n    mousewheel: boolean | Partial<Omit<MouseWheel.Options, 'graph'>>\n    knob: boolean | Partial<Knob>\n  }\n\n  export interface Manual extends Partial<Common>, Partial<ManualBooleans> {\n    grid?:\n      | boolean\n      | number\n      | (Partial<GridManager.CommonOptions> & GridManager.DrawGridOptions)\n    connecting?: Partial<Connecting>\n    translating?: Partial<Translating>\n    transforming?: Partial<Transforming>\n    highlighting?: Partial<Highlighting>\n  }\n\n  export interface Definition extends Common {\n    grid: GridManager.Options\n    connecting: Connecting\n    rotating: Rotating\n    resizing: Resizing\n    translating: Translating\n    transforming: Transforming\n    highlighting: Highlighting\n    embedding: Embedding\n    panning: PanningManager.Options\n    selecting: SelectionManager.Options\n    snapline: SnaplineManager.Options\n    clipboard: ClipboardManager.Options\n    history: HistoryManager.CommonOptions\n    scroller: ScrollerManager.Options\n    minimap: MiniMapManager.Options\n    keyboard: Omit<Keyboard.Options, 'graph'>\n    mousewheel: Omit<MouseWheel.Options, 'graph'>\n    knob: Knob\n  }\n}\n\nexport namespace Options {\n  type OptionItem<T, S> = S | ((this: Graph, arg: T) => S)\n\n  export function parseOptionGroup<\n    K extends KeyValue,\n    S extends KeyValue = KeyValue,\n    T = any,\n  >(graph: Graph, arg: T, options: S): K {\n    const result: any = {}\n    Object.keys(options || {}).forEach((key) => {\n      const val = options[key]\n      result[key] = typeof val === 'function' ? val.call(graph, arg) : val\n    })\n    return result\n  }\n\n  type NodeAnchorOptions =\n    | string\n    | NodeAnchor.NativeItem\n    | NodeAnchor.ManaualItem\n  type EdgeAnchorOptions =\n    | string\n    | EdgeAnchor.NativeItem\n    | EdgeAnchor.ManaualItem\n  type ConnectionPointOptions =\n    | string\n    | ConnectionPoint.NativeItem\n    | ConnectionPoint.ManaualItem\n\n  export interface Connecting {\n    /**\n     * Snap edge to the closest node/port in the given radius on dragging.\n     */\n    snap: boolean | { radius: number }\n\n    /**\n     * @deprecated\n     * When set to `false`, edges can not be pinned to the graph meaning a\n     * source/target of a edge can be a point on the graph.\n     */\n    dangling:\n      | boolean\n      | ((\n          this: Graph,\n          args: {\n            edge: Edge\n            sourceCell?: Cell | null\n            targetCell?: Cell | null\n            sourcePort?: string\n            targetPort?: string\n          },\n        ) => boolean)\n\n    /**\n     * @deprecated\n     * When set to `false`, an node may not have more than one edge with the\n     * same source and target node.\n     */\n    multi:\n      | boolean\n      | ((\n          this: Graph,\n          args: {\n            edge: Edge\n            sourceCell?: Cell | null\n            targetCell?: Cell | null\n            sourcePort?: string\n            targetPort?: string\n          },\n        ) => boolean)\n\n    /**\n     * Specify whether connect to point on the graph is allowed.\n     */\n    allowBlank?:\n      | boolean\n      | ((this: Graph, args: ValidateConnectionArgs) => boolean)\n\n    /**\n     * When set to `false`, edges can not be connected to the same node,\n     * meaning the source and target of the edge can not be the same node.\n     */\n    allowLoop:\n      | boolean\n      | ((this: Graph, args: ValidateConnectionArgs) => boolean)\n\n    /**\n     * Specify whether connect to node(not the port on the node) is allowed.\n     */\n    allowNode:\n      | boolean\n      | ((this: Graph, args: ValidateConnectionArgs) => boolean)\n\n    /**\n     * Specify whether connect to edge is allowed.\n     */\n    allowEdge:\n      | boolean\n      | ((this: Graph, args: ValidateConnectionArgs) => boolean)\n\n    /**\n     * Specify whether connect to port is allowed.\n     */\n    allowPort:\n      | boolean\n      | ((this: Graph, args: ValidateConnectionArgs) => boolean)\n\n    /**\n     * Specify whether more than one edge connected to the same source and\n     * target node is allowed.\n     */\n    allowMulti?:\n      | boolean\n      | 'withPort'\n      | ((this: Graph, args: ValidateConnectionArgs) => boolean)\n\n    /**\n     * Highlights all the available magnets or nodes when a edge is\n     * dragging(reconnecting). This gives a hint to the user to what\n     * other nodes/ports this edge can be connected. What magnets/cells\n     * are available is determined by the `validateConnection` function.\n     */\n    highlight: boolean\n\n    anchor: NodeAnchorOptions\n    sourceAnchor?: NodeAnchorOptions\n    targetAnchor?: NodeAnchorOptions\n    edgeAnchor: EdgeAnchorOptions\n    sourceEdgeAnchor?: EdgeAnchorOptions\n    targetEdgeAnchor?: EdgeAnchorOptions\n\n    connectionPoint: ConnectionPointOptions\n    sourceConnectionPoint?: ConnectionPointOptions\n    targetConnectionPoint?: ConnectionPointOptions\n\n    router: string | Router.NativeItem | Router.ManaualItem\n    connector: string | Connector.NativeItem | Connector.ManaualItem\n    strategy?:\n      | string\n      | ConnectionStrategy.NativeItem\n      | ConnectionPoint.ManaualItem\n      | null\n\n    /**\n     * Check whether to add a new edge to the graph when user clicks\n     * on an a magnet.\n     */\n    validateMagnet?: (\n      this: Graph,\n      args: {\n        cell: Cell\n        view: CellView\n        magnet: Element\n        e: JQuery.MouseDownEvent | JQuery.MouseEnterEvent\n      },\n    ) => boolean\n\n    createEdge?: (\n      this: Graph,\n      args: {\n        sourceCell: Cell\n        sourceView: CellView\n        sourceMagnet: Element\n      },\n    ) => Nilable<Edge> | void\n\n    /**\n     * Custom validation on stop draggin the edge arrowhead(source/target).\n     * If the function returns `false`, the edge is either removed(edges\n     * which are created during the interaction) or reverted to the state\n     * before the interaction.\n     */\n    validateEdge?: (\n      this: Graph,\n      args: {\n        edge: Edge\n        type: Edge.TerminalType\n        previous: Edge.TerminalData\n      },\n    ) => boolean\n\n    /**\n     * Check whether to allow or disallow the edge connection while an\n     * arrowhead end (source/target) being changed.\n     */\n    validateConnection: (this: Graph, args: ValidateConnectionArgs) => boolean\n  }\n\n  export interface ValidateConnectionArgs {\n    type?: Edge.TerminalType | null\n    edge?: Edge | null\n    edgeView?: EdgeView | null\n    sourceCell?: Cell | null\n    targetCell?: Cell | null\n    sourceView?: CellView | null\n    targetView?: CellView | null\n    sourcePort?: string | null\n    targetPort?: string | null\n    sourceMagnet?: Element | null\n    targetMagnet?: Element | null\n  }\n\n  export interface TransformingRaw extends Widget.Options {}\n\n  export type Transforming = {\n    [K in keyof TransformingRaw]?: OptionItem<Node, TransformingRaw[K]>\n  }\n\n  export interface KnobRaw extends Widget.Options {\n    enabled?: boolean\n  }\n\n  export type Knob = {\n    [K in keyof KnobRaw]?: OptionItem<Node, KnobRaw[K]>\n  }\n\n  export interface Translating {\n    /**\n     * Restrict the translation (movement) of nodes by a given bounding box.\n     * If set to `true`, the user will not be able to move nodes outside the\n     * boundary of the graph area.\n     */\n    restrict:\n      | boolean\n      | OptionItem<CellView, Rectangle.RectangleLike | number | null>\n  }\n\n  export interface RotatingRaw {\n    enabled?: boolean\n    grid?: number\n  }\n\n  export type Rotating = {\n    [K in keyof RotatingRaw]?: OptionItem<Node, RotatingRaw[K]>\n  }\n\n  export interface ResizingRaw {\n    enabled?: boolean\n    minWidth?: number\n    maxWidth?: number\n    minHeight?: number\n    maxHeight?: number\n    orthogonal?: boolean\n    restrict?: boolean | number\n    /**\n     * **Deprecation Notice:** resizing option `restricted` is deprecated and\n     * will be moved in next major release. Use `restrict` instead.\n     *\n     * @deprecated\n     */\n    restricted?: boolean | number\n    autoScroll?: boolean\n    preserveAspectRatio?: boolean\n    allowReverse?: boolean\n  }\n\n  export type Resizing = {\n    [K in keyof ResizingRaw]?: OptionItem<Node, ResizingRaw[K]>\n  }\n\n  export interface Embedding {\n    enabled?: boolean\n\n    /**\n     * Determines the way how a cell finds a suitable parent when it's dragged\n     * over the graph. The cell with the highest z-index (visually on the top)\n     * will be chosen.\n     */\n    findParent?:\n      | 'bbox'\n      | 'center'\n      | 'topLeft'\n      | 'topRight'\n      | 'bottomLeft'\n      | 'bottomRight'\n      | ((this: Graph, args: { node: Node; view: NodeView }) => Cell[])\n\n    /**\n     * If enabled only the node on the very front is taken into account for the\n     * embedding. If disabled the nodes under the dragged view are tested one by\n     * one (from front to back) until a valid parent found.\n     */\n    frontOnly?: boolean\n\n    /**\n     * Check whether to allow or disallow the node embedding while it's being\n     * translated. By default, all nodes can be embedded into all other nodes.\n     */\n    validate: (\n      this: Graph,\n      args: {\n        child: Node\n        parent: Node\n        childView: CellView\n        parentView: CellView\n      },\n    ) => boolean\n  }\n\n  /**\n   * Configure which highlighter to use (and with which options) for\n   * each type of interaction.\n   */\n  export interface Highlighting {\n    /**\n     * The default highlighter to use (and options) when none is specified\n     */\n    default: HighlightManager.Options\n    /**\n     * When a cell is dragged over another cell in embedding mode.\n     */\n    embedding?: HighlightManager.Options | null\n    /**\n     * When showing all nodes to which a valid connection can be made.\n     */\n    nodeAvailable?: HighlightManager.Options | null\n    /**\n     * When showing all magnets to which a valid connection can be made.\n     */\n    magnetAvailable?: HighlightManager.Options | null\n    /**\n     * When a valid edge connection can be made to an node.\n     */\n    magnetAdsorbed?: HighlightManager.Options | null\n  }\n}\n\nexport namespace Options {\n  export function get(options: Partial<Manual>) {\n    const {\n      grid,\n      panning,\n      selecting,\n      embedding,\n      snapline,\n      resizing,\n      rotating,\n      knob,\n      clipboard,\n      history,\n      scroller,\n      minimap,\n      keyboard,\n      mousewheel,\n      ...others\n    } = options\n\n    // size\n    // ----\n    const container = options.container\n    if (container != null) {\n      if (others.width == null) {\n        others.width = container.clientWidth\n      }\n\n      if (others.height == null) {\n        others.height = container.clientHeight\n      }\n    } else {\n      throw new Error(\n        `Ensure the container of the graph is specified and valid`,\n      )\n    }\n\n    const result = ObjectExt.merge({}, defaults, others) as Options.Definition\n\n    // grid\n    // ----\n    const defaultGrid: GridManager.CommonOptions = { size: 10, visible: false }\n    if (typeof grid === 'number') {\n      result.grid = { size: grid, visible: false }\n    } else if (typeof grid === 'boolean') {\n      result.grid = { ...defaultGrid, visible: grid }\n    } else {\n      result.grid = { ...defaultGrid, ...grid }\n    }\n\n    // booleas\n    // -------\n    const booleas: (keyof Options.ManualBooleans)[] = [\n      'panning',\n      'selecting',\n      'embedding',\n      'snapline',\n      'resizing',\n      'rotating',\n      'knob',\n      'clipboard',\n      'history',\n      'scroller',\n      'minimap',\n      'keyboard',\n      'mousewheel',\n    ]\n\n    booleas.forEach((key) => {\n      const val = options[key]\n      if (typeof val === 'boolean') {\n        result[key].enabled = val\n      } else {\n        result[key] = {\n          ...result[key],\n          ...(val as any),\n        }\n      }\n    })\n\n    // background\n    // ----------\n    if (\n      result.background &&\n      result.scroller.enabled &&\n      result.scroller.background == null\n    ) {\n      result.scroller.background = result.background\n      delete result.background\n    }\n\n    return result\n  }\n}\n\nexport namespace Options {\n  export const defaults: Partial<Definition> = {\n    x: 0,\n    y: 0,\n    grid: {\n      size: 10,\n      visible: false,\n    },\n    scaling: {\n      min: 0.01,\n      max: 16,\n    },\n    background: false,\n    highlighting: {\n      default: {\n        name: 'stroke',\n        args: {\n          padding: 3,\n        },\n      },\n      nodeAvailable: {\n        name: 'className',\n        args: {\n          className: Util.prefix('available-node'),\n        },\n      },\n      magnetAvailable: {\n        name: 'className',\n        args: {\n          className: Util.prefix('available-magnet'),\n        },\n      },\n    },\n    connecting: {\n      snap: false,\n      multi: true,\n      // TODO: Unannotation the next line when the `multi` option was removed in the next major version.\n      // allowMulti: true,\n      dangling: true,\n      // TODO: Unannotation the next line when the `dangling` option was removed in the next major version.\n      // allowBlank: true,\n      allowLoop: true,\n      allowNode: true,\n      allowEdge: false,\n      allowPort: true,\n      highlight: false,\n\n      anchor: 'center',\n      edgeAnchor: 'ratio',\n      connectionPoint: 'boundary',\n      strategy: null,\n      router: 'normal',\n      connector: 'normal',\n\n      validateConnection(this: Graph, { type, sourceView, targetView }) {\n        const view = type === 'target' ? targetView : sourceView\n        return view != null\n      },\n\n      createEdge() {\n        return new StandardEdge()\n      },\n    },\n    transforming: {\n      clearAll: true,\n      clearOnBlankMouseDown: true,\n    },\n    resizing: {\n      enabled: false,\n      minWidth: 0,\n      minHeight: 0,\n      maxWidth: Number.MAX_SAFE_INTEGER,\n      maxHeight: Number.MAX_SAFE_INTEGER,\n      orthogonal: true,\n      restricted: false,\n      autoScroll: true,\n      preserveAspectRatio: false,\n      allowReverse: true,\n    },\n    rotating: {\n      enabled: false,\n      grid: 15,\n    },\n    translating: {\n      restrict: false,\n    },\n    knob: {\n      enabled: false,\n      clearAll: true,\n      clearOnBlankMouseDown: true,\n    },\n    embedding: {\n      enabled: false,\n      findParent: 'bbox',\n      frontOnly: true,\n      validate: () => true,\n    },\n    selecting: {\n      enabled: false,\n      rubberband: false,\n      rubberNode: true,\n      rubberEdge: false, // next version will set to true\n      pointerEvents: 'auto',\n      multiple: true,\n      multipleSelectionModifiers: ['ctrl', 'meta'],\n      movable: true,\n      strict: false,\n      useCellGeometry: false,\n      selectCellOnMoved: false,\n      selectNodeOnMoved: false,\n      selectEdgeOnMoved: false,\n      content: null,\n      handles: null,\n    },\n    panning: {\n      enabled: false,\n      eventTypes: ['leftMouseDown'],\n    },\n    snapline: {\n      enabled: false,\n    },\n    clipboard: {\n      enabled: false,\n    },\n    history: {\n      enabled: false,\n    },\n    scroller: {\n      enabled: false,\n    },\n    keyboard: {\n      enabled: false,\n    },\n    mousewheel: {\n      enabled: false,\n      factor: 1.2,\n      zoomAtMousePosition: true,\n    },\n\n    async: false,\n    frozen: false,\n    sorting: 'exact',\n\n    moveThreshold: 0,\n    clickThreshold: 0,\n    magnetThreshold: 0,\n    preventDefaultDblClick: true,\n    preventDefaultMouseDown: false,\n    preventDefaultContextMenu: true,\n    preventDefaultBlankAction: true,\n    interacting: {\n      edgeLabelMovable: false,\n    },\n    guard: () => false,\n  }\n}\n"],"mappings":";;;;;;;;AAAA,SAASA,IAAI,QAAQ,WAAW;AAChC,SAASC,SAAS,QAAQ,SAAS;AAKnC,SAASC,IAAI,IAAIC,YAAY,QAAQ,wBAAwB;AA2M7D,OAAM,IAAWC,OAAO;AAAxB,WAAiBA,OAAO;EAGtB,SAAgBC,gBAAgBA,CAI9BC,KAAY,EAAEC,GAAM,EAAEC,OAAU;IAChC,MAAMC,MAAM,GAAQ,EAAE;IACtBC,MAAM,CAACC,IAAI,CAACH,OAAO,IAAI,EAAE,CAAC,CAACI,OAAO,CAAEC,GAAG,IAAI;MACzC,MAAMC,GAAG,GAAGN,OAAO,CAACK,GAAG,CAAC;MACxBJ,MAAM,CAACI,GAAG,CAAC,GAAG,OAAOC,GAAG,KAAK,UAAU,GAAGA,GAAG,CAACC,IAAI,CAACT,KAAK,EAAEC,GAAG,CAAC,GAAGO,GAAG;IACtE,CAAC,CAAC;IACF,OAAOL,MAAM;EACf;EAXgBL,OAAA,CAAAC,gBAAgB,GAAAA,gBAW/B;AAuTH,CAAC,EArUgBD,OAAO,KAAPA,OAAO;AAuUxB,WAAiBA,OAAO;EACtB,SAAgBY,GAAGA,CAACR,OAAwB;IAC1C,MAAM;QACJS,IAAI;QACJC,OAAO;QACPC,SAAS;QACTC,SAAS;QACTC,QAAQ;QACRC,QAAQ;QACRC,QAAQ;QACRC,IAAI;QACJC,SAAS;QACTC,OAAO;QACPC,QAAQ;QACRC,OAAO;QACPC,QAAQ;QACRC;MAAU,IAERtB,OAAO;MADNuB,MAAM,GAAAC,MAAA,CACPxB;MAEJ;MACA;MAAA,EAnBM,kKAgBL,CAAU;IAEX;IACA;IACA,MAAMyB,SAAS,GAAGzB,OAAO,CAACyB,SAAS;IACnC,IAAIA,SAAS,IAAI,IAAI,EAAE;MACrB,IAAIF,MAAM,CAACG,KAAK,IAAI,IAAI,EAAE;QACxBH,MAAM,CAACG,KAAK,GAAGD,SAAS,CAACE,WAAW;;MAGtC,IAAIJ,MAAM,CAACK,MAAM,IAAI,IAAI,EAAE;QACzBL,MAAM,CAACK,MAAM,GAAGH,SAAS,CAACI,YAAY;;KAEzC,MAAM;MACL,MAAM,IAAIC,KAAK,CACb,0DAA0D,CAC3D;;IAGH,MAAM7B,MAAM,GAAGR,SAAS,CAACsC,KAAK,CAAC,EAAE,EAAEnC,OAAA,CAAAoC,QAAQ,EAAET,MAAM,CAAuB;IAE1E;IACA;IACA,MAAMU,WAAW,GAA8B;MAAEC,IAAI,EAAE,EAAE;MAAEC,OAAO,EAAE;IAAK,CAAE;IAC3E,IAAI,OAAO1B,IAAI,KAAK,QAAQ,EAAE;MAC5BR,MAAM,CAACQ,IAAI,GAAG;QAAEyB,IAAI,EAAEzB,IAAI;QAAE0B,OAAO,EAAE;MAAK,CAAE;KAC7C,MAAM,IAAI,OAAO1B,IAAI,KAAK,SAAS,EAAE;MACpCR,MAAM,CAACQ,IAAI,GAAAP,MAAA,CAAAkC,MAAA,CAAAlC,MAAA,CAAAkC,MAAA,KAAQH,WAAW;QAAEE,OAAO,EAAE1B;MAAI,EAAE;KAChD,MAAM;MACLR,MAAM,CAACQ,IAAI,GAAAP,MAAA,CAAAkC,MAAA,CAAAlC,MAAA,CAAAkC,MAAA,KAAQH,WAAW,GAAKxB,IAAI,CAAE;;IAG3C;IACA;IACA,MAAM4B,OAAO,GAAqC,CAChD,SAAS,EACT,WAAW,EACX,WAAW,EACX,UAAU,EACV,UAAU,EACV,UAAU,EACV,MAAM,EACN,WAAW,EACX,SAAS,EACT,UAAU,EACV,SAAS,EACT,UAAU,EACV,YAAY,CACb;IAEDA,OAAO,CAACjC,OAAO,CAAEC,GAAG,IAAI;MACtB,MAAMC,GAAG,GAAGN,OAAO,CAACK,GAAG,CAAC;MACxB,IAAI,OAAOC,GAAG,KAAK,SAAS,EAAE;QAC5BL,MAAM,CAACI,GAAG,CAAC,CAACiC,OAAO,GAAGhC,GAAG;OAC1B,MAAM;QACLL,MAAM,CAACI,GAAG,CAAC,GAAAH,MAAA,CAAAkC,MAAA,CAAAlC,MAAA,CAAAkC,MAAA,KACNnC,MAAM,CAACI,GAAG,CAAC,GACVC,GAAW,CAChB;;IAEL,CAAC,CAAC;IAEF;IACA;IACA,IACEL,MAAM,CAACsC,UAAU,IACjBtC,MAAM,CAACkB,QAAQ,CAACmB,OAAO,IACvBrC,MAAM,CAACkB,QAAQ,CAACoB,UAAU,IAAI,IAAI,EAClC;MACAtC,MAAM,CAACkB,QAAQ,CAACoB,UAAU,GAAGtC,MAAM,CAACsC,UAAU;MAC9C,OAAOtC,MAAM,CAACsC,UAAU;;IAG1B,OAAOtC,MAAM;EACf;EA3FgBL,OAAA,CAAAY,GAAG,GAAAA,GA2FlB;AACH,CAAC,EA7FgBZ,OAAO,KAAPA,OAAO;AA+FxB,WAAiBA,OAAO;EACTA,OAAA,CAAAoC,QAAQ,GAAwB;IAC3CQ,CAAC,EAAE,CAAC;IACJC,CAAC,EAAE,CAAC;IACJhC,IAAI,EAAE;MACJyB,IAAI,EAAE,EAAE;MACRC,OAAO,EAAE;KACV;IACDO,OAAO,EAAE;MACPC,GAAG,EAAE,IAAI;MACTC,GAAG,EAAE;KACN;IACDL,UAAU,EAAE,KAAK;IACjBM,YAAY,EAAE;MACZC,OAAO,EAAE;QACPC,IAAI,EAAE,QAAQ;QACdC,IAAI,EAAE;UACJC,OAAO,EAAE;;OAEZ;MACDC,aAAa,EAAE;QACbH,IAAI,EAAE,WAAW;QACjBC,IAAI,EAAE;UACJG,SAAS,EAAE3D,IAAI,CAAC4D,MAAM,CAAC,gBAAgB;;OAE1C;MACDC,eAAe,EAAE;QACfN,IAAI,EAAE,WAAW;QACjBC,IAAI,EAAE;UACJG,SAAS,EAAE3D,IAAI,CAAC4D,MAAM,CAAC,kBAAkB;;;KAG9C;IACDE,UAAU,EAAE;MACVC,IAAI,EAAE,KAAK;MACXC,KAAK,EAAE,IAAI;MACX;MACA;MACAC,QAAQ,EAAE,IAAI;MACd;MACA;MACAC,SAAS,EAAE,IAAI;MACfC,SAAS,EAAE,IAAI;MACfC,SAAS,EAAE,KAAK;MAChBC,SAAS,EAAE,IAAI;MACfC,SAAS,EAAE,KAAK;MAEhBC,MAAM,EAAE,QAAQ;MAChBC,UAAU,EAAE,OAAO;MACnBC,eAAe,EAAE,UAAU;MAC3BC,QAAQ,EAAE,IAAI;MACdC,MAAM,EAAE,QAAQ;MAChBC,SAAS,EAAE,QAAQ;MAEnBC,kBAAkBA,CAAc;QAAEC,IAAI;QAAEC,UAAU;QAAEC;MAAU,CAAE;QAC9D,MAAMC,IAAI,GAAGH,IAAI,KAAK,QAAQ,GAAGE,UAAU,GAAGD,UAAU;QACxD,OAAOE,IAAI,IAAI,IAAI;MACrB,CAAC;MAEDC,UAAUA,CAAA;QACR,OAAO,IAAI/E,YAAY,EAAE;MAC3B;KACD;IACDgF,YAAY,EAAE;MACZC,QAAQ,EAAE,IAAI;MACdC,qBAAqB,EAAE;KACxB;IACD/D,QAAQ,EAAE;MACRwB,OAAO,EAAE,KAAK;MACdwC,QAAQ,EAAE,CAAC;MACXC,SAAS,EAAE,CAAC;MACZC,QAAQ,EAAEC,MAAM,CAACC,gBAAgB;MACjCC,SAAS,EAAEF,MAAM,CAACC,gBAAgB;MAClCE,UAAU,EAAE,IAAI;MAChBC,UAAU,EAAE,KAAK;MACjBC,UAAU,EAAE,IAAI;MAChBC,mBAAmB,EAAE,KAAK;MAC1BC,YAAY,EAAE;KACf;IACDzE,QAAQ,EAAE;MACRuB,OAAO,EAAE,KAAK;MACd7B,IAAI,EAAE;KACP;IACDgF,WAAW,EAAE;MACXC,QAAQ,EAAE;KACX;IACD1E,IAAI,EAAE;MACJsB,OAAO,EAAE,KAAK;MACdsC,QAAQ,EAAE,IAAI;MACdC,qBAAqB,EAAE;KACxB;IACDjE,SAAS,EAAE;MACT0B,OAAO,EAAE,KAAK;MACdqD,UAAU,EAAE,MAAM;MAClBC,SAAS,EAAE,IAAI;MACfC,QAAQ,EAAEA,CAAA,KAAM;KACjB;IACDlF,SAAS,EAAE;MACT2B,OAAO,EAAE,KAAK;MACdwD,UAAU,EAAE,KAAK;MACjBC,UAAU,EAAE,IAAI;MAChBC,UAAU,EAAE,KAAK;MACjBC,aAAa,EAAE,MAAM;MACrBC,QAAQ,EAAE,IAAI;MACdC,0BAA0B,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC;MAC5CC,OAAO,EAAE,IAAI;MACbC,MAAM,EAAE,KAAK;MACbC,eAAe,EAAE,KAAK;MACtBC,iBAAiB,EAAE,KAAK;MACxBC,iBAAiB,EAAE,KAAK;MACxBC,iBAAiB,EAAE,KAAK;MACxBC,OAAO,EAAE,IAAI;MACbC,OAAO,EAAE;KACV;IACDjG,OAAO,EAAE;MACP4B,OAAO,EAAE,KAAK;MACdsE,UAAU,EAAE,CAAC,eAAe;KAC7B;IACD/F,QAAQ,EAAE;MACRyB,OAAO,EAAE;KACV;IACDrB,SAAS,EAAE;MACTqB,OAAO,EAAE;KACV;IACDpB,OAAO,EAAE;MACPoB,OAAO,EAAE;KACV;IACDnB,QAAQ,EAAE;MACRmB,OAAO,EAAE;KACV;IACDjB,QAAQ,EAAE;MACRiB,OAAO,EAAE;KACV;IACDhB,UAAU,EAAE;MACVgB,OAAO,EAAE,KAAK;MACduE,MAAM,EAAE,GAAG;MACXC,mBAAmB,EAAE;KACtB;IAEDC,KAAK,EAAE,KAAK;IACZC,MAAM,EAAE,KAAK;IACbC,OAAO,EAAE,OAAO;IAEhBC,aAAa,EAAE,CAAC;IAChBC,cAAc,EAAE,CAAC;IACjBC,eAAe,EAAE,CAAC;IAClBC,sBAAsB,EAAE,IAAI;IAC5BC,uBAAuB,EAAE,KAAK;IAC9BC,yBAAyB,EAAE,IAAI;IAC/BC,yBAAyB,EAAE,IAAI;IAC/BC,WAAW,EAAE;MACXC,gBAAgB,EAAE;KACnB;IACDC,KAAK,EAAEA,CAAA,KAAM;GACd;AACH,CAAC,EA3JgB/H,OAAO,KAAPA,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}