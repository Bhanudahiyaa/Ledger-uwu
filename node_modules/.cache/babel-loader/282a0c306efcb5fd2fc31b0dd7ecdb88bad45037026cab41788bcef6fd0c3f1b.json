{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { getDefaultDomain } from '@antv/l7-utils';\nimport BaseModel from \"../../core/BaseModel\";\nimport { RasterImageTriangulation } from \"../../core/triangulation\";\n/* babel-plugin-inline-import '../shaders/raster/raster_2d_frag.glsl' */\nconst rasterFrag = \"layout(std140) uniform commonUniforms {\\n  vec2 u_domain;\\n  float u_opacity;\\n  float u_noDataValue;\\n  float u_clampLow;\\n  float u_clampHigh;\\n};\\n\\nuniform sampler2D u_rasterTexture;\\nuniform sampler2D u_colorTexture;\\n\\nin vec2 v_texCoord;\\n\\nbool isnan_emu(float x) { return (x > 0.0 || x < 0.0) ? x != x : x != 0.0; }\\n\\nout vec4 outputColor;\\n\\nvoid main() {\\n  // Can use any component here since u_rasterTexture is under luminance format.\\n  float value = texture(SAMPLER_2D(u_rasterTexture), vec2(v_texCoord.x, v_texCoord.y)).r;\\n  if (value == u_noDataValue || isnan_emu(value)) {\\n    discard;\\n  } else if ((u_clampLow < 0.5 && value < u_domain[0]) || (u_clampHigh < 0.5 && value > u_domain[1])) {\\n    discard;\\n  } else {\\n    float normalisedValue =(value - u_domain[0]) / (u_domain[1] - u_domain[0]);\\n    vec4 color = texture(SAMPLER_2D(u_colorTexture), vec2(normalisedValue, 0));\\n    \\n    outputColor = color;\\n    outputColor.a = outputColor.a * u_opacity ;\\n    if (outputColor.a < 0.01)\\n      discard;\\n  }\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/raster/raster_2d_vert.glsl' */\nconst rasterVert = \"layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\\n\\nlayout(std140) uniform commonUniforms {\\n  vec2 u_domain;\\n  float u_opacity;\\n  float u_noDataValue;\\n  float u_clampLow;\\n  float u_clampHigh;\\n};\\n\\nout vec2 v_texCoord;\\n\\n#pragma include \\\"projection\\\"\\n\\nvoid main() {\\n  v_texCoord = a_Uv;\\n  vec4 project_pos = project_position(vec4(a_Position, 1.0), a_Position64Low);\\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, 0.0, 1.0));\\n}\\n\";\nexport default class RasterModel extends BaseModel {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"texture\", void 0);\n    _defineProperty(this, \"colorTexture\", void 0);\n  }\n  get attributeLocation() {\n    return Object.assign(super.attributeLocation, {\n      MAX: super.attributeLocation.MAX,\n      UV: 9\n    });\n  }\n  getUninforms() {\n    const commoninfo = this.getCommonUniformsInfo();\n    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());\n    this.updateStyleUnifoms();\n    return _objectSpread(_objectSpread({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);\n  }\n  getCommonUniformsInfo() {\n    const {\n      opacity = 1,\n      clampLow = true,\n      clampHigh = true,\n      noDataValue = -9999999,\n      domain,\n      rampColors\n    } = this.layer.getLayerConfig();\n    const newdomain = domain || getDefaultDomain(rampColors);\n    this.colorTexture = this.layer.textureService.getColorTexture(rampColors, newdomain);\n    const commonOptions = {\n      u_domain: newdomain,\n      u_opacity: opacity || 1,\n      u_noDataValue: noDataValue,\n      u_clampLow: clampLow ? 1 : 0,\n      u_clampHigh: (typeof clampHigh !== 'undefined' ? clampHigh : clampLow) ? 1 : 0,\n      u_rasterTexture: this.texture,\n      u_colorTexture: this.colorTexture\n    };\n    this.textures = [this.texture, this.colorTexture];\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  getRasterData(parserDataItem) {\n    return _asyncToGenerator(function* () {\n      if (Array.isArray(parserDataItem.data)) {\n        // 直接传入波段数据\n        return {\n          data: parserDataItem.data,\n          width: parserDataItem.width,\n          height: parserDataItem.height\n        };\n      } else {\n        // 多波段形式、需要进行处理\n        const {\n          rasterData,\n          width,\n          height\n        } = yield parserDataItem.data;\n        return {\n          data: Array.from(rasterData),\n          width,\n          height\n        };\n      }\n    })();\n  }\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return _this.buildModels();\n    })();\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.initUniformsBuffer();\n      const source = _this2.layer.getSource();\n      const {\n        createTexture2D,\n        queryVerdorInfo\n      } = _this2.rendererService;\n      const parserDataItem = source.data.dataArray[0];\n      const {\n        data,\n        width,\n        height\n      } = yield _this2.getRasterData(parserDataItem);\n      _this2.texture = createTexture2D({\n        // @ts-ignore\n        data: new Float32Array(data),\n        width,\n        height,\n        /**\n         * WebGL1 allow the combination of gl.LUMINANCE & gl.FLOAT with OES_texture_float\n         * TODO: https://github.com/antvis/g-device-api/issues/188\n         */\n        format: queryVerdorInfo() === 'WebGL1' ? gl.LUMINANCE : gl.RED,\n        type: gl.FLOAT,\n        alignment: 1\n      });\n      const model = yield _this2.layer.buildLayerModel({\n        moduleName: 'rasterImageData',\n        vertexShader: rasterVert,\n        fragmentShader: rasterFrag,\n        defines: _this2.getDefines(),\n        triangulation: RasterImageTriangulation,\n        primitive: gl.TRIANGLES,\n        depth: {\n          enable: false\n        },\n        pickingEnabled: false\n      });\n      return [model];\n    })();\n  }\n  clearModels() {\n    var _this$texture, _this$colorTexture;\n    (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();\n    (_this$colorTexture = this.colorTexture) === null || _this$colorTexture === void 0 || _this$colorTexture.destroy();\n  }\n  registerBuiltinAttributes() {\n    // 注册 Position 属性 64 位地位部分，经纬度数据开启双精度，避免大于 22 层级以上出现数据偏移\n    this.registerPosition64LowAttribute();\n\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'uv',\n      type: AttributeType.Attribute,\n      descriptor: {\n        shaderLocation: this.attributeLocation.UV,\n        name: 'a_Uv',\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 2,\n        update: (feature, featureIdx, vertex) => {\n          return [vertex[3], vertex[4]];\n        }\n      }\n    });\n  }\n}","map":{"version":3,"names":["_asyncToGenerator","_objectSpread","_defineProperty","AttributeType","gl","getDefaultDomain","BaseModel","RasterImageTriangulation","rasterFrag","rasterVert","RasterModel","constructor","args","attributeLocation","Object","assign","MAX","UV","getUninforms","commoninfo","getCommonUniformsInfo","attributeInfo","getUniformsBufferInfo","getStyleAttribute","updateStyleUnifoms","uniformsOption","opacity","clampLow","clampHigh","noDataValue","domain","rampColors","layer","getLayerConfig","newdomain","colorTexture","textureService","getColorTexture","commonOptions","u_domain","u_opacity","u_noDataValue","u_clampLow","u_clampHigh","u_rasterTexture","texture","u_colorTexture","textures","commonBufferInfo","getRasterData","parserDataItem","Array","isArray","data","width","height","rasterData","from","initModels","_this","buildModels","_this2","initUniformsBuffer","source","getSource","createTexture2D","queryVerdorInfo","rendererService","dataArray","Float32Array","format","LUMINANCE","RED","type","FLOAT","alignment","model","buildLayerModel","moduleName","vertexShader","fragmentShader","defines","getDefines","triangulation","primitive","TRIANGLES","depth","enable","pickingEnabled","clearModels","_this$texture","_this$colorTexture","destroy","registerBuiltinAttributes","registerPosition64LowAttribute","styleAttributeService","registerStyleAttribute","name","Attribute","descriptor","shaderLocation","buffer","usage","DYNAMIC_DRAW","size","update","feature","featureIdx","vertex"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/l7-layers/es/raster/models/raster.js"],"sourcesContent":["import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { getDefaultDomain } from '@antv/l7-utils';\nimport BaseModel from \"../../core/BaseModel\";\nimport { RasterImageTriangulation } from \"../../core/triangulation\";\n/* babel-plugin-inline-import '../shaders/raster/raster_2d_frag.glsl' */\nconst rasterFrag = \"layout(std140) uniform commonUniforms {\\n  vec2 u_domain;\\n  float u_opacity;\\n  float u_noDataValue;\\n  float u_clampLow;\\n  float u_clampHigh;\\n};\\n\\nuniform sampler2D u_rasterTexture;\\nuniform sampler2D u_colorTexture;\\n\\nin vec2 v_texCoord;\\n\\nbool isnan_emu(float x) { return (x > 0.0 || x < 0.0) ? x != x : x != 0.0; }\\n\\nout vec4 outputColor;\\n\\nvoid main() {\\n  // Can use any component here since u_rasterTexture is under luminance format.\\n  float value = texture(SAMPLER_2D(u_rasterTexture), vec2(v_texCoord.x, v_texCoord.y)).r;\\n  if (value == u_noDataValue || isnan_emu(value)) {\\n    discard;\\n  } else if ((u_clampLow < 0.5 && value < u_domain[0]) || (u_clampHigh < 0.5 && value > u_domain[1])) {\\n    discard;\\n  } else {\\n    float normalisedValue =(value - u_domain[0]) / (u_domain[1] - u_domain[0]);\\n    vec4 color = texture(SAMPLER_2D(u_colorTexture), vec2(normalisedValue, 0));\\n    \\n    outputColor = color;\\n    outputColor.a = outputColor.a * u_opacity ;\\n    if (outputColor.a < 0.01)\\n      discard;\\n  }\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/raster/raster_2d_vert.glsl' */\nconst rasterVert = \"layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\\n\\nlayout(std140) uniform commonUniforms {\\n  vec2 u_domain;\\n  float u_opacity;\\n  float u_noDataValue;\\n  float u_clampLow;\\n  float u_clampHigh;\\n};\\n\\nout vec2 v_texCoord;\\n\\n#pragma include \\\"projection\\\"\\n\\nvoid main() {\\n  v_texCoord = a_Uv;\\n  vec4 project_pos = project_position(vec4(a_Position, 1.0), a_Position64Low);\\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, 0.0, 1.0));\\n}\\n\";\nexport default class RasterModel extends BaseModel {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"texture\", void 0);\n    _defineProperty(this, \"colorTexture\", void 0);\n  }\n  get attributeLocation() {\n    return Object.assign(super.attributeLocation, {\n      MAX: super.attributeLocation.MAX,\n      UV: 9\n    });\n  }\n  getUninforms() {\n    const commoninfo = this.getCommonUniformsInfo();\n    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());\n    this.updateStyleUnifoms();\n    return _objectSpread(_objectSpread({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);\n  }\n  getCommonUniformsInfo() {\n    const {\n      opacity = 1,\n      clampLow = true,\n      clampHigh = true,\n      noDataValue = -9999999,\n      domain,\n      rampColors\n    } = this.layer.getLayerConfig();\n    const newdomain = domain || getDefaultDomain(rampColors);\n    this.colorTexture = this.layer.textureService.getColorTexture(rampColors, newdomain);\n    const commonOptions = {\n      u_domain: newdomain,\n      u_opacity: opacity || 1,\n      u_noDataValue: noDataValue,\n      u_clampLow: clampLow ? 1 : 0,\n      u_clampHigh: (typeof clampHigh !== 'undefined' ? clampHigh : clampLow) ? 1 : 0,\n      u_rasterTexture: this.texture,\n      u_colorTexture: this.colorTexture\n    };\n    this.textures = [this.texture, this.colorTexture];\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  getRasterData(parserDataItem) {\n    return _asyncToGenerator(function* () {\n      if (Array.isArray(parserDataItem.data)) {\n        // 直接传入波段数据\n        return {\n          data: parserDataItem.data,\n          width: parserDataItem.width,\n          height: parserDataItem.height\n        };\n      } else {\n        // 多波段形式、需要进行处理\n        const {\n          rasterData,\n          width,\n          height\n        } = yield parserDataItem.data;\n        return {\n          data: Array.from(rasterData),\n          width,\n          height\n        };\n      }\n    })();\n  }\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return _this.buildModels();\n    })();\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.initUniformsBuffer();\n      const source = _this2.layer.getSource();\n      const {\n        createTexture2D,\n        queryVerdorInfo\n      } = _this2.rendererService;\n      const parserDataItem = source.data.dataArray[0];\n      const {\n        data,\n        width,\n        height\n      } = yield _this2.getRasterData(parserDataItem);\n      _this2.texture = createTexture2D({\n        // @ts-ignore\n        data: new Float32Array(data),\n        width,\n        height,\n        /**\n         * WebGL1 allow the combination of gl.LUMINANCE & gl.FLOAT with OES_texture_float\n         * TODO: https://github.com/antvis/g-device-api/issues/188\n         */\n        format: queryVerdorInfo() === 'WebGL1' ? gl.LUMINANCE : gl.RED,\n        type: gl.FLOAT,\n        alignment: 1\n      });\n      const model = yield _this2.layer.buildLayerModel({\n        moduleName: 'rasterImageData',\n        vertexShader: rasterVert,\n        fragmentShader: rasterFrag,\n        defines: _this2.getDefines(),\n        triangulation: RasterImageTriangulation,\n        primitive: gl.TRIANGLES,\n        depth: {\n          enable: false\n        },\n        pickingEnabled: false\n      });\n      return [model];\n    })();\n  }\n  clearModels() {\n    var _this$texture, _this$colorTexture;\n    (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();\n    (_this$colorTexture = this.colorTexture) === null || _this$colorTexture === void 0 || _this$colorTexture.destroy();\n  }\n  registerBuiltinAttributes() {\n    // 注册 Position 属性 64 位地位部分，经纬度数据开启双精度，避免大于 22 层级以上出现数据偏移\n    this.registerPosition64LowAttribute();\n\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'uv',\n      type: AttributeType.Attribute,\n      descriptor: {\n        shaderLocation: this.attributeLocation.UV,\n        name: 'a_Uv',\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 2,\n        update: (feature, featureIdx, vertex) => {\n          return [vertex[3], vertex[4]];\n        }\n      }\n    });\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}