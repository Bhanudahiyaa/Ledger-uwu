{"ast":null,"code":"import { Util } from '../../global';\nimport { StringExt, FunctionExt } from '../../util';\nimport { Point, Rectangle, Angle } from '../../geometry';\nimport { Cell } from '../../model/cell';\nimport { notify } from '../transform/util';\nexport class NodePreset {\n  constructor(halo) {\n    this.halo = halo;\n  }\n  get options() {\n    return this.halo.options;\n  }\n  get graph() {\n    return this.halo.graph;\n  }\n  get model() {\n    return this.halo.model;\n  }\n  get view() {\n    return this.halo.view;\n  }\n  get cell() {\n    return this.halo.cell;\n  }\n  get node() {\n    return this.cell;\n  }\n  getPresets() {\n    return {\n      className: 'type-node',\n      handles: [{\n        name: 'remove',\n        position: 'nw',\n        events: {\n          mousedown: this.removeCell.bind(this)\n        },\n        icon: null\n      }, {\n        name: 'resize',\n        position: 'se',\n        events: {\n          mousedown: this.startResize.bind(this),\n          mousemove: this.doResize.bind(this),\n          mouseup: this.stopResize.bind(this)\n        },\n        icon: null\n      }, {\n        name: 'clone',\n        position: 'n',\n        events: {\n          mousedown: this.startClone.bind(this),\n          mousemove: this.doClone.bind(this),\n          mouseup: this.stopClone.bind(this)\n        },\n        icon: null\n      }, {\n        name: 'link',\n        position: 'e',\n        events: {\n          mousedown: this.startLink.bind(this),\n          mousemove: this.doLink.bind(this),\n          mouseup: this.stopLink.bind(this)\n        },\n        icon: null\n      }, {\n        name: 'fork',\n        position: 'ne',\n        events: {\n          mousedown: this.startFork.bind(this),\n          mousemove: this.doFork.bind(this),\n          mouseup: this.stopFork.bind(this)\n        },\n        icon: null\n      }, {\n        name: 'unlink',\n        position: 'w',\n        events: {\n          mousedown: this.unlink.bind(this)\n        },\n        icon: null\n      }, {\n        name: 'rotate',\n        position: 'sw',\n        events: {\n          mousedown: this.startRotate.bind(this),\n          mousemove: this.doRotate.bind(this),\n          mouseup: this.stopRotate.bind(this)\n        },\n        icon: null\n      }],\n      bbox(view) {\n        if (this.options.useCellGeometry) {\n          const node = view.cell;\n          return node.getBBox();\n        }\n        return view.getBBox();\n      },\n      content(view) {\n        const template = StringExt.template('x: <%= x %>, y: <%= y %>, width: <%= width %>, height: <%= height %>, angle: <%= angle %>');\n        const cell = view.cell;\n        const bbox = cell.getBBox();\n        return template({\n          x: Math.floor(bbox.x),\n          y: Math.floor(bbox.y),\n          width: Math.floor(bbox.width),\n          height: Math.floor(bbox.height),\n          angle: Math.floor(cell.getAngle())\n        });\n      },\n      magnet(view) {\n        return view.container;\n      },\n      tinyThreshold: 40,\n      smallThreshold: 80,\n      loopEdgePreferredSide: 'top',\n      loopEdgeWidth: 40,\n      rotateGrid: 15,\n      rotateEmbeds: false\n    };\n  }\n  removeCell() {\n    this.model.removeConnectedEdges(this.cell);\n    this.cell.remove();\n  }\n  // #region create edge\n  startLink({\n    x,\n    y\n  }) {\n    this.halo.startBatch();\n    const graph = this.graph;\n    const edge = this.createEdgeConnectedToSource();\n    edge.setTarget({\n      x,\n      y\n    });\n    this.model.addEdge(edge, {\n      validation: false,\n      halo: this.halo.cid,\n      async: false\n    });\n    graph.view.undelegateEvents();\n    this.edgeView = graph.renderer.findViewByCell(edge);\n    this.edgeView.prepareArrowheadDragging('target', {\n      x,\n      y,\n      fallbackAction: 'remove'\n    });\n  }\n  createEdgeConnectedToSource() {\n    const magnet = this.getMagnet(this.view, 'source');\n    const terminal = this.getEdgeTerminal(this.view, magnet);\n    const edge = this.graph.hook.getDefaultEdge(this.view, magnet);\n    edge.setSource(terminal);\n    return edge;\n  }\n  getMagnet(view, terminal) {\n    const magnet = this.options.magnet;\n    if (typeof magnet === 'function') {\n      const val = FunctionExt.call(magnet, this.halo, view, terminal);\n      if (val instanceof SVGElement) {\n        return val;\n      }\n    }\n    throw new Error('`magnet()` has to return an SVGElement');\n  }\n  getEdgeTerminal(view, magnet) {\n    const terminal = {\n      cell: view.cell.id\n    };\n    if (magnet !== view.container) {\n      const port = magnet.getAttribute('port');\n      if (port) {\n        terminal.port = port;\n      } else {\n        terminal.selector = view.getSelector(magnet);\n      }\n    }\n    return terminal;\n  }\n  doLink({\n    e,\n    x,\n    y\n  }) {\n    if (this.edgeView) {\n      this.edgeView.onMouseMove(e, x, y);\n    }\n  }\n  stopLink({\n    e,\n    x,\n    y\n  }) {\n    const edgeView = this.edgeView;\n    if (edgeView) {\n      edgeView.onMouseUp(e, x, y);\n      const edge = edgeView.cell;\n      if (edge.hasLoop()) {\n        this.makeLoopEdge(edge);\n      }\n      this.halo.stopBatch();\n      this.halo.trigger('action:edge:addde', {\n        edge\n      });\n      this.edgeView = null;\n    }\n    this.graph.view.delegateEvents();\n  }\n  makeLoopEdge(edge) {\n    let vertex1 = null;\n    let vertex2 = null;\n    const loopEdgeWidth = this.options.loopEdgeWidth;\n    const graphOptions = this.graph.options;\n    const graphRect = new Rectangle(0, 0, graphOptions.width, graphOptions.height);\n    const bbox = this.graph.graphToLocal(this.view.getBBox());\n    const found = [this.options.loopEdgePreferredSide, 'top', 'bottom', 'left', 'right'].some(position => {\n      let point = null;\n      let dx = 0;\n      let dy = 0;\n      switch (position) {\n        case 'top':\n          point = new Point(bbox.x + bbox.width / 2, bbox.y - loopEdgeWidth);\n          dx = loopEdgeWidth / 2;\n          break;\n        case 'bottom':\n          point = new Point(bbox.x + bbox.width / 2, bbox.y + bbox.height + loopEdgeWidth);\n          dx = loopEdgeWidth / 2;\n          break;\n        case 'left':\n          point = new Point(bbox.x - loopEdgeWidth, bbox.y + bbox.height / 2);\n          dy = loopEdgeWidth / 2;\n          break;\n        case 'right':\n          point = new Point(bbox.x + bbox.width + loopEdgeWidth, bbox.y + bbox.height / 2);\n          dy = loopEdgeWidth / 2;\n          break;\n        default:\n          break;\n      }\n      if (point) {\n        vertex1 = point.translate(-dx, -dy);\n        vertex2 = point.translate(dx, dy);\n        return graphRect.containsPoint(vertex1) && graphRect.containsPoint(vertex2);\n      }\n      return false;\n    });\n    if (found && vertex1 && vertex2) {\n      edge.setVertices([vertex1, vertex2]);\n    }\n  }\n  // #endregion\n  // #region resize\n  startResize({\n    e\n  }) {\n    this.halo.startBatch();\n    this.flip = [1, 0, 0, 1, 1, 0, 0, 1][Math.floor(Angle.normalize(this.node.getAngle()) / 45)];\n    this.view.addClass('node-resizing');\n    notify('node:resize', e, this.view);\n  }\n  doResize({\n    e,\n    dx,\n    dy\n  }) {\n    const size = this.node.getSize();\n    const width = Math.max(size.width + (this.flip ? dx : dy), 1);\n    const height = Math.max(size.height + (this.flip ? dy : dx), 1);\n    this.node.resize(width, height, {\n      absolute: true\n    });\n    notify('node:resizing', e, this.view);\n  }\n  stopResize({\n    e\n  }) {\n    this.view.removeClass('node-resizing');\n    notify('node:resized', e, this.view);\n    this.halo.stopBatch();\n  }\n  // #endregion\n  // #region clone\n  startClone({\n    e,\n    x,\n    y\n  }) {\n    this.halo.startBatch();\n    const options = this.options;\n    const cloned = options.clone(this.cell, {\n      clone: true\n    });\n    if (!Cell.isCell(cloned)) {\n      throw new Error(\"option 'clone()' has to return a cell\");\n    }\n    this.centerNodeAtCursor(cloned, x, y);\n    this.model.addCell(cloned, {\n      halo: this.halo.cid,\n      async: false\n    });\n    const cloneView = this.graph.renderer.findViewByCell(cloned);\n    cloneView.onMouseDown(e, x, y);\n    this.halo.setEventData(e, {\n      cloneView\n    });\n  }\n  centerNodeAtCursor(cell, x, y) {\n    const center = cell.getBBox().getCenter();\n    const dx = x - center.x;\n    const dy = y - center.y;\n    cell.translate(dx, dy);\n  }\n  doClone({\n    e,\n    x,\n    y\n  }) {\n    const view = this.halo.getEventData(e).cloneView;\n    if (view) {\n      view.onMouseMove(e, x, y);\n    }\n  }\n  stopClone({\n    e,\n    x,\n    y\n  }) {\n    const nodeView = this.halo.getEventData(e).cloneView;\n    if (nodeView) {\n      nodeView.onMouseUp(e, x, y);\n    }\n    this.halo.stopBatch();\n  }\n  // #endregion\n  // #region fork\n  startFork({\n    e,\n    x,\n    y\n  }) {\n    this.halo.startBatch();\n    const cloned = this.options.clone(this.cell, {\n      fork: true\n    });\n    if (!Cell.isCell(cloned)) {\n      throw new Error(\"option 'clone()' has to return a cell\");\n    }\n    this.centerNodeAtCursor(cloned, x, y);\n    this.model.addCell(cloned, {\n      halo: this.halo.cid,\n      async: false\n    });\n    const edge = this.createEdgeConnectedToSource();\n    const cloneView = this.graph.renderer.findViewByCell(cloned);\n    const magnet = this.getMagnet(cloneView, 'target');\n    const terminal = this.getEdgeTerminal(cloneView, magnet);\n    edge.setTarget(terminal);\n    this.model.addEdge(edge, {\n      halo: this.halo.cid,\n      async: false\n    });\n    cloneView.onMouseDown(e, x, y);\n    this.halo.setEventData(e, {\n      cloneView\n    });\n  }\n  doFork({\n    e,\n    x,\n    y\n  }) {\n    const view = this.halo.getEventData(e).cloneView;\n    if (view) {\n      view.onMouseMove(e, x, y);\n    }\n  }\n  stopFork({\n    e,\n    x,\n    y\n  }) {\n    const view = this.halo.getEventData(e).cloneView;\n    if (view) {\n      view.onMouseUp(e, x, y);\n    }\n    this.halo.stopBatch();\n  }\n  // #endregion\n  // #region rotate\n  startRotate({\n    e,\n    x,\n    y\n  }) {\n    this.halo.startBatch();\n    const center = this.node.getBBox().getCenter();\n    const nodes = [this.node];\n    if (this.options.rotateEmbeds) {\n      this.node.getDescendants({\n        deep: true\n      }).reduce((memo, cell) => {\n        if (cell.isNode()) {\n          memo.push(cell);\n        }\n        return memo;\n      }, nodes);\n    }\n    this.halo.setEventData(e, {\n      center,\n      nodes,\n      rotateStartAngles: nodes.map(node => node.getAngle()),\n      clientStartAngle: new Point(x, y).theta(center)\n    });\n    nodes.forEach(node => {\n      const view = this.graph.findViewByCell(node);\n      if (view) {\n        view.addClass('node-rotating');\n        notify('node:rotate', e, view);\n      }\n    });\n  }\n  doRotate({\n    e,\n    x,\n    y\n  }) {\n    const data = this.halo.getEventData(e);\n    const delta = data.clientStartAngle - new Point(x, y).theta(data.center);\n    data.nodes.forEach((node, index) => {\n      const startAngle = data.rotateStartAngles[index];\n      const targetAngle = Util.snapToGrid(startAngle + delta, this.options.rotateGrid);\n      node.rotate(targetAngle, {\n        absolute: true,\n        center: data.center,\n        halo: this.halo.cid\n      });\n      notify('node:rotating', e, this.graph.findViewByCell(node));\n    });\n  }\n  stopRotate({\n    e\n  }) {\n    const data = this.halo.getEventData(e);\n    data.nodes.forEach(node => {\n      const view = this.graph.findViewByCell(node);\n      view.removeClass('node-rotating');\n      notify('node:rotated', e, view);\n    });\n    this.halo.stopBatch();\n  }\n  // #endregion\n  // #region unlink\n  unlink() {\n    this.halo.startBatch();\n    this.model.removeConnectedEdges(this.cell);\n    this.halo.stopBatch();\n  }\n}","map":{"version":3,"names":["Util","StringExt","FunctionExt","Point","Rectangle","Angle","Cell","notify","NodePreset","constructor","halo","options","graph","model","view","cell","node","getPresets","className","handles","name","position","events","mousedown","removeCell","bind","icon","startResize","mousemove","doResize","mouseup","stopResize","startClone","doClone","stopClone","startLink","doLink","stopLink","startFork","doFork","stopFork","unlink","startRotate","doRotate","stopRotate","bbox","useCellGeometry","getBBox","content","template","x","Math","floor","y","width","height","angle","getAngle","magnet","container","tinyThreshold","smallThreshold","loopEdgePreferredSide","loopEdgeWidth","rotateGrid","rotateEmbeds","removeConnectedEdges","remove","startBatch","edge","createEdgeConnectedToSource","setTarget","addEdge","validation","cid","async","undelegateEvents","edgeView","renderer","findViewByCell","prepareArrowheadDragging","fallbackAction","getMagnet","terminal","getEdgeTerminal","hook","getDefaultEdge","setSource","val","call","SVGElement","Error","id","port","getAttribute","selector","getSelector","e","onMouseMove","onMouseUp","hasLoop","makeLoopEdge","stopBatch","trigger","delegateEvents","vertex1","vertex2","graphOptions","graphRect","graphToLocal","found","some","point","dx","dy","translate","containsPoint","setVertices","flip","normalize","addClass","size","getSize","max","resize","absolute","removeClass","cloned","clone","isCell","centerNodeAtCursor","addCell","cloneView","onMouseDown","setEventData","center","getCenter","getEventData","nodeView","fork","nodes","getDescendants","deep","reduce","memo","isNode","push","rotateStartAngles","map","clientStartAngle","theta","forEach","data","delta","index","startAngle","targetAngle","snapToGrid","rotate"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/addon/halo/node-preset.ts"],"sourcesContent":["import { Util } from '../../global'\nimport { StringExt, FunctionExt } from '../../util'\nimport { Point, Rectangle, Angle } from '../../geometry'\nimport { Cell } from '../../model/cell'\nimport { Node } from '../../model/node'\nimport { Edge } from '../../model/edge'\nimport { CellView } from '../../view/cell'\nimport { NodeView } from '../../view/node'\nimport { EdgeView } from '../../view/edge'\nimport { Handle } from '../common'\nimport { notify } from '../transform/util'\nimport { Halo } from './index'\n\nexport class NodePreset {\n  private edgeView: EdgeView | null\n  private flip: number\n\n  constructor(private halo: Halo) {}\n\n  get options() {\n    return this.halo.options\n  }\n\n  get graph() {\n    return this.halo.graph\n  }\n\n  get model() {\n    return this.halo.model\n  }\n\n  get view() {\n    return this.halo.view\n  }\n\n  get cell() {\n    return this.halo.cell\n  }\n\n  get node() {\n    return this.cell as Node\n  }\n\n  getPresets(): Halo.Options {\n    return {\n      className: 'type-node',\n      handles: [\n        {\n          name: 'remove',\n          position: 'nw',\n          events: {\n            mousedown: this.removeCell.bind(this),\n          },\n          icon: null,\n        },\n        {\n          name: 'resize',\n          position: 'se',\n          events: {\n            mousedown: this.startResize.bind(this),\n            mousemove: this.doResize.bind(this),\n            mouseup: this.stopResize.bind(this),\n          },\n          icon: null,\n        },\n        {\n          name: 'clone',\n          position: 'n',\n          events: {\n            mousedown: this.startClone.bind(this),\n            mousemove: this.doClone.bind(this),\n            mouseup: this.stopClone.bind(this),\n          },\n          icon: null,\n        },\n        {\n          name: 'link',\n          position: 'e',\n          events: {\n            mousedown: this.startLink.bind(this),\n            mousemove: this.doLink.bind(this),\n            mouseup: this.stopLink.bind(this),\n          },\n          icon: null,\n        },\n        {\n          name: 'fork',\n          position: 'ne',\n          events: {\n            mousedown: this.startFork.bind(this),\n            mousemove: this.doFork.bind(this),\n            mouseup: this.stopFork.bind(this),\n          },\n          icon: null,\n        },\n        {\n          name: 'unlink',\n          position: 'w',\n          events: {\n            mousedown: this.unlink.bind(this),\n          },\n          icon: null,\n        },\n        {\n          name: 'rotate',\n          position: 'sw',\n          events: {\n            mousedown: this.startRotate.bind(this),\n            mousemove: this.doRotate.bind(this),\n            mouseup: this.stopRotate.bind(this),\n          },\n          icon: null,\n        },\n      ],\n\n      bbox(view) {\n        if (this.options.useCellGeometry) {\n          const node = view.cell as Node\n          return node.getBBox()\n        }\n        return view.getBBox()\n      },\n\n      content(view) {\n        const template = StringExt.template(\n          'x: <%= x %>, y: <%= y %>, width: <%= width %>, height: <%= height %>, angle: <%= angle %>',\n        )\n        const cell = view.cell as Node\n        const bbox = cell.getBBox()\n        return template({\n          x: Math.floor(bbox.x),\n          y: Math.floor(bbox.y),\n          width: Math.floor(bbox.width),\n          height: Math.floor(bbox.height),\n          angle: Math.floor(cell.getAngle()),\n        })\n      },\n      magnet(view) {\n        return view.container\n      },\n      tinyThreshold: 40,\n      smallThreshold: 80,\n      loopEdgePreferredSide: 'top',\n      loopEdgeWidth: 40,\n      rotateGrid: 15,\n      rotateEmbeds: false,\n    }\n  }\n\n  removeCell() {\n    this.model.removeConnectedEdges(this.cell)\n    this.cell.remove()\n  }\n\n  // #region create edge\n\n  startLink({ x, y }: Handle.EventArgs) {\n    this.halo.startBatch()\n    const graph = this.graph\n    const edge = this.createEdgeConnectedToSource()\n    edge.setTarget({ x, y })\n    this.model.addEdge(edge, {\n      validation: false,\n      halo: this.halo.cid,\n      async: false,\n    })\n\n    graph.view.undelegateEvents()\n    this.edgeView = graph.renderer.findViewByCell(edge) as EdgeView\n    this.edgeView.prepareArrowheadDragging('target', {\n      x,\n      y,\n      fallbackAction: 'remove',\n    })\n  }\n\n  createEdgeConnectedToSource() {\n    const magnet = this.getMagnet(this.view, 'source')\n    const terminal = this.getEdgeTerminal(this.view, magnet)\n    const edge = this.graph.hook.getDefaultEdge(this.view, magnet)\n    edge.setSource(terminal)\n    return edge\n  }\n\n  getMagnet(view: CellView, terminal: Edge.TerminalType) {\n    const magnet = this.options.magnet\n    if (typeof magnet === 'function') {\n      const val = FunctionExt.call(magnet, this.halo, view, terminal)\n      if (val instanceof SVGElement) {\n        return val\n      }\n    }\n    throw new Error('`magnet()` has to return an SVGElement')\n  }\n\n  getEdgeTerminal(view: CellView, magnet: Element) {\n    const terminal: Edge.TerminalCellData = {\n      cell: view.cell.id,\n    }\n    if (magnet !== view.container) {\n      const port = magnet.getAttribute('port')\n      if (port) {\n        terminal.port = port\n      } else {\n        terminal.selector = view.getSelector(magnet)\n      }\n    }\n    return terminal\n  }\n\n  doLink({ e, x, y }: Handle.EventArgs) {\n    if (this.edgeView) {\n      this.edgeView.onMouseMove(e as JQuery.MouseMoveEvent, x, y)\n    }\n  }\n\n  stopLink({ e, x, y }: Handle.EventArgs) {\n    const edgeView = this.edgeView\n    if (edgeView) {\n      edgeView.onMouseUp(e as JQuery.MouseUpEvent, x, y)\n      const edge = edgeView.cell\n      if (edge.hasLoop()) {\n        this.makeLoopEdge(edge)\n      }\n      this.halo.stopBatch()\n      this.halo.trigger('action:edge:addde', { edge })\n      this.edgeView = null\n    }\n    this.graph.view.delegateEvents()\n  }\n\n  makeLoopEdge(edge: Edge) {\n    let vertex1: Point | null = null\n    let vertex2: Point | null = null\n    const loopEdgeWidth = this.options.loopEdgeWidth!\n    const graphOptions = this.graph.options\n    const graphRect = new Rectangle(\n      0,\n      0,\n      graphOptions.width,\n      graphOptions.height,\n    )\n\n    const bbox = this.graph.graphToLocal(this.view.getBBox())\n    const found = [\n      this.options.loopEdgePreferredSide,\n      'top',\n      'bottom',\n      'left',\n      'right',\n    ].some((position) => {\n      let point: Point | null = null\n      let dx = 0\n      let dy = 0\n      switch (position) {\n        case 'top':\n          point = new Point(bbox.x + bbox.width / 2, bbox.y - loopEdgeWidth)\n          dx = loopEdgeWidth / 2\n          break\n        case 'bottom':\n          point = new Point(\n            bbox.x + bbox.width / 2,\n            bbox.y + bbox.height + loopEdgeWidth,\n          )\n          dx = loopEdgeWidth / 2\n          break\n        case 'left':\n          point = new Point(bbox.x - loopEdgeWidth, bbox.y + bbox.height / 2)\n          dy = loopEdgeWidth / 2\n          break\n        case 'right':\n          point = new Point(\n            bbox.x + bbox.width + loopEdgeWidth,\n            bbox.y + bbox.height / 2,\n          )\n          dy = loopEdgeWidth / 2\n          break\n        default:\n          break\n      }\n\n      if (point) {\n        vertex1 = point.translate(-dx, -dy)\n        vertex2 = point.translate(dx, dy)\n\n        return (\n          graphRect.containsPoint(vertex1) && graphRect.containsPoint(vertex2)\n        )\n      }\n      return false\n    })\n\n    if (found && vertex1 && vertex2) {\n      edge.setVertices([vertex1, vertex2])\n    }\n  }\n\n  // #endregion\n\n  // #region resize\n\n  startResize({ e }: Handle.EventArgs) {\n    this.halo.startBatch()\n    this.flip = [1, 0, 0, 1, 1, 0, 0, 1][\n      Math.floor(Angle.normalize(this.node.getAngle()) / 45)\n    ]\n    this.view.addClass('node-resizing')\n    notify('node:resize', e as JQuery.MouseDownEvent, this.view as NodeView)\n  }\n\n  doResize({ e, dx, dy }: Handle.EventArgs) {\n    const size = this.node.getSize()\n    const width = Math.max(size.width + (this.flip ? dx : dy), 1)\n    const height = Math.max(size.height + (this.flip ? dy : dx), 1)\n    this.node.resize(width, height, {\n      absolute: true,\n    })\n    notify('node:resizing', e as JQuery.MouseMoveEvent, this.view as NodeView)\n  }\n\n  stopResize({ e }: Handle.EventArgs) {\n    this.view.removeClass('node-resizing')\n    notify('node:resized', e as JQuery.MouseUpEvent, this.view as NodeView)\n    this.halo.stopBatch()\n  }\n\n  // #endregion\n\n  // #region clone\n\n  startClone({ e, x, y }: Handle.EventArgs) {\n    this.halo.startBatch()\n    const options = this.options\n    const cloned = options.clone!(this.cell, {\n      clone: true,\n    })\n\n    if (!Cell.isCell(cloned)) {\n      throw new Error(\"option 'clone()' has to return a cell\")\n    }\n\n    this.centerNodeAtCursor(cloned, x, y)\n    this.model.addCell(cloned, {\n      halo: this.halo.cid,\n      async: false,\n    })\n    const cloneView = this.graph.renderer.findViewByCell(cloned) as NodeView\n    cloneView.onMouseDown(e as JQuery.MouseDownEvent, x, y)\n    this.halo.setEventData(e, { cloneView })\n  }\n\n  centerNodeAtCursor(cell: Cell, x: number, y: number) {\n    const center = cell.getBBox().getCenter()\n    const dx = x - center.x\n    const dy = y - center.y\n    cell.translate(dx, dy)\n  }\n\n  doClone({ e, x, y }: Handle.EventArgs) {\n    const view = this.halo.getEventData(e).cloneView as CellView\n    if (view) {\n      view.onMouseMove(e as JQuery.MouseMoveEvent, x, y)\n    }\n  }\n\n  stopClone({ e, x, y }: Handle.EventArgs) {\n    const nodeView = this.halo.getEventData(e).cloneView as NodeView\n    if (nodeView) {\n      nodeView.onMouseUp(e as JQuery.MouseUpEvent, x, y)\n    }\n    this.halo.stopBatch()\n  }\n\n  // #endregion\n\n  // #region fork\n\n  startFork({ e, x, y }: Handle.EventArgs) {\n    this.halo.startBatch()\n\n    const cloned = this.options.clone!(this.cell, {\n      fork: true,\n    })\n\n    if (!Cell.isCell(cloned)) {\n      throw new Error(\"option 'clone()' has to return a cell\")\n    }\n\n    this.centerNodeAtCursor(cloned, x, y)\n    this.model.addCell(cloned, {\n      halo: this.halo.cid,\n      async: false,\n    })\n\n    const edge = this.createEdgeConnectedToSource()\n    const cloneView = this.graph.renderer.findViewByCell(cloned) as CellView\n    const magnet = this.getMagnet(cloneView, 'target')\n    const terminal = this.getEdgeTerminal(cloneView, magnet)\n\n    edge.setTarget(terminal)\n    this.model.addEdge(edge, {\n      halo: this.halo.cid,\n      async: false,\n    })\n\n    cloneView.onMouseDown(e as JQuery.MouseDownEvent, x, y)\n    this.halo.setEventData(e, { cloneView })\n  }\n\n  doFork({ e, x, y }: Handle.EventArgs) {\n    const view = this.halo.getEventData(e).cloneView as CellView\n    if (view) {\n      view.onMouseMove(e as JQuery.MouseMoveEvent, x, y)\n    }\n  }\n\n  stopFork({ e, x, y }: Handle.EventArgs) {\n    const view = this.halo.getEventData(e).cloneView as CellView\n    if (view) {\n      view.onMouseUp(e as JQuery.MouseUpEvent, x, y)\n    }\n    this.halo.stopBatch()\n  }\n\n  // #endregion\n\n  // #region rotate\n\n  startRotate({ e, x, y }: Handle.EventArgs) {\n    this.halo.startBatch()\n    const center = this.node.getBBox().getCenter()\n    const nodes = [this.node]\n    if (this.options.rotateEmbeds) {\n      this.node\n        .getDescendants({\n          deep: true,\n        })\n        .reduce((memo, cell) => {\n          if (cell.isNode()) {\n            memo.push(cell)\n          }\n          return memo\n        }, nodes)\n    }\n\n    this.halo.setEventData(e, {\n      center,\n      nodes,\n      rotateStartAngles: nodes.map((node) => node.getAngle()),\n      clientStartAngle: new Point(x, y).theta(center),\n    })\n\n    nodes.forEach((node) => {\n      const view = this.graph.findViewByCell(node) as NodeView\n      if (view) {\n        view.addClass('node-rotating')\n        notify('node:rotate', e as JQuery.MouseDownEvent, view)\n      }\n    })\n  }\n\n  doRotate({ e, x, y }: Handle.EventArgs) {\n    const data = this.halo.getEventData(e)\n    const delta = data.clientStartAngle - new Point(x, y).theta(data.center)\n    data.nodes.forEach((node: Node, index: number) => {\n      const startAngle = data.rotateStartAngles[index]\n      const targetAngle = Util.snapToGrid(\n        startAngle + delta,\n        this.options.rotateGrid!,\n      )\n      node.rotate(targetAngle, {\n        absolute: true,\n        center: data.center,\n        halo: this.halo.cid,\n      })\n      notify(\n        'node:rotating',\n        e as JQuery.MouseMoveEvent,\n        this.graph.findViewByCell(node) as NodeView,\n      )\n    })\n  }\n\n  stopRotate({ e }: Handle.EventArgs) {\n    const data = this.halo.getEventData(e)\n    data.nodes.forEach((node: Node) => {\n      const view = this.graph.findViewByCell(node) as NodeView\n      view.removeClass('node-rotating')\n      notify('node:rotated', e as JQuery.MouseUpEvent, view)\n    })\n    this.halo.stopBatch()\n  }\n\n  // #endregion\n\n  // #region unlink\n\n  unlink() {\n    this.halo.startBatch()\n    this.model.removeConnectedEdges(this.cell)\n    this.halo.stopBatch()\n  }\n\n  // #endregion\n}\n"],"mappings":"AAAA,SAASA,IAAI,QAAQ,cAAc;AACnC,SAASC,SAAS,EAAEC,WAAW,QAAQ,YAAY;AACnD,SAASC,KAAK,EAAEC,SAAS,EAAEC,KAAK,QAAQ,gBAAgB;AACxD,SAASC,IAAI,QAAQ,kBAAkB;AAOvC,SAASC,MAAM,QAAQ,mBAAmB;AAG1C,OAAM,MAAOC,UAAU;EAIrBC,YAAoBC,IAAU;IAAV,KAAAA,IAAI,GAAJA,IAAI;EAAS;EAEjC,IAAIC,OAAOA,CAAA;IACT,OAAO,IAAI,CAACD,IAAI,CAACC,OAAO;EAC1B;EAEA,IAAIC,KAAKA,CAAA;IACP,OAAO,IAAI,CAACF,IAAI,CAACE,KAAK;EACxB;EAEA,IAAIC,KAAKA,CAAA;IACP,OAAO,IAAI,CAACH,IAAI,CAACG,KAAK;EACxB;EAEA,IAAIC,IAAIA,CAAA;IACN,OAAO,IAAI,CAACJ,IAAI,CAACI,IAAI;EACvB;EAEA,IAAIC,IAAIA,CAAA;IACN,OAAO,IAAI,CAACL,IAAI,CAACK,IAAI;EACvB;EAEA,IAAIC,IAAIA,CAAA;IACN,OAAO,IAAI,CAACD,IAAY;EAC1B;EAEAE,UAAUA,CAAA;IACR,OAAO;MACLC,SAAS,EAAE,WAAW;MACtBC,OAAO,EAAE,CACP;QACEC,IAAI,EAAE,QAAQ;QACdC,QAAQ,EAAE,IAAI;QACdC,MAAM,EAAE;UACNC,SAAS,EAAE,IAAI,CAACC,UAAU,CAACC,IAAI,CAAC,IAAI;SACrC;QACDC,IAAI,EAAE;OACP,EACD;QACEN,IAAI,EAAE,QAAQ;QACdC,QAAQ,EAAE,IAAI;QACdC,MAAM,EAAE;UACNC,SAAS,EAAE,IAAI,CAACI,WAAW,CAACF,IAAI,CAAC,IAAI,CAAC;UACtCG,SAAS,EAAE,IAAI,CAACC,QAAQ,CAACJ,IAAI,CAAC,IAAI,CAAC;UACnCK,OAAO,EAAE,IAAI,CAACC,UAAU,CAACN,IAAI,CAAC,IAAI;SACnC;QACDC,IAAI,EAAE;OACP,EACD;QACEN,IAAI,EAAE,OAAO;QACbC,QAAQ,EAAE,GAAG;QACbC,MAAM,EAAE;UACNC,SAAS,EAAE,IAAI,CAACS,UAAU,CAACP,IAAI,CAAC,IAAI,CAAC;UACrCG,SAAS,EAAE,IAAI,CAACK,OAAO,CAACR,IAAI,CAAC,IAAI,CAAC;UAClCK,OAAO,EAAE,IAAI,CAACI,SAAS,CAACT,IAAI,CAAC,IAAI;SAClC;QACDC,IAAI,EAAE;OACP,EACD;QACEN,IAAI,EAAE,MAAM;QACZC,QAAQ,EAAE,GAAG;QACbC,MAAM,EAAE;UACNC,SAAS,EAAE,IAAI,CAACY,SAAS,CAACV,IAAI,CAAC,IAAI,CAAC;UACpCG,SAAS,EAAE,IAAI,CAACQ,MAAM,CAACX,IAAI,CAAC,IAAI,CAAC;UACjCK,OAAO,EAAE,IAAI,CAACO,QAAQ,CAACZ,IAAI,CAAC,IAAI;SACjC;QACDC,IAAI,EAAE;OACP,EACD;QACEN,IAAI,EAAE,MAAM;QACZC,QAAQ,EAAE,IAAI;QACdC,MAAM,EAAE;UACNC,SAAS,EAAE,IAAI,CAACe,SAAS,CAACb,IAAI,CAAC,IAAI,CAAC;UACpCG,SAAS,EAAE,IAAI,CAACW,MAAM,CAACd,IAAI,CAAC,IAAI,CAAC;UACjCK,OAAO,EAAE,IAAI,CAACU,QAAQ,CAACf,IAAI,CAAC,IAAI;SACjC;QACDC,IAAI,EAAE;OACP,EACD;QACEN,IAAI,EAAE,QAAQ;QACdC,QAAQ,EAAE,GAAG;QACbC,MAAM,EAAE;UACNC,SAAS,EAAE,IAAI,CAACkB,MAAM,CAAChB,IAAI,CAAC,IAAI;SACjC;QACDC,IAAI,EAAE;OACP,EACD;QACEN,IAAI,EAAE,QAAQ;QACdC,QAAQ,EAAE,IAAI;QACdC,MAAM,EAAE;UACNC,SAAS,EAAE,IAAI,CAACmB,WAAW,CAACjB,IAAI,CAAC,IAAI,CAAC;UACtCG,SAAS,EAAE,IAAI,CAACe,QAAQ,CAAClB,IAAI,CAAC,IAAI,CAAC;UACnCK,OAAO,EAAE,IAAI,CAACc,UAAU,CAACnB,IAAI,CAAC,IAAI;SACnC;QACDC,IAAI,EAAE;OACP,CACF;MAEDmB,IAAIA,CAAC/B,IAAI;QACP,IAAI,IAAI,CAACH,OAAO,CAACmC,eAAe,EAAE;UAChC,MAAM9B,IAAI,GAAGF,IAAI,CAACC,IAAY;UAC9B,OAAOC,IAAI,CAAC+B,OAAO,EAAE;;QAEvB,OAAOjC,IAAI,CAACiC,OAAO,EAAE;MACvB,CAAC;MAEDC,OAAOA,CAAClC,IAAI;QACV,MAAMmC,QAAQ,GAAGhD,SAAS,CAACgD,QAAQ,CACjC,2FAA2F,CAC5F;QACD,MAAMlC,IAAI,GAAGD,IAAI,CAACC,IAAY;QAC9B,MAAM8B,IAAI,GAAG9B,IAAI,CAACgC,OAAO,EAAE;QAC3B,OAAOE,QAAQ,CAAC;UACdC,CAAC,EAAEC,IAAI,CAACC,KAAK,CAACP,IAAI,CAACK,CAAC,CAAC;UACrBG,CAAC,EAAEF,IAAI,CAACC,KAAK,CAACP,IAAI,CAACQ,CAAC,CAAC;UACrBC,KAAK,EAAEH,IAAI,CAACC,KAAK,CAACP,IAAI,CAACS,KAAK,CAAC;UAC7BC,MAAM,EAAEJ,IAAI,CAACC,KAAK,CAACP,IAAI,CAACU,MAAM,CAAC;UAC/BC,KAAK,EAAEL,IAAI,CAACC,KAAK,CAACrC,IAAI,CAAC0C,QAAQ,EAAE;SAClC,CAAC;MACJ,CAAC;MACDC,MAAMA,CAAC5C,IAAI;QACT,OAAOA,IAAI,CAAC6C,SAAS;MACvB,CAAC;MACDC,aAAa,EAAE,EAAE;MACjBC,cAAc,EAAE,EAAE;MAClBC,qBAAqB,EAAE,KAAK;MAC5BC,aAAa,EAAE,EAAE;MACjBC,UAAU,EAAE,EAAE;MACdC,YAAY,EAAE;KACf;EACH;EAEAzC,UAAUA,CAAA;IACR,IAAI,CAACX,KAAK,CAACqD,oBAAoB,CAAC,IAAI,CAACnD,IAAI,CAAC;IAC1C,IAAI,CAACA,IAAI,CAACoD,MAAM,EAAE;EACpB;EAEA;EAEAhC,SAASA,CAAC;IAAEe,CAAC;IAAEG;EAAC,CAAoB;IAClC,IAAI,CAAC3C,IAAI,CAAC0D,UAAU,EAAE;IACtB,MAAMxD,KAAK,GAAG,IAAI,CAACA,KAAK;IACxB,MAAMyD,IAAI,GAAG,IAAI,CAACC,2BAA2B,EAAE;IAC/CD,IAAI,CAACE,SAAS,CAAC;MAAErB,CAAC;MAAEG;IAAC,CAAE,CAAC;IACxB,IAAI,CAACxC,KAAK,CAAC2D,OAAO,CAACH,IAAI,EAAE;MACvBI,UAAU,EAAE,KAAK;MACjB/D,IAAI,EAAE,IAAI,CAACA,IAAI,CAACgE,GAAG;MACnBC,KAAK,EAAE;KACR,CAAC;IAEF/D,KAAK,CAACE,IAAI,CAAC8D,gBAAgB,EAAE;IAC7B,IAAI,CAACC,QAAQ,GAAGjE,KAAK,CAACkE,QAAQ,CAACC,cAAc,CAACV,IAAI,CAAa;IAC/D,IAAI,CAACQ,QAAQ,CAACG,wBAAwB,CAAC,QAAQ,EAAE;MAC/C9B,CAAC;MACDG,CAAC;MACD4B,cAAc,EAAE;KACjB,CAAC;EACJ;EAEAX,2BAA2BA,CAAA;IACzB,MAAMZ,MAAM,GAAG,IAAI,CAACwB,SAAS,CAAC,IAAI,CAACpE,IAAI,EAAE,QAAQ,CAAC;IAClD,MAAMqE,QAAQ,GAAG,IAAI,CAACC,eAAe,CAAC,IAAI,CAACtE,IAAI,EAAE4C,MAAM,CAAC;IACxD,MAAMW,IAAI,GAAG,IAAI,CAACzD,KAAK,CAACyE,IAAI,CAACC,cAAc,CAAC,IAAI,CAACxE,IAAI,EAAE4C,MAAM,CAAC;IAC9DW,IAAI,CAACkB,SAAS,CAACJ,QAAQ,CAAC;IACxB,OAAOd,IAAI;EACb;EAEAa,SAASA,CAACpE,IAAc,EAAEqE,QAA2B;IACnD,MAAMzB,MAAM,GAAG,IAAI,CAAC/C,OAAO,CAAC+C,MAAM;IAClC,IAAI,OAAOA,MAAM,KAAK,UAAU,EAAE;MAChC,MAAM8B,GAAG,GAAGtF,WAAW,CAACuF,IAAI,CAAC/B,MAAM,EAAE,IAAI,CAAChD,IAAI,EAAEI,IAAI,EAAEqE,QAAQ,CAAC;MAC/D,IAAIK,GAAG,YAAYE,UAAU,EAAE;QAC7B,OAAOF,GAAG;;;IAGd,MAAM,IAAIG,KAAK,CAAC,wCAAwC,CAAC;EAC3D;EAEAP,eAAeA,CAACtE,IAAc,EAAE4C,MAAe;IAC7C,MAAMyB,QAAQ,GAA0B;MACtCpE,IAAI,EAAED,IAAI,CAACC,IAAI,CAAC6E;KACjB;IACD,IAAIlC,MAAM,KAAK5C,IAAI,CAAC6C,SAAS,EAAE;MAC7B,MAAMkC,IAAI,GAAGnC,MAAM,CAACoC,YAAY,CAAC,MAAM,CAAC;MACxC,IAAID,IAAI,EAAE;QACRV,QAAQ,CAACU,IAAI,GAAGA,IAAI;OACrB,MAAM;QACLV,QAAQ,CAACY,QAAQ,GAAGjF,IAAI,CAACkF,WAAW,CAACtC,MAAM,CAAC;;;IAGhD,OAAOyB,QAAQ;EACjB;EAEA/C,MAAMA,CAAC;IAAE6D,CAAC;IAAE/C,CAAC;IAAEG;EAAC,CAAoB;IAClC,IAAI,IAAI,CAACwB,QAAQ,EAAE;MACjB,IAAI,CAACA,QAAQ,CAACqB,WAAW,CAACD,CAA0B,EAAE/C,CAAC,EAAEG,CAAC,CAAC;;EAE/D;EAEAhB,QAAQA,CAAC;IAAE4D,CAAC;IAAE/C,CAAC;IAAEG;EAAC,CAAoB;IACpC,MAAMwB,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC9B,IAAIA,QAAQ,EAAE;MACZA,QAAQ,CAACsB,SAAS,CAACF,CAAwB,EAAE/C,CAAC,EAAEG,CAAC,CAAC;MAClD,MAAMgB,IAAI,GAAGQ,QAAQ,CAAC9D,IAAI;MAC1B,IAAIsD,IAAI,CAAC+B,OAAO,EAAE,EAAE;QAClB,IAAI,CAACC,YAAY,CAAChC,IAAI,CAAC;;MAEzB,IAAI,CAAC3D,IAAI,CAAC4F,SAAS,EAAE;MACrB,IAAI,CAAC5F,IAAI,CAAC6F,OAAO,CAAC,mBAAmB,EAAE;QAAElC;MAAI,CAAE,CAAC;MAChD,IAAI,CAACQ,QAAQ,GAAG,IAAI;;IAEtB,IAAI,CAACjE,KAAK,CAACE,IAAI,CAAC0F,cAAc,EAAE;EAClC;EAEAH,YAAYA,CAAChC,IAAU;IACrB,IAAIoC,OAAO,GAAiB,IAAI;IAChC,IAAIC,OAAO,GAAiB,IAAI;IAChC,MAAM3C,aAAa,GAAG,IAAI,CAACpD,OAAO,CAACoD,aAAc;IACjD,MAAM4C,YAAY,GAAG,IAAI,CAAC/F,KAAK,CAACD,OAAO;IACvC,MAAMiG,SAAS,GAAG,IAAIxG,SAAS,CAC7B,CAAC,EACD,CAAC,EACDuG,YAAY,CAACrD,KAAK,EAClBqD,YAAY,CAACpD,MAAM,CACpB;IAED,MAAMV,IAAI,GAAG,IAAI,CAACjC,KAAK,CAACiG,YAAY,CAAC,IAAI,CAAC/F,IAAI,CAACiC,OAAO,EAAE,CAAC;IACzD,MAAM+D,KAAK,GAAG,CACZ,IAAI,CAACnG,OAAO,CAACmD,qBAAqB,EAClC,KAAK,EACL,QAAQ,EACR,MAAM,EACN,OAAO,CACR,CAACiD,IAAI,CAAE1F,QAAQ,IAAI;MAClB,IAAI2F,KAAK,GAAiB,IAAI;MAC9B,IAAIC,EAAE,GAAG,CAAC;MACV,IAAIC,EAAE,GAAG,CAAC;MACV,QAAQ7F,QAAQ;QACd,KAAK,KAAK;UACR2F,KAAK,GAAG,IAAI7G,KAAK,CAAC0C,IAAI,CAACK,CAAC,GAAGL,IAAI,CAACS,KAAK,GAAG,CAAC,EAAET,IAAI,CAACQ,CAAC,GAAGU,aAAa,CAAC;UAClEkD,EAAE,GAAGlD,aAAa,GAAG,CAAC;UACtB;QACF,KAAK,QAAQ;UACXiD,KAAK,GAAG,IAAI7G,KAAK,CACf0C,IAAI,CAACK,CAAC,GAAGL,IAAI,CAACS,KAAK,GAAG,CAAC,EACvBT,IAAI,CAACQ,CAAC,GAAGR,IAAI,CAACU,MAAM,GAAGQ,aAAa,CACrC;UACDkD,EAAE,GAAGlD,aAAa,GAAG,CAAC;UACtB;QACF,KAAK,MAAM;UACTiD,KAAK,GAAG,IAAI7G,KAAK,CAAC0C,IAAI,CAACK,CAAC,GAAGa,aAAa,EAAElB,IAAI,CAACQ,CAAC,GAAGR,IAAI,CAACU,MAAM,GAAG,CAAC,CAAC;UACnE2D,EAAE,GAAGnD,aAAa,GAAG,CAAC;UACtB;QACF,KAAK,OAAO;UACViD,KAAK,GAAG,IAAI7G,KAAK,CACf0C,IAAI,CAACK,CAAC,GAAGL,IAAI,CAACS,KAAK,GAAGS,aAAa,EACnClB,IAAI,CAACQ,CAAC,GAAGR,IAAI,CAACU,MAAM,GAAG,CAAC,CACzB;UACD2D,EAAE,GAAGnD,aAAa,GAAG,CAAC;UACtB;QACF;UACE;;MAGJ,IAAIiD,KAAK,EAAE;QACTP,OAAO,GAAGO,KAAK,CAACG,SAAS,CAAC,CAACF,EAAE,EAAE,CAACC,EAAE,CAAC;QACnCR,OAAO,GAAGM,KAAK,CAACG,SAAS,CAACF,EAAE,EAAEC,EAAE,CAAC;QAEjC,OACEN,SAAS,CAACQ,aAAa,CAACX,OAAO,CAAC,IAAIG,SAAS,CAACQ,aAAa,CAACV,OAAO,CAAC;;MAGxE,OAAO,KAAK;IACd,CAAC,CAAC;IAEF,IAAII,KAAK,IAAIL,OAAO,IAAIC,OAAO,EAAE;MAC/BrC,IAAI,CAACgD,WAAW,CAAC,CAACZ,OAAO,EAAEC,OAAO,CAAC,CAAC;;EAExC;EAEA;EAEA;EAEA/E,WAAWA,CAAC;IAAEsE;EAAC,CAAoB;IACjC,IAAI,CAACvF,IAAI,CAAC0D,UAAU,EAAE;IACtB,IAAI,CAACkD,IAAI,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAClCnE,IAAI,CAACC,KAAK,CAAC/C,KAAK,CAACkH,SAAS,CAAC,IAAI,CAACvG,IAAI,CAACyC,QAAQ,EAAE,CAAC,GAAG,EAAE,CAAC,CACvD;IACD,IAAI,CAAC3C,IAAI,CAAC0G,QAAQ,CAAC,eAAe,CAAC;IACnCjH,MAAM,CAAC,aAAa,EAAE0F,CAA0B,EAAE,IAAI,CAACnF,IAAgB,CAAC;EAC1E;EAEAe,QAAQA,CAAC;IAAEoE,CAAC;IAAEgB,EAAE;IAAEC;EAAE,CAAoB;IACtC,MAAMO,IAAI,GAAG,IAAI,CAACzG,IAAI,CAAC0G,OAAO,EAAE;IAChC,MAAMpE,KAAK,GAAGH,IAAI,CAACwE,GAAG,CAACF,IAAI,CAACnE,KAAK,IAAI,IAAI,CAACgE,IAAI,GAAGL,EAAE,GAAGC,EAAE,CAAC,EAAE,CAAC,CAAC;IAC7D,MAAM3D,MAAM,GAAGJ,IAAI,CAACwE,GAAG,CAACF,IAAI,CAAClE,MAAM,IAAI,IAAI,CAAC+D,IAAI,GAAGJ,EAAE,GAAGD,EAAE,CAAC,EAAE,CAAC,CAAC;IAC/D,IAAI,CAACjG,IAAI,CAAC4G,MAAM,CAACtE,KAAK,EAAEC,MAAM,EAAE;MAC9BsE,QAAQ,EAAE;KACX,CAAC;IACFtH,MAAM,CAAC,eAAe,EAAE0F,CAA0B,EAAE,IAAI,CAACnF,IAAgB,CAAC;EAC5E;EAEAiB,UAAUA,CAAC;IAAEkE;EAAC,CAAoB;IAChC,IAAI,CAACnF,IAAI,CAACgH,WAAW,CAAC,eAAe,CAAC;IACtCvH,MAAM,CAAC,cAAc,EAAE0F,CAAwB,EAAE,IAAI,CAACnF,IAAgB,CAAC;IACvE,IAAI,CAACJ,IAAI,CAAC4F,SAAS,EAAE;EACvB;EAEA;EAEA;EAEAtE,UAAUA,CAAC;IAAEiE,CAAC;IAAE/C,CAAC;IAAEG;EAAC,CAAoB;IACtC,IAAI,CAAC3C,IAAI,CAAC0D,UAAU,EAAE;IACtB,MAAMzD,OAAO,GAAG,IAAI,CAACA,OAAO;IAC5B,MAAMoH,MAAM,GAAGpH,OAAO,CAACqH,KAAM,CAAC,IAAI,CAACjH,IAAI,EAAE;MACvCiH,KAAK,EAAE;KACR,CAAC;IAEF,IAAI,CAAC1H,IAAI,CAAC2H,MAAM,CAACF,MAAM,CAAC,EAAE;MACxB,MAAM,IAAIpC,KAAK,CAAC,uCAAuC,CAAC;;IAG1D,IAAI,CAACuC,kBAAkB,CAACH,MAAM,EAAE7E,CAAC,EAAEG,CAAC,CAAC;IACrC,IAAI,CAACxC,KAAK,CAACsH,OAAO,CAACJ,MAAM,EAAE;MACzBrH,IAAI,EAAE,IAAI,CAACA,IAAI,CAACgE,GAAG;MACnBC,KAAK,EAAE;KACR,CAAC;IACF,MAAMyD,SAAS,GAAG,IAAI,CAACxH,KAAK,CAACkE,QAAQ,CAACC,cAAc,CAACgD,MAAM,CAAa;IACxEK,SAAS,CAACC,WAAW,CAACpC,CAA0B,EAAE/C,CAAC,EAAEG,CAAC,CAAC;IACvD,IAAI,CAAC3C,IAAI,CAAC4H,YAAY,CAACrC,CAAC,EAAE;MAAEmC;IAAS,CAAE,CAAC;EAC1C;EAEAF,kBAAkBA,CAACnH,IAAU,EAAEmC,CAAS,EAAEG,CAAS;IACjD,MAAMkF,MAAM,GAAGxH,IAAI,CAACgC,OAAO,EAAE,CAACyF,SAAS,EAAE;IACzC,MAAMvB,EAAE,GAAG/D,CAAC,GAAGqF,MAAM,CAACrF,CAAC;IACvB,MAAMgE,EAAE,GAAG7D,CAAC,GAAGkF,MAAM,CAAClF,CAAC;IACvBtC,IAAI,CAACoG,SAAS,CAACF,EAAE,EAAEC,EAAE,CAAC;EACxB;EAEAjF,OAAOA,CAAC;IAAEgE,CAAC;IAAE/C,CAAC;IAAEG;EAAC,CAAoB;IACnC,MAAMvC,IAAI,GAAG,IAAI,CAACJ,IAAI,CAAC+H,YAAY,CAACxC,CAAC,CAAC,CAACmC,SAAqB;IAC5D,IAAItH,IAAI,EAAE;MACRA,IAAI,CAACoF,WAAW,CAACD,CAA0B,EAAE/C,CAAC,EAAEG,CAAC,CAAC;;EAEtD;EAEAnB,SAASA,CAAC;IAAE+D,CAAC;IAAE/C,CAAC;IAAEG;EAAC,CAAoB;IACrC,MAAMqF,QAAQ,GAAG,IAAI,CAAChI,IAAI,CAAC+H,YAAY,CAACxC,CAAC,CAAC,CAACmC,SAAqB;IAChE,IAAIM,QAAQ,EAAE;MACZA,QAAQ,CAACvC,SAAS,CAACF,CAAwB,EAAE/C,CAAC,EAAEG,CAAC,CAAC;;IAEpD,IAAI,CAAC3C,IAAI,CAAC4F,SAAS,EAAE;EACvB;EAEA;EAEA;EAEAhE,SAASA,CAAC;IAAE2D,CAAC;IAAE/C,CAAC;IAAEG;EAAC,CAAoB;IACrC,IAAI,CAAC3C,IAAI,CAAC0D,UAAU,EAAE;IAEtB,MAAM2D,MAAM,GAAG,IAAI,CAACpH,OAAO,CAACqH,KAAM,CAAC,IAAI,CAACjH,IAAI,EAAE;MAC5C4H,IAAI,EAAE;KACP,CAAC;IAEF,IAAI,CAACrI,IAAI,CAAC2H,MAAM,CAACF,MAAM,CAAC,EAAE;MACxB,MAAM,IAAIpC,KAAK,CAAC,uCAAuC,CAAC;;IAG1D,IAAI,CAACuC,kBAAkB,CAACH,MAAM,EAAE7E,CAAC,EAAEG,CAAC,CAAC;IACrC,IAAI,CAACxC,KAAK,CAACsH,OAAO,CAACJ,MAAM,EAAE;MACzBrH,IAAI,EAAE,IAAI,CAACA,IAAI,CAACgE,GAAG;MACnBC,KAAK,EAAE;KACR,CAAC;IAEF,MAAMN,IAAI,GAAG,IAAI,CAACC,2BAA2B,EAAE;IAC/C,MAAM8D,SAAS,GAAG,IAAI,CAACxH,KAAK,CAACkE,QAAQ,CAACC,cAAc,CAACgD,MAAM,CAAa;IACxE,MAAMrE,MAAM,GAAG,IAAI,CAACwB,SAAS,CAACkD,SAAS,EAAE,QAAQ,CAAC;IAClD,MAAMjD,QAAQ,GAAG,IAAI,CAACC,eAAe,CAACgD,SAAS,EAAE1E,MAAM,CAAC;IAExDW,IAAI,CAACE,SAAS,CAACY,QAAQ,CAAC;IACxB,IAAI,CAACtE,KAAK,CAAC2D,OAAO,CAACH,IAAI,EAAE;MACvB3D,IAAI,EAAE,IAAI,CAACA,IAAI,CAACgE,GAAG;MACnBC,KAAK,EAAE;KACR,CAAC;IAEFyD,SAAS,CAACC,WAAW,CAACpC,CAA0B,EAAE/C,CAAC,EAAEG,CAAC,CAAC;IACvD,IAAI,CAAC3C,IAAI,CAAC4H,YAAY,CAACrC,CAAC,EAAE;MAAEmC;IAAS,CAAE,CAAC;EAC1C;EAEA7F,MAAMA,CAAC;IAAE0D,CAAC;IAAE/C,CAAC;IAAEG;EAAC,CAAoB;IAClC,MAAMvC,IAAI,GAAG,IAAI,CAACJ,IAAI,CAAC+H,YAAY,CAACxC,CAAC,CAAC,CAACmC,SAAqB;IAC5D,IAAItH,IAAI,EAAE;MACRA,IAAI,CAACoF,WAAW,CAACD,CAA0B,EAAE/C,CAAC,EAAEG,CAAC,CAAC;;EAEtD;EAEAb,QAAQA,CAAC;IAAEyD,CAAC;IAAE/C,CAAC;IAAEG;EAAC,CAAoB;IACpC,MAAMvC,IAAI,GAAG,IAAI,CAACJ,IAAI,CAAC+H,YAAY,CAACxC,CAAC,CAAC,CAACmC,SAAqB;IAC5D,IAAItH,IAAI,EAAE;MACRA,IAAI,CAACqF,SAAS,CAACF,CAAwB,EAAE/C,CAAC,EAAEG,CAAC,CAAC;;IAEhD,IAAI,CAAC3C,IAAI,CAAC4F,SAAS,EAAE;EACvB;EAEA;EAEA;EAEA5D,WAAWA,CAAC;IAAEuD,CAAC;IAAE/C,CAAC;IAAEG;EAAC,CAAoB;IACvC,IAAI,CAAC3C,IAAI,CAAC0D,UAAU,EAAE;IACtB,MAAMmE,MAAM,GAAG,IAAI,CAACvH,IAAI,CAAC+B,OAAO,EAAE,CAACyF,SAAS,EAAE;IAC9C,MAAMI,KAAK,GAAG,CAAC,IAAI,CAAC5H,IAAI,CAAC;IACzB,IAAI,IAAI,CAACL,OAAO,CAACsD,YAAY,EAAE;MAC7B,IAAI,CAACjD,IAAI,CACN6H,cAAc,CAAC;QACdC,IAAI,EAAE;OACP,CAAC,CACDC,MAAM,CAAC,CAACC,IAAI,EAAEjI,IAAI,KAAI;QACrB,IAAIA,IAAI,CAACkI,MAAM,EAAE,EAAE;UACjBD,IAAI,CAACE,IAAI,CAACnI,IAAI,CAAC;;QAEjB,OAAOiI,IAAI;MACb,CAAC,EAAEJ,KAAK,CAAC;;IAGb,IAAI,CAAClI,IAAI,CAAC4H,YAAY,CAACrC,CAAC,EAAE;MACxBsC,MAAM;MACNK,KAAK;MACLO,iBAAiB,EAAEP,KAAK,CAACQ,GAAG,CAAEpI,IAAI,IAAKA,IAAI,CAACyC,QAAQ,EAAE,CAAC;MACvD4F,gBAAgB,EAAE,IAAIlJ,KAAK,CAAC+C,CAAC,EAAEG,CAAC,CAAC,CAACiG,KAAK,CAACf,MAAM;KAC/C,CAAC;IAEFK,KAAK,CAACW,OAAO,CAAEvI,IAAI,IAAI;MACrB,MAAMF,IAAI,GAAG,IAAI,CAACF,KAAK,CAACmE,cAAc,CAAC/D,IAAI,CAAa;MACxD,IAAIF,IAAI,EAAE;QACRA,IAAI,CAAC0G,QAAQ,CAAC,eAAe,CAAC;QAC9BjH,MAAM,CAAC,aAAa,EAAE0F,CAA0B,EAAEnF,IAAI,CAAC;;IAE3D,CAAC,CAAC;EACJ;EAEA6B,QAAQA,CAAC;IAAEsD,CAAC;IAAE/C,CAAC;IAAEG;EAAC,CAAoB;IACpC,MAAMmG,IAAI,GAAG,IAAI,CAAC9I,IAAI,CAAC+H,YAAY,CAACxC,CAAC,CAAC;IACtC,MAAMwD,KAAK,GAAGD,IAAI,CAACH,gBAAgB,GAAG,IAAIlJ,KAAK,CAAC+C,CAAC,EAAEG,CAAC,CAAC,CAACiG,KAAK,CAACE,IAAI,CAACjB,MAAM,CAAC;IACxEiB,IAAI,CAACZ,KAAK,CAACW,OAAO,CAAC,CAACvI,IAAU,EAAE0I,KAAa,KAAI;MAC/C,MAAMC,UAAU,GAAGH,IAAI,CAACL,iBAAiB,CAACO,KAAK,CAAC;MAChD,MAAME,WAAW,GAAG5J,IAAI,CAAC6J,UAAU,CACjCF,UAAU,GAAGF,KAAK,EAClB,IAAI,CAAC9I,OAAO,CAACqD,UAAW,CACzB;MACDhD,IAAI,CAAC8I,MAAM,CAACF,WAAW,EAAE;QACvB/B,QAAQ,EAAE,IAAI;QACdU,MAAM,EAAEiB,IAAI,CAACjB,MAAM;QACnB7H,IAAI,EAAE,IAAI,CAACA,IAAI,CAACgE;OACjB,CAAC;MACFnE,MAAM,CACJ,eAAe,EACf0F,CAA0B,EAC1B,IAAI,CAACrF,KAAK,CAACmE,cAAc,CAAC/D,IAAI,CAAa,CAC5C;IACH,CAAC,CAAC;EACJ;EAEA4B,UAAUA,CAAC;IAAEqD;EAAC,CAAoB;IAChC,MAAMuD,IAAI,GAAG,IAAI,CAAC9I,IAAI,CAAC+H,YAAY,CAACxC,CAAC,CAAC;IACtCuD,IAAI,CAACZ,KAAK,CAACW,OAAO,CAAEvI,IAAU,IAAI;MAChC,MAAMF,IAAI,GAAG,IAAI,CAACF,KAAK,CAACmE,cAAc,CAAC/D,IAAI,CAAa;MACxDF,IAAI,CAACgH,WAAW,CAAC,eAAe,CAAC;MACjCvH,MAAM,CAAC,cAAc,EAAE0F,CAAwB,EAAEnF,IAAI,CAAC;IACxD,CAAC,CAAC;IACF,IAAI,CAACJ,IAAI,CAAC4F,SAAS,EAAE;EACvB;EAEA;EAEA;EAEA7D,MAAMA,CAAA;IACJ,IAAI,CAAC/B,IAAI,CAAC0D,UAAU,EAAE;IACtB,IAAI,CAACvD,KAAK,CAACqD,oBAAoB,CAAC,IAAI,CAACnD,IAAI,CAAC;IAC1C,IAAI,CAACL,IAAI,CAAC4F,SAAS,EAAE;EACvB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}