{"ast":null,"code":"import { Dom, ObjectExt, FunctionExt } from '../../util';\nimport { Point, Line } from '../../geometry';\nimport { View } from '../../view/view';\nimport { ToolsView } from '../../view/tool';\nimport * as Util from './util';\nexport class Segments extends ToolsView.ToolItem {\n  constructor() {\n    super(...arguments);\n    this.handles = [];\n  }\n  get vertices() {\n    return this.cellView.cell.getVertices();\n  }\n  update() {\n    this.render();\n    return this;\n  }\n  onRender() {\n    Dom.addClass(this.container, this.prefixClassName('edge-tool-segments'));\n    this.resetHandles();\n    const edgeView = this.cellView;\n    const vertices = [...this.vertices];\n    if (this.options.addRoutePoint === true && vertices.length === 0) {\n      vertices.push(...edgeView.routePoints);\n    }\n    vertices.unshift(edgeView.sourcePoint);\n    vertices.push(edgeView.targetPoint);\n    for (let i = 0, l = vertices.length; i < l - 1; i += 1) {\n      const vertex = vertices[i];\n      const nextVertex = vertices[i + 1];\n      const handle = this.renderHandle(vertex, nextVertex, i);\n      this.stamp(handle.container);\n      this.handles.push(handle);\n    }\n    return this;\n  }\n  renderHandle(vertex, nextVertex, index) {\n    const handle = this.options.createHandle({\n      index,\n      graph: this.graph,\n      guard: evt => this.guard(evt),\n      attrs: this.options.attrs || {}\n    });\n    if (this.options.processHandle) {\n      this.options.processHandle(handle);\n    }\n    this.graph.hook.onToolItemCreated({\n      name: 'segments',\n      cell: this.cell,\n      view: this.cellView,\n      tool: handle\n    });\n    this.updateHandle(handle, vertex, nextVertex);\n    this.container.appendChild(handle.container);\n    this.startHandleListening(handle);\n    return handle;\n  }\n  startHandleListening(handle) {\n    handle.on('change', this.onHandleChange, this);\n    handle.on('changing', this.onHandleChanging, this);\n    handle.on('changed', this.onHandleChanged, this);\n  }\n  stopHandleListening(handle) {\n    handle.off('change', this.onHandleChange, this);\n    handle.off('changing', this.onHandleChanging, this);\n    handle.off('changed', this.onHandleChanged, this);\n  }\n  resetHandles() {\n    const handles = this.handles;\n    this.handles = [];\n    if (handles) {\n      handles.forEach(handle => {\n        this.stopHandleListening(handle);\n        handle.remove();\n      });\n    }\n  }\n  shiftHandleIndexes(delta) {\n    const handles = this.handles;\n    for (let i = 0, n = handles.length; i < n; i += 1) {\n      handles[i].options.index += delta;\n    }\n  }\n  resetAnchor(type, anchor) {\n    const edge = this.cellView.cell;\n    const options = {\n      ui: true,\n      toolId: this.cid\n    };\n    if (anchor) {\n      edge.prop([type, 'anchor'], anchor, options);\n    } else {\n      edge.removeProp([type, 'anchor'], options);\n    }\n  }\n  snapHandle(handle, position, data) {\n    const axis = handle.options.axis;\n    const index = handle.options.index;\n    const edgeView = this.cellView;\n    const edge = edgeView.cell;\n    const vertices = edge.getVertices();\n    const prev = vertices[index - 2] || data.sourceAnchor;\n    const next = vertices[index + 1] || data.targetAnchor;\n    const snapRadius = this.options.snapRadius;\n    if (Math.abs(position[axis] - prev[axis]) < snapRadius) {\n      position[axis] = prev[axis];\n    } else if (Math.abs(position[axis] - next[axis]) < snapRadius) {\n      position[axis] = next[axis];\n    }\n    return position;\n  }\n  onHandleChanging({\n    handle,\n    e\n  }) {\n    const graph = this.graph;\n    const options = this.options;\n    const edgeView = this.cellView;\n    const anchorFn = options.anchor;\n    const axis = handle.options.axis;\n    const index = handle.options.index - 1;\n    const data = this.getEventData(e);\n    const evt = this.normalizeEvent(e);\n    const coords = graph.snapToGrid(evt.clientX, evt.clientY);\n    const position = this.snapHandle(handle, coords.clone(), data);\n    const vertices = ObjectExt.cloneDeep(this.vertices);\n    let vertex = vertices[index];\n    let nextVertex = vertices[index + 1];\n    // First Segment\n    const sourceView = edgeView.sourceView;\n    const sourceBBox = edgeView.sourceBBox;\n    let changeSourceAnchor = false;\n    let deleteSourceAnchor = false;\n    if (!vertex) {\n      vertex = edgeView.sourceAnchor.toJSON();\n      vertex[axis] = position[axis];\n      if (sourceBBox.containsPoint(vertex)) {\n        changeSourceAnchor = true;\n      } else {\n        vertices.unshift(vertex);\n        this.shiftHandleIndexes(1);\n        deleteSourceAnchor = true;\n      }\n    } else if (index === 0) {\n      if (sourceBBox.containsPoint(vertex)) {\n        vertices.shift();\n        this.shiftHandleIndexes(-1);\n        changeSourceAnchor = true;\n      } else {\n        vertex[axis] = position[axis];\n        deleteSourceAnchor = true;\n      }\n    } else {\n      vertex[axis] = position[axis];\n    }\n    if (typeof anchorFn === 'function' && sourceView) {\n      if (changeSourceAnchor) {\n        const sourceAnchorPosition = data.sourceAnchor.clone();\n        sourceAnchorPosition[axis] = position[axis];\n        const sourceAnchor = FunctionExt.call(anchorFn, edgeView, sourceAnchorPosition, sourceView, edgeView.sourceMagnet || sourceView.container, 'source', edgeView, this);\n        this.resetAnchor('source', sourceAnchor);\n      }\n      if (deleteSourceAnchor) {\n        this.resetAnchor('source', data.sourceAnchorDef);\n      }\n    }\n    // Last segment\n    const targetView = edgeView.targetView;\n    const targetBBox = edgeView.targetBBox;\n    let changeTargetAnchor = false;\n    let deleteTargetAnchor = false;\n    if (!nextVertex) {\n      nextVertex = edgeView.targetAnchor.toJSON();\n      nextVertex[axis] = position[axis];\n      if (targetBBox.containsPoint(nextVertex)) {\n        changeTargetAnchor = true;\n      } else {\n        vertices.push(nextVertex);\n        deleteTargetAnchor = true;\n      }\n    } else if (index === vertices.length - 2) {\n      if (targetBBox.containsPoint(nextVertex)) {\n        vertices.pop();\n        changeTargetAnchor = true;\n      } else {\n        nextVertex[axis] = position[axis];\n        deleteTargetAnchor = true;\n      }\n    } else {\n      nextVertex[axis] = position[axis];\n    }\n    if (typeof anchorFn === 'function' && targetView) {\n      if (changeTargetAnchor) {\n        const targetAnchorPosition = data.targetAnchor.clone();\n        targetAnchorPosition[axis] = position[axis];\n        const targetAnchor = FunctionExt.call(anchorFn, edgeView, targetAnchorPosition, targetView, edgeView.targetMagnet || targetView.container, 'target', edgeView, this);\n        this.resetAnchor('target', targetAnchor);\n      }\n      if (deleteTargetAnchor) {\n        this.resetAnchor('target', data.targetAnchorDef);\n      }\n    }\n    if (!Point.equalPoints(vertices, this.vertices)) {\n      this.cellView.cell.setVertices(vertices, {\n        ui: true,\n        toolId: this.cid\n      });\n    }\n    this.updateHandle(handle, vertex, nextVertex, 0);\n    if (!options.stopPropagation) {\n      edgeView.notifyMouseMove(evt, coords.x, coords.y);\n    }\n  }\n  onHandleChange({\n    handle,\n    e\n  }) {\n    const options = this.options;\n    const handles = this.handles;\n    const edgeView = this.cellView;\n    const index = handle.options.index;\n    if (!Array.isArray(handles)) {\n      return;\n    }\n    for (let i = 0, n = handles.length; i < n; i += 1) {\n      if (i !== index) {\n        handles[i].hide();\n      }\n    }\n    this.focus();\n    this.setEventData(e, {\n      sourceAnchor: edgeView.sourceAnchor.clone(),\n      targetAnchor: edgeView.targetAnchor.clone(),\n      sourceAnchorDef: ObjectExt.cloneDeep(this.cell.prop(['source', 'anchor'])),\n      targetAnchorDef: ObjectExt.cloneDeep(this.cell.prop(['target', 'anchor']))\n    });\n    this.cell.startBatch('move-segment', {\n      ui: true,\n      toolId: this.cid\n    });\n    if (!options.stopPropagation) {\n      const normalizedEvent = this.normalizeEvent(e);\n      const coords = this.graph.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n      edgeView.notifyMouseDown(normalizedEvent, coords.x, coords.y);\n    }\n  }\n  onHandleChanged({\n    e\n  }) {\n    const options = this.options;\n    const edgeView = this.cellView;\n    if (options.removeRedundancies) {\n      edgeView.removeRedundantLinearVertices({\n        ui: true,\n        toolId: this.cid\n      });\n    }\n    const normalizedEvent = this.normalizeEvent(e);\n    const coords = this.graph.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n    this.render();\n    this.blur();\n    this.cell.stopBatch('move-segment', {\n      ui: true,\n      toolId: this.cid\n    });\n    if (!options.stopPropagation) {\n      edgeView.notifyMouseUp(normalizedEvent, coords.x, coords.y);\n    }\n    edgeView.checkMouseleave(normalizedEvent);\n    options.onChanged && options.onChanged({\n      edge: edgeView.cell,\n      edgeView\n    });\n  }\n  updateHandle(handle, vertex, nextVertex, offset = 0) {\n    const precision = this.options.precision || 0;\n    const vertical = Math.abs(vertex.x - nextVertex.x) < precision;\n    const horizontal = Math.abs(vertex.y - nextVertex.y) < precision;\n    if (vertical || horizontal) {\n      const segmentLine = new Line(vertex, nextVertex);\n      const length = segmentLine.length();\n      if (length < this.options.threshold) {\n        handle.hide();\n      } else {\n        const position = segmentLine.getCenter();\n        const axis = vertical ? 'x' : 'y';\n        position[axis] += offset || 0;\n        const angle = segmentLine.vector().vectorAngle(new Point(1, 0));\n        handle.updatePosition(position.x, position.y, angle, this.cellView);\n        handle.show();\n        handle.options.axis = axis;\n      }\n    } else {\n      handle.hide();\n    }\n  }\n  onRemove() {\n    this.resetHandles();\n  }\n}\n(function (Segments) {\n  class Handle extends View {\n    constructor(options) {\n      super();\n      this.options = options;\n      this.render();\n      this.delegateEvents({\n        mousedown: 'onMouseDown',\n        touchstart: 'onMouseDown'\n      });\n    }\n    render() {\n      this.container = View.createElement('rect', true);\n      const attrs = this.options.attrs;\n      if (typeof attrs === 'function') {\n        const defaults = Segments.getDefaults();\n        this.setAttrs(Object.assign(Object.assign({}, defaults.attrs), attrs(this)));\n      } else {\n        this.setAttrs(attrs);\n      }\n      this.addClass(this.prefixClassName('edge-tool-segment'));\n    }\n    updatePosition(x, y, angle, view) {\n      const p = view.getClosestPoint(new Point(x, y)) || new Point(x, y);\n      let matrix = Dom.createSVGMatrix().translate(p.x, p.y);\n      if (!p.equals({\n        x,\n        y\n      })) {\n        const line = new Line(x, y, p.x, p.y);\n        let deg = line.vector().vectorAngle(new Point(1, 0));\n        if (deg !== 0) {\n          deg += 90;\n        }\n        matrix = matrix.rotate(deg);\n      } else {\n        matrix = matrix.rotate(angle);\n      }\n      this.setAttrs({\n        transform: Dom.matrixToTransformString(matrix),\n        cursor: angle % 180 === 0 ? 'row-resize' : 'col-resize'\n      });\n    }\n    onMouseDown(evt) {\n      if (this.options.guard(evt)) {\n        return;\n      }\n      this.trigger('change', {\n        e: evt,\n        handle: this\n      });\n      evt.stopPropagation();\n      evt.preventDefault();\n      this.options.graph.view.undelegateEvents();\n      this.delegateDocumentEvents({\n        mousemove: 'onMouseMove',\n        touchmove: 'onMouseMove',\n        mouseup: 'onMouseUp',\n        touchend: 'onMouseUp',\n        touchcancel: 'onMouseUp'\n      }, evt.data);\n    }\n    onMouseMove(evt) {\n      this.emit('changing', {\n        e: evt,\n        handle: this\n      });\n    }\n    onMouseUp(evt) {\n      this.emit('changed', {\n        e: evt,\n        handle: this\n      });\n      this.undelegateDocumentEvents();\n      this.options.graph.view.delegateEvents();\n    }\n    show() {\n      this.container.style.display = '';\n    }\n    hide() {\n      this.container.style.display = 'none';\n    }\n  }\n  Segments.Handle = Handle;\n})(Segments || (Segments = {}));\n(function (Segments) {\n  Segments.config({\n    name: 'segments',\n    precision: 0.5,\n    threshold: 40,\n    snapRadius: 10,\n    stopPropagation: true,\n    removeRedundancies: true,\n    attrs: {\n      width: 20,\n      height: 8,\n      x: -10,\n      y: -4,\n      rx: 4,\n      ry: 4,\n      fill: '#333',\n      stroke: '#fff',\n      'stroke-width': 2\n    },\n    createHandle: options => new Segments.Handle(options),\n    anchor: Util.getAnchor,\n    addRoutePoint: false\n  });\n})(Segments || (Segments = {}));","map":{"version":3,"names":["Dom","ObjectExt","FunctionExt","Point","Line","View","ToolsView","Util","Segments","ToolItem","constructor","handles","vertices","cellView","cell","getVertices","update","render","onRender","addClass","container","prefixClassName","resetHandles","edgeView","options","addRoutePoint","length","push","routePoints","unshift","sourcePoint","targetPoint","i","l","vertex","nextVertex","handle","renderHandle","stamp","index","createHandle","graph","guard","evt","attrs","processHandle","hook","onToolItemCreated","name","view","tool","updateHandle","appendChild","startHandleListening","on","onHandleChange","onHandleChanging","onHandleChanged","stopHandleListening","off","forEach","remove","shiftHandleIndexes","delta","n","resetAnchor","type","anchor","edge","ui","toolId","cid","prop","removeProp","snapHandle","position","data","axis","prev","sourceAnchor","next","targetAnchor","snapRadius","Math","abs","e","anchorFn","getEventData","normalizeEvent","coords","snapToGrid","clientX","clientY","clone","cloneDeep","sourceView","sourceBBox","changeSourceAnchor","deleteSourceAnchor","toJSON","containsPoint","shift","sourceAnchorPosition","call","sourceMagnet","sourceAnchorDef","targetView","targetBBox","changeTargetAnchor","deleteTargetAnchor","pop","targetAnchorPosition","targetMagnet","targetAnchorDef","equalPoints","setVertices","stopPropagation","notifyMouseMove","x","y","Array","isArray","hide","focus","setEventData","startBatch","normalizedEvent","notifyMouseDown","removeRedundancies","removeRedundantLinearVertices","blur","stopBatch","notifyMouseUp","checkMouseleave","onChanged","offset","precision","vertical","horizontal","segmentLine","threshold","getCenter","angle","vector","vectorAngle","updatePosition","show","onRemove","Handle","delegateEvents","mousedown","touchstart","createElement","defaults","getDefaults","setAttrs","Object","assign","p","getClosestPoint","matrix","createSVGMatrix","translate","equals","line","deg","rotate","transform","matrixToTransformString","cursor","onMouseDown","trigger","preventDefault","undelegateEvents","delegateDocumentEvents","mousemove","touchmove","mouseup","touchend","touchcancel","onMouseMove","emit","onMouseUp","undelegateDocumentEvents","style","display","config","width","height","rx","ry","fill","stroke","getAnchor"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/registry/tool/segments.ts"],"sourcesContent":["import { Dom, ObjectExt, FunctionExt } from '../../util'\nimport { Point, Line } from '../../geometry'\nimport { Graph } from '../../graph'\nimport { Edge } from '../../model/edge'\nimport { View } from '../../view/view'\nimport { CellView } from '../../view/cell'\nimport { EdgeView } from '../../view/edge'\nimport { ToolsView } from '../../view/tool'\nimport * as Util from './util'\nimport { Attr } from '../attr'\n\nexport class Segments extends ToolsView.ToolItem<EdgeView, Segments.Options> {\n  protected handles: Segments.Handle[] = []\n\n  protected get vertices() {\n    return this.cellView.cell.getVertices()\n  }\n\n  update() {\n    this.render()\n    return this\n  }\n\n  protected onRender() {\n    Dom.addClass(this.container, this.prefixClassName('edge-tool-segments'))\n    this.resetHandles()\n    const edgeView = this.cellView\n    const vertices = [...this.vertices]\n    if (this.options.addRoutePoint === true && vertices.length === 0) {\n      vertices.push(...edgeView.routePoints)\n    }\n    vertices.unshift(edgeView.sourcePoint)\n    vertices.push(edgeView.targetPoint)\n\n    for (let i = 0, l = vertices.length; i < l - 1; i += 1) {\n      const vertex = vertices[i]\n      const nextVertex = vertices[i + 1]\n      const handle = this.renderHandle(vertex, nextVertex, i)\n      this.stamp(handle.container)\n      this.handles.push(handle)\n    }\n    return this\n  }\n\n  protected renderHandle(\n    vertex: Point.PointLike,\n    nextVertex: Point.PointLike,\n    index: number,\n  ) {\n    const handle = this.options.createHandle!({\n      index,\n      graph: this.graph,\n      guard: (evt) => this.guard(evt),\n      attrs: this.options.attrs || {},\n    })\n\n    if (this.options.processHandle) {\n      this.options.processHandle(handle)\n    }\n\n    this.graph.hook.onToolItemCreated({\n      name: 'segments',\n      cell: this.cell,\n      view: this.cellView,\n      tool: handle,\n    })\n\n    this.updateHandle(handle, vertex, nextVertex)\n    this.container.appendChild(handle.container)\n    this.startHandleListening(handle)\n    return handle\n  }\n\n  protected startHandleListening(handle: Segments.Handle) {\n    handle.on('change', this.onHandleChange, this)\n    handle.on('changing', this.onHandleChanging, this)\n    handle.on('changed', this.onHandleChanged, this)\n  }\n\n  protected stopHandleListening(handle: Segments.Handle) {\n    handle.off('change', this.onHandleChange, this)\n    handle.off('changing', this.onHandleChanging, this)\n    handle.off('changed', this.onHandleChanged, this)\n  }\n\n  protected resetHandles() {\n    const handles = this.handles\n    this.handles = []\n    if (handles) {\n      handles.forEach((handle) => {\n        this.stopHandleListening(handle)\n        handle.remove()\n      })\n    }\n  }\n\n  protected shiftHandleIndexes(delta: number) {\n    const handles = this.handles\n    for (let i = 0, n = handles.length; i < n; i += 1) {\n      handles[i].options.index! += delta\n    }\n  }\n\n  protected resetAnchor(\n    type: Edge.TerminalType,\n    anchor: Edge.TerminalCellData['anchor'],\n  ) {\n    const edge = this.cellView.cell\n    const options = {\n      ui: true,\n      toolId: this.cid,\n    }\n\n    if (anchor) {\n      edge.prop([type, 'anchor'], anchor, options)\n    } else {\n      edge.removeProp([type, 'anchor'], options)\n    }\n  }\n\n  protected snapHandle(\n    handle: Segments.Handle,\n    position: Point.PointLike,\n    data: Segments.EventData,\n  ) {\n    const axis = handle.options.axis!\n    const index = handle.options.index!\n    const edgeView = this.cellView\n    const edge = edgeView.cell\n    const vertices = edge.getVertices()\n    const prev = vertices[index - 2] || data.sourceAnchor\n    const next = vertices[index + 1] || data.targetAnchor\n    const snapRadius = this.options.snapRadius\n    if (Math.abs(position[axis] - prev[axis]) < snapRadius) {\n      position[axis] = prev[axis]\n    } else if (Math.abs(position[axis] - next[axis]) < snapRadius) {\n      position[axis] = next[axis]\n    }\n    return position\n  }\n\n  protected onHandleChanging({\n    handle,\n    e,\n  }: Segments.Handle.EventArgs['changing']) {\n    const graph = this.graph\n    const options = this.options\n    const edgeView = this.cellView\n    const anchorFn = options.anchor\n\n    const axis = handle.options.axis!\n    const index = handle.options.index! - 1\n\n    const data = this.getEventData<Segments.EventData>(e)\n    const evt = this.normalizeEvent(e)\n    const coords = graph.snapToGrid(evt.clientX, evt.clientY)\n    const position = this.snapHandle(handle, coords.clone(), data)\n    const vertices = ObjectExt.cloneDeep(this.vertices)\n    let vertex = vertices[index]\n    let nextVertex = vertices[index + 1]\n\n    // First Segment\n    const sourceView = edgeView.sourceView\n    const sourceBBox = edgeView.sourceBBox\n    let changeSourceAnchor = false\n    let deleteSourceAnchor = false\n\n    if (!vertex) {\n      vertex = edgeView.sourceAnchor.toJSON()\n      vertex[axis] = position[axis]\n      if (sourceBBox.containsPoint(vertex)) {\n        changeSourceAnchor = true\n      } else {\n        vertices.unshift(vertex)\n        this.shiftHandleIndexes(1)\n        deleteSourceAnchor = true\n      }\n    } else if (index === 0) {\n      if (sourceBBox.containsPoint(vertex)) {\n        vertices.shift()\n        this.shiftHandleIndexes(-1)\n        changeSourceAnchor = true\n      } else {\n        vertex[axis] = position[axis]\n        deleteSourceAnchor = true\n      }\n    } else {\n      vertex[axis] = position[axis]\n    }\n\n    if (typeof anchorFn === 'function' && sourceView) {\n      if (changeSourceAnchor) {\n        const sourceAnchorPosition = data.sourceAnchor.clone()\n        sourceAnchorPosition[axis] = position[axis]\n        const sourceAnchor = FunctionExt.call(\n          anchorFn,\n          edgeView,\n          sourceAnchorPosition,\n          sourceView,\n          edgeView.sourceMagnet || sourceView.container,\n          'source',\n          edgeView,\n          this,\n        )\n        this.resetAnchor('source', sourceAnchor)\n      }\n\n      if (deleteSourceAnchor) {\n        this.resetAnchor('source', data.sourceAnchorDef)\n      }\n    }\n\n    // Last segment\n    const targetView = edgeView.targetView\n    const targetBBox = edgeView.targetBBox\n    let changeTargetAnchor = false\n    let deleteTargetAnchor = false\n    if (!nextVertex) {\n      nextVertex = edgeView.targetAnchor.toJSON()\n      nextVertex[axis] = position[axis]\n      if (targetBBox.containsPoint(nextVertex)) {\n        changeTargetAnchor = true\n      } else {\n        vertices.push(nextVertex)\n        deleteTargetAnchor = true\n      }\n    } else if (index === vertices.length - 2) {\n      if (targetBBox.containsPoint(nextVertex)) {\n        vertices.pop()\n        changeTargetAnchor = true\n      } else {\n        nextVertex[axis] = position[axis]\n        deleteTargetAnchor = true\n      }\n    } else {\n      nextVertex[axis] = position[axis]\n    }\n\n    if (typeof anchorFn === 'function' && targetView) {\n      if (changeTargetAnchor) {\n        const targetAnchorPosition = data.targetAnchor.clone()\n        targetAnchorPosition[axis] = position[axis]\n        const targetAnchor = FunctionExt.call(\n          anchorFn,\n          edgeView,\n          targetAnchorPosition,\n          targetView,\n          edgeView.targetMagnet || targetView.container,\n          'target',\n          edgeView,\n          this,\n        )\n        this.resetAnchor('target', targetAnchor)\n      }\n      if (deleteTargetAnchor) {\n        this.resetAnchor('target', data.targetAnchorDef)\n      }\n    }\n\n    if (!Point.equalPoints(vertices, this.vertices)) {\n      this.cellView.cell.setVertices(vertices, { ui: true, toolId: this.cid })\n    }\n\n    this.updateHandle(handle, vertex, nextVertex, 0)\n    if (!options.stopPropagation) {\n      edgeView.notifyMouseMove(evt, coords.x, coords.y)\n    }\n  }\n\n  protected onHandleChange({ handle, e }: Segments.Handle.EventArgs['change']) {\n    const options = this.options\n    const handles = this.handles\n    const edgeView = this.cellView\n\n    const index = handle.options.index\n    if (!Array.isArray(handles)) {\n      return\n    }\n\n    for (let i = 0, n = handles.length; i < n; i += 1) {\n      if (i !== index) {\n        handles[i].hide()\n      }\n    }\n\n    this.focus()\n    this.setEventData<Segments.EventData>(e, {\n      sourceAnchor: edgeView.sourceAnchor.clone(),\n      targetAnchor: edgeView.targetAnchor.clone(),\n      sourceAnchorDef: ObjectExt.cloneDeep(\n        this.cell.prop(['source', 'anchor']),\n      ),\n      targetAnchorDef: ObjectExt.cloneDeep(\n        this.cell.prop(['target', 'anchor']),\n      ),\n    })\n\n    this.cell.startBatch('move-segment', { ui: true, toolId: this.cid })\n\n    if (!options.stopPropagation) {\n      const normalizedEvent = this.normalizeEvent(e)\n      const coords = this.graph.snapToGrid(\n        normalizedEvent.clientX,\n        normalizedEvent.clientY,\n      )\n      edgeView.notifyMouseDown(normalizedEvent, coords.x, coords.y)\n    }\n  }\n\n  protected onHandleChanged({ e }: Segments.Handle.EventArgs['changed']) {\n    const options = this.options\n    const edgeView = this.cellView\n    if (options.removeRedundancies) {\n      edgeView.removeRedundantLinearVertices({ ui: true, toolId: this.cid })\n    }\n\n    const normalizedEvent = this.normalizeEvent(e)\n    const coords = this.graph.snapToGrid(\n      normalizedEvent.clientX,\n      normalizedEvent.clientY,\n    )\n\n    this.render()\n    this.blur()\n\n    this.cell.stopBatch('move-segment', { ui: true, toolId: this.cid })\n    if (!options.stopPropagation) {\n      edgeView.notifyMouseUp(normalizedEvent, coords.x, coords.y)\n    }\n    edgeView.checkMouseleave(normalizedEvent)\n\n    options.onChanged && options.onChanged({ edge: edgeView.cell, edgeView })\n  }\n\n  protected updateHandle(\n    handle: Segments.Handle,\n    vertex: Point.PointLike,\n    nextVertex: Point.PointLike,\n    offset = 0,\n  ) {\n    const precision = this.options.precision || 0\n    const vertical = Math.abs(vertex.x - nextVertex.x) < precision\n    const horizontal = Math.abs(vertex.y - nextVertex.y) < precision\n    if (vertical || horizontal) {\n      const segmentLine = new Line(vertex, nextVertex)\n      const length = segmentLine.length()\n      if (length < this.options.threshold) {\n        handle.hide()\n      } else {\n        const position = segmentLine.getCenter()\n        const axis = vertical ? 'x' : 'y'\n        position[axis] += offset || 0\n        const angle = segmentLine.vector().vectorAngle(new Point(1, 0))\n        handle.updatePosition(position.x, position.y, angle, this.cellView)\n        handle.show()\n        handle.options.axis = axis\n      }\n    } else {\n      handle.hide()\n    }\n  }\n\n  protected onRemove() {\n    this.resetHandles()\n  }\n}\n\nexport namespace Segments {\n  export interface Options extends ToolsView.ToolItem.Options {\n    threshold: number\n    precision?: number\n    snapRadius: number\n    stopPropagation: boolean\n    removeRedundancies: boolean\n    attrs: Attr.SimpleAttrs | ((handle: Handle) => Attr.SimpleAttrs)\n    anchor?: (\n      this: EdgeView,\n      pos: Point,\n      terminalView: CellView,\n      terminalMagnet: Element | null,\n      terminalType: Edge.TerminalType,\n      edgeView: EdgeView,\n      toolView: Segments,\n    ) => Edge.TerminalCellData['anchor']\n    createHandle?: (options: Handle.Options) => Handle\n    processHandle?: (handle: Handle) => void\n    onChanged?: (options: { edge: Edge; edgeView: EdgeView }) => void\n    addRoutePoint?: boolean\n  }\n\n  export interface EventData {\n    sourceAnchor: Point\n    targetAnchor: Point\n    sourceAnchorDef: Edge.TerminalCellData['anchor']\n    targetAnchorDef: Edge.TerminalCellData['anchor']\n  }\n}\n\nexport namespace Segments {\n  export class Handle extends View<Handle.EventArgs> {\n    public container: SVGRectElement\n\n    constructor(public options: Handle.Options) {\n      super()\n      this.render()\n      this.delegateEvents({\n        mousedown: 'onMouseDown',\n        touchstart: 'onMouseDown',\n      })\n    }\n\n    render() {\n      this.container = View.createElement('rect', true) as SVGRectElement\n      const attrs = this.options.attrs\n      if (typeof attrs === 'function') {\n        const defaults = Segments.getDefaults<Segments.Options>()\n        this.setAttrs({\n          ...defaults.attrs,\n          ...attrs(this),\n        })\n      } else {\n        this.setAttrs(attrs)\n      }\n      this.addClass(this.prefixClassName('edge-tool-segment'))\n    }\n\n    updatePosition(x: number, y: number, angle: number, view: EdgeView) {\n      const p = view.getClosestPoint(new Point(x, y)) || new Point(x, y)\n      let matrix = Dom.createSVGMatrix().translate(p.x, p.y)\n      if (!p.equals({ x, y })) {\n        const line = new Line(x, y, p.x, p.y)\n        let deg = line.vector().vectorAngle(new Point(1, 0))\n        if (deg !== 0) {\n          deg += 90\n        }\n        matrix = matrix.rotate(deg)\n      } else {\n        matrix = matrix.rotate(angle)\n      }\n\n      this.setAttrs({\n        transform: Dom.matrixToTransformString(matrix),\n        cursor: angle % 180 === 0 ? 'row-resize' : 'col-resize',\n      })\n    }\n\n    protected onMouseDown(evt: JQuery.MouseDownEvent) {\n      if (this.options.guard(evt)) {\n        return\n      }\n\n      this.trigger('change', { e: evt, handle: this })\n\n      evt.stopPropagation()\n      evt.preventDefault()\n      this.options.graph.view.undelegateEvents()\n      this.delegateDocumentEvents(\n        {\n          mousemove: 'onMouseMove',\n          touchmove: 'onMouseMove',\n          mouseup: 'onMouseUp',\n          touchend: 'onMouseUp',\n          touchcancel: 'onMouseUp',\n        },\n        evt.data,\n      )\n    }\n\n    protected onMouseMove(evt: JQuery.MouseMoveEvent) {\n      this.emit('changing', { e: evt, handle: this })\n    }\n\n    protected onMouseUp(evt: JQuery.MouseUpEvent) {\n      this.emit('changed', { e: evt, handle: this })\n      this.undelegateDocumentEvents()\n      this.options.graph.view.delegateEvents()\n    }\n\n    show() {\n      this.container.style.display = ''\n    }\n\n    hide() {\n      this.container.style.display = 'none'\n    }\n  }\n\n  export namespace Handle {\n    export interface Options {\n      graph: Graph\n      guard: (evt: JQuery.TriggeredEvent) => boolean\n      attrs: Attr.SimpleAttrs | ((handle: Handle) => Attr.SimpleAttrs)\n      index?: number\n      axis?: 'x' | 'y'\n    }\n\n    export interface EventArgs {\n      change: { e: JQuery.MouseDownEvent; handle: Handle }\n      changing: { e: JQuery.MouseMoveEvent; handle: Handle }\n      changed: { e: JQuery.MouseUpEvent; handle: Handle }\n    }\n  }\n}\n\nexport namespace Segments {\n  Segments.config<Options>({\n    name: 'segments',\n    precision: 0.5,\n    threshold: 40,\n    snapRadius: 10,\n    stopPropagation: true,\n    removeRedundancies: true,\n    attrs: {\n      width: 20,\n      height: 8,\n      x: -10,\n      y: -4,\n      rx: 4,\n      ry: 4,\n      fill: '#333',\n      stroke: '#fff',\n      'stroke-width': 2,\n    },\n    createHandle: (options) => new Handle(options),\n    anchor: Util.getAnchor,\n    addRoutePoint: false,\n  })\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}