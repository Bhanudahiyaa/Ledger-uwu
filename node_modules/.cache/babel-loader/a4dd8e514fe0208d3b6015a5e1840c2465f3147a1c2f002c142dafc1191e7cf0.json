{"ast":null,"code":"export var getBBoxFromPoint = function getBBoxFromPoint(point) {\n  var x = point.x,\n    y = point.y;\n  return {\n    x: x,\n    y: y,\n    centerX: x,\n    centerY: y,\n    minX: x,\n    minY: y,\n    maxX: x,\n    maxY: y,\n    height: 0,\n    width: 0\n  };\n};\nexport var getBBoxFromPoints = function getBBoxFromPoints(points) {\n  if (points === void 0) {\n    points = [];\n  }\n  var xs = [];\n  var ys = [];\n  points.forEach(function (p) {\n    xs.push(p.x);\n    ys.push(p.y);\n  });\n  var minX = Math.min.apply(Math, xs);\n  var maxX = Math.max.apply(Math, xs);\n  var minY = Math.min.apply(Math, ys);\n  var maxY = Math.max.apply(Math, ys);\n  return {\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n    maxX: maxX,\n    maxY: maxY,\n    minX: minX,\n    minY: minY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n};\nexport var isBBoxesOverlapping = function isBBoxesOverlapping(b1, b2) {\n  return Math.abs(b1.centerX - b2.centerX) * 2 < b1.width + b2.width && Math.abs(b1.centerY - b2.centerY) * 2 < b1.height + b2.height;\n};\nexport var filterConnectPoints = function filterConnectPoints(points) {\n  // pre-process: remove duplicated points\n  var result = [];\n  var map = {};\n  var pointsLength = points.length;\n  for (var i = pointsLength - 1; i >= 0; i--) {\n    var p = points[i];\n    p.id = \"\".concat(p.x, \"|||\").concat(p.y);\n    if (!map[p.id]) {\n      map[p.id] = p;\n      result.push(p);\n    }\n  }\n  return result;\n};\nexport var simplifyPolyline = function simplifyPolyline(points) {\n  return filterConnectPoints(points);\n};\nexport var getSimplePolyline = function getSimplePolyline(sPoint, tPoint) {\n  return [sPoint, {\n    x: sPoint.x,\n    y: tPoint.y\n  }, tPoint];\n};\nexport var getExpandedBBox = function getExpandedBBox(bbox, offset) {\n  if (bbox.width || bbox.height) {\n    return {\n      centerX: bbox.centerX,\n      centerY: bbox.centerY,\n      minX: bbox.minX - offset,\n      minY: bbox.minY - offset,\n      maxX: bbox.maxX + offset,\n      maxY: bbox.maxY + offset,\n      height: bbox.height + 2 * offset,\n      width: bbox.width + 2 * offset\n    };\n  }\n  // when it is a point\n  return bbox;\n};\nexport var isHorizontalPort = function isHorizontalPort(port, bbox) {\n  var dx = Math.abs(port.x - bbox.centerX);\n  var dy = Math.abs(port.y - bbox.centerY);\n  if (dx === 0 && dy === 0) return 0;\n  return dx / bbox.width > dy / bbox.height;\n};\nexport var getExpandedBBoxPoint = function getExpandedBBoxPoint(bbox,\n// 将原来节点 bbox 扩展了 offset 后的 bbox，且被 gridSize 格式化\npoint,\n// 被 gridSize 格式化后的位置（anchorPoint）\nanotherPoint) {\n  var isHorizontal = isHorizontalPort(point, bbox);\n  if (isHorizontal === 0) {\n    // 说明锚点是节点中心，linkCenter: true。需要根据两个节点的相对关系决定方向\n    var x = bbox.centerX;\n    var y = bbox.centerY;\n    if (anotherPoint.y < point.y) {\n      // 另一端在左上/右上方时，总是从上方走\n      y = bbox.minY;\n    } else if (anotherPoint.x > point.x) {\n      // 另一端在右下方，往右边走\n      x = bbox.maxX;\n    } else if (anotherPoint.x < point.x) {\n      // 另一端在左下方，往左边走\n      x = bbox.minX;\n    } else if (anotherPoint.x === point.x) {\n      // 另一段在正下方，往下走\n      y = bbox.maxY;\n    }\n    return {\n      x: x,\n      y: y\n    };\n  }\n  if (isHorizontal) {\n    return {\n      x: point.x > bbox.centerX ? bbox.maxX : bbox.minX,\n      y: point.y\n    };\n  }\n  return {\n    x: point.x,\n    y: point.y > bbox.centerY ? bbox.maxY : bbox.minY\n  };\n};\n/**\n *\n * @param b1\n * @param b2\n */\nexport var mergeBBox = function mergeBBox(b1, b2) {\n  var minX = Math.min(b1.minX, b2.minX);\n  var minY = Math.min(b1.minY, b2.minY);\n  var maxX = Math.max(b1.maxX, b2.maxX);\n  var maxY = Math.max(b1.maxY, b2.maxY);\n  return {\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n    minX: minX,\n    minY: minY,\n    maxX: maxX,\n    maxY: maxY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n};\nexport var getPointsFromBBox = function getPointsFromBBox(bbox) {\n  // anticlockwise\n  return [{\n    x: bbox.minX,\n    y: bbox.minY\n  }, {\n    x: bbox.maxX,\n    y: bbox.minY\n  }, {\n    x: bbox.maxX,\n    y: bbox.maxY\n  }, {\n    x: bbox.minX,\n    y: bbox.maxY\n  }];\n};\nexport var isPointOutsideBBox = function isPointOutsideBBox(point, bbox) {\n  var x = point.x,\n    y = point.y;\n  return x < bbox.minX || x > bbox.maxX || y < bbox.minY || y > bbox.maxY;\n};\nexport var getBBoxXCrossPoints = function getBBoxXCrossPoints(bbox, x) {\n  if (x < bbox.minX || x > bbox.maxX) {\n    return [];\n  }\n  return [{\n    x: x,\n    y: bbox.minY\n  }, {\n    x: x,\n    y: bbox.maxY\n  }];\n};\nexport var getBBoxYCrossPoints = function getBBoxYCrossPoints(bbox, y) {\n  if (y < bbox.minY || y > bbox.maxY) {\n    return [];\n  }\n  return [{\n    x: bbox.minX,\n    y: y\n  }, {\n    x: bbox.maxX,\n    y: y\n  }];\n};\nexport var getBBoxCrossPointsByPoint = function getBBoxCrossPointsByPoint(bbox, point) {\n  return getBBoxXCrossPoints(bbox, point.x).concat(getBBoxYCrossPoints(bbox, point.y));\n};\n/**\n * 曼哈顿距离\n */\nexport var distance = function distance(p1, p2) {\n  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n};\n/**\n * 如果 points 中的一个节点 x 与 p 相等，则消耗 -2。y 同\n * 即优先选择和 points 在同一水平线 / 垂直线上的点\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport var _costByPoints = function _costByPoints(p, points) {\n  var offset = -2;\n  var result = 0;\n  points.forEach(function (point) {\n    if (point) {\n      if (p.x === point.x) {\n        result += offset;\n      }\n      if (p.y === point.y) {\n        result += offset;\n      }\n    }\n  });\n  return result;\n};\n/**\n * ps 经过 p 到 pt 的距离，减去其他路过节点造成的消耗\n */\nexport var heuristicCostEstimate = function heuristicCostEstimate(p, ps, pt, source, target) {\n  return distance(p, ps) + distance(p, pt) + _costByPoints(p, [ps, pt, source, target]);\n};\nvar _reconstructPath = function reconstructPath(pathPoints, pointById, cameFrom, currentId, iterator) {\n  if (iterator === void 0) {\n    iterator = 0;\n  }\n  pathPoints.unshift(pointById[currentId]);\n  if (cameFrom[currentId] && cameFrom[currentId] !== currentId && iterator <= 100) {\n    _reconstructPath(pathPoints, pointById, cameFrom, cameFrom[currentId], iterator + 1);\n  }\n};\n/**\n * 从 arr 中删去 item\n */\nexport { _reconstructPath as reconstructPath };\nexport var removeFrom = function removeFrom(arr, item) {\n  var index = arr.indexOf(item);\n  if (index > -1) {\n    arr.splice(index, 1);\n  }\n};\nexport var isSegmentsIntersected = function isSegmentsIntersected(p0, p1, p2, p3) {\n  var v1x = p2.x - p0.x;\n  var v1y = p2.y - p0.y;\n  var v2x = p3.x - p0.x;\n  var v2y = p3.y - p0.y;\n  var v3x = p2.x - p1.x;\n  var v3y = p2.y - p1.y;\n  var v4x = p3.x - p1.x;\n  var v4y = p3.y - p1.y;\n  var pd1 = v1x * v2y - v1y * v2x;\n  var pd2 = v3x * v4y - v3y * v4x;\n  var pd3 = v1x * v3y - v1y * v3x;\n  var pd4 = v2x * v4y - v2y * v4x;\n  return pd1 * pd2 <= 0 && pd3 * pd4 <= 0;\n};\nexport var isSegmentCrossingBBox = function isSegmentCrossingBBox(p1, p2, bbox) {\n  if (bbox.width || bbox.height) {\n    var _a = getPointsFromBBox(bbox),\n      pa = _a[0],\n      pb = _a[1],\n      pc = _a[2],\n      pd = _a[3];\n    return isSegmentsIntersected(p1, p2, pa, pb) || isSegmentsIntersected(p1, p2, pa, pd) || isSegmentsIntersected(p1, p2, pb, pc) || isSegmentsIntersected(p1, p2, pc, pd);\n  }\n  return false;\n};\n/**\n * 在 points 中找到满足 x 或 y 和 point 的 x 或 y 相等，且与 point 连线不经过 bbox1 与 bbox2 的点\n */\nexport var getNeighborPoints = function getNeighborPoints(points, point, bbox1, bbox2) {\n  var neighbors = [];\n  points.forEach(function (p) {\n    if (p === point) return;\n    if (p.x === point.x || p.y === point.y) {\n      if (isSegmentCrossingBBox(p, point, bbox1) || isSegmentCrossingBBox(p, point, bbox2)) return;\n      neighbors.push(p);\n    }\n  });\n  return filterConnectPoints(neighbors);\n};\n/**\n * sorted array ascendly\n * add new item to proper index when calling add\n */\nvar SortedArray = /** @class */function () {\n  function SortedArray() {\n    this.arr = [];\n    this.map = {};\n    this.arr = [];\n    this.map = {};\n  }\n  SortedArray.prototype._innerAdd = function (item, length) {\n    var idxRange = [0, length - 1];\n    while (idxRange[1] - idxRange[0] > 1) {\n      var midIdx = Math.floor((idxRange[0] + idxRange[1]) / 2);\n      if (this.arr[midIdx].value > item.value) {\n        idxRange[1] = midIdx;\n      } else if (this.arr[midIdx].value < item.value) {\n        idxRange[0] = midIdx;\n      } else {\n        this.arr.splice(midIdx, 0, item);\n        this.map[item.id] = true;\n        return;\n      }\n    }\n    this.arr.splice(idxRange[1], 0, item);\n    this.map[item.id] = true;\n  };\n  SortedArray.prototype.add = function (item) {\n    // 已经存在，先移除\n    delete this.map[item.id];\n    var length = this.arr.length;\n    if (!length) {\n      this.arr.push(item);\n      this.map[item.id] = true;\n      return;\n    }\n    // 比最后一个大，加入尾部\n    if (this.arr[length - 1].value < item.value) {\n      this.arr.push(item);\n      this.map[item.id] = true;\n      return;\n    }\n    this._innerAdd(item, length);\n  };\n  // only remove from the map to avoid cost\n  // clear the invalid (not in the map) item when calling minId(true)\n  SortedArray.prototype.remove = function (id) {\n    if (!this.map[id]) return;\n    delete this.map[id];\n  };\n  SortedArray.prototype._clearAndGetMinId = function () {\n    var res;\n    for (var i = this.arr.length - 1; i >= 0; i--) {\n      if (this.map[this.arr[i].id]) res = this.arr[i].id;else this.arr.splice(i, 1);\n    }\n    return res;\n  };\n  SortedArray.prototype._findFirstId = function () {\n    while (this.arr.length) {\n      var first = this.arr.shift();\n      if (this.map[first.id]) return first.id;\n    }\n  };\n  SortedArray.prototype.minId = function (clear) {\n    if (clear) {\n      return this._clearAndGetMinId();\n    } else {\n      return this._findFirstId();\n    }\n  };\n  return SortedArray;\n}();\nexport { SortedArray };\nexport var pathFinder = function pathFinder(points, start, goal, sBBox, tBBox, os, ot) {\n  var _a;\n  // A-Star Algorithm\n  var closedSet = [];\n  var openSet = (_a = {}, _a[start.id] = start, _a);\n  var cameFrom = {};\n  var gScore = {}; // all default values are Infinity\n  var fScore = {}; // all default values are Infinity\n  gScore[start.id] = 0;\n  fScore[start.id] = heuristicCostEstimate(start, goal, start);\n  var sortedOpenSet = new SortedArray();\n  sortedOpenSet.add({\n    id: start.id,\n    value: fScore[start.id]\n  });\n  var pointById = {};\n  points.forEach(function (p) {\n    pointById[p.id] = p;\n  });\n  var current;\n  while (Object.keys(openSet).length) {\n    var minId = sortedOpenSet.minId(false);\n    if (minId) {\n      current = openSet[minId];\n    } else {\n      break;\n    }\n    // 若 openSet 中 fScore 最小的点就是终点\n    if (current === goal) {\n      // ending condition\n      var pathPoints = [];\n      _reconstructPath(pathPoints, pointById, cameFrom, goal.id);\n      return pathPoints;\n    }\n    delete openSet[current.id];\n    sortedOpenSet.remove(current.id);\n    closedSet.push(current);\n    var neighborPoints = getNeighborPoints(points, current, sBBox, tBBox);\n    var iterateNeighbors = function iterateNeighbors(items) {\n      items.forEach(function (neighbor) {\n        if (closedSet.indexOf(neighbor) !== -1) {\n          return;\n        }\n        var neighborId = neighbor.id;\n        if (!openSet[neighborId]) {\n          openSet[neighborId] = neighbor;\n        }\n        var tentativeGScore = fScore[current.id] + distance(current, neighbor); // + distance(neighbor, goal);\n        if (gScore[neighborId] && tentativeGScore >= gScore[neighborId]) {\n          sortedOpenSet.add({\n            id: neighborId,\n            value: fScore[neighborId]\n          });\n          return;\n        }\n        cameFrom[neighborId] = current.id;\n        gScore[neighborId] = tentativeGScore;\n        fScore[neighborId] = gScore[neighborId] + heuristicCostEstimate(neighbor, goal, start, os, ot);\n        sortedOpenSet.add({\n          id: neighborId,\n          value: fScore[neighborId]\n        });\n      });\n    };\n    iterateNeighbors(neighborPoints);\n  }\n  // throw new Error('Cannot find path');\n  return [start, goal];\n};\nexport var isBending = function isBending(p0, p1, p2) {\n  return !(p0.x === p1.x && p1.x === p2.x || p0.y === p1.y && p1.y === p2.y);\n};\nexport var getBorderRadiusPoints = function getBorderRadiusPoints(p0, p1, p2, r) {\n  var d0 = distance(p0, p1);\n  var d1 = distance(p2, p1);\n  if (d0 < r) {\n    r = d0;\n  }\n  if (d1 < r) {\n    r = d1;\n  }\n  var ps = {\n    x: p1.x - r / d0 * (p1.x - p0.x),\n    y: p1.y - r / d0 * (p1.y - p0.y)\n  };\n  var pt = {\n    x: p1.x - r / d1 * (p1.x - p2.x),\n    y: p1.y - r / d1 * (p1.y - p2.y)\n  };\n  return [ps, pt];\n};\nexport var getPathWithBorderRadiusByPolyline = function getPathWithBorderRadiusByPolyline(points, borderRadius) {\n  var pathSegments = [];\n  var startPoint = points[0];\n  pathSegments.push(\"M\".concat(startPoint.x, \" \").concat(startPoint.y));\n  points.forEach(function (p, i) {\n    var p1 = points[i + 1];\n    var p2 = points[i + 2];\n    if (p1 && p2) {\n      if (isBending(p, p1, p2)) {\n        var _a = getBorderRadiusPoints(p, p1, p2, borderRadius),\n          ps = _a[0],\n          pt = _a[1];\n        pathSegments.push(\"L\".concat(ps.x, \" \").concat(ps.y));\n        pathSegments.push(\"Q\".concat(p1.x, \" \").concat(p1.y, \" \").concat(pt.x, \" \").concat(pt.y));\n        pathSegments.push(\"L\".concat(pt.x, \" \").concat(pt.y));\n      } else {\n        pathSegments.push(\"L\".concat(p1.x, \" \").concat(p1.y));\n      }\n    } else if (p1) {\n      pathSegments.push(\"L\".concat(p1.x, \" \").concat(p1.y));\n    }\n  });\n  return pathSegments.join('');\n};\nexport var getPolylinePoints = function getPolylinePoints(start, end, sNode, tNode, offset) {\n  var sBBox, tBBox;\n  if (!sNode || !sNode.getType()) {\n    sBBox = getBBoxFromPoint(start);\n  } else if (sNode.getType() === 'combo') {\n    var sKeyShapeBBox = sNode.getKeyShape().getBBox();\n    if (sKeyShapeBBox) {\n      var _a = sNode.getModel(),\n        sx = _a.x,\n        sy = _a.y;\n      sBBox = {\n        x: sx,\n        y: sy,\n        width: sKeyShapeBBox.width,\n        height: sKeyShapeBBox.height,\n        minX: sKeyShapeBBox.minX + sx,\n        maxX: sKeyShapeBBox.maxX + sx,\n        minY: sKeyShapeBBox.minY + sy,\n        maxY: sKeyShapeBBox.maxY + sy\n      };\n      sBBox.centerX = (sBBox.minX + sBBox.maxX) / 2;\n      sBBox.centerY = (sBBox.minY + sBBox.maxY) / 2;\n    } else {\n      sBBox = getBBoxFromPoint(start);\n    }\n  } else {\n    sBBox = sNode && sNode.getBBox();\n  }\n  if (!tNode || !tNode.getType()) {\n    tBBox = getBBoxFromPoint(end);\n  } else if (tNode.getType() === 'combo') {\n    var tKeyShapeBBox = tNode.getKeyShape().getBBox();\n    if (tKeyShapeBBox) {\n      var _b = tNode.getModel(),\n        tx = _b.x,\n        ty = _b.y;\n      tBBox = {\n        x: tx,\n        y: ty,\n        width: tKeyShapeBBox.width,\n        height: tKeyShapeBBox.height,\n        minX: tKeyShapeBBox.minX + tx,\n        maxX: tKeyShapeBBox.maxX + tx,\n        minY: tKeyShapeBBox.minY + ty,\n        maxY: tKeyShapeBBox.maxY + ty\n      };\n      tBBox.centerX = (tBBox.minX + tBBox.maxX) / 2;\n      tBBox.centerY = (tBBox.minY + tBBox.maxY) / 2;\n    } else {\n      tBBox = getBBoxFromPoint(end);\n    }\n  } else {\n    tBBox = tNode && tNode.getBBox();\n  }\n  // if (isBBoxesOverlapping(sBBox, tBBox)) {\n  //   // source and target nodes are overlapping\n  //   return simplifyPolyline(getSimplePolyline(start, end));\n  // }\n  var sxBBox = getExpandedBBox(sBBox, offset);\n  var txBBox = getExpandedBBox(tBBox, offset);\n  // if (isBBoxesOverlapping(sxBBox, txBBox)) {\n  //   // the expanded bounding boxes of source and target nodes are overlapping\n  //   return simplifyPolyline(getSimplePolyline(start, end));\n  // }\n  var sPoint = getExpandedBBoxPoint(sxBBox, start, end);\n  var tPoint = getExpandedBBoxPoint(txBBox, end, start);\n  var lineBBox = getBBoxFromPoints([sPoint, tPoint]);\n  var sMixBBox = mergeBBox(sxBBox, lineBBox);\n  var tMixBBox = mergeBBox(txBBox, lineBBox);\n  var connectPoints = [];\n  connectPoints = connectPoints.concat(getPointsFromBBox(sMixBBox)).concat(getPointsFromBBox(tMixBBox));\n  var centerPoint = {\n    x: (start.x + end.x) / 2,\n    y: (start.y + end.y) / 2\n  };\n  [lineBBox, sMixBBox, tMixBBox].forEach(function (bbox) {\n    connectPoints = connectPoints.concat(getBBoxCrossPointsByPoint(bbox, centerPoint).filter(function (p) {\n      return isPointOutsideBBox(p, sxBBox) && isPointOutsideBBox(p, txBBox);\n    }));\n  });\n  [{\n    x: sPoint.x,\n    y: tPoint.y\n  }, {\n    x: tPoint.x,\n    y: sPoint.y\n  }].forEach(function (p) {\n    // impossible!!\n    if (isPointOutsideBBox(p, sxBBox) && isPointOutsideBBox(p, txBBox) // &&\n    // isPointInsideBBox(p, sMixBBox) && isPointInsideBBox(p, tMixBBox)\n    ) {\n      connectPoints.push(p);\n    }\n  });\n  connectPoints.unshift(sPoint);\n  connectPoints.push(tPoint);\n  // filter out dulplicated points in connectPoints\n  connectPoints = filterConnectPoints(connectPoints); // , sxBBox, txBBox, outerBBox\n  var pathPoints = pathFinder(connectPoints, sPoint, tPoint, sBBox, tBBox, start, end);\n  pathPoints.unshift(start);\n  pathPoints.push(end);\n  return simplifyPolyline(pathPoints);\n};\n/**\n * 去除连续同 x 不同 y 的中间点；去除连续同 y 不同 x 的中间点\n * @param points 坐标集合 { x: number, y: number, id: string }[]\n * @returns\n */\nexport var removeRedundantPoint = function removeRedundantPoint(points) {\n  if (!(points === null || points === void 0 ? void 0 : points.length)) return points;\n  var beginPoint = points[points.length - 1];\n  var current = {\n    x: beginPoint.x,\n    y: beginPoint.y\n  };\n  var continueSameX = [beginPoint];\n  var continueSameY = [beginPoint];\n  for (var i = points.length - 2; i >= 0; i--) {\n    var point = points[i];\n    if (point.x === current.x) {\n      continueSameX.push(point);\n    } else {\n      continueSameX = [point];\n      current.x = point.x;\n    }\n    if (point.y === current.y) {\n      continueSameY.push(point);\n    } else {\n      continueSameY = [point];\n      current.y = point.y;\n    }\n    if (continueSameX.length > 2) {\n      var removeIdx = points.indexOf(continueSameX[1]);\n      if (removeIdx > -1) points.splice(removeIdx, 1);\n      continue;\n    }\n    if (continueSameY.length > 2) {\n      var removeIdx = points.indexOf(continueSameY[1]);\n      if (removeIdx > -1) points.splice(removeIdx, 1);\n    }\n  }\n  return points;\n};","map":{"version":3,"names":["getBBoxFromPoint","point","x","y","centerX","centerY","minX","minY","maxX","maxY","height","width","getBBoxFromPoints","points","xs","ys","forEach","p","push","Math","min","apply","max","isBBoxesOverlapping","b1","b2","abs","filterConnectPoints","result","map","pointsLength","length","i","id","concat","simplifyPolyline","getSimplePolyline","sPoint","tPoint","getExpandedBBox","bbox","offset","isHorizontalPort","port","dx","dy","getExpandedBBoxPoint","anotherPoint","isHorizontal","mergeBBox","getPointsFromBBox","isPointOutsideBBox","getBBoxXCrossPoints","getBBoxYCrossPoints","getBBoxCrossPointsByPoint","distance","p1","p2","_costByPoints","heuristicCostEstimate","ps","pt","source","target","_reconstructPath","reconstructPath","pathPoints","pointById","cameFrom","currentId","iterator","unshift","removeFrom","arr","item","index","indexOf","splice","isSegmentsIntersected","p0","p3","v1x","v1y","v2x","v2y","v3x","v3y","v4x","v4y","pd1","pd2","pd3","pd4","isSegmentCrossingBBox","_a","pa","pb","pc","pd","getNeighborPoints","bbox1","bbox2","neighbors","SortedArray","prototype","_innerAdd","idxRange","midIdx","floor","value","add","remove","_clearAndGetMinId","res","_findFirstId","first","shift","minId","clear","pathFinder","start","goal","sBBox","tBBox","os","ot","closedSet","openSet","gScore","fScore","sortedOpenSet","current","Object","keys","neighborPoints","iterateNeighbors","items","neighbor","neighborId","tentativeGScore","isBending","getBorderRadiusPoints","r","d0","d1","getPathWithBorderRadiusByPolyline","borderRadius","pathSegments","startPoint","join","getPolylinePoints","end","sNode","tNode","getType","sKeyShapeBBox","getKeyShape","getBBox","getModel","sx","sy","tKeyShapeBBox","_b","tx","ty","sxBBox","txBBox","lineBBox","sMixBBox","tMixBBox","connectPoints","centerPoint","filter","removeRedundantPoint","beginPoint","continueSameX","continueSameY","removeIdx"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/g6-element/es/edges/polyline-util.js"],"sourcesContent":["export var getBBoxFromPoint = function getBBoxFromPoint(point) {\n  var x = point.x,\n    y = point.y;\n  return {\n    x: x,\n    y: y,\n    centerX: x,\n    centerY: y,\n    minX: x,\n    minY: y,\n    maxX: x,\n    maxY: y,\n    height: 0,\n    width: 0\n  };\n};\nexport var getBBoxFromPoints = function getBBoxFromPoints(points) {\n  if (points === void 0) {\n    points = [];\n  }\n  var xs = [];\n  var ys = [];\n  points.forEach(function (p) {\n    xs.push(p.x);\n    ys.push(p.y);\n  });\n  var minX = Math.min.apply(Math, xs);\n  var maxX = Math.max.apply(Math, xs);\n  var minY = Math.min.apply(Math, ys);\n  var maxY = Math.max.apply(Math, ys);\n  return {\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n    maxX: maxX,\n    maxY: maxY,\n    minX: minX,\n    minY: minY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n};\nexport var isBBoxesOverlapping = function isBBoxesOverlapping(b1, b2) {\n  return Math.abs(b1.centerX - b2.centerX) * 2 < b1.width + b2.width && Math.abs(b1.centerY - b2.centerY) * 2 < b1.height + b2.height;\n};\nexport var filterConnectPoints = function filterConnectPoints(points) {\n  // pre-process: remove duplicated points\n  var result = [];\n  var map = {};\n  var pointsLength = points.length;\n  for (var i = pointsLength - 1; i >= 0; i--) {\n    var p = points[i];\n    p.id = \"\".concat(p.x, \"|||\").concat(p.y);\n    if (!map[p.id]) {\n      map[p.id] = p;\n      result.push(p);\n    }\n  }\n  return result;\n};\nexport var simplifyPolyline = function simplifyPolyline(points) {\n  return filterConnectPoints(points);\n};\nexport var getSimplePolyline = function getSimplePolyline(sPoint, tPoint) {\n  return [sPoint, {\n    x: sPoint.x,\n    y: tPoint.y\n  }, tPoint];\n};\nexport var getExpandedBBox = function getExpandedBBox(bbox, offset) {\n  if (bbox.width || bbox.height) {\n    return {\n      centerX: bbox.centerX,\n      centerY: bbox.centerY,\n      minX: bbox.minX - offset,\n      minY: bbox.minY - offset,\n      maxX: bbox.maxX + offset,\n      maxY: bbox.maxY + offset,\n      height: bbox.height + 2 * offset,\n      width: bbox.width + 2 * offset\n    };\n  }\n  // when it is a point\n  return bbox;\n};\nexport var isHorizontalPort = function isHorizontalPort(port, bbox) {\n  var dx = Math.abs(port.x - bbox.centerX);\n  var dy = Math.abs(port.y - bbox.centerY);\n  if (dx === 0 && dy === 0) return 0;\n  return dx / bbox.width > dy / bbox.height;\n};\nexport var getExpandedBBoxPoint = function getExpandedBBoxPoint(bbox,\n// 将原来节点 bbox 扩展了 offset 后的 bbox，且被 gridSize 格式化\npoint,\n// 被 gridSize 格式化后的位置（anchorPoint）\nanotherPoint) {\n  var isHorizontal = isHorizontalPort(point, bbox);\n  if (isHorizontal === 0) {\n    // 说明锚点是节点中心，linkCenter: true。需要根据两个节点的相对关系决定方向\n    var x = bbox.centerX;\n    var y = bbox.centerY;\n    if (anotherPoint.y < point.y) {\n      // 另一端在左上/右上方时，总是从上方走\n      y = bbox.minY;\n    } else if (anotherPoint.x > point.x) {\n      // 另一端在右下方，往右边走\n      x = bbox.maxX;\n    } else if (anotherPoint.x < point.x) {\n      // 另一端在左下方，往左边走\n      x = bbox.minX;\n    } else if (anotherPoint.x === point.x) {\n      // 另一段在正下方，往下走\n      y = bbox.maxY;\n    }\n    return {\n      x: x,\n      y: y\n    };\n  }\n  if (isHorizontal) {\n    return {\n      x: point.x > bbox.centerX ? bbox.maxX : bbox.minX,\n      y: point.y\n    };\n  }\n  return {\n    x: point.x,\n    y: point.y > bbox.centerY ? bbox.maxY : bbox.minY\n  };\n};\n/**\n *\n * @param b1\n * @param b2\n */\nexport var mergeBBox = function mergeBBox(b1, b2) {\n  var minX = Math.min(b1.minX, b2.minX);\n  var minY = Math.min(b1.minY, b2.minY);\n  var maxX = Math.max(b1.maxX, b2.maxX);\n  var maxY = Math.max(b1.maxY, b2.maxY);\n  return {\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n    minX: minX,\n    minY: minY,\n    maxX: maxX,\n    maxY: maxY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n};\nexport var getPointsFromBBox = function getPointsFromBBox(bbox) {\n  // anticlockwise\n  return [{\n    x: bbox.minX,\n    y: bbox.minY\n  }, {\n    x: bbox.maxX,\n    y: bbox.minY\n  }, {\n    x: bbox.maxX,\n    y: bbox.maxY\n  }, {\n    x: bbox.minX,\n    y: bbox.maxY\n  }];\n};\nexport var isPointOutsideBBox = function isPointOutsideBBox(point, bbox) {\n  var x = point.x,\n    y = point.y;\n  return x < bbox.minX || x > bbox.maxX || y < bbox.minY || y > bbox.maxY;\n};\nexport var getBBoxXCrossPoints = function getBBoxXCrossPoints(bbox, x) {\n  if (x < bbox.minX || x > bbox.maxX) {\n    return [];\n  }\n  return [{\n    x: x,\n    y: bbox.minY\n  }, {\n    x: x,\n    y: bbox.maxY\n  }];\n};\nexport var getBBoxYCrossPoints = function getBBoxYCrossPoints(bbox, y) {\n  if (y < bbox.minY || y > bbox.maxY) {\n    return [];\n  }\n  return [{\n    x: bbox.minX,\n    y: y\n  }, {\n    x: bbox.maxX,\n    y: y\n  }];\n};\nexport var getBBoxCrossPointsByPoint = function getBBoxCrossPointsByPoint(bbox, point) {\n  return getBBoxXCrossPoints(bbox, point.x).concat(getBBoxYCrossPoints(bbox, point.y));\n};\n/**\n * 曼哈顿距离\n */\nexport var distance = function distance(p1, p2) {\n  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n};\n/**\n * 如果 points 中的一个节点 x 与 p 相等，则消耗 -2。y 同\n * 即优先选择和 points 在同一水平线 / 垂直线上的点\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport var _costByPoints = function _costByPoints(p, points) {\n  var offset = -2;\n  var result = 0;\n  points.forEach(function (point) {\n    if (point) {\n      if (p.x === point.x) {\n        result += offset;\n      }\n      if (p.y === point.y) {\n        result += offset;\n      }\n    }\n  });\n  return result;\n};\n/**\n * ps 经过 p 到 pt 的距离，减去其他路过节点造成的消耗\n */\nexport var heuristicCostEstimate = function heuristicCostEstimate(p, ps, pt, source, target) {\n  return distance(p, ps) + distance(p, pt) + _costByPoints(p, [ps, pt, source, target]);\n};\nvar _reconstructPath = function reconstructPath(pathPoints, pointById, cameFrom, currentId, iterator) {\n  if (iterator === void 0) {\n    iterator = 0;\n  }\n  pathPoints.unshift(pointById[currentId]);\n  if (cameFrom[currentId] && cameFrom[currentId] !== currentId && iterator <= 100) {\n    _reconstructPath(pathPoints, pointById, cameFrom, cameFrom[currentId], iterator + 1);\n  }\n};\n/**\n * 从 arr 中删去 item\n */\nexport { _reconstructPath as reconstructPath };\nexport var removeFrom = function removeFrom(arr, item) {\n  var index = arr.indexOf(item);\n  if (index > -1) {\n    arr.splice(index, 1);\n  }\n};\nexport var isSegmentsIntersected = function isSegmentsIntersected(p0, p1, p2, p3) {\n  var v1x = p2.x - p0.x;\n  var v1y = p2.y - p0.y;\n  var v2x = p3.x - p0.x;\n  var v2y = p3.y - p0.y;\n  var v3x = p2.x - p1.x;\n  var v3y = p2.y - p1.y;\n  var v4x = p3.x - p1.x;\n  var v4y = p3.y - p1.y;\n  var pd1 = v1x * v2y - v1y * v2x;\n  var pd2 = v3x * v4y - v3y * v4x;\n  var pd3 = v1x * v3y - v1y * v3x;\n  var pd4 = v2x * v4y - v2y * v4x;\n  return pd1 * pd2 <= 0 && pd3 * pd4 <= 0;\n};\nexport var isSegmentCrossingBBox = function isSegmentCrossingBBox(p1, p2, bbox) {\n  if (bbox.width || bbox.height) {\n    var _a = getPointsFromBBox(bbox),\n      pa = _a[0],\n      pb = _a[1],\n      pc = _a[2],\n      pd = _a[3];\n    return isSegmentsIntersected(p1, p2, pa, pb) || isSegmentsIntersected(p1, p2, pa, pd) || isSegmentsIntersected(p1, p2, pb, pc) || isSegmentsIntersected(p1, p2, pc, pd);\n  }\n  return false;\n};\n/**\n * 在 points 中找到满足 x 或 y 和 point 的 x 或 y 相等，且与 point 连线不经过 bbox1 与 bbox2 的点\n */\nexport var getNeighborPoints = function getNeighborPoints(points, point, bbox1, bbox2) {\n  var neighbors = [];\n  points.forEach(function (p) {\n    if (p === point) return;\n    if (p.x === point.x || p.y === point.y) {\n      if (isSegmentCrossingBBox(p, point, bbox1) || isSegmentCrossingBBox(p, point, bbox2)) return;\n      neighbors.push(p);\n    }\n  });\n  return filterConnectPoints(neighbors);\n};\n/**\n * sorted array ascendly\n * add new item to proper index when calling add\n */\nvar SortedArray = /** @class */function () {\n  function SortedArray() {\n    this.arr = [];\n    this.map = {};\n    this.arr = [];\n    this.map = {};\n  }\n  SortedArray.prototype._innerAdd = function (item, length) {\n    var idxRange = [0, length - 1];\n    while (idxRange[1] - idxRange[0] > 1) {\n      var midIdx = Math.floor((idxRange[0] + idxRange[1]) / 2);\n      if (this.arr[midIdx].value > item.value) {\n        idxRange[1] = midIdx;\n      } else if (this.arr[midIdx].value < item.value) {\n        idxRange[0] = midIdx;\n      } else {\n        this.arr.splice(midIdx, 0, item);\n        this.map[item.id] = true;\n        return;\n      }\n    }\n    this.arr.splice(idxRange[1], 0, item);\n    this.map[item.id] = true;\n  };\n  SortedArray.prototype.add = function (item) {\n    // 已经存在，先移除\n    delete this.map[item.id];\n    var length = this.arr.length;\n    if (!length) {\n      this.arr.push(item);\n      this.map[item.id] = true;\n      return;\n    }\n    // 比最后一个大，加入尾部\n    if (this.arr[length - 1].value < item.value) {\n      this.arr.push(item);\n      this.map[item.id] = true;\n      return;\n    }\n    this._innerAdd(item, length);\n  };\n  // only remove from the map to avoid cost\n  // clear the invalid (not in the map) item when calling minId(true)\n  SortedArray.prototype.remove = function (id) {\n    if (!this.map[id]) return;\n    delete this.map[id];\n  };\n  SortedArray.prototype._clearAndGetMinId = function () {\n    var res;\n    for (var i = this.arr.length - 1; i >= 0; i--) {\n      if (this.map[this.arr[i].id]) res = this.arr[i].id;else this.arr.splice(i, 1);\n    }\n    return res;\n  };\n  SortedArray.prototype._findFirstId = function () {\n    while (this.arr.length) {\n      var first = this.arr.shift();\n      if (this.map[first.id]) return first.id;\n    }\n  };\n  SortedArray.prototype.minId = function (clear) {\n    if (clear) {\n      return this._clearAndGetMinId();\n    } else {\n      return this._findFirstId();\n    }\n  };\n  return SortedArray;\n}();\nexport { SortedArray };\nexport var pathFinder = function pathFinder(points, start, goal, sBBox, tBBox, os, ot) {\n  var _a;\n  // A-Star Algorithm\n  var closedSet = [];\n  var openSet = (_a = {}, _a[start.id] = start, _a);\n  var cameFrom = {};\n  var gScore = {}; // all default values are Infinity\n  var fScore = {}; // all default values are Infinity\n  gScore[start.id] = 0;\n  fScore[start.id] = heuristicCostEstimate(start, goal, start);\n  var sortedOpenSet = new SortedArray();\n  sortedOpenSet.add({\n    id: start.id,\n    value: fScore[start.id]\n  });\n  var pointById = {};\n  points.forEach(function (p) {\n    pointById[p.id] = p;\n  });\n  var current;\n  while (Object.keys(openSet).length) {\n    var minId = sortedOpenSet.minId(false);\n    if (minId) {\n      current = openSet[minId];\n    } else {\n      break;\n    }\n    // 若 openSet 中 fScore 最小的点就是终点\n    if (current === goal) {\n      // ending condition\n      var pathPoints = [];\n      _reconstructPath(pathPoints, pointById, cameFrom, goal.id);\n      return pathPoints;\n    }\n    delete openSet[current.id];\n    sortedOpenSet.remove(current.id);\n    closedSet.push(current);\n    var neighborPoints = getNeighborPoints(points, current, sBBox, tBBox);\n    var iterateNeighbors = function iterateNeighbors(items) {\n      items.forEach(function (neighbor) {\n        if (closedSet.indexOf(neighbor) !== -1) {\n          return;\n        }\n        var neighborId = neighbor.id;\n        if (!openSet[neighborId]) {\n          openSet[neighborId] = neighbor;\n        }\n        var tentativeGScore = fScore[current.id] + distance(current, neighbor); // + distance(neighbor, goal);\n        if (gScore[neighborId] && tentativeGScore >= gScore[neighborId]) {\n          sortedOpenSet.add({\n            id: neighborId,\n            value: fScore[neighborId]\n          });\n          return;\n        }\n        cameFrom[neighborId] = current.id;\n        gScore[neighborId] = tentativeGScore;\n        fScore[neighborId] = gScore[neighborId] + heuristicCostEstimate(neighbor, goal, start, os, ot);\n        sortedOpenSet.add({\n          id: neighborId,\n          value: fScore[neighborId]\n        });\n      });\n    };\n    iterateNeighbors(neighborPoints);\n  }\n  // throw new Error('Cannot find path');\n  return [start, goal];\n};\nexport var isBending = function isBending(p0, p1, p2) {\n  return !(p0.x === p1.x && p1.x === p2.x || p0.y === p1.y && p1.y === p2.y);\n};\nexport var getBorderRadiusPoints = function getBorderRadiusPoints(p0, p1, p2, r) {\n  var d0 = distance(p0, p1);\n  var d1 = distance(p2, p1);\n  if (d0 < r) {\n    r = d0;\n  }\n  if (d1 < r) {\n    r = d1;\n  }\n  var ps = {\n    x: p1.x - r / d0 * (p1.x - p0.x),\n    y: p1.y - r / d0 * (p1.y - p0.y)\n  };\n  var pt = {\n    x: p1.x - r / d1 * (p1.x - p2.x),\n    y: p1.y - r / d1 * (p1.y - p2.y)\n  };\n  return [ps, pt];\n};\nexport var getPathWithBorderRadiusByPolyline = function getPathWithBorderRadiusByPolyline(points, borderRadius) {\n  var pathSegments = [];\n  var startPoint = points[0];\n  pathSegments.push(\"M\".concat(startPoint.x, \" \").concat(startPoint.y));\n  points.forEach(function (p, i) {\n    var p1 = points[i + 1];\n    var p2 = points[i + 2];\n    if (p1 && p2) {\n      if (isBending(p, p1, p2)) {\n        var _a = getBorderRadiusPoints(p, p1, p2, borderRadius),\n          ps = _a[0],\n          pt = _a[1];\n        pathSegments.push(\"L\".concat(ps.x, \" \").concat(ps.y));\n        pathSegments.push(\"Q\".concat(p1.x, \" \").concat(p1.y, \" \").concat(pt.x, \" \").concat(pt.y));\n        pathSegments.push(\"L\".concat(pt.x, \" \").concat(pt.y));\n      } else {\n        pathSegments.push(\"L\".concat(p1.x, \" \").concat(p1.y));\n      }\n    } else if (p1) {\n      pathSegments.push(\"L\".concat(p1.x, \" \").concat(p1.y));\n    }\n  });\n  return pathSegments.join('');\n};\nexport var getPolylinePoints = function getPolylinePoints(start, end, sNode, tNode, offset) {\n  var sBBox, tBBox;\n  if (!sNode || !sNode.getType()) {\n    sBBox = getBBoxFromPoint(start);\n  } else if (sNode.getType() === 'combo') {\n    var sKeyShapeBBox = sNode.getKeyShape().getBBox();\n    if (sKeyShapeBBox) {\n      var _a = sNode.getModel(),\n        sx = _a.x,\n        sy = _a.y;\n      sBBox = {\n        x: sx,\n        y: sy,\n        width: sKeyShapeBBox.width,\n        height: sKeyShapeBBox.height,\n        minX: sKeyShapeBBox.minX + sx,\n        maxX: sKeyShapeBBox.maxX + sx,\n        minY: sKeyShapeBBox.minY + sy,\n        maxY: sKeyShapeBBox.maxY + sy\n      };\n      sBBox.centerX = (sBBox.minX + sBBox.maxX) / 2;\n      sBBox.centerY = (sBBox.minY + sBBox.maxY) / 2;\n    } else {\n      sBBox = getBBoxFromPoint(start);\n    }\n  } else {\n    sBBox = sNode && sNode.getBBox();\n  }\n  if (!tNode || !tNode.getType()) {\n    tBBox = getBBoxFromPoint(end);\n  } else if (tNode.getType() === 'combo') {\n    var tKeyShapeBBox = tNode.getKeyShape().getBBox();\n    if (tKeyShapeBBox) {\n      var _b = tNode.getModel(),\n        tx = _b.x,\n        ty = _b.y;\n      tBBox = {\n        x: tx,\n        y: ty,\n        width: tKeyShapeBBox.width,\n        height: tKeyShapeBBox.height,\n        minX: tKeyShapeBBox.minX + tx,\n        maxX: tKeyShapeBBox.maxX + tx,\n        minY: tKeyShapeBBox.minY + ty,\n        maxY: tKeyShapeBBox.maxY + ty\n      };\n      tBBox.centerX = (tBBox.minX + tBBox.maxX) / 2;\n      tBBox.centerY = (tBBox.minY + tBBox.maxY) / 2;\n    } else {\n      tBBox = getBBoxFromPoint(end);\n    }\n  } else {\n    tBBox = tNode && tNode.getBBox();\n  }\n  // if (isBBoxesOverlapping(sBBox, tBBox)) {\n  //   // source and target nodes are overlapping\n  //   return simplifyPolyline(getSimplePolyline(start, end));\n  // }\n  var sxBBox = getExpandedBBox(sBBox, offset);\n  var txBBox = getExpandedBBox(tBBox, offset);\n  // if (isBBoxesOverlapping(sxBBox, txBBox)) {\n  //   // the expanded bounding boxes of source and target nodes are overlapping\n  //   return simplifyPolyline(getSimplePolyline(start, end));\n  // }\n  var sPoint = getExpandedBBoxPoint(sxBBox, start, end);\n  var tPoint = getExpandedBBoxPoint(txBBox, end, start);\n  var lineBBox = getBBoxFromPoints([sPoint, tPoint]);\n  var sMixBBox = mergeBBox(sxBBox, lineBBox);\n  var tMixBBox = mergeBBox(txBBox, lineBBox);\n  var connectPoints = [];\n  connectPoints = connectPoints.concat(getPointsFromBBox(sMixBBox)).concat(getPointsFromBBox(tMixBBox));\n  var centerPoint = {\n    x: (start.x + end.x) / 2,\n    y: (start.y + end.y) / 2\n  };\n  [lineBBox, sMixBBox, tMixBBox].forEach(function (bbox) {\n    connectPoints = connectPoints.concat(getBBoxCrossPointsByPoint(bbox, centerPoint).filter(function (p) {\n      return isPointOutsideBBox(p, sxBBox) && isPointOutsideBBox(p, txBBox);\n    }));\n  });\n  [{\n    x: sPoint.x,\n    y: tPoint.y\n  }, {\n    x: tPoint.x,\n    y: sPoint.y\n  }].forEach(function (p) {\n    // impossible!!\n    if (isPointOutsideBBox(p, sxBBox) && isPointOutsideBBox(p, txBBox) // &&\n    // isPointInsideBBox(p, sMixBBox) && isPointInsideBBox(p, tMixBBox)\n    ) {\n      connectPoints.push(p);\n    }\n  });\n  connectPoints.unshift(sPoint);\n  connectPoints.push(tPoint);\n  // filter out dulplicated points in connectPoints\n  connectPoints = filterConnectPoints(connectPoints); // , sxBBox, txBBox, outerBBox\n  var pathPoints = pathFinder(connectPoints, sPoint, tPoint, sBBox, tBBox, start, end);\n  pathPoints.unshift(start);\n  pathPoints.push(end);\n  return simplifyPolyline(pathPoints);\n};\n/**\n * 去除连续同 x 不同 y 的中间点；去除连续同 y 不同 x 的中间点\n * @param points 坐标集合 { x: number, y: number, id: string }[]\n * @returns\n */\nexport var removeRedundantPoint = function removeRedundantPoint(points) {\n  if (!(points === null || points === void 0 ? void 0 : points.length)) return points;\n  var beginPoint = points[points.length - 1];\n  var current = {\n    x: beginPoint.x,\n    y: beginPoint.y\n  };\n  var continueSameX = [beginPoint];\n  var continueSameY = [beginPoint];\n  for (var i = points.length - 2; i >= 0; i--) {\n    var point = points[i];\n    if (point.x === current.x) {\n      continueSameX.push(point);\n    } else {\n      continueSameX = [point];\n      current.x = point.x;\n    }\n    if (point.y === current.y) {\n      continueSameY.push(point);\n    } else {\n      continueSameY = [point];\n      current.y = point.y;\n    }\n    if (continueSameX.length > 2) {\n      var removeIdx = points.indexOf(continueSameX[1]);\n      if (removeIdx > -1) points.splice(removeIdx, 1);\n      continue;\n    }\n    if (continueSameY.length > 2) {\n      var removeIdx = points.indexOf(continueSameY[1]);\n      if (removeIdx > -1) points.splice(removeIdx, 1);\n    }\n  }\n  return points;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}