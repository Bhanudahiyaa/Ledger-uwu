{"ast":null,"code":"/* eslint-disable no-underscore-dangle */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { ArrayExt, StringExt, ObjectExt, FunctionExt } from '../util';\nimport { Rectangle, Point } from '../geometry';\nimport { Basecoat } from '../common';\nimport { Attr } from '../registry';\nimport { Animation } from './animation';\nimport { Store } from './store';\nexport class Cell extends Basecoat {\n  constructor(metadata = {}) {\n    super();\n    const ctor = this.constructor;\n    const defaults = ctor.getDefaults(true);\n    const props = ObjectExt.merge({}, this.preprocess(defaults), this.preprocess(metadata));\n    this.id = props.id || StringExt.uuid();\n    this.store = new Store(props);\n    this.animation = new Animation(this);\n    this.setup();\n    this.init();\n    this.postprocess(metadata);\n  }\n  static config(presets) {\n    const {\n        markup,\n        propHooks,\n        attrHooks\n      } = presets,\n      others = __rest(presets, [\"markup\", \"propHooks\", \"attrHooks\"]);\n    if (markup != null) {\n      this.markup = markup;\n    }\n    if (propHooks) {\n      this.propHooks = this.propHooks.slice();\n      if (Array.isArray(propHooks)) {\n        this.propHooks.push(...propHooks);\n      } else if (typeof propHooks === 'function') {\n        this.propHooks.push(propHooks);\n      } else {\n        Object.keys(propHooks).forEach(name => {\n          const hook = propHooks[name];\n          if (typeof hook === 'function') {\n            this.propHooks.push(hook);\n          }\n        });\n      }\n    }\n    if (attrHooks) {\n      this.attrHooks = Object.assign(Object.assign({}, this.attrHooks), attrHooks);\n    }\n    this.defaults = ObjectExt.merge({}, this.defaults, others);\n  }\n  static getMarkup() {\n    return this.markup;\n  }\n  static getDefaults(raw) {\n    return raw ? this.defaults : ObjectExt.cloneDeep(this.defaults);\n  }\n  static getAttrHooks() {\n    return this.attrHooks;\n  }\n  static applyPropHooks(cell, metadata) {\n    return this.propHooks.reduce((memo, hook) => {\n      return hook ? FunctionExt.call(hook, cell, memo) : memo;\n    }, metadata);\n  }\n  // #endregion\n  get [Symbol.toStringTag]() {\n    return Cell.toStringTag;\n  }\n  init() {}\n  // #region model\n  get model() {\n    return this._model;\n  }\n  set model(model) {\n    if (this._model !== model) {\n      this._model = model;\n    }\n  }\n  // #endregion\n  preprocess(metadata, ignoreIdCheck) {\n    const id = metadata.id;\n    const ctor = this.constructor;\n    const props = ctor.applyPropHooks(this, metadata);\n    if (id == null && ignoreIdCheck !== true) {\n      props.id = StringExt.uuid();\n    }\n    return props;\n  }\n  postprocess(metadata) {} // eslint-disable-line\n  setup() {\n    this.store.on('change:*', metadata => {\n      const {\n        key,\n        current,\n        previous,\n        options\n      } = metadata;\n      this.notify('change:*', {\n        key,\n        options,\n        current,\n        previous,\n        cell: this\n      });\n      this.notify(`change:${key}`, {\n        options,\n        current,\n        previous,\n        cell: this\n      });\n      const type = key;\n      if (type === 'source' || type === 'target') {\n        this.notify(`change:terminal`, {\n          type,\n          current,\n          previous,\n          options,\n          cell: this\n        });\n      }\n    });\n    this.store.on('changed', ({\n      options\n    }) => this.notify('changed', {\n      options,\n      cell: this\n    }));\n  }\n  notify(name, args) {\n    this.trigger(name, args);\n    const model = this.model;\n    if (model) {\n      model.notify(`cell:${name}`, args);\n      if (this.isNode()) {\n        model.notify(`node:${name}`, Object.assign(Object.assign({}, args), {\n          node: this\n        }));\n      } else if (this.isEdge()) {\n        model.notify(`edge:${name}`, Object.assign(Object.assign({}, args), {\n          edge: this\n        }));\n      }\n    }\n    return this;\n  }\n  isNode() {\n    return false;\n  }\n  isEdge() {\n    return false;\n  }\n  isSameStore(cell) {\n    return this.store === cell.store;\n  }\n  get view() {\n    return this.store.get('view');\n  }\n  get shape() {\n    return this.store.get('shape', '');\n  }\n  getProp(key, defaultValue) {\n    if (key == null) {\n      return this.store.get();\n    }\n    return this.store.get(key, defaultValue);\n  }\n  setProp(key, value, options) {\n    if (typeof key === 'string') {\n      this.store.set(key, value, options);\n    } else {\n      const props = this.preprocess(key, true);\n      this.store.set(ObjectExt.merge({}, this.getProp(), props), value);\n      this.postprocess(key);\n    }\n    return this;\n  }\n  removeProp(key, options) {\n    if (typeof key === 'string' || Array.isArray(key)) {\n      this.store.removeByPath(key, options);\n    } else {\n      this.store.remove(options);\n    }\n    return this;\n  }\n  hasChanged(key) {\n    return key == null ? this.store.hasChanged() : this.store.hasChanged(key);\n  }\n  getPropByPath(path) {\n    return this.store.getByPath(path);\n  }\n  setPropByPath(path, value, options = {}) {\n    if (this.model) {\n      // update inner reference\n      if (path === 'children') {\n        this._children = value ? value.map(id => this.model.getCell(id)).filter(child => child != null) : null;\n      } else if (path === 'parent') {\n        this._parent = value ? this.model.getCell(value) : null;\n      }\n    }\n    this.store.setByPath(path, value, options);\n    return this;\n  }\n  removePropByPath(path, options = {}) {\n    const paths = Array.isArray(path) ? path : path.split('/');\n    // Once a property is removed from the `attrs` the CellView will\n    // recognize a `dirty` flag and re-render itself in order to remove\n    // the attribute from SVGElement.\n    if (paths[0] === 'attrs') {\n      options.dirty = true;\n    }\n    this.store.removeByPath(paths, options);\n    return this;\n  }\n  prop(key, value, options) {\n    if (key == null) {\n      return this.getProp();\n    }\n    if (typeof key === 'string' || Array.isArray(key)) {\n      if (arguments.length === 1) {\n        return this.getPropByPath(key);\n      }\n      if (value == null) {\n        return this.removePropByPath(key, options || {});\n      }\n      return this.setPropByPath(key, value, options || {});\n    }\n    return this.setProp(key, value || {});\n  }\n  previous(name) {\n    return this.store.getPrevious(name);\n  }\n  // #endregion\n  // #region zIndex\n  get zIndex() {\n    return this.getZIndex();\n  }\n  set zIndex(z) {\n    if (z == null) {\n      this.removeZIndex();\n    } else {\n      this.setZIndex(z);\n    }\n  }\n  getZIndex() {\n    return this.store.get('zIndex');\n  }\n  setZIndex(z, options = {}) {\n    this.store.set('zIndex', z, options);\n    return this;\n  }\n  removeZIndex(options = {}) {\n    this.store.remove('zIndex', options);\n    return this;\n  }\n  toFront(options = {}) {\n    const model = this.model;\n    if (model) {\n      let z = model.getMaxZIndex();\n      let cells;\n      if (options.deep) {\n        cells = this.getDescendants({\n          deep: true,\n          breadthFirst: true\n        });\n        cells.unshift(this);\n      } else {\n        cells = [this];\n      }\n      z = z - cells.length + 1;\n      const count = model.total();\n      let changed = model.indexOf(this) !== count - cells.length;\n      if (!changed) {\n        changed = cells.some((cell, index) => cell.getZIndex() !== z + index);\n      }\n      if (changed) {\n        this.batchUpdate('to-front', () => {\n          z += cells.length;\n          cells.forEach((cell, index) => {\n            cell.setZIndex(z + index, options);\n          });\n        });\n      }\n    }\n    return this;\n  }\n  toBack(options = {}) {\n    const model = this.model;\n    if (model) {\n      let z = model.getMinZIndex();\n      let cells;\n      if (options.deep) {\n        cells = this.getDescendants({\n          deep: true,\n          breadthFirst: true\n        });\n        cells.unshift(this);\n      } else {\n        cells = [this];\n      }\n      let changed = model.indexOf(this) !== 0;\n      if (!changed) {\n        changed = cells.some((cell, index) => cell.getZIndex() !== z + index);\n      }\n      if (changed) {\n        this.batchUpdate('to-back', () => {\n          z -= cells.length;\n          cells.forEach((cell, index) => {\n            cell.setZIndex(z + index, options);\n          });\n        });\n      }\n    }\n    return this;\n  }\n  // #endregion\n  // #region markup\n  get markup() {\n    return this.getMarkup();\n  }\n  set markup(value) {\n    if (value == null) {\n      this.removeMarkup();\n    } else {\n      this.setMarkup(value);\n    }\n  }\n  getMarkup() {\n    let markup = this.store.get('markup');\n    if (markup == null) {\n      const ctor = this.constructor;\n      markup = ctor.getMarkup();\n    }\n    return markup;\n  }\n  setMarkup(markup, options = {}) {\n    this.store.set('markup', markup, options);\n    return this;\n  }\n  removeMarkup(options = {}) {\n    this.store.remove('markup', options);\n    return this;\n  }\n  // #endregion\n  // #region attrs\n  get attrs() {\n    return this.getAttrs();\n  }\n  set attrs(value) {\n    if (value == null) {\n      this.removeAttrs();\n    } else {\n      this.setAttrs(value);\n    }\n  }\n  getAttrs() {\n    const result = this.store.get('attrs');\n    return result ? Object.assign({}, result) : {};\n  }\n  setAttrs(attrs, options = {}) {\n    if (attrs == null) {\n      this.removeAttrs(options);\n    } else {\n      const set = attrs => this.store.set('attrs', attrs, options);\n      if (options.overwrite === true) {\n        set(attrs);\n      } else {\n        const prev = this.getAttrs();\n        if (options.deep === false) {\n          set(Object.assign(Object.assign({}, prev), attrs));\n        } else {\n          set(ObjectExt.merge({}, prev, attrs));\n        }\n      }\n    }\n    return this;\n  }\n  replaceAttrs(attrs, options = {}) {\n    return this.setAttrs(attrs, Object.assign(Object.assign({}, options), {\n      overwrite: true\n    }));\n  }\n  updateAttrs(attrs, options = {}) {\n    return this.setAttrs(attrs, Object.assign(Object.assign({}, options), {\n      deep: false\n    }));\n  }\n  removeAttrs(options = {}) {\n    this.store.remove('attrs', options);\n    return this;\n  }\n  getAttrDefinition(attrName) {\n    if (!attrName) {\n      return null;\n    }\n    const ctor = this.constructor;\n    const hooks = ctor.getAttrHooks() || {};\n    let definition = hooks[attrName] || Attr.registry.get(attrName);\n    if (!definition) {\n      const name = StringExt.camelCase(attrName);\n      definition = hooks[name] || Attr.registry.get(name);\n    }\n    return definition || null;\n  }\n  getAttrByPath(path) {\n    if (path == null || path === '') {\n      return this.getAttrs();\n    }\n    return this.getPropByPath(this.prefixAttrPath(path));\n  }\n  setAttrByPath(path, value, options = {}) {\n    this.setPropByPath(this.prefixAttrPath(path), value, options);\n    return this;\n  }\n  removeAttrByPath(path, options = {}) {\n    this.removePropByPath(this.prefixAttrPath(path), options);\n    return this;\n  }\n  prefixAttrPath(path) {\n    return Array.isArray(path) ? ['attrs'].concat(path) : `attrs/${path}`;\n  }\n  attr(path, value, options) {\n    if (path == null) {\n      return this.getAttrByPath();\n    }\n    if (typeof path === 'string' || Array.isArray(path)) {\n      if (arguments.length === 1) {\n        return this.getAttrByPath(path);\n      }\n      if (value == null) {\n        return this.removeAttrByPath(path, options || {});\n      }\n      return this.setAttrByPath(path, value, options || {});\n    }\n    return this.setAttrs(path, value || {});\n  }\n  // #endregion\n  // #region visible\n  get visible() {\n    return this.isVisible();\n  }\n  set visible(value) {\n    this.setVisible(value);\n  }\n  setVisible(visible, options = {}) {\n    this.store.set('visible', visible, options);\n    return this;\n  }\n  isVisible() {\n    return this.store.get('visible') !== false;\n  }\n  show(options = {}) {\n    if (!this.isVisible()) {\n      this.setVisible(true, options);\n    }\n    return this;\n  }\n  hide(options = {}) {\n    if (this.isVisible()) {\n      this.setVisible(false, options);\n    }\n    return this;\n  }\n  toggleVisible(isVisible, options = {}) {\n    const visible = typeof isVisible === 'boolean' ? isVisible : !this.isVisible();\n    const localOptions = typeof isVisible === 'boolean' ? options : isVisible;\n    if (visible) {\n      this.show(localOptions);\n    } else {\n      this.hide(localOptions);\n    }\n    return this;\n  }\n  // #endregion\n  // #region data\n  get data() {\n    return this.getData();\n  }\n  set data(val) {\n    this.setData(val);\n  }\n  getData() {\n    return this.store.get('data');\n  }\n  setData(data, options = {}) {\n    if (data == null) {\n      this.removeData(options);\n    } else {\n      const set = data => this.store.set('data', data, options);\n      if (options.overwrite === true) {\n        set(data);\n      } else {\n        const prev = this.getData();\n        if (options.deep === false) {\n          set(typeof data === 'object' ? Object.assign(Object.assign({}, prev), data) : data);\n        } else {\n          set(ObjectExt.merge({}, prev, data));\n        }\n      }\n    }\n    return this;\n  }\n  replaceData(data, options = {}) {\n    return this.setData(data, Object.assign(Object.assign({}, options), {\n      overwrite: true\n    }));\n  }\n  updateData(data, options = {}) {\n    return this.setData(data, Object.assign(Object.assign({}, options), {\n      deep: false\n    }));\n  }\n  removeData(options = {}) {\n    this.store.remove('data', options);\n    return this;\n  }\n  // #endregion\n  // #region parent children\n  get parent() {\n    return this.getParent();\n  }\n  get children() {\n    return this.getChildren();\n  }\n  getParentId() {\n    return this.store.get('parent');\n  }\n  getParent() {\n    const parentId = this.getParentId();\n    if (parentId && this.model) {\n      const parent = this.model.getCell(parentId);\n      this._parent = parent;\n      return parent;\n    }\n    return null;\n  }\n  getChildren() {\n    const childrenIds = this.store.get('children');\n    if (childrenIds && childrenIds.length && this.model) {\n      const children = childrenIds.map(id => {\n        var _a;\n        return (_a = this.model) === null || _a === void 0 ? void 0 : _a.getCell(id);\n      }).filter(cell => cell != null);\n      this._children = children;\n      return [...children];\n    }\n    return null;\n  }\n  hasParent() {\n    return this.parent != null;\n  }\n  isParentOf(child) {\n    return child != null && child.getParent() === this;\n  }\n  isChildOf(parent) {\n    return parent != null && this.getParent() === parent;\n  }\n  eachChild(iterator, context) {\n    if (this.children) {\n      this.children.forEach(iterator, context);\n    }\n    return this;\n  }\n  filterChild(filter, context) {\n    return this.children ? this.children.filter(filter, context) : [];\n  }\n  getChildCount() {\n    return this.children == null ? 0 : this.children.length;\n  }\n  getChildIndex(child) {\n    return this.children == null ? -1 : this.children.indexOf(child);\n  }\n  getChildAt(index) {\n    return this.children != null && index >= 0 ? this.children[index] : null;\n  }\n  getAncestors(options = {}) {\n    const ancestors = [];\n    let parent = this.getParent();\n    while (parent) {\n      ancestors.push(parent);\n      parent = options.deep !== false ? parent.getParent() : null;\n    }\n    return ancestors;\n  }\n  getDescendants(options = {}) {\n    if (options.deep !== false) {\n      // breadth first\n      if (options.breadthFirst) {\n        const cells = [];\n        const queue = this.getChildren() || [];\n        while (queue.length > 0) {\n          const parent = queue.shift();\n          const children = parent.getChildren();\n          cells.push(parent);\n          if (children) {\n            queue.push(...children);\n          }\n        }\n        return cells;\n      }\n      // depth first\n      {\n        const cells = this.getChildren() || [];\n        cells.forEach(cell => {\n          cells.push(...cell.getDescendants(options));\n        });\n        return cells;\n      }\n    }\n    return this.getChildren() || [];\n  }\n  isDescendantOf(ancestor, options = {}) {\n    if (ancestor == null) {\n      return false;\n    }\n    if (options.deep !== false) {\n      let current = this.getParent();\n      while (current) {\n        if (current === ancestor) {\n          return true;\n        }\n        current = current.getParent();\n      }\n      return false;\n    }\n    return this.isChildOf(ancestor);\n  }\n  isAncestorOf(descendant, options = {}) {\n    if (descendant == null) {\n      return false;\n    }\n    return descendant.isDescendantOf(this, options);\n  }\n  contains(cell) {\n    return this.isAncestorOf(cell);\n  }\n  getCommonAncestor(...cells) {\n    return Cell.getCommonAncestor(this, ...cells);\n  }\n  setParent(parent, options = {}) {\n    this._parent = parent;\n    if (parent) {\n      this.store.set('parent', parent.id, options);\n    } else {\n      this.store.remove('parent', options);\n    }\n    return this;\n  }\n  setChildren(children, options = {}) {\n    this._children = children;\n    if (children != null) {\n      this.store.set('children', children.map(child => child.id), options);\n    } else {\n      this.store.remove('children', options);\n    }\n    return this;\n  }\n  unembed(child, options = {}) {\n    const children = this.children;\n    if (children != null && child != null) {\n      const index = this.getChildIndex(child);\n      if (index !== -1) {\n        children.splice(index, 1);\n        child.setParent(null, options);\n        this.setChildren(children, options);\n      }\n    }\n    return this;\n  }\n  embed(child, options = {}) {\n    child.addTo(this, options);\n    return this;\n  }\n  addTo(target, options = {}) {\n    if (Cell.isCell(target)) {\n      target.addChild(this, options);\n    } else {\n      target.addCell(this, options);\n    }\n    return this;\n  }\n  insertTo(parent, index, options = {}) {\n    parent.insertChild(this, index, options);\n    return this;\n  }\n  addChild(child, options = {}) {\n    return this.insertChild(child, undefined, options);\n  }\n  insertChild(child, index, options = {}) {\n    if (child != null && child !== this) {\n      const oldParent = child.getParent();\n      const changed = this !== oldParent;\n      let pos = index;\n      if (pos == null) {\n        pos = this.getChildCount();\n        if (!changed) {\n          pos -= 1;\n        }\n      }\n      // remove from old parent\n      if (oldParent) {\n        const children = oldParent.getChildren();\n        if (children) {\n          const index = children.indexOf(child);\n          if (index >= 0) {\n            child.setParent(null, options);\n            children.splice(index, 1);\n            oldParent.setChildren(children, options);\n          }\n        }\n      }\n      let children = this.children;\n      if (children == null) {\n        children = [];\n        children.push(child);\n      } else {\n        children.splice(pos, 0, child);\n      }\n      child.setParent(this, options);\n      this.setChildren(children, options);\n      if (changed && this.model) {\n        const incomings = this.model.getIncomingEdges(this);\n        const outgoings = this.model.getOutgoingEdges(this);\n        if (incomings) {\n          incomings.forEach(edge => edge.updateParent(options));\n        }\n        if (outgoings) {\n          outgoings.forEach(edge => edge.updateParent(options));\n        }\n      }\n      if (this.model) {\n        this.model.addCell(child, options);\n      }\n    }\n    return this;\n  }\n  removeFromParent(options = {}) {\n    const parent = this.getParent();\n    if (parent != null) {\n      const index = parent.getChildIndex(this);\n      parent.removeChildAt(index, options);\n    }\n    return this;\n  }\n  removeChild(child, options = {}) {\n    const index = this.getChildIndex(child);\n    return this.removeChildAt(index, options);\n  }\n  removeChildAt(index, options = {}) {\n    const child = this.getChildAt(index);\n    const children = this.children;\n    if (children != null && child != null) {\n      this.unembed(child, options);\n      child.remove(options);\n    }\n    return child;\n  }\n  remove(options = {}) {\n    this.batchUpdate('remove', () => {\n      const parent = this.getParent();\n      if (parent) {\n        parent.removeChild(this, options);\n      }\n      if (options.deep !== false) {\n        this.eachChild(child => child.remove(options));\n      }\n      if (this.model) {\n        this.model.removeCell(this, options);\n      }\n    });\n    return this;\n  }\n  transition(path, target, options = {}, delim = '/') {\n    return this.animation.start(path, target, options, delim);\n  }\n  stopTransition(path, options, delim = '/') {\n    this.animation.stop(path, options, delim);\n    return this;\n  }\n  getTransitions() {\n    return this.animation.get();\n  }\n  // #endregion\n  // #region transform\n  // eslint-disable-next-line\n  translate(tx, ty, options) {\n    return this;\n  }\n  scale(sx,\n  // eslint-disable-line\n  sy,\n  // eslint-disable-line\n  origin,\n  // eslint-disable-line\n  options) {\n    return this;\n  }\n  addTools(items, obj, options) {\n    const toolItems = Array.isArray(items) ? items : [items];\n    const name = typeof obj === 'string' ? obj : null;\n    const config = typeof obj === 'object' ? obj : typeof options === 'object' ? options : {};\n    if (config.reset) {\n      return this.setTools({\n        name,\n        items: toolItems,\n        local: config.local\n      }, config);\n    }\n    let tools = ObjectExt.cloneDeep(this.getTools());\n    if (tools == null || name == null || tools.name === name) {\n      if (tools == null) {\n        tools = {};\n      }\n      if (!tools.items) {\n        tools.items = [];\n      }\n      tools.name = name;\n      tools.items = [...tools.items, ...toolItems];\n      return this.setTools(Object.assign({}, tools), config);\n    }\n  }\n  setTools(tools, options = {}) {\n    if (tools == null) {\n      this.removeTools();\n    } else {\n      this.store.set('tools', Cell.normalizeTools(tools), options);\n    }\n    return this;\n  }\n  getTools() {\n    return this.store.get('tools');\n  }\n  removeTools(options = {}) {\n    this.store.remove('tools', options);\n    return this;\n  }\n  hasTools(name) {\n    const tools = this.getTools();\n    if (tools == null) {\n      return false;\n    }\n    if (name == null) {\n      return true;\n    }\n    return tools.name === name;\n  }\n  hasTool(name) {\n    const tools = this.getTools();\n    if (tools == null) {\n      return false;\n    }\n    return tools.items.some(item => typeof item === 'string' ? item === name : item.name === name);\n  }\n  removeTool(nameOrIndex, options = {}) {\n    const tools = ObjectExt.cloneDeep(this.getTools());\n    if (tools) {\n      let updated = false;\n      const items = tools.items.slice();\n      const remove = index => {\n        items.splice(index, 1);\n        updated = true;\n      };\n      if (typeof nameOrIndex === 'number') {\n        remove(nameOrIndex);\n      } else {\n        for (let i = items.length - 1; i >= 0; i -= 1) {\n          const item = items[i];\n          const exist = typeof item === 'string' ? item === nameOrIndex : item.name === nameOrIndex;\n          if (exist) {\n            remove(i);\n          }\n        }\n      }\n      if (updated) {\n        tools.items = items;\n        this.setTools(tools, options);\n      }\n    }\n    return this;\n  }\n  // #endregion\n  // #region common\n  // eslint-disable-next-line\n  getBBox(options) {\n    return new Rectangle();\n  }\n  // eslint-disable-next-line\n  getConnectionPoint(edge, type) {\n    return new Point();\n  }\n  toJSON(options = {}) {\n    const props = Object.assign({}, this.store.get());\n    const toString = Object.prototype.toString;\n    const cellType = this.isNode() ? 'node' : this.isEdge() ? 'edge' : 'cell';\n    if (!props.shape) {\n      const ctor = this.constructor;\n      throw new Error(`Unable to serialize ${cellType} missing \"shape\" prop, check the ${cellType} \"${ctor.name || toString.call(ctor)}\"`);\n    }\n    const ctor = this.constructor;\n    const diff = options.diff === true;\n    const attrs = props.attrs || {};\n    const presets = ctor.getDefaults(true);\n    // When `options.diff` is `true`, we should process the custom options,\n    // such as `width`, `height` etc. to ensure the comparing work correctly.\n    const defaults = diff ? this.preprocess(presets, true) : presets;\n    const defaultAttrs = defaults.attrs || {};\n    const finalAttrs = {};\n    Object.keys(props).forEach(key => {\n      const val = props[key];\n      if (val != null && !Array.isArray(val) && typeof val === 'object' && !ObjectExt.isPlainObject(val)) {\n        throw new Error(`Can only serialize ${cellType} with plain-object props, but got a \"${toString.call(val)}\" type of key \"${key}\" on ${cellType} \"${this.id}\"`);\n      }\n      if (key !== 'attrs' && key !== 'shape' && diff) {\n        const preset = defaults[key];\n        if (ObjectExt.isEqual(val, preset)) {\n          delete props[key];\n        }\n      }\n    });\n    Object.keys(attrs).forEach(key => {\n      const attr = attrs[key];\n      const defaultAttr = defaultAttrs[key];\n      Object.keys(attr).forEach(name => {\n        const value = attr[name];\n        const defaultValue = defaultAttr ? defaultAttr[name] : null;\n        if (value != null && typeof value === 'object' && !Array.isArray(value)) {\n          Object.keys(value).forEach(subName => {\n            const subValue = value[subName];\n            if (defaultAttr == null || defaultValue == null || !ObjectExt.isObject(defaultValue) || !ObjectExt.isEqual(defaultValue[subName], subValue)) {\n              if (finalAttrs[key] == null) {\n                finalAttrs[key] = {};\n              }\n              if (finalAttrs[key][name] == null) {\n                finalAttrs[key][name] = {};\n              }\n              const tmp = finalAttrs[key][name];\n              tmp[subName] = subValue;\n            }\n          });\n        } else if (defaultAttr == null || !ObjectExt.isEqual(defaultValue, value)) {\n          // `value` is not an object, default attribute with `key` does not\n          // exist or it is different than the attribute value set on the cell.\n          if (finalAttrs[key] == null) {\n            finalAttrs[key] = {};\n          }\n          finalAttrs[key][name] = value;\n        }\n      });\n    });\n    const finalProps = Object.assign(Object.assign({}, props), {\n      attrs: ObjectExt.isEmpty(finalAttrs) ? undefined : finalAttrs\n    });\n    if (finalProps.attrs == null) {\n      delete finalProps.attrs;\n    }\n    const ret = finalProps;\n    if (ret.angle === 0) {\n      delete ret.angle;\n    }\n    return ObjectExt.cloneDeep(ret);\n  }\n  clone(options = {}) {\n    if (!options.deep) {\n      const data = Object.assign({}, this.store.get());\n      if (!options.keepId) {\n        delete data.id;\n      }\n      delete data.parent;\n      delete data.children;\n      const ctor = this.constructor;\n      return new ctor(data); // eslint-disable-line new-cap\n    }\n    // Deep cloning. Clone the cell itself and all its children.\n    const map = Cell.deepClone(this);\n    return map[this.id];\n  }\n  findView(graph) {\n    return graph.renderer.findViewByCell(this);\n  }\n  // #endregion\n  // #region batch\n  startBatch(name, data = {}, model = this.model) {\n    this.notify('batch:start', {\n      name,\n      data,\n      cell: this\n    });\n    if (model) {\n      model.startBatch(name, Object.assign(Object.assign({}, data), {\n        cell: this\n      }));\n    }\n    return this;\n  }\n  stopBatch(name, data = {}, model = this.model) {\n    if (model) {\n      model.stopBatch(name, Object.assign(Object.assign({}, data), {\n        cell: this\n      }));\n    }\n    this.notify('batch:stop', {\n      name,\n      data,\n      cell: this\n    });\n    return this;\n  }\n  batchUpdate(name, execute, data) {\n    // The model is null after cell was removed(remove batch).\n    // So we should temp save model to trigger pairing batch event.\n    const model = this.model;\n    this.startBatch(name, data, model);\n    const result = execute();\n    this.stopBatch(name, data, model);\n    return result;\n  }\n  // #endregion\n  // #region IDisposable\n  dispose() {\n    this.removeFromParent();\n    this.store.dispose();\n  }\n}\nCell.defaults = {};\nCell.attrHooks = {};\nCell.propHooks = [];\n__decorate([Basecoat.dispose()], Cell.prototype, \"dispose\", null);\n(function (Cell) {\n  function normalizeTools(raw) {\n    if (typeof raw === 'string') {\n      return {\n        items: [raw]\n      };\n    }\n    if (Array.isArray(raw)) {\n      return {\n        items: raw\n      };\n    }\n    if (raw.items) {\n      return raw;\n    }\n    return {\n      items: [raw]\n    };\n  }\n  Cell.normalizeTools = normalizeTools;\n})(Cell || (Cell = {}));\n(function (Cell) {\n  Cell.toStringTag = `X6.${Cell.name}`;\n  function isCell(instance) {\n    if (instance == null) {\n      return false;\n    }\n    if (instance instanceof Cell) {\n      return true;\n    }\n    const tag = instance[Symbol.toStringTag];\n    const cell = instance;\n    if ((tag == null || tag === Cell.toStringTag) && typeof cell.isNode === 'function' && typeof cell.isEdge === 'function' && typeof cell.prop === 'function' && typeof cell.attr === 'function') {\n      return true;\n    }\n    return false;\n  }\n  Cell.isCell = isCell;\n})(Cell || (Cell = {}));\n(function (Cell) {\n  function getCommonAncestor(...cells) {\n    const ancestors = cells.filter(cell => cell != null).map(cell => cell.getAncestors()).sort((a, b) => {\n      return a.length - b.length;\n    });\n    const first = ancestors.shift();\n    return first.find(cell => ancestors.every(item => item.includes(cell))) || null;\n  }\n  Cell.getCommonAncestor = getCommonAncestor;\n  function getCellsBBox(cells, options = {}) {\n    let bbox = null;\n    for (let i = 0, ii = cells.length; i < ii; i += 1) {\n      const cell = cells[i];\n      let rect = cell.getBBox(options);\n      if (rect) {\n        if (cell.isNode()) {\n          const angle = cell.getAngle();\n          if (angle != null && angle !== 0) {\n            rect = rect.bbox(angle);\n          }\n        }\n        bbox = bbox == null ? rect : bbox.union(rect);\n      }\n    }\n    return bbox;\n  }\n  Cell.getCellsBBox = getCellsBBox;\n  function deepClone(cell) {\n    const cells = [cell, ...cell.getDescendants({\n      deep: true\n    })];\n    return Cell.cloneCells(cells);\n  }\n  Cell.deepClone = deepClone;\n  function cloneCells(cells) {\n    const inputs = ArrayExt.uniq(cells);\n    const cloneMap = inputs.reduce((map, cell) => {\n      map[cell.id] = cell.clone();\n      return map;\n    }, {});\n    inputs.forEach(cell => {\n      const clone = cloneMap[cell.id];\n      if (clone.isEdge()) {\n        const sourceId = clone.getSourceCellId();\n        const targetId = clone.getTargetCellId();\n        if (sourceId && cloneMap[sourceId]) {\n          // Source is a node and the node is among the clones.\n          // Then update the source of the cloned edge.\n          clone.setSource(Object.assign(Object.assign({}, clone.getSource()), {\n            cell: cloneMap[sourceId].id\n          }));\n        }\n        if (targetId && cloneMap[targetId]) {\n          // Target is a node and the node is among the clones.\n          // Then update the target of the cloned edge.\n          clone.setTarget(Object.assign(Object.assign({}, clone.getTarget()), {\n            cell: cloneMap[targetId].id\n          }));\n        }\n      }\n      // Find the parent of the original cell\n      const parent = cell.getParent();\n      if (parent && cloneMap[parent.id]) {\n        clone.setParent(cloneMap[parent.id]);\n      }\n      // Find the children of the original cell\n      const children = cell.getChildren();\n      if (children && children.length) {\n        const embeds = children.reduce((memo, child) => {\n          // Embedded cells that are not being cloned can not be carried\n          // over with other embedded cells.\n          if (cloneMap[child.id]) {\n            memo.push(cloneMap[child.id]);\n          }\n          return memo;\n        }, []);\n        if (embeds.length > 0) {\n          clone.setChildren(embeds);\n        }\n      }\n    });\n    return cloneMap;\n  }\n  Cell.cloneCells = cloneCells;\n})(Cell || (Cell = {}));\n(function (Cell) {\n  Cell.config({\n    propHooks(_a) {\n      var {\n          tools\n        } = _a,\n        metadata = __rest(_a, [\"tools\"]);\n      if (tools) {\n        metadata.tools = Cell.normalizeTools(tools);\n      }\n      return metadata;\n    }\n  });\n})(Cell || (Cell = {}));","map":{"version":3,"names":["ArrayExt","StringExt","ObjectExt","FunctionExt","Rectangle","Point","Basecoat","Attr","Animation","Store","Cell","constructor","metadata","ctor","defaults","getDefaults","props","merge","preprocess","id","uuid","store","animation","setup","init","postprocess","config","presets","markup","propHooks","attrHooks","others","__rest","slice","Array","isArray","push","Object","keys","forEach","name","hook","assign","getMarkup","raw","cloneDeep","getAttrHooks","applyPropHooks","cell","reduce","memo","call","Symbol","toStringTag","model","_model","ignoreIdCheck","on","key","current","previous","options","notify","type","args","trigger","isNode","node","isEdge","edge","isSameStore","view","get","shape","getProp","defaultValue","setProp","value","set","removeProp","removeByPath","remove","hasChanged","getPropByPath","path","getByPath","setPropByPath","_children","map","getCell","filter","child","_parent","setByPath","removePropByPath","paths","split","dirty","prop","arguments","length","getPrevious","zIndex","getZIndex","z","removeZIndex","setZIndex","toFront","getMaxZIndex","cells","deep","getDescendants","breadthFirst","unshift","count","total","changed","indexOf","some","index","batchUpdate","toBack","getMinZIndex","removeMarkup","setMarkup","attrs","getAttrs","removeAttrs","setAttrs","result","overwrite","prev","replaceAttrs","updateAttrs","getAttrDefinition","attrName","hooks","definition","registry","camelCase","getAttrByPath","prefixAttrPath","setAttrByPath","removeAttrByPath","concat","attr","visible","isVisible","setVisible","show","hide","toggleVisible","localOptions","data","getData","val","setData","removeData","replaceData","updateData","parent","getParent","children","getChildren","getParentId","parentId","childrenIds","_a","hasParent","isParentOf","isChildOf","eachChild","iterator","context","filterChild","getChildCount","getChildIndex","getChildAt","getAncestors","ancestors","queue","shift","isDescendantOf","ancestor","isAncestorOf","descendant","contains","getCommonAncestor","setParent","setChildren","unembed","splice","embed","addTo","target","isCell","addChild","addCell","insertTo","insertChild","undefined","oldParent","pos","incomings","getIncomingEdges","outgoings","getOutgoingEdges","updateParent","removeFromParent","removeChildAt","removeChild","removeCell","transition","delim","start","stopTransition","stop","getTransitions","translate","tx","ty","scale","sx","sy","origin","addTools","items","obj","toolItems","reset","setTools","local","tools","getTools","removeTools","normalizeTools","hasTools","hasTool","item","removeTool","nameOrIndex","updated","i","exist","getBBox","getConnectionPoint","toJSON","toString","prototype","cellType","Error","diff","defaultAttrs","finalAttrs","isPlainObject","preset","isEqual","defaultAttr","subName","subValue","isObject","tmp","finalProps","isEmpty","ret","angle","clone","keepId","deepClone","findView","graph","renderer","findViewByCell","startBatch","stopBatch","execute","dispose","__decorate","instance","tag","sort","a","b","first","find","every","includes","getCellsBBox","bbox","ii","rect","getAngle","union","cloneCells","inputs","uniq","cloneMap","sourceId","getSourceCellId","targetId","getTargetCellId","setSource","getSource","setTarget","getTarget","embeds"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/model/cell.ts"],"sourcesContent":["/* eslint-disable no-underscore-dangle */\n\nimport { NonUndefined } from 'utility-types'\nimport { ArrayExt, StringExt, ObjectExt, FunctionExt } from '../util'\nimport { Rectangle, Point } from '../geometry'\nimport { KeyValue, Size } from '../types'\nimport { Knob } from '../addon/knob'\nimport { Basecoat } from '../common'\nimport { Attr } from '../registry'\nimport { Markup, CellView } from '../view'\nimport { Graph } from '../graph'\nimport { Model } from './model'\nimport { Animation } from './animation'\nimport { PortManager } from './port'\nimport { Store } from './store'\nimport { Node } from './node'\nimport { Edge } from './edge'\n\nexport class Cell<\n  Properties extends Cell.Properties = Cell.Properties,\n> extends Basecoat<Cell.EventArgs> {\n  // #region static\n\n  protected static markup: Markup\n  protected static defaults: Cell.Defaults = {}\n  protected static attrHooks: Attr.Definitions = {}\n  protected static propHooks: Cell.PropHook[] = []\n\n  public static config<C extends Cell.Config = Cell.Config>(presets: C) {\n    const { markup, propHooks, attrHooks, ...others } = presets\n\n    if (markup != null) {\n      this.markup = markup\n    }\n\n    if (propHooks) {\n      this.propHooks = this.propHooks.slice()\n      if (Array.isArray(propHooks)) {\n        this.propHooks.push(...propHooks)\n      } else if (typeof propHooks === 'function') {\n        this.propHooks.push(propHooks)\n      } else {\n        Object.keys(propHooks).forEach((name) => {\n          const hook = propHooks[name]\n          if (typeof hook === 'function') {\n            this.propHooks.push(hook)\n          }\n        })\n      }\n    }\n\n    if (attrHooks) {\n      this.attrHooks = { ...this.attrHooks, ...attrHooks }\n    }\n\n    this.defaults = ObjectExt.merge({}, this.defaults, others)\n  }\n\n  public static getMarkup() {\n    return this.markup\n  }\n\n  public static getDefaults<T extends Cell.Defaults = Cell.Defaults>(\n    raw?: boolean,\n  ): T {\n    return (raw ? this.defaults : ObjectExt.cloneDeep(this.defaults)) as T\n  }\n\n  public static getAttrHooks() {\n    return this.attrHooks\n  }\n\n  public static applyPropHooks(\n    cell: Cell,\n    metadata: Cell.Metadata,\n  ): Cell.Metadata {\n    return this.propHooks.reduce((memo, hook) => {\n      return hook ? FunctionExt.call(hook, cell, memo) : memo\n    }, metadata)\n  }\n\n  // #endregion\n\n  protected get [Symbol.toStringTag]() {\n    return Cell.toStringTag\n  }\n\n  public readonly id: string\n  protected readonly store: Store<Cell.Properties>\n  protected readonly animation: Animation\n  protected _model: Model | null // eslint-disable-line\n  protected _parent: Cell | null // eslint-disable-line\n  protected _children: Cell[] | null // eslint-disable-line\n\n  constructor(metadata: Cell.Metadata = {}) {\n    super()\n\n    const ctor = this.constructor as typeof Cell\n    const defaults = ctor.getDefaults(true)\n    const props = ObjectExt.merge(\n      {},\n      this.preprocess(defaults),\n      this.preprocess(metadata),\n    )\n\n    this.id = props.id || StringExt.uuid()\n    this.store = new Store(props)\n    this.animation = new Animation(this)\n    this.setup()\n    this.init()\n    this.postprocess(metadata)\n  }\n\n  init() {}\n\n  // #region model\n\n  get model() {\n    return this._model\n  }\n\n  set model(model: Model | null) {\n    if (this._model !== model) {\n      this._model = model\n    }\n  }\n\n  // #endregion\n\n  protected preprocess(\n    metadata: Cell.Metadata,\n    ignoreIdCheck?: boolean,\n  ): Properties {\n    const id = metadata.id\n    const ctor = this.constructor as typeof Cell\n    const props = ctor.applyPropHooks(this, metadata)\n\n    if (id == null && ignoreIdCheck !== true) {\n      props.id = StringExt.uuid()\n    }\n\n    return props as Properties\n  }\n\n  protected postprocess(metadata: Cell.Metadata) {} // eslint-disable-line\n\n  protected setup() {\n    this.store.on('change:*', (metadata) => {\n      const { key, current, previous, options } = metadata\n\n      this.notify('change:*', {\n        key,\n        options,\n        current,\n        previous,\n        cell: this,\n      })\n\n      this.notify(`change:${key}` as keyof Cell.EventArgs, {\n        options,\n        current,\n        previous,\n        cell: this,\n      })\n\n      const type = key as Edge.TerminalType\n      if (type === 'source' || type === 'target') {\n        this.notify(`change:terminal`, {\n          type,\n          current,\n          previous,\n          options,\n          cell: this,\n        })\n      }\n    })\n\n    this.store.on('changed', ({ options }) =>\n      this.notify('changed', { options, cell: this }),\n    )\n  }\n\n  notify<Key extends keyof Cell.EventArgs>(\n    name: Key,\n    args: Cell.EventArgs[Key],\n  ): this\n  notify(name: Exclude<string, keyof Cell.EventArgs>, args: any): this\n  notify<Key extends keyof Cell.EventArgs>(\n    name: Key,\n    args: Cell.EventArgs[Key],\n  ) {\n    this.trigger(name, args)\n    const model = this.model\n    if (model) {\n      model.notify(`cell:${name}`, args)\n      if (this.isNode()) {\n        model.notify(`node:${name}`, { ...args, node: this })\n      } else if (this.isEdge()) {\n        model.notify(`edge:${name}`, { ...args, edge: this })\n      }\n    }\n    return this\n  }\n\n  isNode(): this is Node {\n    return false\n  }\n\n  isEdge(): this is Edge {\n    return false\n  }\n\n  isSameStore(cell: Cell) {\n    return this.store === cell.store\n  }\n\n  get view() {\n    return this.store.get('view')\n  }\n\n  get shape() {\n    return this.store.get('shape', '')\n  }\n\n  // #region get/set\n\n  getProp(): Properties\n  getProp<K extends keyof Properties>(key: K): Properties[K]\n  getProp<K extends keyof Properties>(\n    key: K,\n    defaultValue: Properties[K],\n  ): NonUndefined<Properties[K]>\n  getProp<T>(key: string): T\n  getProp<T>(key: string, defaultValue: T): T\n  getProp(key?: string, defaultValue?: any) {\n    if (key == null) {\n      return this.store.get()\n    }\n\n    return this.store.get(key, defaultValue)\n  }\n\n  setProp<K extends keyof Properties>(\n    key: K,\n    value: Properties[K] | null | undefined | void,\n    options?: Cell.SetOptions,\n  ): this\n  setProp(key: string, value: any, options?: Cell.SetOptions): this\n  setProp(props: Partial<Properties>, options?: Cell.SetOptions): this\n  setProp(\n    key: string | Partial<Properties>,\n    value?: any,\n    options?: Cell.SetOptions,\n  ) {\n    if (typeof key === 'string') {\n      this.store.set(key, value, options)\n    } else {\n      const props = this.preprocess(key, true)\n      this.store.set(ObjectExt.merge({}, this.getProp(), props), value)\n      this.postprocess(key)\n    }\n    return this\n  }\n\n  removeProp<K extends keyof Properties>(\n    key: K | K[],\n    options?: Cell.SetOptions,\n  ): this\n  removeProp(key: string | string[], options?: Cell.SetOptions): this\n  removeProp(options?: Cell.SetOptions): this\n  removeProp(\n    key?: string | string[] | Cell.SetOptions,\n    options?: Cell.SetOptions,\n  ) {\n    if (typeof key === 'string' || Array.isArray(key)) {\n      this.store.removeByPath(key, options)\n    } else {\n      this.store.remove(options)\n    }\n    return this\n  }\n\n  hasChanged(): boolean\n  hasChanged<K extends keyof Properties>(key: K | null): boolean\n  hasChanged(key: string | null): boolean\n  hasChanged(key?: string | null) {\n    return key == null ? this.store.hasChanged() : this.store.hasChanged(key)\n  }\n\n  getPropByPath<T>(path: string | string[]) {\n    return this.store.getByPath<T>(path)\n  }\n\n  setPropByPath(\n    path: string | string[],\n    value: any,\n    options: Cell.SetByPathOptions = {},\n  ) {\n    if (this.model) {\n      // update inner reference\n      if (path === 'children') {\n        this._children = value\n          ? value\n              .map((id: string) => this.model!.getCell(id))\n              .filter((child: Cell) => child != null)\n          : null\n      } else if (path === 'parent') {\n        this._parent = value ? this.model.getCell(value) : null\n      }\n    }\n\n    this.store.setByPath(path, value, options)\n    return this\n  }\n\n  removePropByPath(path: string | string[], options: Cell.SetOptions = {}) {\n    const paths = Array.isArray(path) ? path : path.split('/')\n    // Once a property is removed from the `attrs` the CellView will\n    // recognize a `dirty` flag and re-render itself in order to remove\n    // the attribute from SVGElement.\n    if (paths[0] === 'attrs') {\n      options.dirty = true\n    }\n    this.store.removeByPath(paths, options)\n    return this\n  }\n\n  prop(): Properties\n  prop<K extends keyof Properties>(key: K): Properties[K]\n  prop<T>(key: string): T\n  prop<T>(path: string[]): T\n  prop<K extends keyof Properties>(\n    key: K,\n    value: Properties[K] | null | undefined | void,\n    options?: Cell.SetOptions,\n  ): this\n  prop(key: string, value: any, options?: Cell.SetOptions): this\n  prop(path: string[], value: any, options?: Cell.SetOptions): this\n  prop(props: Partial<Properties>, options?: Cell.SetOptions): this\n  prop(\n    key?: string | string[] | Partial<Properties>,\n    value?: any,\n    options?: Cell.SetOptions,\n  ) {\n    if (key == null) {\n      return this.getProp()\n    }\n\n    if (typeof key === 'string' || Array.isArray(key)) {\n      if (arguments.length === 1) {\n        return this.getPropByPath(key)\n      }\n\n      if (value == null) {\n        return this.removePropByPath(key, options || {})\n      }\n\n      return this.setPropByPath(key, value, options || {})\n    }\n\n    return this.setProp(key, value || {})\n  }\n\n  previous<K extends keyof Properties>(name: K): Properties[K] | undefined\n  previous<T>(name: string): T | undefined\n  previous(name: string) {\n    return this.store.getPrevious(name as keyof Cell.Properties)\n  }\n\n  // #endregion\n\n  // #region zIndex\n\n  get zIndex() {\n    return this.getZIndex()\n  }\n\n  set zIndex(z: number | undefined | null) {\n    if (z == null) {\n      this.removeZIndex()\n    } else {\n      this.setZIndex(z)\n    }\n  }\n\n  getZIndex() {\n    return this.store.get('zIndex')\n  }\n\n  setZIndex(z: number, options: Cell.SetOptions = {}) {\n    this.store.set('zIndex', z, options)\n    return this\n  }\n\n  removeZIndex(options: Cell.SetOptions = {}) {\n    this.store.remove('zIndex', options)\n    return this\n  }\n\n  toFront(options: Cell.ToFrontOptions = {}) {\n    const model = this.model\n    if (model) {\n      let z = model.getMaxZIndex()\n      let cells: Cell[]\n      if (options.deep) {\n        cells = this.getDescendants({ deep: true, breadthFirst: true })\n        cells.unshift(this)\n      } else {\n        cells = [this]\n      }\n\n      z = z - cells.length + 1\n\n      const count = model.total()\n      let changed = model.indexOf(this) !== count - cells.length\n      if (!changed) {\n        changed = cells.some((cell, index) => cell.getZIndex() !== z + index)\n      }\n\n      if (changed) {\n        this.batchUpdate('to-front', () => {\n          z += cells.length\n          cells.forEach((cell, index) => {\n            cell.setZIndex(z + index, options)\n          })\n        })\n      }\n    }\n\n    return this\n  }\n\n  toBack(options: Cell.ToBackOptions = {}) {\n    const model = this.model\n    if (model) {\n      let z = model.getMinZIndex()\n      let cells: Cell[]\n\n      if (options.deep) {\n        cells = this.getDescendants({ deep: true, breadthFirst: true })\n        cells.unshift(this)\n      } else {\n        cells = [this]\n      }\n\n      let changed = model.indexOf(this) !== 0\n      if (!changed) {\n        changed = cells.some((cell, index) => cell.getZIndex() !== z + index)\n      }\n\n      if (changed) {\n        this.batchUpdate('to-back', () => {\n          z -= cells.length\n          cells.forEach((cell, index) => {\n            cell.setZIndex(z + index, options)\n          })\n        })\n      }\n    }\n\n    return this\n  }\n\n  // #endregion\n\n  // #region markup\n\n  get markup() {\n    return this.getMarkup()\n  }\n\n  set markup(value: Markup | undefined | null) {\n    if (value == null) {\n      this.removeMarkup()\n    } else {\n      this.setMarkup(value)\n    }\n  }\n\n  getMarkup() {\n    let markup = this.store.get('markup')\n    if (markup == null) {\n      const ctor = this.constructor as typeof Cell\n      markup = ctor.getMarkup()\n    }\n    return markup\n  }\n\n  setMarkup(markup: Markup, options: Cell.SetOptions = {}) {\n    this.store.set('markup', markup, options)\n    return this\n  }\n\n  removeMarkup(options: Cell.SetOptions = {}) {\n    this.store.remove('markup', options)\n    return this\n  }\n\n  // #endregion\n\n  // #region attrs\n\n  get attrs() {\n    return this.getAttrs()\n  }\n\n  set attrs(value: Attr.CellAttrs | null | undefined) {\n    if (value == null) {\n      this.removeAttrs()\n    } else {\n      this.setAttrs(value)\n    }\n  }\n\n  getAttrs() {\n    const result = this.store.get('attrs')\n    return result ? { ...result } : {}\n  }\n\n  setAttrs(\n    attrs: Attr.CellAttrs | null | undefined,\n    options: Cell.SetAttrOptions = {},\n  ) {\n    if (attrs == null) {\n      this.removeAttrs(options)\n    } else {\n      const set = (attrs: Attr.CellAttrs) =>\n        this.store.set('attrs', attrs, options)\n\n      if (options.overwrite === true) {\n        set(attrs)\n      } else {\n        const prev = this.getAttrs()\n        if (options.deep === false) {\n          set({ ...prev, ...attrs })\n        } else {\n          set(ObjectExt.merge({}, prev, attrs))\n        }\n      }\n    }\n\n    return this\n  }\n\n  replaceAttrs(attrs: Attr.CellAttrs, options: Cell.SetOptions = {}) {\n    return this.setAttrs(attrs, { ...options, overwrite: true })\n  }\n\n  updateAttrs(attrs: Attr.CellAttrs, options: Cell.SetOptions = {}) {\n    return this.setAttrs(attrs, { ...options, deep: false })\n  }\n\n  removeAttrs(options: Cell.SetOptions = {}) {\n    this.store.remove('attrs', options)\n    return this\n  }\n\n  getAttrDefinition(attrName: string) {\n    if (!attrName) {\n      return null\n    }\n\n    const ctor = this.constructor as typeof Cell\n    const hooks = ctor.getAttrHooks() || {}\n    let definition = hooks[attrName] || Attr.registry.get(attrName)\n    if (!definition) {\n      const name = StringExt.camelCase(attrName)\n      definition = hooks[name] || Attr.registry.get(name)\n    }\n\n    return definition || null\n  }\n\n  getAttrByPath(): Attr.CellAttrs\n  getAttrByPath<T>(path: string | string[]): T\n  getAttrByPath<T>(path?: string | string[]) {\n    if (path == null || path === '') {\n      return this.getAttrs()\n    }\n    return this.getPropByPath<T>(this.prefixAttrPath(path))\n  }\n\n  setAttrByPath(\n    path: string | string[],\n    value: Attr.ComplexAttrValue,\n    options: Cell.SetOptions = {},\n  ) {\n    this.setPropByPath(this.prefixAttrPath(path), value, options)\n    return this\n  }\n\n  removeAttrByPath(path: string | string[], options: Cell.SetOptions = {}) {\n    this.removePropByPath(this.prefixAttrPath(path), options)\n    return this\n  }\n\n  protected prefixAttrPath(path: string | string[]) {\n    return Array.isArray(path) ? ['attrs'].concat(path) : `attrs/${path}`\n  }\n\n  attr(): Attr.CellAttrs\n  attr<T>(path: string | string[]): T\n  attr(\n    path: string | string[],\n    value: Attr.ComplexAttrValue | null,\n    options?: Cell.SetOptions,\n  ): this\n  attr(attrs: Attr.CellAttrs, options?: Cell.SetAttrOptions): this\n  attr(\n    path?: string | string[] | Attr.CellAttrs,\n    value?: Attr.ComplexAttrValue | Cell.SetOptions,\n    options?: Cell.SetOptions,\n  ) {\n    if (path == null) {\n      return this.getAttrByPath()\n    }\n\n    if (typeof path === 'string' || Array.isArray(path)) {\n      if (arguments.length === 1) {\n        return this.getAttrByPath(path)\n      }\n      if (value == null) {\n        return this.removeAttrByPath(path, options || {})\n      }\n      return this.setAttrByPath(\n        path,\n        value as Attr.ComplexAttrValue,\n        options || {},\n      )\n    }\n\n    return this.setAttrs(path, (value || {}) as Cell.SetOptions)\n  }\n\n  // #endregion\n\n  // #region visible\n\n  get visible() {\n    return this.isVisible()\n  }\n\n  set visible(value: boolean) {\n    this.setVisible(value)\n  }\n\n  setVisible(visible: boolean, options: Cell.SetOptions = {}) {\n    this.store.set('visible', visible, options)\n    return this\n  }\n\n  isVisible() {\n    return this.store.get('visible') !== false\n  }\n\n  show(options: Cell.SetOptions = {}) {\n    if (!this.isVisible()) {\n      this.setVisible(true, options)\n    }\n    return this\n  }\n\n  hide(options: Cell.SetOptions = {}) {\n    if (this.isVisible()) {\n      this.setVisible(false, options)\n    }\n    return this\n  }\n\n  toggleVisible(visible: boolean, options?: Cell.SetOptions): this\n  toggleVisible(options?: Cell.SetOptions): this\n  toggleVisible(\n    isVisible?: boolean | Cell.SetOptions,\n    options: Cell.SetOptions = {},\n  ) {\n    const visible =\n      typeof isVisible === 'boolean' ? isVisible : !this.isVisible()\n    const localOptions = typeof isVisible === 'boolean' ? options : isVisible\n    if (visible) {\n      this.show(localOptions)\n    } else {\n      this.hide(localOptions)\n    }\n    return this\n  }\n\n  // #endregion\n\n  // #region data\n\n  get data(): Properties['data'] {\n    return this.getData()\n  }\n\n  set data(val: Properties['data']) {\n    this.setData(val)\n  }\n\n  getData<T = Properties['data']>(): T {\n    return this.store.get<T>('data')\n  }\n\n  setData<T = Properties['data']>(data: T, options: Cell.SetDataOptions = {}) {\n    if (data == null) {\n      this.removeData(options)\n    } else {\n      const set = (data: T) => this.store.set('data', data, options)\n\n      if (options.overwrite === true) {\n        set(data)\n      } else {\n        const prev = this.getData<Record<string, any>>()\n        if (options.deep === false) {\n          set(typeof data === 'object' ? { ...prev, ...data } : data)\n        } else {\n          set(ObjectExt.merge({}, prev, data))\n        }\n      }\n    }\n\n    return this\n  }\n\n  replaceData<T = Properties['data']>(data: T, options: Cell.SetOptions = {}) {\n    return this.setData(data, { ...options, overwrite: true })\n  }\n\n  updateData<T = Properties['data']>(data: T, options: Cell.SetOptions = {}) {\n    return this.setData(data, { ...options, deep: false })\n  }\n\n  removeData(options: Cell.SetOptions = {}) {\n    this.store.remove('data', options)\n    return this\n  }\n\n  // #endregion\n\n  // #region parent children\n\n  get parent(): Cell | null {\n    return this.getParent()\n  }\n\n  get children() {\n    return this.getChildren()\n  }\n\n  getParentId() {\n    return this.store.get('parent')\n  }\n\n  getParent<T extends Cell = Cell>(): T | null {\n    const parentId = this.getParentId()\n    if (parentId && this.model) {\n      const parent = this.model.getCell<T>(parentId)\n      this._parent = parent\n      return parent\n    }\n    return null\n  }\n\n  getChildren() {\n    const childrenIds = this.store.get('children')\n    if (childrenIds && childrenIds.length && this.model) {\n      const children = childrenIds\n        .map((id) => this.model?.getCell(id))\n        .filter((cell) => cell != null) as Cell[]\n      this._children = children\n      return [...children]\n    }\n    return null\n  }\n\n  hasParent() {\n    return this.parent != null\n  }\n\n  isParentOf(child: Cell | null): boolean {\n    return child != null && child.getParent() === this\n  }\n\n  isChildOf(parent: Cell | null): boolean {\n    return parent != null && this.getParent() === parent\n  }\n\n  eachChild(\n    iterator: (child: Cell, index: number, children: Cell[]) => void,\n    context?: any,\n  ) {\n    if (this.children) {\n      this.children.forEach(iterator, context)\n    }\n    return this\n  }\n\n  filterChild(\n    filter: (cell: Cell, index: number, arr: Cell[]) => boolean,\n    context?: any,\n  ): Cell[] {\n    return this.children ? this.children.filter(filter, context) : []\n  }\n\n  getChildCount() {\n    return this.children == null ? 0 : this.children.length\n  }\n\n  getChildIndex(child: Cell) {\n    return this.children == null ? -1 : this.children.indexOf(child)\n  }\n\n  getChildAt(index: number) {\n    return this.children != null && index >= 0 ? this.children[index] : null\n  }\n\n  getAncestors(options: { deep?: boolean } = {}): Cell[] {\n    const ancestors: Cell[] = []\n    let parent = this.getParent()\n    while (parent) {\n      ancestors.push(parent)\n      parent = options.deep !== false ? parent.getParent() : null\n    }\n    return ancestors\n  }\n\n  getDescendants(options: Cell.GetDescendantsOptions = {}): Cell[] {\n    if (options.deep !== false) {\n      // breadth first\n      if (options.breadthFirst) {\n        const cells = []\n        const queue = this.getChildren() || []\n\n        while (queue.length > 0) {\n          const parent = queue.shift()!\n          const children = parent.getChildren()\n          cells.push(parent)\n          if (children) {\n            queue.push(...children)\n          }\n        }\n        return cells\n      }\n\n      // depth first\n      {\n        const cells = this.getChildren() || []\n        cells.forEach((cell) => {\n          cells.push(...cell.getDescendants(options))\n        })\n        return cells\n      }\n    }\n\n    return this.getChildren() || []\n  }\n\n  isDescendantOf(\n    ancestor: Cell | null,\n    options: { deep?: boolean } = {},\n  ): boolean {\n    if (ancestor == null) {\n      return false\n    }\n\n    if (options.deep !== false) {\n      let current = this.getParent()\n      while (current) {\n        if (current === ancestor) {\n          return true\n        }\n        current = current.getParent()\n      }\n\n      return false\n    }\n\n    return this.isChildOf(ancestor)\n  }\n\n  isAncestorOf(\n    descendant: Cell | null,\n    options: { deep?: boolean } = {},\n  ): boolean {\n    if (descendant == null) {\n      return false\n    }\n\n    return descendant.isDescendantOf(this, options)\n  }\n\n  contains(cell: Cell | null) {\n    return this.isAncestorOf(cell)\n  }\n\n  getCommonAncestor(...cells: (Cell | null | undefined)[]): Cell | null {\n    return Cell.getCommonAncestor(this, ...cells)\n  }\n\n  setParent(parent: Cell | null, options: Cell.SetOptions = {}) {\n    this._parent = parent\n    if (parent) {\n      this.store.set('parent', parent.id, options)\n    } else {\n      this.store.remove('parent', options)\n    }\n    return this\n  }\n\n  setChildren(children: Cell[] | null, options: Cell.SetOptions = {}) {\n    this._children = children\n    if (children != null) {\n      this.store.set(\n        'children',\n        children.map((child) => child.id),\n        options,\n      )\n    } else {\n      this.store.remove('children', options)\n    }\n    return this\n  }\n\n  unembed(child: Cell, options: Cell.SetOptions = {}) {\n    const children = this.children\n    if (children != null && child != null) {\n      const index = this.getChildIndex(child)\n      if (index !== -1) {\n        children.splice(index, 1)\n        child.setParent(null, options)\n        this.setChildren(children, options)\n      }\n    }\n    return this\n  }\n\n  embed(child: Cell, options: Cell.SetOptions = {}) {\n    child.addTo(this, options)\n    return this\n  }\n\n  addTo(model: Model, options?: Cell.SetOptions): this\n  addTo(graph: Graph, options?: Cell.SetOptions): this\n  addTo(parent: Cell, options?: Cell.SetOptions): this\n  addTo(target: Model | Graph | Cell, options: Cell.SetOptions = {}) {\n    if (Cell.isCell(target)) {\n      target.addChild(this, options)\n    } else {\n      target.addCell(this, options)\n    }\n    return this\n  }\n\n  insertTo(parent: Cell, index?: number, options: Cell.SetOptions = {}) {\n    parent.insertChild(this, index, options)\n    return this\n  }\n\n  addChild(child: Cell | null, options: Cell.SetOptions = {}) {\n    return this.insertChild(child, undefined, options)\n  }\n\n  insertChild(\n    child: Cell | null,\n    index?: number,\n    options: Cell.SetOptions = {},\n  ): this {\n    if (child != null && child !== this) {\n      const oldParent = child.getParent()\n      const changed = this !== oldParent\n\n      let pos = index\n      if (pos == null) {\n        pos = this.getChildCount()\n        if (!changed) {\n          pos -= 1\n        }\n      }\n\n      // remove from old parent\n      if (oldParent) {\n        const children = oldParent.getChildren()\n        if (children) {\n          const index = children.indexOf(child)\n          if (index >= 0) {\n            child.setParent(null, options)\n            children.splice(index, 1)\n            oldParent.setChildren(children, options)\n          }\n        }\n      }\n\n      let children = this.children\n      if (children == null) {\n        children = []\n        children.push(child)\n      } else {\n        children.splice(pos, 0, child)\n      }\n\n      child.setParent(this, options)\n      this.setChildren(children, options)\n\n      if (changed && this.model) {\n        const incomings = this.model.getIncomingEdges(this)\n        const outgoings = this.model.getOutgoingEdges(this)\n\n        if (incomings) {\n          incomings.forEach((edge) => edge.updateParent(options))\n        }\n\n        if (outgoings) {\n          outgoings.forEach((edge) => edge.updateParent(options))\n        }\n      }\n\n      if (this.model) {\n        this.model.addCell(child, options)\n      }\n    }\n\n    return this\n  }\n\n  removeFromParent(options: Cell.RemoveOptions = {}) {\n    const parent = this.getParent()\n    if (parent != null) {\n      const index = parent.getChildIndex(this)\n      parent.removeChildAt(index, options)\n    }\n    return this\n  }\n\n  removeChild(child: Cell, options: Cell.RemoveOptions = {}) {\n    const index = this.getChildIndex(child)\n    return this.removeChildAt(index, options)\n  }\n\n  removeChildAt(index: number, options: Cell.RemoveOptions = {}) {\n    const child = this.getChildAt(index)\n    const children = this.children\n\n    if (children != null && child != null) {\n      this.unembed(child, options)\n      child.remove(options)\n    }\n\n    return child\n  }\n\n  remove(options: Cell.RemoveOptions = {}) {\n    this.batchUpdate('remove', () => {\n      const parent = this.getParent()\n      if (parent) {\n        parent.removeChild(this, options)\n      }\n\n      if (options.deep !== false) {\n        this.eachChild((child) => child.remove(options))\n      }\n\n      if (this.model) {\n        this.model.removeCell(this, options)\n      }\n    })\n    return this\n  }\n\n  // #endregion\n\n  // #region transition\n\n  transition<K extends keyof Properties>(\n    path: K,\n    target: Properties[K],\n    options?: Animation.StartOptions<Properties[K]>,\n    delim?: string,\n  ): () => void\n  transition<T extends Animation.TargetValue>(\n    path: string | string[],\n    target: T,\n    options?: Animation.StartOptions<T>,\n    delim?: string,\n  ): () => void\n  transition<T extends Animation.TargetValue>(\n    path: string | string[],\n    target: T,\n    options: Animation.StartOptions<T> = {},\n    delim = '/',\n  ) {\n    return this.animation.start(path, target, options, delim)\n  }\n\n  stopTransition<T extends Animation.TargetValue>(\n    path: string | string[],\n    options?: Animation.StopOptions<T>,\n    delim = '/',\n  ) {\n    this.animation.stop(path, options, delim)\n    return this\n  }\n\n  getTransitions() {\n    return this.animation.get()\n  }\n\n  // #endregion\n\n  // #region transform\n\n  // eslint-disable-next-line\n  translate(tx: number, ty: number, options?: Cell.TranslateOptions) {\n    return this\n  }\n\n  scale(\n    sx: number, // eslint-disable-line\n    sy: number, // eslint-disable-line\n    origin?: Point | Point.PointLike, // eslint-disable-line\n    options?: Node.SetOptions, // eslint-disable-line\n  ) {\n    return this\n  }\n\n  // #endregion\n\n  // #region tools\n\n  addTools(\n    items: Cell.ToolItem | Cell.ToolItem[],\n    options?: Cell.AddToolOptions,\n  ): void\n  addTools(\n    items: Cell.ToolItem | Cell.ToolItem[],\n    name: string,\n    options?: Cell.AddToolOptions,\n  ): void\n  addTools(\n    items: Cell.ToolItem | Cell.ToolItem[],\n    obj?: string | Cell.AddToolOptions,\n    options?: Cell.AddToolOptions,\n  ) {\n    const toolItems = Array.isArray(items) ? items : [items]\n    const name = typeof obj === 'string' ? obj : null\n    const config =\n      typeof obj === 'object' ? obj : typeof options === 'object' ? options : {}\n\n    if (config.reset) {\n      return this.setTools(\n        { name, items: toolItems, local: config.local },\n        config,\n      )\n    }\n    let tools = ObjectExt.cloneDeep(this.getTools())\n    if (tools == null || name == null || tools.name === name) {\n      if (tools == null) {\n        tools = {} as Cell.Tools\n      }\n\n      if (!tools.items) {\n        tools.items = []\n      }\n\n      tools.name = name\n      tools.items = [...tools.items, ...toolItems]\n\n      return this.setTools({ ...tools }, config)\n    }\n  }\n\n  setTools(tools?: Cell.ToolsLoose | null, options: Cell.SetOptions = {}) {\n    if (tools == null) {\n      this.removeTools()\n    } else {\n      this.store.set('tools', Cell.normalizeTools(tools), options)\n    }\n    return this\n  }\n\n  getTools(): Cell.Tools | null {\n    return this.store.get<Cell.Tools>('tools')\n  }\n\n  removeTools(options: Cell.SetOptions = {}) {\n    this.store.remove('tools', options)\n    return this\n  }\n\n  hasTools(name?: string) {\n    const tools = this.getTools()\n    if (tools == null) {\n      return false\n    }\n\n    if (name == null) {\n      return true\n    }\n\n    return tools.name === name\n  }\n\n  hasTool(name: string) {\n    const tools = this.getTools()\n    if (tools == null) {\n      return false\n    }\n    return tools.items.some((item) =>\n      typeof item === 'string' ? item === name : item.name === name,\n    )\n  }\n\n  removeTool(name: string, options?: Cell.SetOptions): this\n  removeTool(index: number, options?: Cell.SetOptions): this\n  removeTool(nameOrIndex: string | number, options: Cell.SetOptions = {}) {\n    const tools = ObjectExt.cloneDeep(this.getTools())\n    if (tools) {\n      let updated = false\n      const items = tools.items.slice()\n      const remove = (index: number) => {\n        items.splice(index, 1)\n        updated = true\n      }\n\n      if (typeof nameOrIndex === 'number') {\n        remove(nameOrIndex)\n      } else {\n        for (let i = items.length - 1; i >= 0; i -= 1) {\n          const item = items[i]\n          const exist =\n            typeof item === 'string'\n              ? item === nameOrIndex\n              : item.name === nameOrIndex\n          if (exist) {\n            remove(i)\n          }\n        }\n      }\n\n      if (updated) {\n        tools.items = items\n        this.setTools(tools, options)\n      }\n    }\n    return this\n  }\n\n  // #endregion\n\n  // #region common\n\n  // eslint-disable-next-line\n  getBBox(options?: { deep?: boolean }) {\n    return new Rectangle()\n  }\n\n  // eslint-disable-next-line\n  getConnectionPoint(edge: Edge, type: Edge.TerminalType) {\n    return new Point()\n  }\n\n  toJSON(\n    options: Cell.ToJSONOptions = {},\n  ): this extends Node\n    ? Node.Properties\n    : this extends Edge\n    ? Edge.Properties\n    : Properties {\n    const props = { ...this.store.get() }\n    const toString = Object.prototype.toString\n    const cellType = this.isNode() ? 'node' : this.isEdge() ? 'edge' : 'cell'\n\n    if (!props.shape) {\n      const ctor = this.constructor\n      throw new Error(\n        `Unable to serialize ${cellType} missing \"shape\" prop, check the ${cellType} \"${\n          ctor.name || toString.call(ctor)\n        }\"`,\n      )\n    }\n\n    const ctor = this.constructor as typeof Cell\n    const diff = options.diff === true\n    const attrs = props.attrs || {}\n    const presets = ctor.getDefaults(true) as Properties\n    // When `options.diff` is `true`, we should process the custom options,\n    // such as `width`, `height` etc. to ensure the comparing work correctly.\n    const defaults = diff ? this.preprocess(presets, true) : presets\n    const defaultAttrs = defaults.attrs || {}\n    const finalAttrs: Attr.CellAttrs = {}\n\n    Object.keys(props).forEach((key) => {\n      const val = props[key]\n      if (\n        val != null &&\n        !Array.isArray(val) &&\n        typeof val === 'object' &&\n        !ObjectExt.isPlainObject(val)\n      ) {\n        throw new Error(\n          `Can only serialize ${cellType} with plain-object props, but got a \"${toString.call(\n            val,\n          )}\" type of key \"${key}\" on ${cellType} \"${this.id}\"`,\n        )\n      }\n\n      if (key !== 'attrs' && key !== 'shape' && diff) {\n        const preset = defaults[key]\n        if (ObjectExt.isEqual(val, preset)) {\n          delete props[key]\n        }\n      }\n    })\n\n    Object.keys(attrs).forEach((key) => {\n      const attr = attrs[key]\n      const defaultAttr = defaultAttrs[key]\n\n      Object.keys(attr).forEach((name) => {\n        const value = attr[name] as KeyValue\n        const defaultValue = defaultAttr ? defaultAttr[name] : null\n\n        if (\n          value != null &&\n          typeof value === 'object' &&\n          !Array.isArray(value)\n        ) {\n          Object.keys(value).forEach((subName) => {\n            const subValue = value[subName]\n            if (\n              defaultAttr == null ||\n              defaultValue == null ||\n              !ObjectExt.isObject(defaultValue) ||\n              !ObjectExt.isEqual(defaultValue[subName], subValue)\n            ) {\n              if (finalAttrs[key] == null) {\n                finalAttrs[key] = {}\n              }\n              if (finalAttrs[key][name] == null) {\n                finalAttrs[key][name] = {}\n              }\n              const tmp = finalAttrs[key][name] as KeyValue\n              tmp[subName] = subValue\n            }\n          })\n        } else if (\n          defaultAttr == null ||\n          !ObjectExt.isEqual(defaultValue, value)\n        ) {\n          // `value` is not an object, default attribute with `key` does not\n          // exist or it is different than the attribute value set on the cell.\n          if (finalAttrs[key] == null) {\n            finalAttrs[key] = {}\n          }\n          finalAttrs[key][name] = value as any\n        }\n      })\n    })\n\n    const finalProps = {\n      ...props,\n      attrs: ObjectExt.isEmpty(finalAttrs) ? undefined : finalAttrs,\n    }\n\n    if (finalProps.attrs == null) {\n      delete finalProps.attrs\n    }\n\n    const ret = finalProps as any\n    if (ret.angle === 0) {\n      delete ret.angle\n    }\n\n    return ObjectExt.cloneDeep(ret)\n  }\n\n  clone(\n    options: Cell.CloneOptions = {},\n  ): this extends Node ? Node : this extends Edge ? Edge : Cell {\n    if (!options.deep) {\n      const data = { ...this.store.get() }\n      if (!options.keepId) {\n        delete data.id\n      }\n      delete data.parent\n      delete data.children\n      const ctor = this.constructor as typeof Cell\n      return new ctor(data) as any // eslint-disable-line new-cap\n    }\n\n    // Deep cloning. Clone the cell itself and all its children.\n    const map = Cell.deepClone(this)\n    return map[this.id] as any\n  }\n\n  findView(graph: Graph): CellView | null {\n    return graph.renderer.findViewByCell(this)\n  }\n\n  // #endregion\n\n  // #region batch\n\n  startBatch(\n    name: Model.BatchName,\n    data: KeyValue = {},\n    model: Model | null = this.model,\n  ) {\n    this.notify('batch:start', { name, data, cell: this })\n\n    if (model) {\n      model.startBatch(name, { ...data, cell: this })\n    }\n\n    return this\n  }\n\n  stopBatch(\n    name: Model.BatchName,\n    data: KeyValue = {},\n    model: Model | null = this.model,\n  ) {\n    if (model) {\n      model.stopBatch(name, { ...data, cell: this })\n    }\n\n    this.notify('batch:stop', { name, data, cell: this })\n    return this\n  }\n\n  batchUpdate<T>(name: Model.BatchName, execute: () => T, data?: KeyValue): T {\n    // The model is null after cell was removed(remove batch).\n    // So we should temp save model to trigger pairing batch event.\n    const model = this.model\n    this.startBatch(name, data, model)\n    const result = execute()\n    this.stopBatch(name, data, model)\n    return result\n  }\n\n  // #endregion\n\n  // #region IDisposable\n\n  @Basecoat.dispose()\n  dispose() {\n    this.removeFromParent()\n    this.store.dispose()\n  }\n\n  // #endregion\n}\n\nexport namespace Cell {\n  export interface Common {\n    view?: string\n    shape?: string\n    markup?: Markup\n    attrs?: Attr.CellAttrs\n    zIndex?: number\n    visible?: boolean\n    data?: any\n    knob?: Knob.Metadata | Knob.Metadata[]\n  }\n\n  export interface Defaults extends Common {}\n\n  export interface Metadata extends Common, KeyValue {\n    id?: string\n    tools?: ToolsLoose\n  }\n\n  export interface Properties extends Defaults, Metadata {\n    parent?: string\n    children?: string[]\n    tools?: Tools\n  }\n}\n\nexport namespace Cell {\n  export type ToolItem =\n    | string\n    | {\n        name: string\n        args?: any\n      }\n\n  export interface Tools {\n    name?: string | null\n    local?: boolean\n    items: ToolItem[]\n  }\n\n  export type ToolsLoose = ToolItem | ToolItem[] | Tools\n\n  export function normalizeTools(raw: ToolsLoose): Tools {\n    if (typeof raw === 'string') {\n      return { items: [raw] }\n    }\n\n    if (Array.isArray(raw)) {\n      return { items: raw }\n    }\n\n    if ((raw as Tools).items) {\n      return raw as Tools\n    }\n\n    return {\n      items: [raw as ToolItem],\n    }\n  }\n}\n\nexport namespace Cell {\n  export interface SetOptions extends Store.SetOptions {}\n\n  export interface MutateOptions extends Store.MutateOptions {}\n\n  export interface RemoveOptions extends SetOptions {\n    deep?: boolean\n  }\n\n  export interface SetAttrOptions extends SetOptions {\n    deep?: boolean\n    overwrite?: boolean\n  }\n\n  export interface SetDataOptions extends SetOptions {\n    deep?: boolean\n    overwrite?: boolean\n  }\n\n  export interface SetByPathOptions extends Store.SetByPathOptions {}\n\n  export interface ToFrontOptions extends SetOptions {\n    deep?: boolean\n  }\n\n  export interface ToBackOptions extends ToFrontOptions {}\n\n  export interface TranslateOptions extends SetOptions {\n    tx?: number\n    ty?: number\n    translateBy?: string | number\n  }\n\n  export interface AddToolOptions extends SetOptions {\n    reset?: boolean\n    local?: boolean\n  }\n\n  export interface GetDescendantsOptions {\n    deep?: boolean\n    breadthFirst?: boolean\n  }\n\n  export interface ToJSONOptions {\n    diff?: boolean\n  }\n\n  export interface CloneOptions {\n    deep?: boolean\n    keepId?: boolean\n  }\n}\n\nexport namespace Cell {\n  export interface EventArgs {\n    'transition:start': Animation.CallbackArgs<Animation.TargetValue>\n    'transition:progress': Animation.ProgressArgs<Animation.TargetValue>\n    'transition:complete': Animation.CallbackArgs<Animation.TargetValue>\n    'transition:stop': Animation.StopArgs<Animation.TargetValue>\n    'transition:finish': Animation.CallbackArgs<Animation.TargetValue>\n\n    // common\n    'change:*': ChangeAnyKeyArgs\n    'change:attrs': ChangeArgs<Attr.CellAttrs>\n    'change:zIndex': ChangeArgs<number>\n    'change:markup': ChangeArgs<Markup>\n    'change:visible': ChangeArgs<boolean>\n    'change:parent': ChangeArgs<string>\n    'change:children': ChangeArgs<string[]>\n    'change:tools': ChangeArgs<Tools>\n    'change:view': ChangeArgs<string>\n    'change:data': ChangeArgs<any>\n\n    // node\n    'change:size': NodeChangeArgs<Size>\n    'change:angle': NodeChangeArgs<number>\n    'change:position': NodeChangeArgs<Point.PointLike>\n    'change:ports': NodeChangeArgs<PortManager.Port[]>\n    'change:portMarkup': NodeChangeArgs<Markup>\n    'change:portLabelMarkup': NodeChangeArgs<Markup>\n    'change:portContainerMarkup': NodeChangeArgs<Markup>\n    'ports:removed': {\n      cell: Cell\n      node: Node\n      removed: PortManager.Port[]\n    }\n    'ports:added': {\n      cell: Cell\n      node: Node\n      added: PortManager.Port[]\n    }\n\n    // edge\n    'change:source': EdgeChangeArgs<Edge.TerminalData>\n    'change:target': EdgeChangeArgs<Edge.TerminalData>\n    'change:terminal': EdgeChangeArgs<Edge.TerminalData> & {\n      type: Edge.TerminalType\n    }\n    'change:router': EdgeChangeArgs<Edge.RouterData>\n    'change:connector': EdgeChangeArgs<Edge.ConnectorData>\n    'change:vertices': EdgeChangeArgs<Point.PointLike[]>\n    'change:labels': EdgeChangeArgs<Edge.Label[]>\n    'change:defaultLabel': EdgeChangeArgs<Edge.Label>\n    'change:toolMarkup': EdgeChangeArgs<Markup>\n    'change:doubleToolMarkup': EdgeChangeArgs<Markup>\n    'change:vertexMarkup': EdgeChangeArgs<Markup>\n    'change:arrowheadMarkup': EdgeChangeArgs<Markup>\n    'vertexs:added': {\n      cell: Cell\n      edge: Edge\n      added: Point.PointLike[]\n    }\n    'vertexs:removed': {\n      cell: Cell\n      edge: Edge\n      removed: Point.PointLike[]\n    }\n    'labels:added': {\n      cell: Cell\n      edge: Edge\n      added: Edge.Label[]\n    }\n    'labels:removed': {\n      cell: Cell\n      edge: Edge\n      removed: Edge.Label[]\n    }\n\n    'batch:start': {\n      name: Model.BatchName\n      data: KeyValue\n      cell: Cell\n    }\n\n    'batch:stop': {\n      name: Model.BatchName\n      data: KeyValue\n      cell: Cell\n    }\n\n    changed: {\n      cell: Cell\n      options: MutateOptions\n    }\n\n    added: {\n      cell: Cell\n      index: number\n      options: Cell.SetOptions\n    }\n\n    removed: {\n      cell: Cell\n      index: number\n      options: Cell.RemoveOptions\n    }\n  }\n\n  interface ChangeAnyKeyArgs<T extends keyof Properties = keyof Properties> {\n    key: T\n    current: Properties[T]\n    previous: Properties[T]\n    options: MutateOptions\n    cell: Cell\n  }\n\n  export interface ChangeArgs<T> {\n    cell: Cell\n    current?: T\n    previous?: T\n    options: MutateOptions\n  }\n\n  interface NodeChangeArgs<T> extends ChangeArgs<T> {\n    node: Node\n  }\n\n  interface EdgeChangeArgs<T> extends ChangeArgs<T> {\n    edge: Edge\n  }\n}\n\nexport namespace Cell {\n  export const toStringTag = `X6.${Cell.name}`\n\n  export function isCell(instance: any): instance is Cell {\n    if (instance == null) {\n      return false\n    }\n\n    if (instance instanceof Cell) {\n      return true\n    }\n\n    const tag = instance[Symbol.toStringTag]\n    const cell = instance as Cell\n\n    if (\n      (tag == null || tag === toStringTag) &&\n      typeof cell.isNode === 'function' &&\n      typeof cell.isEdge === 'function' &&\n      typeof cell.prop === 'function' &&\n      typeof cell.attr === 'function'\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n\nexport namespace Cell {\n  export function getCommonAncestor(\n    ...cells: (Cell | null | undefined)[]\n  ): Cell | null {\n    const ancestors = cells\n      .filter((cell) => cell != null)\n      .map((cell) => cell!.getAncestors())\n      .sort((a, b) => {\n        return a.length - b.length\n      })\n\n    const first = ancestors.shift()!\n    return (\n      first.find((cell) => ancestors.every((item) => item.includes(cell))) ||\n      null\n    )\n  }\n\n  export interface GetCellsBBoxOptions {\n    deep?: boolean\n  }\n\n  export function getCellsBBox(\n    cells: Cell[],\n    options: GetCellsBBoxOptions = {},\n  ) {\n    let bbox: Rectangle | null = null\n\n    for (let i = 0, ii = cells.length; i < ii; i += 1) {\n      const cell = cells[i]\n      let rect = cell.getBBox(options)\n      if (rect) {\n        if (cell.isNode()) {\n          const angle = cell.getAngle()\n          if (angle != null && angle !== 0) {\n            rect = rect.bbox(angle)\n          }\n        }\n        bbox = bbox == null ? rect : bbox.union(rect)\n      }\n    }\n\n    return bbox\n  }\n\n  export function deepClone(cell: Cell) {\n    const cells = [cell, ...cell.getDescendants({ deep: true })]\n    return Cell.cloneCells(cells)\n  }\n\n  export function cloneCells(cells: Cell[]) {\n    const inputs = ArrayExt.uniq(cells)\n    const cloneMap = inputs.reduce<KeyValue<Cell>>((map, cell) => {\n      map[cell.id] = cell.clone()\n      return map\n    }, {})\n\n    inputs.forEach((cell) => {\n      const clone = cloneMap[cell.id]\n      if (clone.isEdge()) {\n        const sourceId = clone.getSourceCellId()\n        const targetId = clone.getTargetCellId()\n        if (sourceId && cloneMap[sourceId]) {\n          // Source is a node and the node is among the clones.\n          // Then update the source of the cloned edge.\n          clone.setSource({\n            ...clone.getSource(),\n            cell: cloneMap[sourceId].id,\n          })\n        }\n        if (targetId && cloneMap[targetId]) {\n          // Target is a node and the node is among the clones.\n          // Then update the target of the cloned edge.\n          clone.setTarget({\n            ...clone.getTarget(),\n            cell: cloneMap[targetId].id,\n          })\n        }\n      }\n\n      // Find the parent of the original cell\n      const parent = cell.getParent()\n      if (parent && cloneMap[parent.id]) {\n        clone.setParent(cloneMap[parent.id])\n      }\n\n      // Find the children of the original cell\n      const children = cell.getChildren()\n      if (children && children.length) {\n        const embeds = children.reduce<Cell[]>((memo, child) => {\n          // Embedded cells that are not being cloned can not be carried\n          // over with other embedded cells.\n          if (cloneMap[child.id]) {\n            memo.push(cloneMap[child.id])\n          }\n          return memo\n        }, [])\n\n        if (embeds.length > 0) {\n          clone.setChildren(embeds)\n        }\n      }\n    })\n\n    return cloneMap\n  }\n}\n\nexport namespace Cell {\n  export type Definition = typeof Cell\n\n  export type PropHook<M extends Metadata = Metadata, C extends Cell = Cell> = (\n    this: C,\n    metadata: M,\n  ) => M\n\n  export type PropHooks<M extends Metadata = Metadata, C extends Cell = Cell> =\n    | KeyValue<PropHook<M, C>>\n    | PropHook<M, C>\n    | PropHook<M, C>[]\n\n  export interface Config<M extends Metadata = Metadata, C extends Cell = Cell>\n    extends Defaults,\n      KeyValue {\n    constructorName?: string\n    overwrite?: boolean\n    propHooks?: PropHooks<M, C>\n    attrHooks?: Attr.Definitions\n  }\n}\n\nexport namespace Cell {\n  Cell.config({\n    propHooks({ tools, ...metadata }) {\n      if (tools) {\n        metadata.tools = normalizeTools(tools)\n      }\n      return metadata\n    },\n  })\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}