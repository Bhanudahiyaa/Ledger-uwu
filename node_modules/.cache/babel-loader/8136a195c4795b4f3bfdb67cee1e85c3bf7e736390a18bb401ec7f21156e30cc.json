{"ast":null,"code":"import UnitBezier from '@mapbox/unitbezier';\nexport const interpolates = {\n  number: function number(from, to, t) {\n    return from + t * (to - from);\n  }\n};\n\n/**\n * constrain n to the given range via min + max\n *\n * @param n - value\n * @param min - the minimum value to be returned\n * @param max - the maximum value to be returned\n * @returns the clamped value\n */\nexport function clamp(n, min, max) {\n  return Math.min(max, Math.max(min, n));\n}\n\n/**\n * constrain n to the given range, excluding the minimum, via modular arithmetic\n *\n * @param n - value\n * @param min - the minimum value to be returned, exclusive\n * @param max - the maximum value to be returned, inclusive\n * @returns constrained number\n */\nexport function wrap(n, min, max) {\n  const d = max - min;\n  const w = ((n - min) % d + d) % d + min;\n  return w === min ? max : w;\n}\nlet id = 1;\n\n/**\n * Return a unique numeric id, starting at 1 and incrementing with\n * each call.\n *\n * @returns unique numeric id.\n */\nexport function uniqueId() {\n  return id++;\n}\n\n/**\n * Given a destination object and optionally many source objects,\n * copy all properties from the source objects into the destination.\n * The last source object given overrides properties from previous\n * source objects.\n *\n * @param dest - destination object\n * @param sources - sources from which properties are pulled\n */\n\nexport function extend(dest, ...sources) {\n  for (const src of sources) {\n    for (const k in src) {\n      dest[k] = src[k];\n    }\n  }\n  return dest;\n}\n\n// See https://stackoverflow.com/questions/49401866/all-possible-keys-of-an-union-type\n\n/**\n * Given an object and a number of properties as strings, return version\n * of that object with only those properties.\n *\n * @param src - the object\n * @param properties - an array of property names chosen\n * to appear on the resulting object.\n * @returns object with limited properties.\n * @example\n * ```ts\n * let foo = { name: 'Charlie', age: 10 };\n * let justName = pick(foo, ['name']); // justName = { name: 'Charlie' }\n * ```\n */\nexport function pick(src, properties) {\n  const result = {};\n  for (let i = 0; i < properties.length; i++) {\n    const k = properties[i];\n    if (k in src) {\n      result[k] = src[k];\n    }\n  }\n  return result;\n}\n\n/**\n * Makes optional keys required and add the the undefined type.\n *\n * ```\n * interface Test {\n *  foo: number;\n *  bar?: number;\n *  baz: number | undefined;\n * }\n *\n * Complete<Test> {\n *  foo: number;\n *  bar: number | undefined;\n *  baz: number | undefined;\n * }\n *\n * ```\n *\n * See https://medium.com/terria/typescript-transforming-optional-properties-to-required-properties-that-may-be-undefined-7482cb4e1585\n */\n\n/**\n * Given given (x, y), (x1, y1) control points for a bezier curve,\n * return a function that interpolates along that curve.\n *\n * @param p1x - control point 1 x coordinate\n * @param p1y - control point 1 y coordinate\n * @param p2x - control point 2 x coordinate\n * @param p2y - control point 2 y coordinate\n */\nexport function bezier(p1x, p1y, p2x, p2y) {\n  const bezier = new UnitBezier(p1x, p1y, p2x, p2y);\n  return t => {\n    return bezier.solve(t);\n  };\n}\n\n/**\n * A default bezier-curve powered easing function with\n * control points (0.25, 0.1) and (0.25, 1)\n */\nexport const defaultEasing = bezier(0.25, 0.1, 0.25, 1);\n\n/**\n * Print a warning message to the console and ensure duplicate warning messages\n * are not printed.\n */\nconst warnOnceHistory = {};\nexport function warnOnce(message) {\n  if (!warnOnceHistory[message]) {\n    // console isn't defined in some WebWorkers, see #2558\n    if (typeof console !== 'undefined') console.warn(message);\n    warnOnceHistory[message] = true;\n  }\n}\n\n/**\n * This method converts degrees to radians.\n * The return value is the radian value.\n * @param degrees - The number of degrees\n * @returns radians\n */\nexport function degreesToRadians(degrees) {\n  return degrees * Math.PI / 180;\n}","map":{"version":3,"names":["UnitBezier","interpolates","number","from","to","t","clamp","n","min","max","Math","wrap","d","w","id","uniqueId","extend","dest","sources","src","k","pick","properties","result","i","length","bezier","p1x","p1y","p2x","p2y","solve","defaultEasing","warnOnceHistory","warnOnce","message","console","warn","degreesToRadians","degrees","PI"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/l7-map/es/map/util/util.js"],"sourcesContent":["import UnitBezier from '@mapbox/unitbezier';\nexport const interpolates = {\n  number: function number(from, to, t) {\n    return from + t * (to - from);\n  }\n};\n\n/**\n * constrain n to the given range via min + max\n *\n * @param n - value\n * @param min - the minimum value to be returned\n * @param max - the maximum value to be returned\n * @returns the clamped value\n */\nexport function clamp(n, min, max) {\n  return Math.min(max, Math.max(min, n));\n}\n\n/**\n * constrain n to the given range, excluding the minimum, via modular arithmetic\n *\n * @param n - value\n * @param min - the minimum value to be returned, exclusive\n * @param max - the maximum value to be returned, inclusive\n * @returns constrained number\n */\nexport function wrap(n, min, max) {\n  const d = max - min;\n  const w = ((n - min) % d + d) % d + min;\n  return w === min ? max : w;\n}\nlet id = 1;\n\n/**\n * Return a unique numeric id, starting at 1 and incrementing with\n * each call.\n *\n * @returns unique numeric id.\n */\nexport function uniqueId() {\n  return id++;\n}\n\n/**\n * Given a destination object and optionally many source objects,\n * copy all properties from the source objects into the destination.\n * The last source object given overrides properties from previous\n * source objects.\n *\n * @param dest - destination object\n * @param sources - sources from which properties are pulled\n */\n\nexport function extend(dest, ...sources) {\n  for (const src of sources) {\n    for (const k in src) {\n      dest[k] = src[k];\n    }\n  }\n  return dest;\n}\n\n// See https://stackoverflow.com/questions/49401866/all-possible-keys-of-an-union-type\n\n/**\n * Given an object and a number of properties as strings, return version\n * of that object with only those properties.\n *\n * @param src - the object\n * @param properties - an array of property names chosen\n * to appear on the resulting object.\n * @returns object with limited properties.\n * @example\n * ```ts\n * let foo = { name: 'Charlie', age: 10 };\n * let justName = pick(foo, ['name']); // justName = { name: 'Charlie' }\n * ```\n */\nexport function pick(src, properties) {\n  const result = {};\n  for (let i = 0; i < properties.length; i++) {\n    const k = properties[i];\n    if (k in src) {\n      result[k] = src[k];\n    }\n  }\n  return result;\n}\n\n/**\n * Makes optional keys required and add the the undefined type.\n *\n * ```\n * interface Test {\n *  foo: number;\n *  bar?: number;\n *  baz: number | undefined;\n * }\n *\n * Complete<Test> {\n *  foo: number;\n *  bar: number | undefined;\n *  baz: number | undefined;\n * }\n *\n * ```\n *\n * See https://medium.com/terria/typescript-transforming-optional-properties-to-required-properties-that-may-be-undefined-7482cb4e1585\n */\n\n/**\n * Given given (x, y), (x1, y1) control points for a bezier curve,\n * return a function that interpolates along that curve.\n *\n * @param p1x - control point 1 x coordinate\n * @param p1y - control point 1 y coordinate\n * @param p2x - control point 2 x coordinate\n * @param p2y - control point 2 y coordinate\n */\nexport function bezier(p1x, p1y, p2x, p2y) {\n  const bezier = new UnitBezier(p1x, p1y, p2x, p2y);\n  return t => {\n    return bezier.solve(t);\n  };\n}\n\n/**\n * A default bezier-curve powered easing function with\n * control points (0.25, 0.1) and (0.25, 1)\n */\nexport const defaultEasing = bezier(0.25, 0.1, 0.25, 1);\n\n/**\n * Print a warning message to the console and ensure duplicate warning messages\n * are not printed.\n */\nconst warnOnceHistory = {};\nexport function warnOnce(message) {\n  if (!warnOnceHistory[message]) {\n    // console isn't defined in some WebWorkers, see #2558\n    if (typeof console !== 'undefined') console.warn(message);\n    warnOnceHistory[message] = true;\n  }\n}\n\n/**\n * This method converts degrees to radians.\n * The return value is the radian value.\n * @param degrees - The number of degrees\n * @returns radians\n */\nexport function degreesToRadians(degrees) {\n  return degrees * Math.PI / 180;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}