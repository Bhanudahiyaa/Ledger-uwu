{"ast":null,"code":"import { isNumber } from '../../../util';\nimport graphlib from './graphlib';\nconst Graph = graphlib.Graph;\n/*\n * Adds a dummy node to the graph and return v.\n */\nconst addDummyNode = (g, type, attrs, name) => {\n  let v;\n  do {\n    v = `${name}${Math.random()}`;\n  } while (g.hasNode(v));\n  attrs.dummy = type;\n  g.setNode(v, attrs);\n  return v;\n};\n/*\n * Returns a new graph with only simple edges. Handles aggregation of data\n * associated with multi-edges.\n */\nconst simplify = g => {\n  const simplified = new Graph().setGraph(g.graph());\n  g.nodes().forEach(v => {\n    simplified.setNode(v, g.node(v));\n  });\n  g.edges().forEach(e => {\n    const simpleLabel = simplified.edge(e.v, e.w) || {\n      weight: 0,\n      minlen: 1\n    };\n    const label = g.edge(e);\n    simplified.setEdge(e.v, e.w, {\n      weight: simpleLabel.weight + label.weight,\n      minlen: Math.max(simpleLabel.minlen, label.minlen)\n    });\n  });\n  return simplified;\n};\nconst asNonCompoundGraph = g => {\n  const simplified = new Graph({\n    multigraph: g.isMultigraph()\n  }).setGraph(g.graph());\n  g.nodes().forEach(v => {\n    var _a;\n    if (!((_a = g.children(v)) === null || _a === void 0 ? void 0 : _a.length)) {\n      simplified.setNode(v, g.node(v));\n    }\n  });\n  g.edges().forEach(e => simplified.setEdge(e, g.edge(e)));\n  return simplified;\n};\nconst zipObject = (keys, values) => {\n  const result = {};\n  keys === null || keys === void 0 ? void 0 : keys.forEach((key, i) => {\n    result[key] = values[i];\n  });\n  return result;\n};\nconst successorWeights = g => {\n  const weightMap = g.nodes().map(v => {\n    var _a;\n    const sucs = {};\n    (_a = g.outEdges(v)) === null || _a === void 0 ? void 0 : _a.forEach(e => {\n      sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;\n    });\n    return sucs;\n  });\n  return zipObject(g.nodes(), weightMap);\n};\nconst predecessorWeights = g => {\n  const weightMap = g.nodes().map(v => {\n    var _a;\n    const preds = {};\n    (_a = g.inEdges(v)) === null || _a === void 0 ? void 0 : _a.forEach(e => {\n      preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;\n    });\n    return preds;\n  });\n  return zipObject(g.nodes(), weightMap);\n};\n/*\n * Finds where a line starting at point ({x, y}) would intersect a rectangle\n * ({x, y, width, height}) if it were pointing at the rectangle's center.\n */\nconst intersectRect = (rect, point) => {\n  const x = rect.x;\n  const y = rect.y;\n  // Rectangle intersection algorithm from:\n  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes\n  const dx = point.x - x;\n  const dy = point.y - y;\n  let w = rect.width / 2;\n  let h = rect.height / 2;\n  if (!dx && !dy) {\n    // throw new Error(\"Not possible to find intersection inside of the rectangle\");\n    // completely overlapped\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  let sx;\n  let sy;\n  if (Math.abs(dy) * w > Math.abs(dx) * h) {\n    // Intersection is top or bottom of rect.\n    if (dy < 0) {\n      h = -h;\n    }\n    sx = h * dx / dy;\n    sy = h;\n  } else {\n    // Intersection is left or right of rect.\n    if (dx < 0) {\n      w = -w;\n    }\n    sx = w;\n    sy = w * dy / dx;\n  }\n  return {\n    x: x + sx,\n    y: y + sy\n  };\n};\n/*\n * Given a DAG with each node assigned \"rank\" and \"order\" properties, this\n * const will produce a matrix with the ids of each node.\n */\nconst buildLayerMatrix = g => {\n  const layering = [];\n  const layeringNodes = [];\n  const rankMax = maxRank(g) + 1;\n  for (let i = 0; i < rankMax; i++) {\n    layering.push([]);\n    layeringNodes.push([]);\n  }\n  // const layering = _.map(_.range(maxRank(g) + 1), function() { return []; });\n  g.nodes().forEach(v => {\n    const node = g.node(v);\n    const rank = node.rank;\n    if (rank !== undefined && layering[rank]) {\n      layeringNodes[rank].push(v);\n    }\n  });\n  layeringNodes === null || layeringNodes === void 0 ? void 0 : layeringNodes.forEach((layer, rank) => {\n    layer === null || layer === void 0 ? void 0 : layer.sort((va, vb) => {\n      var _a, _b;\n      return ((_a = g.node(va)) === null || _a === void 0 ? void 0 : _a.order) - ((_b = g.node(vb)) === null || _b === void 0 ? void 0 : _b.order);\n    });\n    layer.forEach(v => {\n      layering[rank].push(v);\n    });\n  });\n  return layering;\n};\n/*\n * Adjusts the ranks for all nodes in the graph such that all nodes v have\n * rank(v) >= 0 and at least one node w has rank(w) = 0.\n */\nconst normalizeRanks = g => {\n  const nodeRanks = g.nodes().filter(v => g.node(v).rank !== undefined).map(v => g.node(v).rank);\n  const min = Math.min(...nodeRanks);\n  g.nodes().forEach(v => {\n    const node = g.node(v);\n    if (node.hasOwnProperty(\"rank\")) {\n      if (!node.rank) node.rank = 0;\n      node.rank -= min;\n    }\n  });\n};\nconst removeEmptyRanks = g => {\n  // Ranks may not start at 0, so we need to offset them\n  const nodeRanks = g.nodes().filter(v => g.node(v).rank !== undefined).map(v => g.node(v).rank);\n  const offset = Math.min(...nodeRanks);\n  const layers = [];\n  g.nodes().forEach(v => {\n    var _a;\n    const rank = (((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.rank) || 0) - offset;\n    if (!layers[rank]) {\n      layers[rank] = [];\n    }\n    layers[rank].push(v);\n  });\n  let delta = 0;\n  const nodeRankFactor = g.graph().nodeRankFactor || 0;\n  for (let i = 0; i < layers.length; i++) {\n    const vs = layers[i];\n    if (vs === undefined && i % nodeRankFactor !== 0) {\n      --delta;\n    } else if (delta) {\n      vs === null || vs === void 0 ? void 0 : vs.forEach(v => {\n        if (!g.node(v).rank) g.node(v).rank = 0;\n        g.node(v).rank += delta;\n      });\n    }\n  }\n};\nconst addBorderNode = (g, prefix, rank, order) => {\n  const node = {\n    width: 0,\n    height: 0\n  };\n  if (isNumber(rank) && isNumber(order)) {\n    node.rank = rank;\n    node.order = order;\n  }\n  return addDummyNode(g, \"border\", node, prefix);\n};\nconst maxRank = g => {\n  const nodeRanks = g.nodes().map(v => {\n    const rank = g.node(v).rank;\n    if (rank !== undefined) {\n      return rank;\n    }\n    return -Infinity;\n  });\n  return Math.max(...nodeRanks);\n};\n/*\n * Partition a collection into two groups: `lhs` and `rhs`. If the supplied\n * const returns true for an entry it goes into `lhs`. Otherwise it goes\n * into `rhs.\n */\nconst partition = (collection, fn) => {\n  const result = {\n    lhs: [],\n    rhs: []\n  };\n  collection === null || collection === void 0 ? void 0 : collection.forEach(value => {\n    if (fn(value)) {\n      result.lhs.push(value);\n    } else {\n      result.rhs.push(value);\n    }\n  });\n  return result;\n};\n/*\n * Returns a new const that wraps `fn` with a timer. The wrapper logs the\n * time it takes to execute the function.\n */\nconst time = (name, fn) => {\n  const start = Date.now();\n  try {\n    return fn();\n  } finally {\n    console.log(`${name} time: ${Date.now() - start}ms`);\n  }\n};\nconst notime = (name, fn) => {\n  return fn();\n};\nconst minBy = (array, func) => {\n  let min = Infinity;\n  let minObject;\n  array === null || array === void 0 ? void 0 : array.forEach(item => {\n    const value = func(item);\n    if (min > value) {\n      min = value;\n      minObject = item;\n    }\n  });\n  return minObject;\n};\nexport { addDummyNode, simplify, asNonCompoundGraph, successorWeights, predecessorWeights, intersectRect, buildLayerMatrix, normalizeRanks, removeEmptyRanks, addBorderNode, maxRank, partition, time, notime, zipObject, minBy };\nexport default {\n  addDummyNode,\n  simplify,\n  asNonCompoundGraph,\n  successorWeights,\n  predecessorWeights,\n  intersectRect,\n  buildLayerMatrix,\n  normalizeRanks,\n  removeEmptyRanks,\n  addBorderNode,\n  maxRank,\n  partition,\n  time,\n  notime,\n  zipObject,\n  minBy\n};","map":{"version":3,"names":["isNumber","graphlib","Graph","addDummyNode","g","type","attrs","name","v","Math","random","hasNode","dummy","setNode","simplify","simplified","setGraph","graph","nodes","forEach","node","edges","e","simpleLabel","edge","w","weight","minlen","label","setEdge","max","asNonCompoundGraph","multigraph","isMultigraph","_a","children","length","zipObject","keys","values","result","key","i","successorWeights","weightMap","map","sucs","outEdges","predecessorWeights","preds","inEdges","intersectRect","rect","point","x","y","dx","dy","width","h","height","sx","sy","abs","buildLayerMatrix","layering","layeringNodes","rankMax","maxRank","push","rank","undefined","layer","sort","va","vb","_b","order","normalizeRanks","nodeRanks","filter","min","hasOwnProperty","removeEmptyRanks","offset","layers","delta","nodeRankFactor","vs","addBorderNode","prefix","Infinity","partition","collection","fn","lhs","rhs","value","time","start","Date","now","console","log","notime","minBy","array","func","minObject","item"],"sources":["../../../../src/layout/dagre/src/util.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}