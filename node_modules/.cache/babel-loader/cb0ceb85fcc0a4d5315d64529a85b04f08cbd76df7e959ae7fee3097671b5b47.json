{"ast":null,"code":"import graphlib from '../graphlib';\nimport util from '../util';\nconst Graph = graphlib.Graph;\n/*\n * This module provides coordinate assignment based on Brandes and KÃ¶pf, \"Fast\n * and Simple Horizontal Coordinate Assignment.\"\n */\n/*\n * Marks all edges in the graph with a type-1 conflict with the \"type1Conflict\"\n * property. A type-1 conflict is one where a non-inner segment crosses an\n * inner segment. An inner segment is an edge with both incident nodes marked\n * with the \"dummy\" property.\n *\n * This algorithm scans layer by layer, starting with the second, for type-1\n * conflicts between the current layer and the previous layer. For each layer\n * it scans the nodes from left to right until it reaches one that is incident\n * on an inner segment. It then scans predecessors to determine if they have\n * edges that cross that inner segment. At the end a final scan is done for all\n * nodes on the current rank to see if they cross the last visited inner\n * segment.\n *\n * This algorithm (safely) assumes that a dummy node will only be incident on a\n * single node in the layers being scanned.\n */\nconst findType1Conflicts = (g, layering) => {\n  const conflicts = {};\n  const visitLayer = (prevLayer, layer) => {\n    // last visited node in the previous layer that is incident on an inner\n    // segment.\n    let k0 = 0;\n    // Tracks the last node in this layer scanned for crossings with a type-1\n    // segment.\n    let scanPos = 0;\n    const prevLayerLength = prevLayer.length;\n    const lastNode = layer === null || layer === void 0 ? void 0 : layer[(layer === null || layer === void 0 ? void 0 : layer.length) - 1];\n    layer === null || layer === void 0 ? void 0 : layer.forEach((v, i) => {\n      var _a;\n      const w = findOtherInnerSegmentNode(g, v);\n      const k1 = w ? g.node(w).order : prevLayerLength;\n      if (w || v === lastNode) {\n        (_a = layer.slice(scanPos, i + 1)) === null || _a === void 0 ? void 0 : _a.forEach(scanNode => {\n          var _a;\n          (_a = g.predecessors(scanNode)) === null || _a === void 0 ? void 0 : _a.forEach(u => {\n            const uLabel = g.node(u);\n            const uPos = uLabel.order;\n            if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g.node(scanNode).dummy)) {\n              addConflict(conflicts, u, scanNode);\n            }\n          });\n        });\n        scanPos = i + 1;\n        k0 = k1;\n      }\n    });\n    return layer;\n  };\n  if (layering === null || layering === void 0 ? void 0 : layering.length) {\n    layering.reduce(visitLayer);\n  }\n  return conflicts;\n};\nconst findType2Conflicts = (g, layering) => {\n  const conflicts = {};\n  const scan = (south, southPos, southEnd, prevNorthBorder, nextNorthBorder) => {\n    let v;\n    const range = [];\n    for (let i = southPos; i < southEnd; i++) {\n      range.push(i);\n    }\n    range.forEach(i => {\n      var _a;\n      v = south[i];\n      if (g.node(v).dummy) {\n        (_a = g.predecessors(v)) === null || _a === void 0 ? void 0 : _a.forEach(u => {\n          const uNode = g.node(u);\n          if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {\n            addConflict(conflicts, u, v);\n          }\n        });\n      }\n    });\n  };\n  const visitLayer = (north, south) => {\n    let prevNorthPos = -1;\n    let nextNorthPos;\n    let southPos = 0;\n    south === null || south === void 0 ? void 0 : south.forEach((v, southLookahead) => {\n      if (g.node(v).dummy === \"border\") {\n        const predecessors = g.predecessors(v) || [];\n        if (predecessors.length) {\n          nextNorthPos = g.node(predecessors[0]).order;\n          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);\n          southPos = southLookahead;\n          prevNorthPos = nextNorthPos;\n        }\n      }\n      scan(south, southPos, south.length, nextNorthPos, north.length);\n    });\n    return south;\n  };\n  if (layering === null || layering === void 0 ? void 0 : layering.length) {\n    layering.reduce(visitLayer);\n  }\n  return conflicts;\n};\nconst findOtherInnerSegmentNode = (g, v) => {\n  var _a;\n  if (g.node(v).dummy) {\n    return (_a = g.predecessors(v)) === null || _a === void 0 ? void 0 : _a.find(u => g.node(u).dummy);\n  }\n};\nconst addConflict = (conflicts, v, w) => {\n  let vv = v;\n  let ww = w;\n  if (vv > ww) {\n    const tmp = vv;\n    vv = ww;\n    ww = tmp;\n  }\n  let conflictsV = conflicts[vv];\n  if (!conflictsV) {\n    conflicts[vv] = conflictsV = {};\n  }\n  conflictsV[ww] = true;\n};\nconst hasConflict = (conflicts, v, w) => {\n  let vv = v;\n  let ww = w;\n  if (vv > ww) {\n    const tmp = v;\n    vv = ww;\n    ww = tmp;\n  }\n  return conflicts[vv] && conflicts[vv].hasOwnProperty(ww);\n};\n/*\n * Try to align nodes into vertical \"blocks\" where possible. This algorithm\n * attempts to align a node with one of its median neighbors. If the edge\n * connecting a neighbor is a type-1 conflict then we ignore that possibility.\n * If a previous node has already formed a block with a node after the node\n * we're trying to form a block with, we also ignore that possibility - our\n * blocks would be split in that scenario.\n */\nconst verticalAlignment = (g, layering, conflicts, neighborFn) => {\n  const root = {};\n  const align = {};\n  const pos = {};\n  // We cache the position here based on the layering because the graph and\n  // layering may be out of sync. The layering matrix is manipulated to\n  // generate different extreme alignments.\n  layering === null || layering === void 0 ? void 0 : layering.forEach(layer => {\n    layer === null || layer === void 0 ? void 0 : layer.forEach((v, order) => {\n      root[v] = v;\n      align[v] = v;\n      pos[v] = order;\n    });\n  });\n  layering === null || layering === void 0 ? void 0 : layering.forEach(layer => {\n    let prevIdx = -1;\n    layer === null || layer === void 0 ? void 0 : layer.forEach(v => {\n      let ws = neighborFn(v);\n      if (ws.length) {\n        ws = ws.sort((a, b) => pos[a] - pos[b]);\n        const mp = (ws.length - 1) / 2;\n        for (let i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {\n          const w = ws[i];\n          if (align[v] === v && prevIdx < pos[w] && !hasConflict(conflicts, v, w)) {\n            align[w] = v;\n            align[v] = root[v] = root[w];\n            prevIdx = pos[w];\n          }\n        }\n      }\n    });\n  });\n  return {\n    root,\n    align\n  };\n};\nconst horizontalCompaction = (g, layering, root, align, reverseSep) => {\n  var _a;\n  // This portion of the algorithm differs from BK due to a number of problems.\n  // Instead of their algorithm we construct a new block graph and do two\n  // sweeps. The first sweep places blocks with the smallest possible\n  // coordinates. The second sweep removes unused space by moving blocks to the\n  // greatest coordinates without violating separation.\n  const xs = {};\n  const blockG = buildBlockGraph(g, layering, root, reverseSep);\n  const borderType = reverseSep ? \"borderLeft\" : \"borderRight\";\n  const iterate = (setXsFunc, nextNodesFunc) => {\n    let stack = blockG.nodes();\n    let elem = stack.pop();\n    const visited = {};\n    while (elem) {\n      if (visited[elem]) {\n        setXsFunc(elem);\n      } else {\n        visited[elem] = true;\n        stack.push(elem);\n        stack = stack.concat(nextNodesFunc(elem));\n      }\n      elem = stack.pop();\n    }\n  };\n  // First pass, assign smallest coordinates\n  const pass1 = elem => {\n    xs[elem] = (blockG.inEdges(elem) || []).reduce((acc, e) => {\n      return Math.max(acc, (xs[e.v] || 0) + blockG.edge(e));\n    }, 0);\n  };\n  // Second pass, assign greatest coordinates\n  const pass2 = elem => {\n    const min = (blockG.outEdges(elem) || []).reduce((acc, e) => {\n      return Math.min(acc, (xs[e.w] || 0) - blockG.edge(e));\n    }, Number.POSITIVE_INFINITY);\n    const node = g.node(elem);\n    if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {\n      xs[elem] = Math.max(xs[elem], min);\n    }\n  };\n  iterate(pass1, blockG.predecessors.bind(blockG));\n  iterate(pass2, blockG.successors.bind(blockG));\n  // Assign x coordinates to all nodes\n  // @ts-ignore\n  (_a = Object.values(align)) === null || _a === void 0 ? void 0 : _a.forEach(v => {\n    xs[v] = xs[root[v]];\n  });\n  return xs;\n};\nconst buildBlockGraph = (g, layering, root, reverseSep) => {\n  const blockGraph = new Graph();\n  const graphLabel = g.graph();\n  const sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);\n  layering === null || layering === void 0 ? void 0 : layering.forEach(layer => {\n    let u;\n    layer === null || layer === void 0 ? void 0 : layer.forEach(v => {\n      const vRoot = root[v];\n      blockGraph.setNode(vRoot);\n      if (u) {\n        const uRoot = root[u];\n        const prevMax = blockGraph.edge(uRoot, vRoot);\n        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));\n      }\n      u = v;\n    });\n  });\n  return blockGraph;\n};\n/*\n * Returns the alignment that has the smallest width of the given alignments.\n */\nconst findSmallestWidthAlignment = (g, xss) => {\n  // @ts-ignore\n  return util.minBy(Object.values(xss), xs => {\n    var _a;\n    let max = Number.NEGATIVE_INFINITY;\n    let min = Number.POSITIVE_INFINITY;\n    (_a = Object.keys(xs)) === null || _a === void 0 ? void 0 : _a.forEach(v => {\n      const x = xs[v];\n      const halfWidth = width(g, v) / 2;\n      max = Math.max(x + halfWidth, max);\n      min = Math.min(x - halfWidth, min);\n    });\n    return max - min;\n  });\n};\n/*\n * Align the coordinates of each of the layout alignments such that\n * left-biased alignments have their minimum coordinate at the same point as\n * the minimum coordinate of the smallest width alignment and right-biased\n * alignments have their maximum coordinate at the same point as the maximum\n * coordinate of the smallest width alignment.\n */\nfunction alignCoordinates(xss, alignTo) {\n  // @ts-ignore\n  const alignToVals = Object.values(alignTo);\n  const alignToMin = Math.min(...alignToVals);\n  const alignToMax = Math.max(...alignToVals);\n  [\"u\", \"d\"].forEach(vert => {\n    [\"l\", \"r\"].forEach(horiz => {\n      const alignment = vert + horiz;\n      const xs = xss[alignment];\n      let delta;\n      if (xs === alignTo) return;\n      const xsVals = Object.values(xs);\n      delta = horiz === \"l\" ? alignToMin - Math.min(...xsVals) : alignToMax - Math.max(...xsVals);\n      if (delta) {\n        xss[alignment] = {};\n        Object.keys(xs).forEach(key => {\n          xss[alignment][key] = xs[key] + delta;\n        });\n      }\n    });\n  });\n}\nconst balance = (xss, align) => {\n  const result = {};\n  Object.keys(xss.ul).forEach(key => {\n    if (align) {\n      result[key] = xss[align.toLowerCase()][key];\n    } else {\n      // @ts-ignore\n      const values = Object.values(xss).map(x => x[key]);\n      const xs = values.sort((a, b) => a - b);\n      result[key] = (xs[1] + xs[2]) / 2;\n    }\n  });\n  return result;\n  // return _.mapValues(xss.ul, function(ignore, v) {\n  //   if (align) {\n  //     return xss[align.toLowerCase()][v];\n  //   } else {\n  //     const xs = _.sortBy(_.map(xss, v));\n  //     return (xs[1] + xs[2]) / 2;\n  //   }\n  // });\n};\nconst positionX = g => {\n  const layering = util.buildLayerMatrix(g);\n  const conflicts = Object.assign(findType1Conflicts(g, layering), findType2Conflicts(g, layering));\n  const xss = {};\n  let adjustedLayering;\n  [\"u\", \"d\"].forEach(vert => {\n    // @ts-ignore\n    adjustedLayering = vert === \"u\" ? layering : Object.values(layering).reverse();\n    [\"l\", \"r\"].forEach(horiz => {\n      if (horiz === \"r\") {\n        // @ts-ignore\n        adjustedLayering = adjustedLayering.map(inner => Object.values(inner).reverse());\n      }\n      const neighborFn = (vert === \"u\" ? g.predecessors : g.successors).bind(g);\n      const align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);\n      let xs = horizontalCompaction(g, adjustedLayering, align.root, align.align, horiz === \"r\");\n      if (horiz === \"r\") {\n        // @ts-ignore\n        xs = Object.values(xs).map(x => -x);\n      }\n      xss[vert + horiz] = xs;\n    });\n  });\n  const smallestWidth = findSmallestWidthAlignment(g, xss);\n  alignCoordinates(xss, smallestWidth);\n  return balance(xss, g.graph().align);\n};\nconst sep = (nodeSep, edgeSep, reverseSep) => {\n  return (g, v, w) => {\n    const vLabel = g.node(v);\n    const wLabel = g.node(w);\n    let sum = 0;\n    let delta;\n    sum += vLabel.width / 2;\n    if (vLabel.hasOwnProperty(\"labelpos\")) {\n      switch ((vLabel.labelpos || '').toLowerCase()) {\n        case \"l\":\n          delta = -vLabel.width / 2;\n          break;\n        case \"r\":\n          delta = vLabel.width / 2;\n          break;\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n    delta = 0;\n    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;\n    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;\n    sum += wLabel.width / 2;\n    if (wLabel.hasOwnProperty(\"labelpos\")) {\n      switch ((wLabel.labelpos || '').toLowerCase()) {\n        case \"l\":\n          delta = wLabel.width / 2;\n          break;\n        case \"r\":\n          delta = -wLabel.width / 2;\n          break;\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n    delta = 0;\n    return sum;\n  };\n};\nconst width = (g, v) => {\n  var _a;\n  return ((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.width) || 0;\n};\nexport { positionX, findType1Conflicts, findType2Conflicts, addConflict, hasConflict, verticalAlignment, horizontalCompaction, alignCoordinates, findSmallestWidthAlignment, balance };\nexport default {\n  positionX,\n  findType1Conflicts,\n  findType2Conflicts,\n  addConflict,\n  hasConflict,\n  verticalAlignment,\n  horizontalCompaction,\n  alignCoordinates,\n  findSmallestWidthAlignment,\n  balance\n};","map":{"version":3,"names":["graphlib","util","Graph","findType1Conflicts","g","layering","conflicts","visitLayer","prevLayer","layer","k0","scanPos","prevLayerLength","length","lastNode","forEach","v","i","w","findOtherInnerSegmentNode","k1","node","order","_a","slice","scanNode","predecessors","u","uLabel","uPos","dummy","addConflict","reduce","findType2Conflicts","scan","south","southPos","southEnd","prevNorthBorder","nextNorthBorder","range","push","uNode","north","prevNorthPos","nextNorthPos","southLookahead","find","vv","ww","tmp","conflictsV","hasConflict","hasOwnProperty","verticalAlignment","neighborFn","root","align","pos","prevIdx","ws","sort","a","b","mp","Math","floor","il","ceil","horizontalCompaction","reverseSep","xs","blockG","buildBlockGraph","borderType","iterate","setXsFunc","nextNodesFunc","stack","nodes","elem","pop","visited","concat","pass1","inEdges","acc","e","max","edge","pass2","min","outEdges","Number","POSITIVE_INFINITY","bind","successors","Object","values","blockGraph","graphLabel","graph","sepFn","sep","nodesep","edgesep","vRoot","setNode","uRoot","prevMax","setEdge","findSmallestWidthAlignment","xss","minBy","NEGATIVE_INFINITY","keys","x","halfWidth","width","alignCoordinates","alignTo","alignToVals","alignToMin","alignToMax","vert","horiz","alignment","delta","xsVals","key","balance","result","ul","toLowerCase","map","positionX","buildLayerMatrix","assign","adjustedLayering","reverse","inner","smallestWidth","nodeSep","edgeSep","vLabel","wLabel","sum","labelpos"],"sources":["../../../../../src/layout/dagre/src/position/bk.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}