{"ast":null,"code":"// src/transform/grid.ts\nimport { Satistics, aProjectFlat } from \"@antv/l7-utils\";\nvar R_EARTH = 6378e3;\nfunction aggregatorToGrid(data, option) {\n  const dataArray = data.dataArray;\n  const {\n    size = 10\n  } = option;\n  const pixlSize = size / (2 * Math.PI * R_EARTH) * (256 << 20) / 2;\n  const {\n    gridHash,\n    gridOffset\n  } = _pointsGridHash(dataArray, size);\n  const layerData = _getGridLayerDataFromGridHash(gridHash, gridOffset, option);\n  return {\n    yOffset: pixlSize,\n    xOffset: pixlSize,\n    radius: pixlSize,\n    type: \"grid\",\n    dataArray: layerData\n  };\n}\nfunction _pointsGridHash(dataArray, size) {\n  let latMin = Infinity;\n  let latMax = -Infinity;\n  let pLat;\n  for (const point of dataArray) {\n    pLat = point.coordinates[1];\n    if (Number.isFinite(pLat)) {\n      latMin = pLat < latMin ? pLat : latMin;\n      latMax = pLat > latMax ? pLat : latMax;\n    }\n  }\n  const centerLat = (latMin + latMax) / 2;\n  const gridOffset = _calculateGridLatLonOffset(size, centerLat);\n  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {\n    return {\n      gridHash: {},\n      gridOffset\n    };\n  }\n  const gridHash = {};\n  for (const point of dataArray) {\n    const lat = point.coordinates[1];\n    const lng = point.coordinates[0];\n    if (Number.isFinite(lat) && Number.isFinite(lng)) {\n      const latIdx = Math.floor((lat + 90) / gridOffset.yOffset);\n      const lonIdx = Math.floor((lng + 180) / gridOffset.xOffset);\n      const key = `${latIdx}-${lonIdx}`;\n      gridHash[key] = gridHash[key] || {\n        count: 0,\n        points: []\n      };\n      gridHash[key].count += 1;\n      gridHash[key].points.push(point);\n    }\n  }\n  return {\n    gridHash,\n    gridOffset\n  };\n}\nfunction _calculateGridLatLonOffset(cellSize, latitude) {\n  const yOffset = _calculateLatOffset(cellSize);\n  const xOffset = _calculateLonOffset(latitude, cellSize);\n  return {\n    yOffset,\n    xOffset\n  };\n}\nfunction _calculateLatOffset(dy) {\n  return dy / R_EARTH * (180 / Math.PI);\n}\nfunction _calculateLonOffset(lat, dx) {\n  return dx / R_EARTH * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);\n}\nfunction _getGridLayerDataFromGridHash(gridHash, gridOffset, option) {\n  return Object.keys(gridHash).reduce((accu, key, i) => {\n    const idxs = key.split(\"-\");\n    const latIdx = parseInt(idxs[0], 10);\n    const lonIdx = parseInt(idxs[1], 10);\n    const item = {};\n    if (option.field && option.method) {\n      const columns = Satistics.getColumn(gridHash[key].points, option.field);\n      item[option.method] = Satistics.statMap[option.method](columns);\n    }\n    Object.assign(item, {\n      _id: i,\n      coordinates: aProjectFlat([-180 + gridOffset.xOffset * (lonIdx + 0.5), -90 + gridOffset.yOffset * (latIdx + 0.5)]),\n      rawData: gridHash[key].points,\n      count: gridHash[key].count\n    });\n    accu.push(item);\n    return accu;\n  }, []);\n}\nexport { aggregatorToGrid };","map":{"version":3,"names":["Satistics","aProjectFlat","R_EARTH","aggregatorToGrid","data","option","dataArray","size","pixlSize","Math","PI","gridHash","gridOffset","_pointsGridHash","layerData","_getGridLayerDataFromGridHash","yOffset","xOffset","radius","type","latMin","Infinity","latMax","pLat","point","coordinates","Number","isFinite","centerLat","_calculateGridLatLonOffset","lat","lng","latIdx","floor","lonIdx","key","count","points","push","cellSize","latitude","_calculateLatOffset","_calculateLonOffset","dy","dx","cos","Object","keys","reduce","accu","i","idxs","split","parseInt","item","field","method","columns","getColumn","statMap","assign","_id","rawData"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/l7-source/es/transform/grid.js"],"sourcesContent":["// src/transform/grid.ts\nimport { Satistics, aProjectFlat } from \"@antv/l7-utils\";\nvar R_EARTH = 6378e3;\nfunction aggregatorToGrid(data, option) {\n  const dataArray = data.dataArray;\n  const { size = 10 } = option;\n  const pixlSize = size / (2 * Math.PI * R_EARTH) * (256 << 20) / 2;\n  const { gridHash, gridOffset } = _pointsGridHash(dataArray, size);\n  const layerData = _getGridLayerDataFromGridHash(gridHash, gridOffset, option);\n  return {\n    yOffset: pixlSize,\n    xOffset: pixlSize,\n    radius: pixlSize,\n    type: \"grid\",\n    dataArray: layerData\n  };\n}\nfunction _pointsGridHash(dataArray, size) {\n  let latMin = Infinity;\n  let latMax = -Infinity;\n  let pLat;\n  for (const point of dataArray) {\n    pLat = point.coordinates[1];\n    if (Number.isFinite(pLat)) {\n      latMin = pLat < latMin ? pLat : latMin;\n      latMax = pLat > latMax ? pLat : latMax;\n    }\n  }\n  const centerLat = (latMin + latMax) / 2;\n  const gridOffset = _calculateGridLatLonOffset(size, centerLat);\n  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {\n    return { gridHash: {}, gridOffset };\n  }\n  const gridHash = {};\n  for (const point of dataArray) {\n    const lat = point.coordinates[1];\n    const lng = point.coordinates[0];\n    if (Number.isFinite(lat) && Number.isFinite(lng)) {\n      const latIdx = Math.floor((lat + 90) / gridOffset.yOffset);\n      const lonIdx = Math.floor((lng + 180) / gridOffset.xOffset);\n      const key = `${latIdx}-${lonIdx}`;\n      gridHash[key] = gridHash[key] || { count: 0, points: [] };\n      gridHash[key].count += 1;\n      gridHash[key].points.push(point);\n    }\n  }\n  return { gridHash, gridOffset };\n}\nfunction _calculateGridLatLonOffset(cellSize, latitude) {\n  const yOffset = _calculateLatOffset(cellSize);\n  const xOffset = _calculateLonOffset(latitude, cellSize);\n  return { yOffset, xOffset };\n}\nfunction _calculateLatOffset(dy) {\n  return dy / R_EARTH * (180 / Math.PI);\n}\nfunction _calculateLonOffset(lat, dx) {\n  return dx / R_EARTH * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);\n}\nfunction _getGridLayerDataFromGridHash(gridHash, gridOffset, option) {\n  return Object.keys(gridHash).reduce((accu, key, i) => {\n    const idxs = key.split(\"-\");\n    const latIdx = parseInt(idxs[0], 10);\n    const lonIdx = parseInt(idxs[1], 10);\n    const item = {};\n    if (option.field && option.method) {\n      const columns = Satistics.getColumn(gridHash[key].points, option.field);\n      item[option.method] = Satistics.statMap[option.method](columns);\n    }\n    Object.assign(item, {\n      _id: i,\n      coordinates: aProjectFlat([\n        -180 + gridOffset.xOffset * (lonIdx + 0.5),\n        -90 + gridOffset.yOffset * (latIdx + 0.5)\n      ]),\n      rawData: gridHash[key].points,\n      count: gridHash[key].count\n    });\n    accu.push(item);\n    return accu;\n  }, []);\n}\nexport {\n  aggregatorToGrid\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}