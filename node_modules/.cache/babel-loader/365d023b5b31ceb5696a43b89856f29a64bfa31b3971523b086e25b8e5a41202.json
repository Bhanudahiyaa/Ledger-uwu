{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _dec, _class;\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nimport { generateAABBFromVertices } from '@antv/g-webgpu-core';\nimport { injectable } from 'inversify';\nimport { Geometry } from '.';\nexport var\n/**\n * borrow from playcanvas\n */\nSphere = (_dec = injectable(), _dec(_class = /*#__PURE__*/function (_Geometry) {\n  _inherits(Sphere, _Geometry);\n  var _super = _createSuper(Sphere);\n  function Sphere() {\n    _classCallCheck(this, Sphere);\n    return _super.apply(this, arguments);\n  }\n  _createClass(Sphere, [{\n    key: \"onEntityCreated\",\n    value: function onEntityCreated() {\n      var _this$config = this.config,\n        _this$config$radius = _this$config.radius,\n        radius = _this$config$radius === void 0 ? 0.5 : _this$config$radius,\n        _this$config$latitude = _this$config.latitudeBands,\n        latitudeBands = _this$config$latitude === void 0 ? 16 : _this$config$latitude,\n        _this$config$longitud = _this$config.longitudeBands,\n        longitudeBands = _this$config$longitud === void 0 ? 16 : _this$config$longitud;\n      var positions = [];\n      var normals = [];\n      var uvs = [];\n      var indices = [];\n      for (var lat = 0; lat <= latitudeBands; lat++) {\n        var theta = lat * Math.PI / latitudeBands;\n        var sinTheta = Math.sin(theta);\n        var cosTheta = Math.cos(theta);\n        for (var lon = 0; lon <= longitudeBands; lon++) {\n          // Sweep the sphere from the positive Z axis to match a 3DS Max sphere\n          var phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2.0;\n          var sinPhi = Math.sin(phi);\n          var cosPhi = Math.cos(phi);\n          var x = cosPhi * sinTheta;\n          var y = cosTheta;\n          var z = sinPhi * sinTheta;\n          var u = 1.0 - lon / longitudeBands;\n          var v = 1.0 - lat / latitudeBands;\n          positions.push(x * radius, y * radius, z * radius);\n          normals.push(x, y, z);\n          uvs.push(u, v);\n        }\n      }\n      for (var _lat = 0; _lat < latitudeBands; ++_lat) {\n        for (var _lon = 0; _lon < longitudeBands; ++_lon) {\n          var first = _lat * (longitudeBands + 1) + _lon;\n          var second = first + longitudeBands + 1;\n          indices.push(first + 1, second, first);\n          indices.push(first + 1, second + 1, second);\n        }\n      } // generate AABB\n\n      var aabb = generateAABBFromVertices(positions);\n      var component = this.getComponent();\n      component.indices = Uint32Array.from(indices);\n      component.aabb = aabb;\n      component.vertexCount = positions.length / 3;\n      component.attributes = [{\n        dirty: true,\n        name: 'position',\n        data: Float32Array.from(positions),\n        arrayStride: 4 * 3,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 0,\n          offset: 0,\n          format: 'float3'\n        }]\n      }, {\n        dirty: true,\n        name: 'normal',\n        data: Float32Array.from(normals),\n        arrayStride: 4 * 3,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 1,\n          offset: 0,\n          format: 'float3'\n        }]\n      }, {\n        dirty: true,\n        name: 'uv',\n        data: Float32Array.from(uvs),\n        arrayStride: 4 * 2,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 2,\n          offset: 0,\n          format: 'float2'\n        }]\n      }]; // TODO: barycentric & tangent\n    }\n  }]);\n  return Sphere;\n}(Geometry)) || _class);","map":{"version":3,"names":["generateAABBFromVertices","injectable","Geometry","Sphere","_dec","_class","_Geometry","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","key","value","onEntityCreated","_this$config","config","_this$config$radius","radius","_this$config$latitude","latitudeBands","_this$config$longitud","longitudeBands","positions","normals","uvs","indices","lat","theta","Math","PI","sinTheta","sin","cosTheta","cos","lon","phi","sinPhi","cosPhi","x","y","z","u","v","push","_lat","_lon","first","second","aabb","component","getComponent","Uint32Array","from","vertexCount","length","attributes","dirty","name","data","Float32Array","arrayStride","stepMode","shaderLocation","offset","format"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/g-webgpu/src/geometry/Sphere.ts"],"sourcesContent":["import { generateAABBFromVertices } from '@antv/g-webgpu-core';\nimport { vec3 } from 'gl-matrix';\nimport { inject, injectable } from 'inversify';\nimport { Geometry } from '.';\n\nexport interface ISphereGeometryParams {\n  radius: number;\n  latitudeBands: number;\n  longitudeBands: number;\n}\n\n@injectable()\n/**\n * borrow from playcanvas\n */\nexport class Sphere extends Geometry<Partial<ISphereGeometryParams>> {\n  protected onEntityCreated() {\n    const {\n      radius = 0.5,\n      latitudeBands = 16,\n      longitudeBands = 16,\n    } = this.config;\n\n    const positions: number[] = [];\n    const normals: number[] = [];\n    const uvs: number[] = [];\n    const indices: number[] = [];\n\n    for (let lat = 0; lat <= latitudeBands; lat++) {\n      const theta = (lat * Math.PI) / latitudeBands;\n      const sinTheta = Math.sin(theta);\n      const cosTheta = Math.cos(theta);\n\n      for (let lon = 0; lon <= longitudeBands; lon++) {\n        // Sweep the sphere from the positive Z axis to match a 3DS Max sphere\n        const phi = (lon * 2 * Math.PI) / longitudeBands - Math.PI / 2.0;\n        const sinPhi = Math.sin(phi);\n        const cosPhi = Math.cos(phi);\n\n        const x = cosPhi * sinTheta;\n        const y = cosTheta;\n        const z = sinPhi * sinTheta;\n        const u = 1.0 - lon / longitudeBands;\n        const v = 1.0 - lat / latitudeBands;\n\n        positions.push(x * radius, y * radius, z * radius);\n        normals.push(x, y, z);\n        uvs.push(u, v);\n      }\n    }\n\n    for (let lat = 0; lat < latitudeBands; ++lat) {\n      for (let lon = 0; lon < longitudeBands; ++lon) {\n        const first = lat * (longitudeBands + 1) + lon;\n        const second = first + longitudeBands + 1;\n\n        indices.push(first + 1, second, first);\n        indices.push(first + 1, second + 1, second);\n      }\n    }\n\n    // generate AABB\n    const aabb = generateAABBFromVertices(positions);\n\n    const component = this.getComponent();\n    component.indices = Uint32Array.from(indices);\n    component.aabb = aabb;\n    component.vertexCount = positions.length / 3;\n    component.attributes = [\n      {\n        dirty: true,\n        name: 'position',\n        data: Float32Array.from(positions),\n        arrayStride: 4 * 3,\n        stepMode: 'vertex',\n        attributes: [\n          {\n            shaderLocation: 0,\n            offset: 0,\n            format: 'float3',\n          },\n        ],\n      },\n      {\n        dirty: true,\n        name: 'normal',\n        data: Float32Array.from(normals),\n        arrayStride: 4 * 3,\n        stepMode: 'vertex',\n        attributes: [\n          {\n            shaderLocation: 1,\n            offset: 0,\n            format: 'float3',\n          },\n        ],\n      },\n      {\n        dirty: true,\n        name: 'uv',\n        data: Float32Array.from(uvs),\n        arrayStride: 4 * 2,\n        stepMode: 'vertex',\n        attributes: [\n          {\n            shaderLocation: 2,\n            offset: 0,\n            format: 'float2',\n          },\n        ],\n      },\n    ];\n\n    // TODO: barycentric & tangent\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}