{"ast":null,"code":"import { ArrayExt } from '../../../util';\nimport { Point } from '../../../geometry';\n/**\n * Helper structure to identify whether a point lies inside an obstacle.\n */\nexport class ObstacleMap {\n  constructor(options) {\n    this.options = options;\n    this.mapGridSize = 100;\n    this.map = {};\n  }\n  /**\n   * Builds a map of all nodes for quicker obstacle queries i.e. is a point\n   * contained in any obstacle?\n   *\n   * A simplified grid search.\n   */\n  build(model, edge) {\n    const options = this.options;\n    // source or target node could be excluded from set of obstacles\n    const excludedTerminals = options.excludeTerminals.reduce((memo, type) => {\n      const terminal = edge[type];\n      if (terminal) {\n        const cell = model.getCell(terminal.cell);\n        if (cell) {\n          memo.push(cell);\n        }\n      }\n      return memo;\n    }, []);\n    let excludedAncestors = [];\n    const source = model.getCell(edge.getSourceCellId());\n    if (source) {\n      excludedAncestors = ArrayExt.union(excludedAncestors, source.getAncestors().map(cell => cell.id));\n    }\n    const target = model.getCell(edge.getTargetCellId());\n    if (target) {\n      excludedAncestors = ArrayExt.union(excludedAncestors, target.getAncestors().map(cell => cell.id));\n    }\n    // The graph is divided into smaller cells, where each holds information\n    // about which node belong to it. When we query whether a point lies\n    // inside an obstacle we don't need to go through all obstacles, we check\n    // only those in a particular cell.\n    const mapGridSize = this.mapGridSize;\n    model.getNodes().reduce((map, node) => {\n      const shape = node.shape;\n      const excludeShapes = options.excludeShapes;\n      const excType = shape ? excludeShapes.includes(shape) : false;\n      const excTerminal = excludedTerminals.some(cell => cell.id === node.id);\n      const excludedNode = options.excludeNodes.some(item => {\n        if (typeof item === 'string') {\n          return node.id === item;\n        }\n        return item === node;\n      });\n      const excAncestor = excludedAncestors.includes(node.id);\n      const excHidden = options.excludeHiddenNodes && !node.isVisible();\n      const excluded = excType || excTerminal || excludedNode || excAncestor || excHidden;\n      if (!excluded) {\n        const bbox = node.getBBox().moveAndExpand(options.paddingBox);\n        const origin = bbox.getOrigin().snapToGrid(mapGridSize);\n        const corner = bbox.getCorner().snapToGrid(mapGridSize);\n        for (let x = origin.x; x <= corner.x; x += mapGridSize) {\n          for (let y = origin.y; y <= corner.y; y += mapGridSize) {\n            const key = new Point(x, y).toString();\n            if (map[key] == null) {\n              map[key] = [];\n            }\n            map[key].push(bbox);\n          }\n        }\n      }\n      return map;\n    }, this.map);\n    return this;\n  }\n  isAccessible(point) {\n    const key = point.clone().snapToGrid(this.mapGridSize).toString();\n    const rects = this.map[key];\n    return rects ? rects.every(rect => !rect.containsPoint(point)) : true;\n  }\n}","map":{"version":3,"names":["ArrayExt","Point","ObstacleMap","constructor","options","mapGridSize","map","build","model","edge","excludedTerminals","excludeTerminals","reduce","memo","type","terminal","cell","getCell","push","excludedAncestors","source","getSourceCellId","union","getAncestors","id","target","getTargetCellId","getNodes","node","shape","excludeShapes","excType","includes","excTerminal","some","excludedNode","excludeNodes","item","excAncestor","excHidden","excludeHiddenNodes","isVisible","excluded","bbox","getBBox","moveAndExpand","paddingBox","origin","getOrigin","snapToGrid","corner","getCorner","x","y","key","toString","isAccessible","point","clone","rects","every","rect","containsPoint"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/registry/router/manhattan/obstacle-map.ts"],"sourcesContent":["import { ArrayExt } from '../../../util'\nimport { KeyValue } from '../../../types'\nimport { Rectangle, Point } from '../../../geometry'\nimport { Cell, Edge, Model } from '../../../model'\nimport { ResolvedOptions } from './options'\n\n/**\n * Helper structure to identify whether a point lies inside an obstacle.\n */\nexport class ObstacleMap {\n  options: ResolvedOptions\n\n  /**\n   * How to divide the paper when creating the elements map\n   */\n  mapGridSize: number\n\n  map: KeyValue<Rectangle[]>\n\n  constructor(options: ResolvedOptions) {\n    this.options = options\n    this.mapGridSize = 100\n    this.map = {}\n  }\n\n  /**\n   * Builds a map of all nodes for quicker obstacle queries i.e. is a point\n   * contained in any obstacle?\n   *\n   * A simplified grid search.\n   */\n  build(model: Model, edge: Edge) {\n    const options = this.options\n    // source or target node could be excluded from set of obstacles\n    const excludedTerminals = options.excludeTerminals.reduce<Cell[]>(\n      (memo, type) => {\n        const terminal = edge[type]\n        if (terminal) {\n          const cell = model.getCell((terminal as Edge.TerminalCellData).cell)\n          if (cell) {\n            memo.push(cell)\n          }\n        }\n\n        return memo\n      },\n      [],\n    )\n\n    let excludedAncestors: string[] = []\n\n    const source = model.getCell(edge.getSourceCellId())\n    if (source) {\n      excludedAncestors = ArrayExt.union(\n        excludedAncestors,\n        source.getAncestors().map((cell) => cell.id),\n      )\n    }\n\n    const target = model.getCell(edge.getTargetCellId())\n    if (target) {\n      excludedAncestors = ArrayExt.union(\n        excludedAncestors,\n        target.getAncestors().map((cell) => cell.id),\n      )\n    }\n\n    // The graph is divided into smaller cells, where each holds information\n    // about which node belong to it. When we query whether a point lies\n    // inside an obstacle we don't need to go through all obstacles, we check\n    // only those in a particular cell.\n    const mapGridSize = this.mapGridSize\n\n    model.getNodes().reduce((map, node) => {\n      const shape = node.shape\n      const excludeShapes = options.excludeShapes\n      const excType = shape ? excludeShapes.includes(shape) : false\n      const excTerminal = excludedTerminals.some((cell) => cell.id === node.id)\n      const excludedNode = options.excludeNodes.some((item) => {\n        if (typeof item === 'string') {\n          return node.id === item\n        }\n        return item === node\n      })\n      const excAncestor = excludedAncestors.includes(node.id)\n      const excHidden = options.excludeHiddenNodes && !node.isVisible()\n      const excluded =\n        excType || excTerminal || excludedNode || excAncestor || excHidden\n\n      if (!excluded) {\n        const bbox = node.getBBox().moveAndExpand(options.paddingBox)\n        const origin = bbox.getOrigin().snapToGrid(mapGridSize)\n        const corner = bbox.getCorner().snapToGrid(mapGridSize)\n\n        for (let x = origin.x; x <= corner.x; x += mapGridSize) {\n          for (let y = origin.y; y <= corner.y; y += mapGridSize) {\n            const key = new Point(x, y).toString()\n            if (map[key] == null) {\n              map[key] = []\n            }\n            map[key].push(bbox)\n          }\n        }\n      }\n      return map\n    }, this.map)\n\n    return this\n  }\n\n  isAccessible(point: Point) {\n    const key = point.clone().snapToGrid(this.mapGridSize).toString()\n\n    const rects = this.map[key]\n    return rects ? rects.every((rect) => !rect.containsPoint(point)) : true\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}