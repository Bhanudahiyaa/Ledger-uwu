{"ast":null,"code":"import { Point } from '../../geometry';\nimport { attr } from './attr';\nimport { getBBox, getTransformToElement } from './geom';\nimport { createSVGTransform, parseTransformString, transformStringToMatrix, matrixToTransformString } from './matrix';\nexport function transform(elem, matrix, options = {}) {\n  if (matrix == null) {\n    return transformStringToMatrix(attr(elem, 'transform'));\n  }\n  if (options.absolute) {\n    elem.setAttribute('transform', matrixToTransformString(matrix));\n    return;\n  }\n  const transformList = elem.transform;\n  const svgTransform = createSVGTransform(matrix);\n  transformList.baseVal.appendItem(svgTransform);\n}\nexport function translate(elem, tx, ty = 0, options = {}) {\n  let transformAttr = attr(elem, 'transform');\n  const transform = parseTransformString(transformAttr);\n  if (tx == null) {\n    return transform.translation;\n  }\n  transformAttr = transform.raw;\n  transformAttr = transformAttr.replace(/translate\\([^)]*\\)/g, '').trim();\n  const newTx = options.absolute ? tx : transform.translation.tx + tx;\n  const newTy = options.absolute ? ty : transform.translation.ty + ty;\n  const newTranslate = `translate(${newTx},${newTy})`;\n  // Note that `translate()` is always the first transformation. This is\n  // usually the desired case.\n  elem.setAttribute('transform', `${newTranslate} ${transformAttr}`.trim());\n}\nexport function rotate(elem, angle, cx, cy, options = {}) {\n  let transformAttr = attr(elem, 'transform');\n  const transform = parseTransformString(transformAttr);\n  if (angle == null) {\n    return transform.rotation;\n  }\n  transformAttr = transform.raw;\n  transformAttr = transformAttr.replace(/rotate\\([^)]*\\)/g, '').trim();\n  angle %= 360; // eslint-disable-line\n  const newAngle = options.absolute ? angle : transform.rotation.angle + angle;\n  const newOrigin = cx != null && cy != null ? `,${cx},${cy}` : '';\n  const newRotate = `rotate(${newAngle}${newOrigin})`;\n  elem.setAttribute('transform', `${transformAttr} ${newRotate}`.trim());\n}\nexport function scale(elem, sx, sy) {\n  let transformAttr = attr(elem, 'transform');\n  const transform = parseTransformString(transformAttr);\n  if (sx == null) {\n    return transform.scale;\n  }\n  sy = sy == null ? sx : sy; // eslint-disable-line\n  transformAttr = transform.raw;\n  transformAttr = transformAttr.replace(/scale\\([^)]*\\)/g, '').trim();\n  const newScale = `scale(${sx},${sy})`;\n  elem.setAttribute('transform', `${transformAttr} ${newScale}`.trim());\n}\nexport function translateAndAutoOrient(elem, position, reference, target) {\n  const pos = Point.create(position);\n  const ref = Point.create(reference);\n  if (!target) {\n    const svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;\n    target = svg; // eslint-disable-line\n  }\n  // Clean-up previously set transformations except the scale.\n  // If we didn't clean up the previous transformations then they'd\n  // add up with the old ones. Scale is an exception as it doesn't\n  // add up, consider: `this.scale(2).scale(2).scale(2)`. The result\n  // is that the element is scaled by the factor 2, not 8.\n  const s = scale(elem);\n  elem.setAttribute('transform', '');\n  const bbox = getBBox(elem, {\n    target\n  }).scale(s.sx, s.sy);\n  // 1. Translate to origin.\n  const translateToOrigin = createSVGTransform();\n  translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2);\n  // 2. Rotate around origin.\n  const rotateAroundOrigin = createSVGTransform();\n  const angle = pos.angleBetween(ref, pos.clone().translate(1, 0));\n  if (angle) rotateAroundOrigin.setRotate(angle, 0, 0);\n  // 3. Translate to the `position` + the offset (half my width)\n  //    towards the `reference` point.\n  const translateFromOrigin = createSVGTransform();\n  const finalPosition = pos.clone().move(ref, bbox.width / 2);\n  translateFromOrigin.setTranslate(2 * pos.x - finalPosition.x, 2 * pos.y - finalPosition.y);\n  // 4. Get the current transformation matrix of this node\n  const ctm = getTransformToElement(elem, target);\n  // 5. Apply transformations and the scale\n  const transform = createSVGTransform();\n  transform.setMatrix(translateFromOrigin.matrix.multiply(rotateAroundOrigin.matrix.multiply(translateToOrigin.matrix.multiply(ctm.scale(s.sx, s.sy)))));\n  elem.setAttribute('transform', matrixToTransformString(transform.matrix));\n}","map":{"version":3,"names":["Point","attr","getBBox","getTransformToElement","createSVGTransform","parseTransformString","transformStringToMatrix","matrixToTransformString","transform","elem","matrix","options","absolute","setAttribute","transformList","svgTransform","baseVal","appendItem","translate","tx","ty","transformAttr","translation","raw","replace","trim","newTx","newTy","newTranslate","rotate","angle","cx","cy","rotation","newAngle","newOrigin","newRotate","scale","sx","sy","newScale","translateAndAutoOrient","position","reference","target","pos","create","ref","svg","SVGSVGElement","ownerSVGElement","s","bbox","translateToOrigin","setTranslate","x","width","y","height","rotateAroundOrigin","angleBetween","clone","setRotate","translateFromOrigin","finalPosition","move","ctm","setMatrix","multiply"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/util/dom/transform.ts"],"sourcesContent":["import { Point } from '../../geometry'\nimport { attr } from './attr'\nimport { getBBox, getTransformToElement } from './geom'\nimport {\n  Scale,\n  Rotation,\n  Translation,\n  createSVGTransform,\n  parseTransformString,\n  transformStringToMatrix,\n  matrixToTransformString,\n} from './matrix'\n\nexport interface TransformOptions {\n  absolute?: boolean\n}\n\nexport function transform(elem: Element): DOMMatrix\nexport function transform(\n  elem: SVGElement,\n  matrix: DOMMatrix,\n  options?: TransformOptions,\n): void\nexport function transform(\n  elem: SVGGraphicsElement,\n  matrix?: DOMMatrix,\n  options: TransformOptions = {},\n) {\n  if (matrix == null) {\n    return transformStringToMatrix(attr(elem, 'transform'))\n  }\n\n  if (options.absolute) {\n    elem.setAttribute('transform', matrixToTransformString(matrix))\n    return\n  }\n\n  const transformList = elem.transform\n  const svgTransform = createSVGTransform(matrix)\n  transformList.baseVal.appendItem(svgTransform)\n}\n\nexport function translate(elem: Element): Translation\nexport function translate(\n  elem: Element,\n  tx: number,\n  ty?: number,\n  options?: TransformOptions,\n): void\nexport function translate(\n  elem: Element,\n  tx?: number,\n  ty = 0,\n  options: TransformOptions = {},\n) {\n  let transformAttr = attr(elem, 'transform')\n  const transform = parseTransformString(transformAttr)\n  if (tx == null) {\n    return transform.translation\n  }\n\n  transformAttr = transform.raw\n  transformAttr = transformAttr.replace(/translate\\([^)]*\\)/g, '').trim()\n\n  const newTx = options.absolute ? tx : transform.translation.tx + tx\n  const newTy = options.absolute ? ty : transform.translation.ty + ty\n  const newTranslate = `translate(${newTx},${newTy})`\n\n  // Note that `translate()` is always the first transformation. This is\n  // usually the desired case.\n  elem.setAttribute('transform', `${newTranslate} ${transformAttr}`.trim())\n}\n\nexport function rotate(elem: Element): Rotation\nexport function rotate(\n  elem: Element,\n  angle: number,\n  cx?: number,\n  cy?: number,\n  options?: TransformOptions,\n): void\nexport function rotate(\n  elem: Element,\n  angle?: number,\n  cx?: number,\n  cy?: number,\n  options: TransformOptions = {},\n) {\n  let transformAttr = attr(elem, 'transform')\n  const transform = parseTransformString(transformAttr)\n\n  if (angle == null) {\n    return transform.rotation\n  }\n\n  transformAttr = transform.raw\n  transformAttr = transformAttr.replace(/rotate\\([^)]*\\)/g, '').trim()\n\n  angle %= 360 // eslint-disable-line\n  const newAngle = options.absolute ? angle : transform.rotation.angle + angle\n  const newOrigin = cx != null && cy != null ? `,${cx},${cy}` : ''\n  const newRotate = `rotate(${newAngle}${newOrigin})`\n  elem.setAttribute('transform', `${transformAttr} ${newRotate}`.trim())\n}\n\nexport function scale(elem: Element): Scale\nexport function scale(elem: Element, sx: number, sy?: number): void\nexport function scale(elem: Element, sx?: number, sy?: number) {\n  let transformAttr = attr(elem, 'transform')\n  const transform = parseTransformString(transformAttr)\n\n  if (sx == null) {\n    return transform.scale\n  }\n\n  sy = sy == null ? sx : sy // eslint-disable-line\n\n  transformAttr = transform.raw\n  transformAttr = transformAttr.replace(/scale\\([^)]*\\)/g, '').trim()\n  const newScale = `scale(${sx},${sy})`\n  elem.setAttribute('transform', `${transformAttr} ${newScale}`.trim())\n}\n\nexport function translateAndAutoOrient(\n  elem: SVGElement,\n  position: Point.PointLike | Point.PointData,\n  reference: Point.PointLike | Point.PointData,\n  target?: SVGElement,\n) {\n  const pos = Point.create(position)\n  const ref = Point.create(reference)\n\n  if (!target) {\n    const svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement!\n    target = svg // eslint-disable-line\n  }\n\n  // Clean-up previously set transformations except the scale.\n  // If we didn't clean up the previous transformations then they'd\n  // add up with the old ones. Scale is an exception as it doesn't\n  // add up, consider: `this.scale(2).scale(2).scale(2)`. The result\n  // is that the element is scaled by the factor 2, not 8.\n  const s = scale(elem)\n  elem.setAttribute('transform', '')\n  const bbox = getBBox(elem, { target }).scale(s.sx, s.sy)\n\n  // 1. Translate to origin.\n  const translateToOrigin = createSVGTransform()\n  translateToOrigin.setTranslate(\n    -bbox.x - bbox.width / 2,\n    -bbox.y - bbox.height / 2,\n  )\n\n  // 2. Rotate around origin.\n  const rotateAroundOrigin = createSVGTransform()\n  const angle = pos.angleBetween(ref, pos.clone().translate(1, 0))\n  if (angle) rotateAroundOrigin.setRotate(angle, 0, 0)\n\n  // 3. Translate to the `position` + the offset (half my width)\n  //    towards the `reference` point.\n  const translateFromOrigin = createSVGTransform()\n  const finalPosition = pos.clone().move(ref, bbox.width / 2)\n  translateFromOrigin.setTranslate(\n    2 * pos.x - finalPosition.x,\n    2 * pos.y - finalPosition.y,\n  )\n\n  // 4. Get the current transformation matrix of this node\n  const ctm = getTransformToElement(elem, target)\n\n  // 5. Apply transformations and the scale\n  const transform = createSVGTransform()\n  transform.setMatrix(\n    translateFromOrigin.matrix.multiply(\n      rotateAroundOrigin.matrix.multiply(\n        translateToOrigin.matrix.multiply(ctm.scale(s.sx, s.sy)),\n      ),\n    ),\n  )\n\n  elem.setAttribute('transform', matrixToTransformString(transform.matrix))\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}