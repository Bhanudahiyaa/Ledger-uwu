{"ast":null,"code":"import { Point } from './point';\nimport { Rectangle } from './rectangle';\nimport { Line } from './line';\nimport { Geometry } from './geometry';\nexport class Polyline extends Geometry {\n  constructor(points) {\n    super();\n    if (points != null) {\n      if (typeof points === 'string') {\n        return Polyline.parse(points);\n      }\n      this.points = points.map(p => Point.create(p));\n    } else {\n      this.points = [];\n    }\n  }\n  get [Symbol.toStringTag]() {\n    return Polyline.toStringTag;\n  }\n  get start() {\n    if (this.points.length === 0) {\n      return null;\n    }\n    return this.points[0];\n  }\n  get end() {\n    if (this.points.length === 0) {\n      return null;\n    }\n    return this.points[this.points.length - 1];\n  }\n  scale(sx, sy, origin = new Point()) {\n    this.points.forEach(p => p.scale(sx, sy, origin));\n    return this;\n  }\n  rotate(angle, origin) {\n    this.points.forEach(p => p.rotate(angle, origin));\n    return this;\n  }\n  translate(dx, dy) {\n    const t = Point.create(dx, dy);\n    this.points.forEach(p => p.translate(t.x, t.y));\n    return this;\n  }\n  bbox() {\n    if (this.points.length === 0) {\n      return new Rectangle();\n    }\n    let x1 = Infinity;\n    let x2 = -Infinity;\n    let y1 = Infinity;\n    let y2 = -Infinity;\n    const points = this.points;\n    for (let i = 0, ii = points.length; i < ii; i += 1) {\n      const point = points[i];\n      const x = point.x;\n      const y = point.y;\n      if (x < x1) x1 = x;\n      if (x > x2) x2 = x;\n      if (y < y1) y1 = y;\n      if (y > y2) y2 = y;\n    }\n    return new Rectangle(x1, y1, x2 - x1, y2 - y1);\n  }\n  closestPoint(p) {\n    const cpLength = this.closestPointLength(p);\n    return this.pointAtLength(cpLength);\n  }\n  closestPointLength(p) {\n    const points = this.points;\n    const count = points.length;\n    if (count === 0 || count === 1) {\n      return 0;\n    }\n    let length = 0;\n    let cpLength = 0;\n    let minSqrDistance = Infinity;\n    for (let i = 0, ii = count - 1; i < ii; i += 1) {\n      const line = new Line(points[i], points[i + 1]);\n      const lineLength = line.length();\n      const cpNormalizedLength = line.closestPointNormalizedLength(p);\n      const cp = line.pointAt(cpNormalizedLength);\n      const sqrDistance = cp.squaredDistance(p);\n      if (sqrDistance < minSqrDistance) {\n        minSqrDistance = sqrDistance;\n        cpLength = length + cpNormalizedLength * lineLength;\n      }\n      length += lineLength;\n    }\n    return cpLength;\n  }\n  closestPointNormalizedLength(p) {\n    const cpLength = this.closestPointLength(p);\n    if (cpLength === 0) {\n      return 0;\n    }\n    const length = this.length();\n    if (length === 0) {\n      return 0;\n    }\n    return cpLength / length;\n  }\n  closestPointTangent(p) {\n    const cpLength = this.closestPointLength(p);\n    return this.tangentAtLength(cpLength);\n  }\n  containsPoint(p) {\n    if (this.points.length === 0) {\n      return false;\n    }\n    const ref = Point.clone(p);\n    const x = ref.x;\n    const y = ref.y;\n    const points = this.points;\n    const count = points.length;\n    let startIndex = count - 1;\n    let intersectionCount = 0;\n    for (let endIndex = 0; endIndex < count; endIndex += 1) {\n      const start = points[startIndex];\n      const end = points[endIndex];\n      if (ref.equals(start)) {\n        return true;\n      }\n      const segment = new Line(start, end);\n      if (segment.containsPoint(p)) {\n        return true;\n      }\n      // do we have an intersection?\n      if (y <= start.y && y > end.y || y > start.y && y <= end.y) {\n        // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`\n        // (when `y === start.y === end.y`)\n        // this conditional branch IS entered when `segment` touches `ray` at only one point\n        // (e.g. when `y === start.y !== end.y`)\n        // since this branch is entered again for the following segment, the two touches cancel out\n        const xDifference = start.x - x > end.x - x ? start.x - x : end.x - x;\n        if (xDifference >= 0) {\n          // segment lies at least partially to the right of `p`\n          const rayEnd = new Point(x + xDifference, y); // right\n          const ray = new Line(p, rayEnd);\n          if (segment.intersectsWithLine(ray)) {\n            // an intersection was detected to the right of `p`\n            intersectionCount += 1;\n          }\n        } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)\n      }\n      // move to check the next polyline segment\n      startIndex = endIndex;\n    }\n    // returns `true` for odd numbers of intersections (even-odd algorithm)\n    return intersectionCount % 2 === 1;\n  }\n  intersectsWithLine(line) {\n    const intersections = [];\n    for (let i = 0, n = this.points.length - 1; i < n; i += 1) {\n      const a = this.points[i];\n      const b = this.points[i + 1];\n      const int = line.intersectsWithLine(new Line(a, b));\n      if (int) {\n        intersections.push(int);\n      }\n    }\n    return intersections.length > 0 ? intersections : null;\n  }\n  isDifferentiable() {\n    for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {\n      const a = this.points[i];\n      const b = this.points[i + 1];\n      const line = new Line(a, b);\n      if (line.isDifferentiable()) {\n        return true;\n      }\n    }\n    return false;\n  }\n  length() {\n    let len = 0;\n    for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {\n      const a = this.points[i];\n      const b = this.points[i + 1];\n      len += a.distance(b);\n    }\n    return len;\n  }\n  pointAt(ratio) {\n    const points = this.points;\n    const count = points.length;\n    if (count === 0) {\n      return null;\n    }\n    if (count === 1) {\n      return points[0].clone();\n    }\n    if (ratio <= 0) {\n      return points[0].clone();\n    }\n    if (ratio >= 1) {\n      return points[count - 1].clone();\n    }\n    const total = this.length();\n    const length = total * ratio;\n    return this.pointAtLength(length);\n  }\n  pointAtLength(length) {\n    const points = this.points;\n    const count = points.length;\n    if (count === 0) {\n      return null;\n    }\n    if (count === 1) {\n      return points[0].clone();\n    }\n    let fromStart = true;\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n    let tmp = 0;\n    for (let i = 0, ii = count - 1; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i;\n      const a = points[index];\n      const b = points[index + 1];\n      const l = new Line(a, b);\n      const d = a.distance(b);\n      if (length <= tmp + d) {\n        return l.pointAtLength((fromStart ? 1 : -1) * (length - tmp));\n      }\n      tmp += d;\n    }\n    const lastPoint = fromStart ? points[count - 1] : points[0];\n    return lastPoint.clone();\n  }\n  tangentAt(ratio) {\n    const points = this.points;\n    const count = points.length;\n    if (count === 0 || count === 1) {\n      return null;\n    }\n    if (ratio < 0) {\n      ratio = 0; // eslint-disable-line\n    }\n    if (ratio > 1) {\n      ratio = 1; // eslint-disable-line\n    }\n    const total = this.length();\n    const length = total * ratio;\n    return this.tangentAtLength(length);\n  }\n  tangentAtLength(length) {\n    const points = this.points;\n    const count = points.length;\n    if (count === 0 || count === 1) {\n      return null;\n    }\n    let fromStart = true;\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n    let lastValidLine;\n    let tmp = 0;\n    for (let i = 0, ii = count - 1; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i;\n      const a = points[index];\n      const b = points[index + 1];\n      const l = new Line(a, b);\n      const d = a.distance(b);\n      if (l.isDifferentiable()) {\n        // has a tangent line (line length is not 0)\n        if (length <= tmp + d) {\n          return l.tangentAtLength((fromStart ? 1 : -1) * (length - tmp));\n        }\n        lastValidLine = l;\n      }\n      tmp += d;\n    }\n    if (lastValidLine) {\n      const ratio = fromStart ? 1 : 0;\n      return lastValidLine.tangentAt(ratio);\n    }\n    return null;\n  }\n  simplify(\n  // TODO: Accept startIndex and endIndex to specify where to start and end simplification\n  options = {}) {\n    const points = this.points;\n    // we need at least 3 points\n    if (points.length < 3) {\n      return this;\n    }\n    const threshold = options.threshold || 0;\n    // start at the beginning of the polyline and go forward\n    let currentIndex = 0;\n    // we need at least one intermediate point (3 points) in every iteration\n    // as soon as that stops being true, we know we reached the end of the polyline\n    while (points[currentIndex + 2]) {\n      const firstIndex = currentIndex;\n      const middleIndex = currentIndex + 1;\n      const lastIndex = currentIndex + 2;\n      const firstPoint = points[firstIndex];\n      const middlePoint = points[middleIndex];\n      const lastPoint = points[lastIndex];\n      const chord = new Line(firstPoint, lastPoint); // = connection between first and last point\n      const closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point\n      const closestPointDistance = closestPoint.distance(middlePoint);\n      if (closestPointDistance <= threshold) {\n        // middle point is close enough to the chord = simplify\n        // 1) remove middle point:\n        points.splice(middleIndex, 1);\n        // 2) in next iteration, investigate the newly-created triplet of points\n        //    - do not change `currentIndex`\n        //    = (first point stays, point after removed point becomes middle point)\n      } else {\n        // middle point is far from the chord\n        // 1) preserve middle point\n        // 2) in next iteration, move `currentIndex` by one step:\n        currentIndex += 1;\n        //    = (point after first point becomes first point)\n      }\n    }\n    // `points` array was modified in-place\n    return this;\n  }\n  toHull() {\n    const points = this.points;\n    const count = points.length;\n    if (count === 0) {\n      return new Polyline();\n    }\n    // Step 1: find the starting point -- point with\n    // the lowest y (if equality, highest x).\n    let startPoint = points[0];\n    for (let i = 1; i < count; i += 1) {\n      if (points[i].y < startPoint.y) {\n        startPoint = points[i];\n      } else if (points[i].y === startPoint.y && points[i].x > startPoint.x) {\n        startPoint = points[i];\n      }\n    }\n    // Step 2: sort the list of points by angle between line\n    // from start point to current point and the x-axis (theta).\n    // Step 2a: create the point records = [point, originalIndex, angle]\n    const sortedRecords = [];\n    for (let i = 0; i < count; i += 1) {\n      let angle = startPoint.theta(points[i]);\n      if (angle === 0) {\n        // Give highest angle to start point.\n        // The start point will end up at end of sorted list.\n        // The start point will end up at beginning of hull points list.\n        angle = 360;\n      }\n      sortedRecords.push([points[i], i, angle]);\n    }\n    // Step 2b: sort the list in place\n    sortedRecords.sort((record1, record2) => {\n      let ret = record1[2] - record2[2];\n      if (ret === 0) {\n        ret = record2[1] - record1[1];\n      }\n      return ret;\n    });\n    // Step 2c: duplicate start record from the top of\n    // the stack to the bottom of the stack.\n    if (sortedRecords.length > 2) {\n      const startPoint = sortedRecords[sortedRecords.length - 1];\n      sortedRecords.unshift(startPoint);\n    }\n    // Step 3\n    // ------\n    // Step 3a: go through sorted points in order and find those with\n    // right turns, and we want to get our results in clockwise order.\n    // Dictionary of points with left turns - cannot be on the hull.\n    const insidePoints = {};\n    // Stack of records with right turns - hull point candidates.\n    const hullRecords = [];\n    const getKey = record => `${record[0].toString()}@${record[1]}`;\n    while (sortedRecords.length !== 0) {\n      const currentRecord = sortedRecords.pop();\n      const currentPoint = currentRecord[0];\n      // Check if point has already been discarded.\n      if (insidePoints[getKey(currentRecord)]) {\n        continue;\n      }\n      let correctTurnFound = false;\n      while (!correctTurnFound) {\n        if (hullRecords.length < 2) {\n          // Not enough points for comparison, just add current point.\n          hullRecords.push(currentRecord);\n          correctTurnFound = true;\n        } else {\n          const lastHullRecord = hullRecords.pop();\n          const lastHullPoint = lastHullRecord[0];\n          const secondLastHullRecord = hullRecords.pop();\n          const secondLastHullPoint = secondLastHullRecord[0];\n          const crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);\n          if (crossProduct < 0) {\n            // Found a right turn.\n            hullRecords.push(secondLastHullRecord);\n            hullRecords.push(lastHullRecord);\n            hullRecords.push(currentRecord);\n            correctTurnFound = true;\n          } else if (crossProduct === 0) {\n            // the three points are collinear\n            // three options:\n            // there may be a 180 or 0 degree angle at lastHullPoint\n            // or two of the three points are coincident\n            // we have to take rounding errors into account\n            const THRESHOLD = 1e-10;\n            const angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);\n            if (Math.abs(angleBetween - 180) < THRESHOLD) {\n              // rouding around 180 to 180\n              // if the cross product is 0 because the angle is 180 degrees\n              // discard last hull point (add to insidePoints)\n              // insidePoints.unshift(lastHullPoint);\n              insidePoints[getKey(lastHullRecord)] = lastHullPoint;\n              // reenter second-to-last hull point (will be last at next iter)\n              hullRecords.push(secondLastHullRecord);\n              // do not do anything with current point\n              // correct turn not found\n            } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {\n              // if the cross product is 0 because two points are the same\n              // discard last hull point (add to insidePoints)\n              // insidePoints.unshift(lastHullPoint);\n              insidePoints[getKey(lastHullRecord)] = lastHullPoint;\n              // reenter second-to-last hull point (will be last at next iter)\n              hullRecords.push(secondLastHullRecord);\n              // do not do anything with current point\n              // correct turn not found\n            } else if (Math.abs((angleBetween + 1) % 360 - 1) < THRESHOLD) {\n              // rounding around 0 and 360 to 0\n              // if the cross product is 0 because the angle is 0 degrees\n              // remove last hull point from hull BUT do not discard it\n              // reenter second-to-last hull point (will be last at next iter)\n              hullRecords.push(secondLastHullRecord);\n              // put last hull point back into the sorted point records list\n              sortedRecords.push(lastHullRecord);\n              // we are switching the order of the 0deg and 180deg points\n              // correct turn not found\n            }\n          } else {\n            // found a left turn\n            // discard last hull point (add to insidePoints)\n            // insidePoints.unshift(lastHullPoint);\n            insidePoints[getKey(lastHullRecord)] = lastHullPoint;\n            // reenter second-to-last hull point (will be last at next iter of loop)\n            hullRecords.push(secondLastHullRecord);\n            // do not do anything with current point\n            // correct turn not found\n          }\n        }\n      }\n    }\n    // At this point, hullPointRecords contains the output points in clockwise order\n    // the points start with lowest-y,highest-x startPoint, and end at the same point\n    // Step 3b: remove duplicated startPointRecord from the end of the array\n    if (hullRecords.length > 2) {\n      hullRecords.pop();\n    }\n    // Step 4: find the lowest originalIndex record and put it at the beginning of hull\n    let lowestHullIndex; // the lowest originalIndex on the hull\n    let indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex\n    for (let i = 0, n = hullRecords.length; i < n; i += 1) {\n      const currentHullIndex = hullRecords[i][1];\n      if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {\n        lowestHullIndex = currentHullIndex;\n        indexOfLowestHullIndexRecord = i;\n      }\n    }\n    let hullPointRecordsReordered = [];\n    if (indexOfLowestHullIndexRecord > 0) {\n      const newFirstChunk = hullRecords.slice(indexOfLowestHullIndexRecord);\n      const newSecondChunk = hullRecords.slice(0, indexOfLowestHullIndexRecord);\n      hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);\n    } else {\n      hullPointRecordsReordered = hullRecords;\n    }\n    const hullPoints = [];\n    for (let i = 0, n = hullPointRecordsReordered.length; i < n; i += 1) {\n      hullPoints.push(hullPointRecordsReordered[i][0]);\n    }\n    return new Polyline(hullPoints);\n  }\n  equals(p) {\n    if (p == null) {\n      return false;\n    }\n    if (p.points.length !== this.points.length) {\n      return false;\n    }\n    return p.points.every((a, i) => a.equals(this.points[i]));\n  }\n  clone() {\n    return new Polyline(this.points.map(p => p.clone()));\n  }\n  toJSON() {\n    return this.points.map(p => p.toJSON());\n  }\n  serialize() {\n    return this.points.map(p => `${p.x}, ${p.y}`).join(' ');\n  }\n}\n(function (Polyline) {\n  Polyline.toStringTag = `X6.Geometry.${Polyline.name}`;\n  function isPolyline(instance) {\n    if (instance == null) {\n      return false;\n    }\n    if (instance instanceof Polyline) {\n      return true;\n    }\n    const tag = instance[Symbol.toStringTag];\n    const polyline = instance;\n    if ((tag == null || tag === Polyline.toStringTag) && typeof polyline.toHull === 'function' && typeof polyline.simplify === 'function') {\n      return true;\n    }\n    return false;\n  }\n  Polyline.isPolyline = isPolyline;\n})(Polyline || (Polyline = {}));\n(function (Polyline) {\n  function parse(svgString) {\n    const str = svgString.trim();\n    if (str === '') {\n      return new Polyline();\n    }\n    const points = [];\n    const coords = str.split(/\\s*,\\s*|\\s+/);\n    for (let i = 0, ii = coords.length; i < ii; i += 2) {\n      points.push({\n        x: +coords[i],\n        y: +coords[i + 1]\n      });\n    }\n    return new Polyline(points);\n  }\n  Polyline.parse = parse;\n})(Polyline || (Polyline = {}));","map":{"version":3,"names":["Point","Rectangle","Line","Geometry","Polyline","constructor","points","parse","map","p","create","Symbol","toStringTag","start","length","end","scale","sx","sy","origin","forEach","rotate","angle","translate","dx","dy","t","x","y","bbox","x1","Infinity","x2","y1","y2","i","ii","point","closestPoint","cpLength","closestPointLength","pointAtLength","count","minSqrDistance","line","lineLength","cpNormalizedLength","closestPointNormalizedLength","cp","pointAt","sqrDistance","squaredDistance","closestPointTangent","tangentAtLength","containsPoint","ref","clone","startIndex","intersectionCount","endIndex","equals","segment","xDifference","rayEnd","ray","intersectsWithLine","intersections","n","a","b","int","push","isDifferentiable","len","distance","ratio","total","fromStart","tmp","index","l","d","lastPoint","tangentAt","lastValidLine","simplify","options","threshold","currentIndex","firstIndex","middleIndex","lastIndex","firstPoint","middlePoint","chord","closestPointDistance","splice","toHull","startPoint","sortedRecords","theta","sort","record1","record2","ret","unshift","insidePoints","hullRecords","getKey","record","toString","currentRecord","pop","currentPoint","correctTurnFound","lastHullRecord","lastHullPoint","secondLastHullRecord","secondLastHullPoint","crossProduct","cross","THRESHOLD","angleBetween","Math","abs","lowestHullIndex","indexOfLowestHullIndexRecord","currentHullIndex","undefined","hullPointRecordsReordered","newFirstChunk","slice","newSecondChunk","concat","hullPoints","every","toJSON","serialize","join","name","isPolyline","instance","tag","polyline","svgString","str","trim","coords","split"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/geometry/polyline.ts"],"sourcesContent":["import { Point } from './point'\nimport { Rectangle } from './rectangle'\nimport { Line } from './line'\nimport { Geometry } from './geometry'\n\nexport class Polyline extends Geometry {\n  points: Point[]\n\n  protected get [Symbol.toStringTag]() {\n    return Polyline.toStringTag\n  }\n\n  get start() {\n    if (this.points.length === 0) {\n      return null\n    }\n    return this.points[0]\n  }\n\n  get end() {\n    if (this.points.length === 0) {\n      return null\n    }\n    return this.points[this.points.length - 1]\n  }\n\n  constructor(points?: (Point.PointLike | Point.PointData)[] | string) {\n    super()\n    if (points != null) {\n      if (typeof points === 'string') {\n        return Polyline.parse(points)\n      }\n      this.points = points.map((p) => Point.create(p))\n    } else {\n      this.points = []\n    }\n  }\n\n  scale(\n    sx: number,\n    sy: number,\n    origin: Point.PointLike | Point.PointData = new Point(),\n  ) {\n    this.points.forEach((p) => p.scale(sx, sy, origin))\n    return this\n  }\n\n  rotate(angle: number, origin?: Point.PointLike | Point.PointData) {\n    this.points.forEach((p) => p.rotate(angle, origin))\n    return this\n  }\n\n  translate(dx: number, dy: number): this\n  translate(p: Point.PointLike | Point.PointData): this\n  translate(dx: number | Point.PointLike | Point.PointData, dy?: number): this {\n    const t = Point.create(dx, dy)\n    this.points.forEach((p) => p.translate(t.x, t.y))\n    return this\n  }\n\n  bbox() {\n    if (this.points.length === 0) {\n      return new Rectangle()\n    }\n\n    let x1 = Infinity\n    let x2 = -Infinity\n    let y1 = Infinity\n    let y2 = -Infinity\n\n    const points = this.points\n    for (let i = 0, ii = points.length; i < ii; i += 1) {\n      const point = points[i]\n      const x = point.x\n      const y = point.y\n\n      if (x < x1) x1 = x\n      if (x > x2) x2 = x\n      if (y < y1) y1 = y\n      if (y > y2) y2 = y\n    }\n\n    return new Rectangle(x1, y1, x2 - x1, y2 - y1)\n  }\n\n  closestPoint(p: Point.PointLike | Point.PointData) {\n    const cpLength = this.closestPointLength(p)\n    return this.pointAtLength(cpLength)\n  }\n\n  closestPointLength(p: Point.PointLike | Point.PointData) {\n    const points = this.points\n    const count = points.length\n    if (count === 0 || count === 1) {\n      return 0\n    }\n\n    let length = 0\n    let cpLength = 0\n    let minSqrDistance = Infinity\n    for (let i = 0, ii = count - 1; i < ii; i += 1) {\n      const line = new Line(points[i], points[i + 1])\n      const lineLength = line.length()\n      const cpNormalizedLength = line.closestPointNormalizedLength(p)\n      const cp = line.pointAt(cpNormalizedLength)\n\n      const sqrDistance = cp.squaredDistance(p)\n      if (sqrDistance < minSqrDistance) {\n        minSqrDistance = sqrDistance\n        cpLength = length + cpNormalizedLength * lineLength\n      }\n\n      length += lineLength\n    }\n\n    return cpLength\n  }\n\n  closestPointNormalizedLength(p: Point.PointLike | Point.PointData) {\n    const cpLength = this.closestPointLength(p)\n    if (cpLength === 0) {\n      return 0\n    }\n\n    const length = this.length()\n    if (length === 0) {\n      return 0\n    }\n\n    return cpLength / length\n  }\n\n  closestPointTangent(p: Point.PointLike | Point.PointData) {\n    const cpLength = this.closestPointLength(p)\n    return this.tangentAtLength(cpLength)\n  }\n\n  containsPoint(p: Point.PointLike | Point.PointData) {\n    if (this.points.length === 0) {\n      return false\n    }\n\n    const ref = Point.clone(p)\n    const x = ref.x\n    const y = ref.y\n    const points = this.points\n    const count = points.length\n\n    let startIndex = count - 1\n    let intersectionCount = 0\n    for (let endIndex = 0; endIndex < count; endIndex += 1) {\n      const start = points[startIndex]\n      const end = points[endIndex]\n      if (ref.equals(start)) {\n        return true\n      }\n\n      const segment = new Line(start, end)\n      if (segment.containsPoint(p)) {\n        return true\n      }\n\n      // do we have an intersection?\n      if ((y <= start.y && y > end.y) || (y > start.y && y <= end.y)) {\n        // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`\n        // (when `y === start.y === end.y`)\n        // this conditional branch IS entered when `segment` touches `ray` at only one point\n        // (e.g. when `y === start.y !== end.y`)\n        // since this branch is entered again for the following segment, the two touches cancel out\n\n        const xDifference = start.x - x > end.x - x ? start.x - x : end.x - x\n        if (xDifference >= 0) {\n          // segment lies at least partially to the right of `p`\n          const rayEnd = new Point(x + xDifference, y) // right\n          const ray = new Line(p, rayEnd)\n\n          if (segment.intersectsWithLine(ray)) {\n            // an intersection was detected to the right of `p`\n            intersectionCount += 1\n          }\n        } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)\n      }\n\n      // move to check the next polyline segment\n      startIndex = endIndex\n    }\n\n    // returns `true` for odd numbers of intersections (even-odd algorithm)\n    return intersectionCount % 2 === 1\n  }\n\n  intersectsWithLine(line: Line) {\n    const intersections = []\n    for (let i = 0, n = this.points.length - 1; i < n; i += 1) {\n      const a = this.points[i]\n      const b = this.points[i + 1]\n      const int = line.intersectsWithLine(new Line(a, b))\n      if (int) {\n        intersections.push(int)\n      }\n    }\n    return intersections.length > 0 ? intersections : null\n  }\n\n  isDifferentiable() {\n    for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {\n      const a = this.points[i]\n      const b = this.points[i + 1]\n      const line = new Line(a, b)\n      if (line.isDifferentiable()) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  length() {\n    let len = 0\n    for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {\n      const a = this.points[i]\n      const b = this.points[i + 1]\n      len += a.distance(b)\n    }\n    return len\n  }\n\n  pointAt(ratio: number) {\n    const points = this.points\n    const count = points.length\n    if (count === 0) {\n      return null\n    }\n\n    if (count === 1) {\n      return points[0].clone()\n    }\n\n    if (ratio <= 0) {\n      return points[0].clone()\n    }\n\n    if (ratio >= 1) {\n      return points[count - 1].clone()\n    }\n\n    const total = this.length()\n    const length = total * ratio\n    return this.pointAtLength(length)\n  }\n\n  pointAtLength(length: number) {\n    const points = this.points\n    const count = points.length\n    if (count === 0) {\n      return null\n    }\n\n    if (count === 1) {\n      return points[0].clone()\n    }\n\n    let fromStart = true\n    if (length < 0) {\n      fromStart = false\n      length = -length // eslint-disable-line\n    }\n\n    let tmp = 0\n    for (let i = 0, ii = count - 1; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i\n      const a = points[index]\n      const b = points[index + 1]\n      const l = new Line(a, b)\n      const d = a.distance(b)\n\n      if (length <= tmp + d) {\n        return l.pointAtLength((fromStart ? 1 : -1) * (length - tmp))\n      }\n\n      tmp += d\n    }\n\n    const lastPoint = fromStart ? points[count - 1] : points[0]\n    return lastPoint.clone()\n  }\n\n  tangentAt(ratio: number) {\n    const points = this.points\n    const count = points.length\n    if (count === 0 || count === 1) {\n      return null\n    }\n\n    if (ratio < 0) {\n      ratio = 0 // eslint-disable-line\n    }\n\n    if (ratio > 1) {\n      ratio = 1 // eslint-disable-line\n    }\n\n    const total = this.length()\n    const length = total * ratio\n\n    return this.tangentAtLength(length)\n  }\n\n  tangentAtLength(length: number) {\n    const points = this.points\n    const count = points.length\n    if (count === 0 || count === 1) {\n      return null\n    }\n\n    let fromStart = true\n    if (length < 0) {\n      fromStart = false\n      length = -length // eslint-disable-line\n    }\n\n    let lastValidLine\n    let tmp = 0\n    for (let i = 0, ii = count - 1; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i\n      const a = points[index]\n      const b = points[index + 1]\n      const l = new Line(a, b)\n      const d = a.distance(b)\n\n      if (l.isDifferentiable()) {\n        // has a tangent line (line length is not 0)\n        if (length <= tmp + d) {\n          return l.tangentAtLength((fromStart ? 1 : -1) * (length - tmp))\n        }\n\n        lastValidLine = l\n      }\n\n      tmp += d\n    }\n\n    if (lastValidLine) {\n      const ratio = fromStart ? 1 : 0\n      return lastValidLine.tangentAt(ratio)\n    }\n\n    return null\n  }\n\n  simplify(\n    // TODO: Accept startIndex and endIndex to specify where to start and end simplification\n    options: {\n      /**\n       * The max distance of middle point from chord to be simplified.\n       */\n      threshold?: number\n    } = {},\n  ) {\n    const points = this.points\n    // we need at least 3 points\n    if (points.length < 3) {\n      return this\n    }\n\n    const threshold = options.threshold || 0\n\n    // start at the beginning of the polyline and go forward\n    let currentIndex = 0\n    // we need at least one intermediate point (3 points) in every iteration\n    // as soon as that stops being true, we know we reached the end of the polyline\n    while (points[currentIndex + 2]) {\n      const firstIndex = currentIndex\n      const middleIndex = currentIndex + 1\n      const lastIndex = currentIndex + 2\n\n      const firstPoint = points[firstIndex]\n      const middlePoint = points[middleIndex]\n      const lastPoint = points[lastIndex]\n\n      const chord = new Line(firstPoint, lastPoint) // = connection between first and last point\n      const closestPoint = chord.closestPoint(middlePoint) // = closest point on chord from middle point\n      const closestPointDistance = closestPoint.distance(middlePoint)\n      if (closestPointDistance <= threshold) {\n        // middle point is close enough to the chord = simplify\n        // 1) remove middle point:\n        points.splice(middleIndex, 1)\n        // 2) in next iteration, investigate the newly-created triplet of points\n        //    - do not change `currentIndex`\n        //    = (first point stays, point after removed point becomes middle point)\n      } else {\n        // middle point is far from the chord\n        // 1) preserve middle point\n        // 2) in next iteration, move `currentIndex` by one step:\n        currentIndex += 1\n        //    = (point after first point becomes first point)\n      }\n    }\n\n    // `points` array was modified in-place\n    return this\n  }\n\n  toHull() {\n    const points = this.points\n    const count = points.length\n    if (count === 0) {\n      return new Polyline()\n    }\n\n    // Step 1: find the starting point -- point with\n    // the lowest y (if equality, highest x).\n    let startPoint: Point = points[0]\n    for (let i = 1; i < count; i += 1) {\n      if (points[i].y < startPoint.y) {\n        startPoint = points[i]\n      } else if (points[i].y === startPoint.y && points[i].x > startPoint.x) {\n        startPoint = points[i]\n      }\n    }\n\n    // Step 2: sort the list of points by angle between line\n    // from start point to current point and the x-axis (theta).\n\n    // Step 2a: create the point records = [point, originalIndex, angle]\n    const sortedRecords: Types.HullRecord[] = []\n    for (let i = 0; i < count; i += 1) {\n      let angle = startPoint.theta(points[i])\n      if (angle === 0) {\n        // Give highest angle to start point.\n        // The start point will end up at end of sorted list.\n        // The start point will end up at beginning of hull points list.\n        angle = 360\n      }\n\n      sortedRecords.push([points[i], i, angle])\n    }\n\n    // Step 2b: sort the list in place\n    sortedRecords.sort((record1, record2) => {\n      let ret = record1[2] - record2[2]\n      if (ret === 0) {\n        ret = record2[1] - record1[1]\n      }\n\n      return ret\n    })\n\n    // Step 2c: duplicate start record from the top of\n    // the stack to the bottom of the stack.\n    if (sortedRecords.length > 2) {\n      const startPoint = sortedRecords[sortedRecords.length - 1]\n      sortedRecords.unshift(startPoint)\n    }\n\n    // Step 3\n    // ------\n\n    // Step 3a: go through sorted points in order and find those with\n    // right turns, and we want to get our results in clockwise order.\n\n    // Dictionary of points with left turns - cannot be on the hull.\n    const insidePoints: { [key: string]: Point } = {}\n    // Stack of records with right turns - hull point candidates.\n    const hullRecords: Types.HullRecord[] = []\n    const getKey = (record: Types.HullRecord) =>\n      `${record[0].toString()}@${record[1]}`\n\n    while (sortedRecords.length !== 0) {\n      const currentRecord = sortedRecords.pop()!\n      const currentPoint = currentRecord[0]\n\n      // Check if point has already been discarded.\n      if (insidePoints[getKey(currentRecord)]) {\n        continue\n      }\n\n      let correctTurnFound = false\n      while (!correctTurnFound) {\n        if (hullRecords.length < 2) {\n          // Not enough points for comparison, just add current point.\n          hullRecords.push(currentRecord)\n          correctTurnFound = true\n        } else {\n          const lastHullRecord = hullRecords.pop()!\n          const lastHullPoint = lastHullRecord[0]\n          const secondLastHullRecord = hullRecords.pop()!\n          const secondLastHullPoint = secondLastHullRecord[0]\n\n          const crossProduct = secondLastHullPoint.cross(\n            lastHullPoint,\n            currentPoint,\n          )\n\n          if (crossProduct < 0) {\n            // Found a right turn.\n            hullRecords.push(secondLastHullRecord)\n            hullRecords.push(lastHullRecord)\n            hullRecords.push(currentRecord)\n            correctTurnFound = true\n          } else if (crossProduct === 0) {\n            // the three points are collinear\n            // three options:\n            // there may be a 180 or 0 degree angle at lastHullPoint\n            // or two of the three points are coincident\n\n            // we have to take rounding errors into account\n            const THRESHOLD = 1e-10\n            const angleBetween = lastHullPoint.angleBetween(\n              secondLastHullPoint,\n              currentPoint,\n            )\n\n            if (Math.abs(angleBetween - 180) < THRESHOLD) {\n              // rouding around 180 to 180\n              // if the cross product is 0 because the angle is 180 degrees\n              // discard last hull point (add to insidePoints)\n              // insidePoints.unshift(lastHullPoint);\n              insidePoints[getKey(lastHullRecord)] = lastHullPoint\n              // reenter second-to-last hull point (will be last at next iter)\n              hullRecords.push(secondLastHullRecord)\n              // do not do anything with current point\n              // correct turn not found\n            } else if (\n              lastHullPoint.equals(currentPoint) ||\n              secondLastHullPoint.equals(lastHullPoint)\n            ) {\n              // if the cross product is 0 because two points are the same\n              // discard last hull point (add to insidePoints)\n              // insidePoints.unshift(lastHullPoint);\n              insidePoints[getKey(lastHullRecord)] = lastHullPoint\n              // reenter second-to-last hull point (will be last at next iter)\n              hullRecords.push(secondLastHullRecord)\n              // do not do anything with current point\n              // correct turn not found\n            } else if (Math.abs(((angleBetween + 1) % 360) - 1) < THRESHOLD) {\n              // rounding around 0 and 360 to 0\n              // if the cross product is 0 because the angle is 0 degrees\n              // remove last hull point from hull BUT do not discard it\n              // reenter second-to-last hull point (will be last at next iter)\n              hullRecords.push(secondLastHullRecord)\n              // put last hull point back into the sorted point records list\n              sortedRecords.push(lastHullRecord)\n              // we are switching the order of the 0deg and 180deg points\n              // correct turn not found\n            }\n          } else {\n            // found a left turn\n            // discard last hull point (add to insidePoints)\n            // insidePoints.unshift(lastHullPoint);\n            insidePoints[getKey(lastHullRecord)] = lastHullPoint\n            // reenter second-to-last hull point (will be last at next iter of loop)\n            hullRecords.push(secondLastHullRecord)\n            // do not do anything with current point\n            // correct turn not found\n          }\n        }\n      }\n    }\n\n    // At this point, hullPointRecords contains the output points in clockwise order\n    // the points start with lowest-y,highest-x startPoint, and end at the same point\n\n    // Step 3b: remove duplicated startPointRecord from the end of the array\n    if (hullRecords.length > 2) {\n      hullRecords.pop()\n    }\n\n    // Step 4: find the lowest originalIndex record and put it at the beginning of hull\n    let lowestHullIndex // the lowest originalIndex on the hull\n    let indexOfLowestHullIndexRecord = -1 // the index of the record with lowestHullIndex\n    for (let i = 0, n = hullRecords.length; i < n; i += 1) {\n      const currentHullIndex = hullRecords[i][1]\n\n      if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {\n        lowestHullIndex = currentHullIndex\n        indexOfLowestHullIndexRecord = i\n      }\n    }\n\n    let hullPointRecordsReordered = []\n    if (indexOfLowestHullIndexRecord > 0) {\n      const newFirstChunk = hullRecords.slice(indexOfLowestHullIndexRecord)\n      const newSecondChunk = hullRecords.slice(0, indexOfLowestHullIndexRecord)\n      hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk)\n    } else {\n      hullPointRecordsReordered = hullRecords\n    }\n\n    const hullPoints = []\n    for (let i = 0, n = hullPointRecordsReordered.length; i < n; i += 1) {\n      hullPoints.push(hullPointRecordsReordered[i][0])\n    }\n\n    return new Polyline(hullPoints)\n  }\n\n  equals(p: Polyline) {\n    if (p == null) {\n      return false\n    }\n\n    if (p.points.length !== this.points.length) {\n      return false\n    }\n\n    return p.points.every((a, i) => a.equals(this.points[i]))\n  }\n\n  clone() {\n    return new Polyline(this.points.map((p) => p.clone()))\n  }\n\n  toJSON() {\n    return this.points.map((p) => p.toJSON())\n  }\n\n  serialize() {\n    return this.points.map((p) => `${p.x}, ${p.y}`).join(' ')\n  }\n}\n\nexport namespace Polyline {\n  export const toStringTag = `X6.Geometry.${Polyline.name}`\n\n  export function isPolyline(instance: any): instance is Polyline {\n    if (instance == null) {\n      return false\n    }\n\n    if (instance instanceof Polyline) {\n      return true\n    }\n\n    const tag = instance[Symbol.toStringTag]\n    const polyline = instance as Polyline\n\n    if (\n      (tag == null || tag === toStringTag) &&\n      typeof polyline.toHull === 'function' &&\n      typeof polyline.simplify === 'function'\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n\nexport namespace Polyline {\n  export function parse(svgString: string) {\n    const str = svgString.trim()\n    if (str === '') {\n      return new Polyline()\n    }\n\n    const points = []\n\n    const coords = str.split(/\\s*,\\s*|\\s+/)\n    for (let i = 0, ii = coords.length; i < ii; i += 2) {\n      points.push({ x: +coords[i], y: +coords[i + 1] })\n    }\n\n    return new Polyline(points)\n  }\n}\n\nnamespace Types {\n  export type HullRecord = [Point, number, number]\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}