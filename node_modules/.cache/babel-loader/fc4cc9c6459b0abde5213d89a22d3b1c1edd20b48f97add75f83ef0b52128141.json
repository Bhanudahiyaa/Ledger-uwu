{"ast":null,"code":"// src/lineAtOffset/greatCircle.ts\nimport { degreesToRadians, radiansToDegrees } from \"@turf/helpers\";\nfunction greatCircleLineAtOffset(source, target, offset, thetaOffset, segmentNumber = 30, autoFit) {\n  let pointOffset = offset;\n  if (autoFit) {\n    pointOffset = Math.round(offset * 29) / 29;\n  }\n  return interpolate(source, target, pointOffset);\n}\nfunction getAngularDist(source, target) {\n  const delta = [source[0] - target[0], source[1] - target[1]];\n  const sinHalfDelta = [Math.sin(delta[0] / 2), Math.sin(delta[1] / 2)];\n  const a = sinHalfDelta[1] * sinHalfDelta[1] + Math.cos(source[1]) * Math.cos(target[1]) * sinHalfDelta[0] * sinHalfDelta[0];\n  return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n}\nfunction interpolate(s, t, offset) {\n  const source = [degreesToRadians(s[0]), degreesToRadians(s[1])];\n  const target = [degreesToRadians(t[0]), degreesToRadians(t[1])];\n  const angularDist = getAngularDist(source, target);\n  if (Math.abs(angularDist - Math.PI) < 1e-3) {\n    return [(1 - offset) * source[0] + offset * target[0], (1 - offset) * source[1] + offset * target[1]];\n  }\n  const a = Math.sin((1 - offset) * angularDist) / Math.sin(angularDist);\n  const b = Math.sin(offset * angularDist) / Math.sin(angularDist);\n  const sinSource = [Math.sin(source[0]), Math.sin(source[1])];\n  const cosSource = [Math.cos(source[0]), Math.cos(source[1])];\n  const sinTarget = [Math.sin(target[0]), Math.sin(target[1])];\n  const cosTarget = [Math.cos(target[0]), Math.cos(target[1])];\n  const x = a * cosSource[1] * cosSource[0] + b * cosTarget[1] * cosTarget[0];\n  const y = a * cosSource[1] * sinSource[0] + b * cosTarget[1] * sinTarget[0];\n  const z = a * sinSource[1] + b * sinTarget[1];\n  return [radiansToDegrees(Math.atan2(y, x)), radiansToDegrees(Math.atan2(z, Math.sqrt(x * x + y * y)))];\n}\nexport { greatCircleLineAtOffset, interpolate };","map":{"version":3,"names":["degreesToRadians","radiansToDegrees","greatCircleLineAtOffset","source","target","offset","thetaOffset","segmentNumber","autoFit","pointOffset","Math","round","interpolate","getAngularDist","delta","sinHalfDelta","sin","a","cos","atan2","sqrt","s","t","angularDist","abs","PI","b","sinSource","cosSource","sinTarget","cosTarget","x","y","z"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/l7-utils/es/lineAtOffset/greatCircle.js"],"sourcesContent":["// src/lineAtOffset/greatCircle.ts\nimport { degreesToRadians, radiansToDegrees } from \"@turf/helpers\";\nfunction greatCircleLineAtOffset(source, target, offset, thetaOffset, segmentNumber = 30, autoFit) {\n  let pointOffset = offset;\n  if (autoFit) {\n    pointOffset = Math.round(offset * 29) / 29;\n  }\n  return interpolate(source, target, pointOffset);\n}\nfunction getAngularDist(source, target) {\n  const delta = [source[0] - target[0], source[1] - target[1]];\n  const sinHalfDelta = [Math.sin(delta[0] / 2), Math.sin(delta[1] / 2)];\n  const a = sinHalfDelta[1] * sinHalfDelta[1] + Math.cos(source[1]) * Math.cos(target[1]) * sinHalfDelta[0] * sinHalfDelta[0];\n  return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n}\nfunction interpolate(s, t, offset) {\n  const source = [degreesToRadians(s[0]), degreesToRadians(s[1])];\n  const target = [degreesToRadians(t[0]), degreesToRadians(t[1])];\n  const angularDist = getAngularDist(source, target);\n  if (Math.abs(angularDist - Math.PI) < 1e-3) {\n    return [\n      (1 - offset) * source[0] + offset * target[0],\n      (1 - offset) * source[1] + offset * target[1]\n    ];\n  }\n  const a = Math.sin((1 - offset) * angularDist) / Math.sin(angularDist);\n  const b = Math.sin(offset * angularDist) / Math.sin(angularDist);\n  const sinSource = [Math.sin(source[0]), Math.sin(source[1])];\n  const cosSource = [Math.cos(source[0]), Math.cos(source[1])];\n  const sinTarget = [Math.sin(target[0]), Math.sin(target[1])];\n  const cosTarget = [Math.cos(target[0]), Math.cos(target[1])];\n  const x = a * cosSource[1] * cosSource[0] + b * cosTarget[1] * cosTarget[0];\n  const y = a * cosSource[1] * sinSource[0] + b * cosTarget[1] * sinTarget[0];\n  const z = a * sinSource[1] + b * sinTarget[1];\n  return [\n    radiansToDegrees(Math.atan2(y, x)),\n    radiansToDegrees(Math.atan2(z, Math.sqrt(x * x + y * y)))\n  ];\n}\nexport {\n  greatCircleLineAtOffset,\n  interpolate\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}