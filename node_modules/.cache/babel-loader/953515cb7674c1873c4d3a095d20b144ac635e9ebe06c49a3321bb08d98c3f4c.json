{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _dec, _class;\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nimport { generateAABBFromVertices } from '@antv/g-webgpu-core';\nimport { injectable } from 'inversify';\nimport { Geometry } from '.';\nexport var\n/**\n * borrow from playcanvas\n */\nPlane = (_dec = injectable(), _dec(_class = /*#__PURE__*/function (_Geometry) {\n  _inherits(Plane, _Geometry);\n  var _super = _createSuper(Plane);\n  function Plane() {\n    _classCallCheck(this, Plane);\n    return _super.apply(this, arguments);\n  }\n  _createClass(Plane, [{\n    key: \"onEntityCreated\",\n    value: function onEntityCreated() {\n      var _this$config = this.config,\n        _this$config$halfExte = _this$config.halfExtents,\n        halfExtents = _this$config$halfExte === void 0 ? [0.5, 0.5] : _this$config$halfExte,\n        _this$config$widthSeg = _this$config.widthSegments,\n        widthSegments = _this$config$widthSeg === void 0 ? 5 : _this$config$widthSeg,\n        _this$config$lengthSe = _this$config.lengthSegments,\n        lengthSegments = _this$config$lengthSe === void 0 ? 5 : _this$config$lengthSe;\n      var positions = [];\n      var normals = [];\n      var uvs = [];\n      var indices = [];\n      var vcounter = 0;\n      for (var i = 0; i <= widthSegments; i++) {\n        for (var j = 0; j <= lengthSegments; j++) {\n          var x = -halfExtents[0] + 2.0 * halfExtents[0] * i / widthSegments;\n          var y = 0.0;\n          var z = -(-halfExtents[1] + 2.0 * halfExtents[1] * j / lengthSegments);\n          var u = i / widthSegments;\n          var v = j / lengthSegments;\n          positions.push(x, y, z);\n          normals.push(0.0, 1.0, 0.0);\n          uvs.push(u, v);\n          if (i < widthSegments && j < lengthSegments) {\n            indices.push(vcounter + lengthSegments + 1, vcounter + 1, vcounter);\n            indices.push(vcounter + lengthSegments + 1, vcounter + lengthSegments + 2, vcounter + 1);\n          }\n          vcounter++;\n        }\n      } // generate AABB\n\n      var aabb = generateAABBFromVertices(positions);\n      var component = this.getComponent();\n      component.indices = Uint32Array.from(indices);\n      component.aabb = aabb;\n      component.vertexCount = vcounter;\n      component.attributes = [{\n        dirty: true,\n        name: 'position',\n        data: Float32Array.from(positions),\n        arrayStride: 4 * 3,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 0,\n          offset: 0,\n          format: 'float3'\n        }]\n      }, {\n        dirty: true,\n        name: 'normal',\n        data: Float32Array.from(normals),\n        arrayStride: 4 * 3,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 1,\n          offset: 0,\n          format: 'float3'\n        }]\n      }, {\n        dirty: true,\n        name: 'uv',\n        data: Float32Array.from(uvs),\n        arrayStride: 4 * 2,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 2,\n          offset: 0,\n          format: 'float2'\n        }]\n      }]; // TODO: barycentric & tangent\n    }\n  }]);\n  return Plane;\n}(Geometry)) || _class);","map":{"version":3,"names":["generateAABBFromVertices","injectable","Geometry","Plane","_dec","_class","_Geometry","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","key","value","onEntityCreated","_this$config","config","_this$config$halfExte","halfExtents","_this$config$widthSeg","widthSegments","_this$config$lengthSe","lengthSegments","positions","normals","uvs","indices","vcounter","i","j","x","y","z","u","v","push","aabb","component","getComponent","Uint32Array","from","vertexCount","attributes","dirty","name","data","Float32Array","arrayStride","stepMode","shaderLocation","offset","format"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/g-webgpu/src/geometry/Plane.ts"],"sourcesContent":["import { generateAABBFromVertices } from '@antv/g-webgpu-core';\nimport { vec3 } from 'gl-matrix';\nimport { inject, injectable } from 'inversify';\nimport { Geometry } from '.';\n\nexport interface IPlaneGeometryParams {\n  halfExtents: vec3;\n  widthSegments: number;\n  lengthSegments: number;\n}\n\n@injectable()\n/**\n * borrow from playcanvas\n */\nexport class Plane extends Geometry<Partial<IPlaneGeometryParams>> {\n  protected onEntityCreated() {\n    const {\n      halfExtents = [0.5, 0.5],\n      widthSegments = 5,\n      lengthSegments = 5,\n    } = this.config;\n\n    const positions: number[] = [];\n    const normals: number[] = [];\n    const uvs: number[] = [];\n    const indices: number[] = [];\n    let vcounter = 0;\n\n    for (let i = 0; i <= widthSegments; i++) {\n      for (let j = 0; j <= lengthSegments; j++) {\n        const x = -halfExtents[0] + (2.0 * halfExtents[0] * i) / widthSegments;\n        const y = 0.0;\n        const z = -(\n          -halfExtents[1] +\n          (2.0 * halfExtents[1] * j) / lengthSegments\n        );\n        const u = i / widthSegments;\n        const v = j / lengthSegments;\n\n        positions.push(x, y, z);\n        normals.push(0.0, 1.0, 0.0);\n        uvs.push(u, v);\n\n        if (i < widthSegments && j < lengthSegments) {\n          indices.push(vcounter + lengthSegments + 1, vcounter + 1, vcounter);\n          indices.push(\n            vcounter + lengthSegments + 1,\n            vcounter + lengthSegments + 2,\n            vcounter + 1,\n          );\n        }\n\n        vcounter++;\n      }\n    }\n\n    // generate AABB\n    const aabb = generateAABBFromVertices(positions);\n\n    const component = this.getComponent();\n    component.indices = Uint32Array.from(indices);\n    component.aabb = aabb;\n    component.vertexCount = vcounter;\n    component.attributes = [\n      {\n        dirty: true,\n        name: 'position',\n        data: Float32Array.from(positions),\n        arrayStride: 4 * 3,\n        stepMode: 'vertex',\n        attributes: [\n          {\n            shaderLocation: 0,\n            offset: 0,\n            format: 'float3',\n          },\n        ],\n      },\n      {\n        dirty: true,\n        name: 'normal',\n        data: Float32Array.from(normals),\n        arrayStride: 4 * 3,\n        stepMode: 'vertex',\n        attributes: [\n          {\n            shaderLocation: 1,\n            offset: 0,\n            format: 'float3',\n          },\n        ],\n      },\n      {\n        dirty: true,\n        name: 'uv',\n        data: Float32Array.from(uvs),\n        arrayStride: 4 * 2,\n        stepMode: 'vertex',\n        attributes: [\n          {\n            shaderLocation: 2,\n            offset: 0,\n            format: 'float2',\n          },\n        ],\n      },\n    ];\n\n    // TODO: barycentric & tangent\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}