{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { aProjectFlat } from '@antv/l7-utils';\nimport { vec2 } from 'gl-matrix';\nconst tmp = vec2.create();\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst capEnd = vec2.create();\nconst lineA = vec2.create();\nconst lineB = vec2.create();\nconst tangent = vec2.create();\nexport function computeMiter(lineTangent, miter, start, end, halfThick) {\n  vec2.add(lineTangent, start, end);\n  vec2.normalize(lineTangent, lineTangent);\n  miter = vec2.fromValues(-lineTangent[1], lineTangent[0]);\n  const tmpvec = vec2.fromValues(-start[1], start[0]);\n  return [halfThick / vec2.dot(miter, tmpvec), miter];\n}\nexport function computeNormal(out, dir) {\n  return vec2.set(out, -dir[1], dir[0]);\n}\nexport function direction(out, a, b) {\n  vec2.sub(out, a, b);\n  vec2.normalize(out, out);\n  return out;\n}\nfunction isPointEqual(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\nexport function getArrayUnique(matrix) {\n  const map = new Map();\n  for (let i = 0; i < matrix.length; i++) {\n    const key = matrix[0].toString() + '-' + matrix[1].toString();\n    if (map.get(key)) {\n      matrix.splice(i, 1);\n      i++;\n    } else {\n      map.set(key, key);\n    }\n  }\n  return matrix;\n}\nexport default class ExtrudePolyline {\n  constructor(opts = {}) {\n    _defineProperty(this, \"complex\", void 0);\n    _defineProperty(this, \"join\", void 0);\n    _defineProperty(this, \"cap\", void 0);\n    _defineProperty(this, \"miterLimit\", void 0);\n    _defineProperty(this, \"thickness\", void 0);\n    _defineProperty(this, \"normal\", void 0);\n    _defineProperty(this, \"lastFlip\", -1);\n    _defineProperty(this, \"miter\", vec2.fromValues(0, 0));\n    _defineProperty(this, \"started\", false);\n    _defineProperty(this, \"dash\", false);\n    _defineProperty(this, \"totalDistance\", 0);\n    _defineProperty(this, \"currentIndex\", 0);\n    this.join = opts.join || 'miter';\n    this.cap = opts.cap || 'butt';\n    this.miterLimit = opts.miterLimit || 10;\n    this.thickness = opts.thickness || 1;\n    this.dash = opts.dash || false;\n    this.complex = {\n      positions: [],\n      indices: [],\n      normals: [],\n      startIndex: 0,\n      indexes: []\n    };\n  }\n  simpleExtrude(points) {\n    const complex = this.complex;\n    if (points.length <= 1) {\n      return complex;\n    }\n    this.lastFlip = -1;\n    this.started = false;\n    this.normal = null;\n    this.totalDistance = 0;\n    const total = points.length;\n    let count = complex.startIndex;\n    for (let i = 1; i < total; i++) {\n      const last = points[i - 1];\n      const cur = points[i];\n      const next = i < points.length - 1 ? points[i + 1] : null;\n      const amt = this.simpleSegment(complex, count, last, cur, next);\n      count += amt;\n    }\n    if (this.dash) {\n      for (let i = 0; i < complex.positions.length / 6; i++) {\n        complex.positions[i * 6 + 5] = this.totalDistance;\n      }\n    }\n    complex.startIndex = complex.positions.length / 6;\n    return complex;\n  }\n  extrude(points) {\n    const complex = this.complex;\n    if (points.length <= 1) {\n      return complex;\n    }\n    this.lastFlip = -1;\n    this.started = false;\n    this.normal = null;\n    this.totalDistance = 0;\n    // 去除数组里重复的点\n    // points = getArrayUnique(points);\n    const total = points.length;\n    let count = complex.startIndex;\n    for (let i = 1; i < total; i++) {\n      const last = points[i - 1];\n      const cur = points[i];\n      const next = i < points.length - 1 ? points[i + 1] : null;\n      const amt = this.segment(complex, count, last, cur, next);\n      count += amt;\n    }\n    if (this.dash) {\n      for (let i = 0; i < complex.positions.length / 6; i++) {\n        complex.positions[i * 6 + 5] = this.totalDistance;\n      }\n    }\n    complex.startIndex = complex.positions.length / 6;\n    return complex;\n  }\n  simpleSegment(complex, index, last, cur, next) {\n    let count = 0;\n    const indices = complex.indices;\n    const positions = complex.positions;\n    const normals = complex.normals;\n    const flatCur = aProjectFlat([cur[0], cur[1]]);\n    const flatLast = aProjectFlat([last[0], last[1]]);\n    // @ts-ignore\n    direction(lineA, flatCur, flatLast);\n    let segmentDistance = 0;\n    if (this.dash) {\n      // @ts-ignore\n      segmentDistance = this.lineSegmentDistance(flatCur, flatLast);\n      this.totalDistance += segmentDistance;\n    }\n    if (!this.normal) {\n      this.normal = vec2.create();\n      computeNormal(this.normal, lineA);\n    }\n    if (!this.started) {\n      this.started = true;\n      this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);\n    }\n    indices.push(index + 0, index + 1, index + 2);\n    if (!next) {\n      computeNormal(this.normal, lineA);\n      this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);\n      indices.push(...(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n      count += 2;\n    } else {\n      const flatNext = aProjectFlat([next[0], next[1]]);\n      if (isPointEqual(flatCur, flatNext)) {\n        vec2.add(flatNext, flatCur, vec2.normalize(flatNext, vec2.subtract(flatNext, flatCur, flatLast)));\n      }\n      direction(lineB, flatNext, flatCur);\n\n      // stores tangent & miter\n\n      const [miterLen, miter] = computeMiter(tangent, vec2.create(), lineA, lineB, this.thickness);\n      // normal(tmp, lineA)\n\n      // get orientation\n      let flip = vec2.dot(tangent, this.normal) < 0 ? -1 : 1;\n      this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);\n      indices.push(...(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n      flip = -1;\n\n      // the miter is now the normal for our next join\n      vec2.copy(this.normal, miter);\n      count += 2;\n      this.lastFlip = flip;\n    }\n    return count;\n  }\n  segment(complex, index, last, cur, next) {\n    let count = 0;\n    const indices = complex.indices;\n    const positions = complex.positions;\n    const normals = complex.normals;\n    const capSquare = this.cap === 'square';\n    const joinBevel = this.join === 'bevel';\n    const flatCur = aProjectFlat([cur[0], cur[1]]);\n    const flatLast = aProjectFlat([last[0], last[1]]);\n    // @ts-ignore\n    direction(lineA, flatCur, flatLast);\n    let segmentDistance = 0;\n    if (this.dash) {\n      // @ts-ignore\n      segmentDistance = this.lineSegmentDistance(flatCur, flatLast);\n      this.totalDistance += segmentDistance;\n    }\n    if (!this.normal) {\n      this.normal = vec2.create();\n      computeNormal(this.normal, lineA);\n    }\n    if (!this.started) {\n      this.started = true;\n\n      // if the end cap is type square, we can just push the verts out a bit\n      if (capSquare) {\n        // vec2.scaleAndAdd(capEnd, last, lineA, -this.thickness);\n        const out1 = vec2.create();\n        const out2 = vec2.create();\n        vec2.add(out1, this.normal, lineA);\n        vec2.add(out2, this.normal, lineA);\n        normals.push(out2[0], out2[1], 0);\n        normals.push(out1[0], out1[1], 0);\n        positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, -this.thickness, last[2] | 0);\n        this.complex.indexes.push(this.currentIndex);\n        positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, this.thickness, last[2] | 0);\n        this.complex.indexes.push(this.currentIndex);\n        this.currentIndex++;\n        // this.extrusions(positions, normals, last, out, this.thickness);\n        // last = capEnd;\n      } else {\n        this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);\n      }\n    }\n    indices.push(index + 0, index + 1, index + 2);\n    if (!next) {\n      computeNormal(this.normal, lineA);\n      if (capSquare) {\n        // vec2.scaleAndAdd(capEnd, cur, lineA, this.thickness);\n        // cur = capEnd;\n        const out1 = vec2.create();\n        const out2 = vec2.create();\n        vec2.sub(out2, lineA, this.normal);\n        vec2.add(out1, lineA, this.normal);\n        // this.extrusions(positions, normals, cur, out, this.thickness);\n        normals.push(out2[0], out2[1], 0);\n        normals.push(out1[0], out1[1], 0);\n        positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n        this.complex.indexes.push(this.currentIndex);\n        positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n        this.complex.indexes.push(this.currentIndex);\n        this.currentIndex++;\n      } else {\n        this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);\n      }\n\n      // this.extrusions(positions, normals, cur, this.normal, this.thickness);\n      indices.push(...(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n      count += 2;\n    } else {\n      const flatNext = aProjectFlat([next[0], next[1]]);\n      if (isPointEqual(flatCur, flatNext)) {\n        vec2.add(flatNext, flatCur, vec2.normalize(flatNext, vec2.subtract(flatNext, flatCur, flatLast)));\n      }\n      direction(lineB, flatNext, flatCur);\n\n      // stores tangent & miter\n\n      const [miterLen, miter] = computeMiter(tangent, vec2.create(), lineA, lineB, this.thickness);\n      // normal(tmp, lineA)\n\n      // get orientation\n      let flip = vec2.dot(tangent, this.normal) < 0 ? -1 : 1;\n      let bevel = joinBevel;\n      if (!bevel && this.join === 'miter') {\n        const limit = miterLen;\n        if (limit > this.miterLimit) {\n          bevel = true;\n        }\n      }\n      if (bevel) {\n        normals.push(this.normal[0], this.normal[1], 0);\n        normals.push(miter[0], miter[1], 0);\n        positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n        this.complex.indexes.push(this.currentIndex);\n        positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness * flip, cur[2] | 0);\n        this.complex.indexes.push(this.currentIndex);\n        this.currentIndex++;\n        indices.push(...(this.lastFlip !== -flip ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n\n        // now add the bevel triangle\n        indices.push(index + 2, index + 3, index + 4);\n        computeNormal(tmp, lineB);\n        vec2.copy(this.normal, tmp); // store normal for next round\n        normals.push(this.normal[0], this.normal[1], 0);\n        positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n        this.complex.indexes.push(this.currentIndex);\n        this.currentIndex++;\n        count += 3;\n      } else {\n        this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);\n        indices.push(...(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n        flip = -1;\n\n        // the miter is now the normal for our next join\n        vec2.copy(this.normal, miter);\n        count += 2;\n      }\n      this.lastFlip = flip;\n    }\n    return count;\n  }\n  extrusions(positions, normals, point,\n  // 顶点\n  normal,\n  // 法向量\n  thickness,\n  // 高度\n  distanceRadio) {\n    normals.push(normal[0], normal[1], 0);\n    normals.push(normal[0], normal[1], 0);\n    positions.push(point[0], point[1], point[2] | 0, distanceRadio, -thickness, point[2] | 0);\n    this.complex.indexes.push(this.currentIndex);\n    positions.push(point[0], point[1], point[2] | 0, distanceRadio, thickness, point[2] | 0);\n    this.complex.indexes.push(this.currentIndex);\n    this.currentIndex++;\n  }\n  lineSegmentDistance(b1, a1) {\n    const dx = a1[0] - b1[0];\n    const dy = a1[1] - b1[1];\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n}","map":{"version":3,"names":["_defineProperty","aProjectFlat","vec2","tmp","create","capEnd","lineA","lineB","tangent","computeMiter","lineTangent","miter","start","end","halfThick","add","normalize","fromValues","tmpvec","dot","computeNormal","out","dir","set","direction","a","b","sub","isPointEqual","getArrayUnique","matrix","map","Map","i","length","key","toString","get","splice","ExtrudePolyline","constructor","opts","join","cap","miterLimit","thickness","dash","complex","positions","indices","normals","startIndex","indexes","simpleExtrude","points","lastFlip","started","normal","totalDistance","total","count","last","cur","next","amt","simpleSegment","extrude","segment","index","flatCur","flatLast","segmentDistance","lineSegmentDistance","extrusions","push","flatNext","subtract","miterLen","flip","copy","capSquare","joinBevel","out1","out2","currentIndex","bevel","limit","point","distanceRadio","b1","a1","dx","dy","Math","sqrt"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/l7-layers/es/utils/extrude_polyline.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { aProjectFlat } from '@antv/l7-utils';\nimport { vec2 } from 'gl-matrix';\nconst tmp = vec2.create();\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst capEnd = vec2.create();\nconst lineA = vec2.create();\nconst lineB = vec2.create();\nconst tangent = vec2.create();\nexport function computeMiter(lineTangent, miter, start, end, halfThick) {\n  vec2.add(lineTangent, start, end);\n  vec2.normalize(lineTangent, lineTangent);\n  miter = vec2.fromValues(-lineTangent[1], lineTangent[0]);\n  const tmpvec = vec2.fromValues(-start[1], start[0]);\n  return [halfThick / vec2.dot(miter, tmpvec), miter];\n}\nexport function computeNormal(out, dir) {\n  return vec2.set(out, -dir[1], dir[0]);\n}\nexport function direction(out, a, b) {\n  vec2.sub(out, a, b);\n  vec2.normalize(out, out);\n  return out;\n}\nfunction isPointEqual(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\nexport function getArrayUnique(matrix) {\n  const map = new Map();\n  for (let i = 0; i < matrix.length; i++) {\n    const key = matrix[0].toString() + '-' + matrix[1].toString();\n    if (map.get(key)) {\n      matrix.splice(i, 1);\n      i++;\n    } else {\n      map.set(key, key);\n    }\n  }\n  return matrix;\n}\nexport default class ExtrudePolyline {\n  constructor(opts = {}) {\n    _defineProperty(this, \"complex\", void 0);\n    _defineProperty(this, \"join\", void 0);\n    _defineProperty(this, \"cap\", void 0);\n    _defineProperty(this, \"miterLimit\", void 0);\n    _defineProperty(this, \"thickness\", void 0);\n    _defineProperty(this, \"normal\", void 0);\n    _defineProperty(this, \"lastFlip\", -1);\n    _defineProperty(this, \"miter\", vec2.fromValues(0, 0));\n    _defineProperty(this, \"started\", false);\n    _defineProperty(this, \"dash\", false);\n    _defineProperty(this, \"totalDistance\", 0);\n    _defineProperty(this, \"currentIndex\", 0);\n    this.join = opts.join || 'miter';\n    this.cap = opts.cap || 'butt';\n    this.miterLimit = opts.miterLimit || 10;\n    this.thickness = opts.thickness || 1;\n    this.dash = opts.dash || false;\n    this.complex = {\n      positions: [],\n      indices: [],\n      normals: [],\n      startIndex: 0,\n      indexes: []\n    };\n  }\n  simpleExtrude(points) {\n    const complex = this.complex;\n    if (points.length <= 1) {\n      return complex;\n    }\n    this.lastFlip = -1;\n    this.started = false;\n    this.normal = null;\n    this.totalDistance = 0;\n    const total = points.length;\n    let count = complex.startIndex;\n    for (let i = 1; i < total; i++) {\n      const last = points[i - 1];\n      const cur = points[i];\n      const next = i < points.length - 1 ? points[i + 1] : null;\n      const amt = this.simpleSegment(complex, count, last, cur, next);\n      count += amt;\n    }\n    if (this.dash) {\n      for (let i = 0; i < complex.positions.length / 6; i++) {\n        complex.positions[i * 6 + 5] = this.totalDistance;\n      }\n    }\n    complex.startIndex = complex.positions.length / 6;\n    return complex;\n  }\n  extrude(points) {\n    const complex = this.complex;\n    if (points.length <= 1) {\n      return complex;\n    }\n    this.lastFlip = -1;\n    this.started = false;\n    this.normal = null;\n    this.totalDistance = 0;\n    // 去除数组里重复的点\n    // points = getArrayUnique(points);\n    const total = points.length;\n    let count = complex.startIndex;\n    for (let i = 1; i < total; i++) {\n      const last = points[i - 1];\n      const cur = points[i];\n      const next = i < points.length - 1 ? points[i + 1] : null;\n      const amt = this.segment(complex, count, last, cur, next);\n      count += amt;\n    }\n    if (this.dash) {\n      for (let i = 0; i < complex.positions.length / 6; i++) {\n        complex.positions[i * 6 + 5] = this.totalDistance;\n      }\n    }\n    complex.startIndex = complex.positions.length / 6;\n    return complex;\n  }\n  simpleSegment(complex, index, last, cur, next) {\n    let count = 0;\n    const indices = complex.indices;\n    const positions = complex.positions;\n    const normals = complex.normals;\n    const flatCur = aProjectFlat([cur[0], cur[1]]);\n    const flatLast = aProjectFlat([last[0], last[1]]);\n    // @ts-ignore\n    direction(lineA, flatCur, flatLast);\n    let segmentDistance = 0;\n    if (this.dash) {\n      // @ts-ignore\n      segmentDistance = this.lineSegmentDistance(flatCur, flatLast);\n      this.totalDistance += segmentDistance;\n    }\n    if (!this.normal) {\n      this.normal = vec2.create();\n      computeNormal(this.normal, lineA);\n    }\n    if (!this.started) {\n      this.started = true;\n      this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);\n    }\n    indices.push(index + 0, index + 1, index + 2);\n    if (!next) {\n      computeNormal(this.normal, lineA);\n      this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);\n      indices.push(...(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n      count += 2;\n    } else {\n      const flatNext = aProjectFlat([next[0], next[1]]);\n      if (isPointEqual(flatCur, flatNext)) {\n        vec2.add(flatNext, flatCur, vec2.normalize(flatNext, vec2.subtract(flatNext, flatCur, flatLast)));\n      }\n      direction(lineB, flatNext, flatCur);\n\n      // stores tangent & miter\n\n      const [miterLen, miter] = computeMiter(tangent, vec2.create(), lineA, lineB, this.thickness);\n      // normal(tmp, lineA)\n\n      // get orientation\n      let flip = vec2.dot(tangent, this.normal) < 0 ? -1 : 1;\n      this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);\n      indices.push(...(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n      flip = -1;\n\n      // the miter is now the normal for our next join\n      vec2.copy(this.normal, miter);\n      count += 2;\n      this.lastFlip = flip;\n    }\n    return count;\n  }\n  segment(complex, index, last, cur, next) {\n    let count = 0;\n    const indices = complex.indices;\n    const positions = complex.positions;\n    const normals = complex.normals;\n    const capSquare = this.cap === 'square';\n    const joinBevel = this.join === 'bevel';\n    const flatCur = aProjectFlat([cur[0], cur[1]]);\n    const flatLast = aProjectFlat([last[0], last[1]]);\n    // @ts-ignore\n    direction(lineA, flatCur, flatLast);\n    let segmentDistance = 0;\n    if (this.dash) {\n      // @ts-ignore\n      segmentDistance = this.lineSegmentDistance(flatCur, flatLast);\n      this.totalDistance += segmentDistance;\n    }\n    if (!this.normal) {\n      this.normal = vec2.create();\n      computeNormal(this.normal, lineA);\n    }\n    if (!this.started) {\n      this.started = true;\n\n      // if the end cap is type square, we can just push the verts out a bit\n      if (capSquare) {\n        // vec2.scaleAndAdd(capEnd, last, lineA, -this.thickness);\n        const out1 = vec2.create();\n        const out2 = vec2.create();\n        vec2.add(out1, this.normal, lineA);\n        vec2.add(out2, this.normal, lineA);\n        normals.push(out2[0], out2[1], 0);\n        normals.push(out1[0], out1[1], 0);\n        positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, -this.thickness, last[2] | 0);\n        this.complex.indexes.push(this.currentIndex);\n        positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, this.thickness, last[2] | 0);\n        this.complex.indexes.push(this.currentIndex);\n        this.currentIndex++;\n        // this.extrusions(positions, normals, last, out, this.thickness);\n        // last = capEnd;\n      } else {\n        this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);\n      }\n    }\n    indices.push(index + 0, index + 1, index + 2);\n    if (!next) {\n      computeNormal(this.normal, lineA);\n      if (capSquare) {\n        // vec2.scaleAndAdd(capEnd, cur, lineA, this.thickness);\n        // cur = capEnd;\n        const out1 = vec2.create();\n        const out2 = vec2.create();\n        vec2.sub(out2, lineA, this.normal);\n        vec2.add(out1, lineA, this.normal);\n        // this.extrusions(positions, normals, cur, out, this.thickness);\n        normals.push(out2[0], out2[1], 0);\n        normals.push(out1[0], out1[1], 0);\n        positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n        this.complex.indexes.push(this.currentIndex);\n        positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n        this.complex.indexes.push(this.currentIndex);\n        this.currentIndex++;\n      } else {\n        this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);\n      }\n\n      // this.extrusions(positions, normals, cur, this.normal, this.thickness);\n      indices.push(...(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n      count += 2;\n    } else {\n      const flatNext = aProjectFlat([next[0], next[1]]);\n      if (isPointEqual(flatCur, flatNext)) {\n        vec2.add(flatNext, flatCur, vec2.normalize(flatNext, vec2.subtract(flatNext, flatCur, flatLast)));\n      }\n      direction(lineB, flatNext, flatCur);\n\n      // stores tangent & miter\n\n      const [miterLen, miter] = computeMiter(tangent, vec2.create(), lineA, lineB, this.thickness);\n      // normal(tmp, lineA)\n\n      // get orientation\n      let flip = vec2.dot(tangent, this.normal) < 0 ? -1 : 1;\n      let bevel = joinBevel;\n      if (!bevel && this.join === 'miter') {\n        const limit = miterLen;\n        if (limit > this.miterLimit) {\n          bevel = true;\n        }\n      }\n      if (bevel) {\n        normals.push(this.normal[0], this.normal[1], 0);\n        normals.push(miter[0], miter[1], 0);\n        positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n        this.complex.indexes.push(this.currentIndex);\n        positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness * flip, cur[2] | 0);\n        this.complex.indexes.push(this.currentIndex);\n        this.currentIndex++;\n        indices.push(...(this.lastFlip !== -flip ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n\n        // now add the bevel triangle\n        indices.push(index + 2, index + 3, index + 4);\n        computeNormal(tmp, lineB);\n        vec2.copy(this.normal, tmp); // store normal for next round\n        normals.push(this.normal[0], this.normal[1], 0);\n        positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n        this.complex.indexes.push(this.currentIndex);\n        this.currentIndex++;\n        count += 3;\n      } else {\n        this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);\n        indices.push(...(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n        flip = -1;\n\n        // the miter is now the normal for our next join\n        vec2.copy(this.normal, miter);\n        count += 2;\n      }\n      this.lastFlip = flip;\n    }\n    return count;\n  }\n  extrusions(positions, normals, point,\n  // 顶点\n  normal,\n  // 法向量\n  thickness,\n  // 高度\n  distanceRadio) {\n    normals.push(normal[0], normal[1], 0);\n    normals.push(normal[0], normal[1], 0);\n    positions.push(point[0], point[1], point[2] | 0, distanceRadio, -thickness, point[2] | 0);\n    this.complex.indexes.push(this.currentIndex);\n    positions.push(point[0], point[1], point[2] | 0, distanceRadio, thickness, point[2] | 0);\n    this.complex.indexes.push(this.currentIndex);\n    this.currentIndex++;\n  }\n  lineSegmentDistance(b1, a1) {\n    const dx = a1[0] - b1[0];\n    const dy = a1[1] - b1[1];\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}