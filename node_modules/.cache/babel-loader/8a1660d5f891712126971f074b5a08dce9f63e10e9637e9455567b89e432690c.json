{"ast":null,"code":"import { ObjectExt, NumberExt, Dom, FunctionExt } from '../../util';\nexport const text = {\n  qualify(text, {\n    attrs\n  }) {\n    return attrs.textWrap == null || !ObjectExt.isPlainObject(attrs.textWrap);\n  },\n  set(text, {\n    view,\n    elem,\n    attrs\n  }) {\n    const cacheName = 'x6-text';\n    const $elem = view.$(elem);\n    const cache = $elem.data(cacheName);\n    const json = str => {\n      try {\n        return JSON.parse(str);\n      } catch (error) {\n        return str;\n      }\n    };\n    const options = {\n      x: attrs.x,\n      eol: attrs.eol,\n      annotations: json(attrs.annotations),\n      textPath: json(attrs['text-path'] || attrs.textPath),\n      textVerticalAnchor: attrs['text-vertical-anchor'] || attrs.textVerticalAnchor,\n      displayEmpty: (attrs['display-empty'] || attrs.displayEmpty) === 'true',\n      lineHeight: attrs['line-height'] || attrs.lineHeight\n    };\n    const fontSize = attrs['font-size'] || attrs.fontSize;\n    const textHash = JSON.stringify([text, options]);\n    if (fontSize) {\n      elem.setAttribute('font-size', fontSize);\n    }\n    // Updates the text only if there was a change in the string\n    // or any of its attributes.\n    if (cache == null || cache !== textHash) {\n      // Text Along Path Selector\n      const textPath = options.textPath;\n      if (textPath != null && typeof textPath === 'object') {\n        const selector = textPath.selector;\n        if (typeof selector === 'string') {\n          const pathNode = view.find(selector)[0];\n          if (pathNode instanceof SVGPathElement) {\n            Dom.ensureId(pathNode);\n            options.textPath = Object.assign({\n              'xlink:href': `#${pathNode.id}`\n            }, textPath);\n          }\n        }\n      }\n      Dom.text(elem, `${text}`, options);\n      $elem.data(cacheName, textHash);\n    }\n  }\n};\nexport const textWrap = {\n  qualify: ObjectExt.isPlainObject,\n  set(val, {\n    view,\n    elem,\n    attrs,\n    refBBox\n  }) {\n    const info = val;\n    // option `width`\n    const width = info.width || 0;\n    if (NumberExt.isPercentage(width)) {\n      refBBox.width *= parseFloat(width) / 100;\n    } else if (width <= 0) {\n      refBBox.width += width;\n    } else {\n      refBBox.width = width;\n    }\n    // option `height`\n    const height = info.height || 0;\n    if (NumberExt.isPercentage(height)) {\n      refBBox.height *= parseFloat(height) / 100;\n    } else if (height <= 0) {\n      refBBox.height += height;\n    } else {\n      refBBox.height = height;\n    }\n    // option `text`\n    let wrappedText;\n    let txt = info.text;\n    if (txt == null) {\n      txt = attrs.text;\n    }\n    if (txt != null) {\n      wrappedText = Dom.breakText(`${txt}`, refBBox, {\n        'font-weight': attrs['font-weight'] || attrs.fontWeight,\n        'font-size': attrs['font-size'] || attrs.fontSize,\n        'font-family': attrs['font-family'] || attrs.fontFamily,\n        lineHeight: attrs.lineHeight\n      }, {\n        svgDocument: view.graph.view.svg,\n        ellipsis: info.ellipsis,\n        hyphen: info.hyphen,\n        breakWord: info.breakWord\n      });\n    } else {\n      wrappedText = '';\n    }\n    FunctionExt.call(text.set, this, wrappedText, {\n      view,\n      elem,\n      attrs,\n      refBBox,\n      cell: view.cell\n    });\n  }\n};\nconst isTextInUse = (val, {\n  attrs\n}) => {\n  return attrs.text !== undefined;\n};\nexport const lineHeight = {\n  qualify: isTextInUse\n};\nexport const textVerticalAnchor = {\n  qualify: isTextInUse\n};\nexport const textPath = {\n  qualify: isTextInUse\n};\nexport const annotations = {\n  qualify: isTextInUse\n};\nexport const eol = {\n  qualify: isTextInUse\n};\nexport const displayEmpty = {\n  qualify: isTextInUse\n};","map":{"version":3,"names":["ObjectExt","NumberExt","Dom","FunctionExt","text","qualify","attrs","textWrap","isPlainObject","set","view","elem","cacheName","$elem","$","cache","data","json","str","JSON","parse","error","options","x","eol","annotations","textPath","textVerticalAnchor","displayEmpty","lineHeight","fontSize","textHash","stringify","setAttribute","selector","pathNode","find","SVGPathElement","ensureId","Object","assign","id","val","refBBox","info","width","isPercentage","parseFloat","height","wrappedText","txt","breakText","fontWeight","fontFamily","svgDocument","graph","svg","ellipsis","hyphen","breakWord","call","cell","isTextInUse","undefined"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/registry/attr/text.ts"],"sourcesContent":["import {\n  ObjectExt,\n  JSONObject,\n  NumberExt,\n  Dom,\n  FunctionExt,\n  Text,\n} from '../../util'\nimport { Attr } from './index'\n\nexport const text: Attr.Definition = {\n  qualify(text, { attrs }) {\n    return attrs.textWrap == null || !ObjectExt.isPlainObject(attrs.textWrap)\n  },\n  set(text, { view, elem, attrs }) {\n    const cacheName = 'x6-text'\n    const $elem = view.$(elem)\n    const cache = $elem.data(cacheName)\n    const json = <T>(str: any) => {\n      try {\n        return JSON.parse(str) as T\n      } catch (error) {\n        return str\n      }\n    }\n    const options: Dom.TextOptions = {\n      x: attrs.x as string | number,\n      eol: attrs.eol as string,\n      annotations: json(attrs.annotations) as\n        | Text.Annotation\n        | Text.Annotation[],\n      textPath: json(attrs['text-path'] || attrs.textPath),\n      textVerticalAnchor: (attrs['text-vertical-anchor'] ||\n        attrs.textVerticalAnchor) as 'middle' | 'bottom' | 'top' | number,\n      displayEmpty: (attrs['display-empty'] || attrs.displayEmpty) === 'true',\n      lineHeight: (attrs['line-height'] || attrs.lineHeight) as string,\n    }\n\n    const fontSize = (attrs['font-size'] || attrs.fontSize) as string\n    const textHash = JSON.stringify([text, options])\n\n    if (fontSize) {\n      elem.setAttribute('font-size', fontSize)\n    }\n\n    // Updates the text only if there was a change in the string\n    // or any of its attributes.\n    if (cache == null || cache !== textHash) {\n      // Text Along Path Selector\n      const textPath = options.textPath as any\n      if (textPath != null && typeof textPath === 'object') {\n        const selector = textPath.selector\n        if (typeof selector === 'string') {\n          const pathNode = view.find(selector)[0]\n          if (pathNode instanceof SVGPathElement) {\n            Dom.ensureId(pathNode)\n            options.textPath = {\n              'xlink:href': `#${pathNode.id}`,\n              ...textPath,\n            }\n          }\n        }\n      }\n\n      Dom.text(elem as SVGElement, `${text}`, options)\n      $elem.data(cacheName, textHash)\n    }\n  },\n}\n\nexport const textWrap: Attr.Definition = {\n  qualify: ObjectExt.isPlainObject,\n  set(val, { view, elem, attrs, refBBox }) {\n    const info = val as JSONObject\n\n    // option `width`\n    const width = info.width || 0\n    if (NumberExt.isPercentage(width)) {\n      refBBox.width *= parseFloat(width) / 100\n    } else if (width <= 0) {\n      refBBox.width += width as number\n    } else {\n      refBBox.width = width as number\n    }\n\n    // option `height`\n    const height = info.height || 0\n    if (NumberExt.isPercentage(height)) {\n      refBBox.height *= parseFloat(height) / 100\n    } else if (height <= 0) {\n      refBBox.height += height as number\n    } else {\n      refBBox.height = height as number\n    }\n\n    // option `text`\n    let wrappedText\n    let txt = info.text\n    if (txt == null) {\n      txt = attrs.text\n    }\n\n    if (txt != null) {\n      wrappedText = Dom.breakText(\n        `${txt}`,\n        refBBox,\n        {\n          'font-weight': attrs['font-weight'] || attrs.fontWeight,\n          'font-size': attrs['font-size'] || attrs.fontSize,\n          'font-family': attrs['font-family'] || attrs.fontFamily,\n          lineHeight: attrs.lineHeight,\n        },\n        {\n          svgDocument: view.graph.view.svg,\n          ellipsis: info.ellipsis as string,\n          hyphen: info.hyphen as string,\n          breakWord: info.breakWord as boolean,\n        },\n      )\n    } else {\n      wrappedText = ''\n    }\n\n    FunctionExt.call(text.set, this, wrappedText, {\n      view,\n      elem,\n      attrs,\n      refBBox,\n      cell: view.cell,\n    })\n  },\n}\n\nconst isTextInUse: Attr.QualifyFucntion = (val, { attrs }) => {\n  return attrs.text !== undefined\n}\n\nexport const lineHeight: Attr.Definition = {\n  qualify: isTextInUse,\n}\n\nexport const textVerticalAnchor: Attr.Definition = {\n  qualify: isTextInUse,\n}\n\nexport const textPath: Attr.Definition = {\n  qualify: isTextInUse,\n}\n\nexport const annotations: Attr.Definition = {\n  qualify: isTextInUse,\n}\n\nexport const eol: Attr.Definition = {\n  qualify: isTextInUse,\n}\n\nexport const displayEmpty: Attr.Definition = {\n  qualify: isTextInUse,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}