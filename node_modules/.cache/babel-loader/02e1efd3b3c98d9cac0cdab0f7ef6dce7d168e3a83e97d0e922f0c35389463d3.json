{"ast":null,"code":"import * as util from './util';\nimport { Angle } from './angle';\nimport { Line } from './line';\nimport { Point } from './point';\nimport { Geometry } from './geometry';\nexport class Rectangle extends Geometry {\n  constructor(x, y, width, height) {\n    super();\n    this.x = x == null ? 0 : x;\n    this.y = y == null ? 0 : y;\n    this.width = width == null ? 0 : width;\n    this.height = height == null ? 0 : height;\n  }\n  get [Symbol.toStringTag]() {\n    return Rectangle.toStringTag;\n  }\n  get left() {\n    return this.x;\n  }\n  get top() {\n    return this.y;\n  }\n  get right() {\n    return this.x + this.width;\n  }\n  get bottom() {\n    return this.y + this.height;\n  }\n  get origin() {\n    return new Point(this.x, this.y);\n  }\n  get topLeft() {\n    return new Point(this.x, this.y);\n  }\n  get topCenter() {\n    return new Point(this.x + this.width / 2, this.y);\n  }\n  get topRight() {\n    return new Point(this.x + this.width, this.y);\n  }\n  get center() {\n    return new Point(this.x + this.width / 2, this.y + this.height / 2);\n  }\n  get bottomLeft() {\n    return new Point(this.x, this.y + this.height);\n  }\n  get bottomCenter() {\n    return new Point(this.x + this.width / 2, this.y + this.height);\n  }\n  get bottomRight() {\n    return new Point(this.x + this.width, this.y + this.height);\n  }\n  get corner() {\n    return new Point(this.x + this.width, this.y + this.height);\n  }\n  get rightMiddle() {\n    return new Point(this.x + this.width, this.y + this.height / 2);\n  }\n  get leftMiddle() {\n    return new Point(this.x, this.y + this.height / 2);\n  }\n  get topLine() {\n    return new Line(this.topLeft, this.topRight);\n  }\n  get rightLine() {\n    return new Line(this.topRight, this.bottomRight);\n  }\n  get bottomLine() {\n    return new Line(this.bottomLeft, this.bottomRight);\n  }\n  get leftLine() {\n    return new Line(this.topLeft, this.bottomLeft);\n  }\n  getOrigin() {\n    return this.origin;\n  }\n  getTopLeft() {\n    return this.topLeft;\n  }\n  getTopCenter() {\n    return this.topCenter;\n  }\n  getTopRight() {\n    return this.topRight;\n  }\n  getCenter() {\n    return this.center;\n  }\n  getCenterX() {\n    return this.x + this.width / 2;\n  }\n  getCenterY() {\n    return this.y + this.height / 2;\n  }\n  getBottomLeft() {\n    return this.bottomLeft;\n  }\n  getBottomCenter() {\n    return this.bottomCenter;\n  }\n  getBottomRight() {\n    return this.bottomRight;\n  }\n  getCorner() {\n    return this.corner;\n  }\n  getRightMiddle() {\n    return this.rightMiddle;\n  }\n  getLeftMiddle() {\n    return this.leftMiddle;\n  }\n  getTopLine() {\n    return this.topLine;\n  }\n  getRightLine() {\n    return this.rightLine;\n  }\n  getBottomLine() {\n    return this.bottomLine;\n  }\n  getLeftLine() {\n    return this.leftLine;\n  }\n  /**\n   * Returns a rectangle that is the bounding box of the rectangle.\n   *\n   * If `angle` is specified, the bounding box calculation will take into\n   * account the rotation of the rectangle by angle degrees around its center.\n   */\n  bbox(angle) {\n    if (!angle) {\n      return this.clone();\n    }\n    const rad = Angle.toRad(angle);\n    const st = Math.abs(Math.sin(rad));\n    const ct = Math.abs(Math.cos(rad));\n    const w = this.width * ct + this.height * st;\n    const h = this.width * st + this.height * ct;\n    return new Rectangle(this.x + (this.width - w) / 2, this.y + (this.height - h) / 2, w, h);\n  }\n  round(precision = 0) {\n    this.x = util.round(this.x, precision);\n    this.y = util.round(this.y, precision);\n    this.width = util.round(this.width, precision);\n    this.height = util.round(this.height, precision);\n    return this;\n  }\n  add(x, y, width, height) {\n    const rect = Rectangle.create(x, y, width, height);\n    const minX = Math.min(this.x, rect.x);\n    const minY = Math.min(this.y, rect.y);\n    const maxX = Math.max(this.x + this.width, rect.x + rect.width);\n    const maxY = Math.max(this.y + this.height, rect.y + rect.height);\n    this.x = minX;\n    this.y = minY;\n    this.width = maxX - minX;\n    this.height = maxY - minY;\n    return this;\n  }\n  update(x, y, width, height) {\n    const rect = Rectangle.create(x, y, width, height);\n    this.x = rect.x;\n    this.y = rect.y;\n    this.width = rect.width;\n    this.height = rect.height;\n    return this;\n  }\n  inflate(dx, dy) {\n    const w = dx;\n    const h = dy != null ? dy : dx;\n    this.x -= w;\n    this.y -= h;\n    this.width += 2 * w;\n    this.height += 2 * h;\n    return this;\n  }\n  snapToGrid(gx, gy) {\n    const origin = this.origin.snapToGrid(gx, gy);\n    const corner = this.corner.snapToGrid(gx, gy);\n    this.x = origin.x;\n    this.y = origin.y;\n    this.width = corner.x - origin.x;\n    this.height = corner.y - origin.y;\n    return this;\n  }\n  translate(tx, ty) {\n    const p = Point.create(tx, ty);\n    this.x += p.x;\n    this.y += p.y;\n    return this;\n  }\n  scale(sx, sy, origin = new Point()) {\n    const pos = this.origin.scale(sx, sy, origin);\n    this.x = pos.x;\n    this.y = pos.y;\n    this.width *= sx;\n    this.height *= sy;\n    return this;\n  }\n  rotate(degree, center = this.getCenter()) {\n    if (degree !== 0) {\n      const rad = Angle.toRad(degree);\n      const cos = Math.cos(rad);\n      const sin = Math.sin(rad);\n      let p1 = this.getOrigin();\n      let p2 = this.getTopRight();\n      let p3 = this.getBottomRight();\n      let p4 = this.getBottomLeft();\n      p1 = Point.rotateEx(p1, cos, sin, center);\n      p2 = Point.rotateEx(p2, cos, sin, center);\n      p3 = Point.rotateEx(p3, cos, sin, center);\n      p4 = Point.rotateEx(p4, cos, sin, center);\n      const rect = new Rectangle(p1.x, p1.y, 0, 0);\n      rect.add(p2.x, p2.y, 0, 0);\n      rect.add(p3.x, p3.y, 0, 0);\n      rect.add(p4.x, p4.y, 0, 0);\n      this.update(rect);\n    }\n    return this;\n  }\n  rotate90() {\n    const t = (this.width - this.height) / 2;\n    this.x += t;\n    this.y -= t;\n    const tmp = this.width;\n    this.width = this.height;\n    this.height = tmp;\n    return this;\n  }\n  /**\n   * Translates the rectangle by `rect.x` and `rect.y` and expand it by\n   * `rect.width` and `rect.height`.\n   */\n  moveAndExpand(rect) {\n    const ref = Rectangle.clone(rect);\n    this.x += ref.x || 0;\n    this.y += ref.y || 0;\n    this.width += ref.width || 0;\n    this.height += ref.height || 0;\n    return this;\n  }\n  /**\n   * Returns an object where `sx` and `sy` give the maximum scaling that can be\n   * applied to the rectangle so that it would still fit into `limit`. If\n   * `origin` is specified, the rectangle is scaled around it; otherwise, it is\n   * scaled around its center.\n   */\n  getMaxScaleToFit(limit, origin = this.center) {\n    const rect = Rectangle.clone(limit);\n    const ox = origin.x;\n    const oy = origin.y;\n    // Find the maximal possible scale for all corners, so when the scale\n    // is applied the point is still inside the rectangle.\n    let sx1 = Infinity;\n    let sx2 = Infinity;\n    let sx3 = Infinity;\n    let sx4 = Infinity;\n    let sy1 = Infinity;\n    let sy2 = Infinity;\n    let sy3 = Infinity;\n    let sy4 = Infinity;\n    // Top Left\n    const p1 = rect.topLeft;\n    if (p1.x < ox) {\n      sx1 = (this.x - ox) / (p1.x - ox);\n    }\n    if (p1.y < oy) {\n      sy1 = (this.y - oy) / (p1.y - oy);\n    }\n    // Bottom Right\n    const p2 = rect.bottomRight;\n    if (p2.x > ox) {\n      sx2 = (this.x + this.width - ox) / (p2.x - ox);\n    }\n    if (p2.y > oy) {\n      sy2 = (this.y + this.height - oy) / (p2.y - oy);\n    }\n    // Top Right\n    const p3 = rect.topRight;\n    if (p3.x > ox) {\n      sx3 = (this.x + this.width - ox) / (p3.x - ox);\n    }\n    if (p3.y < oy) {\n      sy3 = (this.y - oy) / (p3.y - oy);\n    }\n    // Bottom Left\n    const p4 = rect.bottomLeft;\n    if (p4.x < ox) {\n      sx4 = (this.x - ox) / (p4.x - ox);\n    }\n    if (p4.y > oy) {\n      sy4 = (this.y + this.height - oy) / (p4.y - oy);\n    }\n    return {\n      sx: Math.min(sx1, sx2, sx3, sx4),\n      sy: Math.min(sy1, sy2, sy3, sy4)\n    };\n  }\n  /**\n   * Returns a number that specifies the maximum scaling that can be applied to\n   * the rectangle along both axes so that it would still fit into `limit`. If\n   * `origin` is specified, the rectangle is scaled around it; otherwise, it is\n   * scaled around its center.\n   */\n  getMaxUniformScaleToFit(limit, origin = this.center) {\n    const scale = this.getMaxScaleToFit(limit, origin);\n    return Math.min(scale.sx, scale.sy);\n  }\n  containsPoint(x, y) {\n    return util.containsPoint(this, Point.create(x, y));\n  }\n  containsRect(x, y, width, height) {\n    const b = Rectangle.create(x, y, width, height);\n    const x1 = this.x;\n    const y1 = this.y;\n    const w1 = this.width;\n    const h1 = this.height;\n    const x2 = b.x;\n    const y2 = b.y;\n    const w2 = b.width;\n    const h2 = b.height;\n    // one of the dimensions is 0\n    if (w1 === 0 || h1 === 0 || w2 === 0 || h2 === 0) {\n      return false;\n    }\n    return x2 >= x1 && y2 >= y1 && x2 + w2 <= x1 + w1 && y2 + h2 <= y1 + h1;\n  }\n  /**\n   * Returns an array of the intersection points of the rectangle and the line.\n   * Return `null` if no intersection exists.\n   */\n  intersectsWithLine(line) {\n    const rectLines = [this.topLine, this.rightLine, this.bottomLine, this.leftLine];\n    const points = [];\n    const dedupeArr = [];\n    rectLines.forEach(l => {\n      const p = line.intersectsWithLine(l);\n      if (p !== null && dedupeArr.indexOf(p.toString()) < 0) {\n        points.push(p);\n        dedupeArr.push(p.toString());\n      }\n    });\n    return points.length > 0 ? points : null;\n  }\n  /**\n   * Returns the point on the boundary of the rectangle that is the intersection\n   * of the rectangle with a line starting in the center the rectangle ending in\n   * the point `p`.\n   *\n   * If `angle` is specified, the intersection will take into account the\n   * rotation of the rectangle by `angle` degrees around its center.\n   */\n  intersectsWithLineFromCenterToPoint(p, angle) {\n    const ref = Point.clone(p);\n    const center = this.center;\n    let result = null;\n    if (angle != null && angle !== 0) {\n      ref.rotate(angle, center);\n    }\n    const sides = [this.topLine, this.rightLine, this.bottomLine, this.leftLine];\n    const connector = new Line(center, ref);\n    for (let i = sides.length - 1; i >= 0; i -= 1) {\n      const intersection = sides[i].intersectsWithLine(connector);\n      if (intersection !== null) {\n        result = intersection;\n        break;\n      }\n    }\n    if (result && angle != null && angle !== 0) {\n      result.rotate(-angle, center);\n    }\n    return result;\n  }\n  intersectsWithRect(x, y, width, height) {\n    const ref = Rectangle.create(x, y, width, height);\n    // no intersection\n    if (!this.isIntersectWithRect(ref)) {\n      return null;\n    }\n    const myOrigin = this.origin;\n    const myCorner = this.corner;\n    const rOrigin = ref.origin;\n    const rCorner = ref.corner;\n    const xx = Math.max(myOrigin.x, rOrigin.x);\n    const yy = Math.max(myOrigin.y, rOrigin.y);\n    return new Rectangle(xx, yy, Math.min(myCorner.x, rCorner.x) - xx, Math.min(myCorner.y, rCorner.y) - yy);\n  }\n  isIntersectWithRect(x, y, width, height) {\n    const ref = Rectangle.create(x, y, width, height);\n    const myOrigin = this.origin;\n    const myCorner = this.corner;\n    const rOrigin = ref.origin;\n    const rCorner = ref.corner;\n    if (rCorner.x <= myOrigin.x || rCorner.y <= myOrigin.y || rOrigin.x >= myCorner.x || rOrigin.y >= myCorner.y) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Normalize the rectangle, i.e. make it so that it has non-negative\n   * width and height. If width is less than `0`, the function swaps left and\n   * right corners and if height is less than `0`, the top and bottom corners\n   * are swapped.\n   */\n  normalize() {\n    let newx = this.x;\n    let newy = this.y;\n    let newwidth = this.width;\n    let newheight = this.height;\n    if (this.width < 0) {\n      newx = this.x + this.width;\n      newwidth = -this.width;\n    }\n    if (this.height < 0) {\n      newy = this.y + this.height;\n      newheight = -this.height;\n    }\n    this.x = newx;\n    this.y = newy;\n    this.width = newwidth;\n    this.height = newheight;\n    return this;\n  }\n  /**\n   * Returns a rectangle that is a union of this rectangle and rectangle `rect`.\n   */\n  union(rect) {\n    const ref = Rectangle.clone(rect);\n    const myOrigin = this.origin;\n    const myCorner = this.corner;\n    const rOrigin = ref.origin;\n    const rCorner = ref.corner;\n    const originX = Math.min(myOrigin.x, rOrigin.x);\n    const originY = Math.min(myOrigin.y, rOrigin.y);\n    const cornerX = Math.max(myCorner.x, rCorner.x);\n    const cornerY = Math.max(myCorner.y, rCorner.y);\n    return new Rectangle(originX, originY, cornerX - originX, cornerY - originY);\n  }\n  /**\n   * Returns a string (\"top\", \"left\", \"right\" or \"bottom\") denoting the side of\n   * the rectangle which is nearest to the point `p`.\n   */\n  getNearestSideToPoint(p) {\n    const ref = Point.clone(p);\n    const distLeft = ref.x - this.x;\n    const distRight = this.x + this.width - ref.x;\n    const distTop = ref.y - this.y;\n    const distBottom = this.y + this.height - ref.y;\n    let closest = distLeft;\n    let side = 'left';\n    if (distRight < closest) {\n      closest = distRight;\n      side = 'right';\n    }\n    if (distTop < closest) {\n      closest = distTop;\n      side = 'top';\n    }\n    if (distBottom < closest) {\n      side = 'bottom';\n    }\n    return side;\n  }\n  /**\n   * Returns a point on the boundary of the rectangle nearest to the point `p`.\n   */\n  getNearestPointToPoint(p) {\n    const ref = Point.clone(p);\n    if (this.containsPoint(ref)) {\n      const side = this.getNearestSideToPoint(ref);\n      switch (side) {\n        case 'right':\n          return new Point(this.x + this.width, ref.y);\n        case 'left':\n          return new Point(this.x, ref.y);\n        case 'bottom':\n          return new Point(ref.x, this.y + this.height);\n        case 'top':\n          return new Point(ref.x, this.y);\n        default:\n          break;\n      }\n    }\n    return ref.adhereToRect(this);\n  }\n  equals(rect) {\n    return rect != null && rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;\n  }\n  clone() {\n    return new Rectangle(this.x, this.y, this.width, this.height);\n  }\n  toJSON() {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height\n    };\n  }\n  serialize() {\n    return `${this.x} ${this.y} ${this.width} ${this.height}`;\n  }\n}\n(function (Rectangle) {\n  Rectangle.toStringTag = `X6.Geometry.${Rectangle.name}`;\n  function isRectangle(instance) {\n    if (instance == null) {\n      return false;\n    }\n    if (instance instanceof Rectangle) {\n      return true;\n    }\n    const tag = instance[Symbol.toStringTag];\n    const rect = instance;\n    if ((tag == null || tag === Rectangle.toStringTag) && typeof rect.x === 'number' && typeof rect.y === 'number' && typeof rect.width === 'number' && typeof rect.height === 'number' && typeof rect.inflate === 'function' && typeof rect.moveAndExpand === 'function') {\n      return true;\n    }\n    return false;\n  }\n  Rectangle.isRectangle = isRectangle;\n})(Rectangle || (Rectangle = {}));\n(function (Rectangle) {\n  function isRectangleLike(o) {\n    return o != null && typeof o === 'object' && typeof o.x === 'number' && typeof o.y === 'number' && typeof o.width === 'number' && typeof o.height === 'number';\n  }\n  Rectangle.isRectangleLike = isRectangleLike;\n})(Rectangle || (Rectangle = {}));\n(function (Rectangle) {\n  function create(x, y, width, height) {\n    if (x == null || typeof x === 'number') {\n      return new Rectangle(x, y, width, height);\n    }\n    return clone(x);\n  }\n  Rectangle.create = create;\n  function clone(rect) {\n    if (Rectangle.isRectangle(rect)) {\n      return rect.clone();\n    }\n    if (Array.isArray(rect)) {\n      return new Rectangle(rect[0], rect[1], rect[2], rect[3]);\n    }\n    return new Rectangle(rect.x, rect.y, rect.width, rect.height);\n  }\n  Rectangle.clone = clone;\n  function fromSize(size) {\n    return new Rectangle(0, 0, size.width, size.height);\n  }\n  Rectangle.fromSize = fromSize;\n  function fromPositionAndSize(pos, size) {\n    return new Rectangle(pos.x, pos.y, size.width, size.height);\n  }\n  Rectangle.fromPositionAndSize = fromPositionAndSize;\n  /**\n   * Returns a new rectangle from the given ellipse.\n   */\n  function fromEllipse(ellipse) {\n    return new Rectangle(ellipse.x - ellipse.a, ellipse.y - ellipse.b, 2 * ellipse.a, 2 * ellipse.b);\n  }\n  Rectangle.fromEllipse = fromEllipse;\n})(Rectangle || (Rectangle = {}));","map":{"version":3,"names":["util","Angle","Line","Point","Geometry","Rectangle","constructor","x","y","width","height","Symbol","toStringTag","left","top","right","bottom","origin","topLeft","topCenter","topRight","center","bottomLeft","bottomCenter","bottomRight","corner","rightMiddle","leftMiddle","topLine","rightLine","bottomLine","leftLine","getOrigin","getTopLeft","getTopCenter","getTopRight","getCenter","getCenterX","getCenterY","getBottomLeft","getBottomCenter","getBottomRight","getCorner","getRightMiddle","getLeftMiddle","getTopLine","getRightLine","getBottomLine","getLeftLine","bbox","angle","clone","rad","toRad","st","Math","abs","sin","ct","cos","w","h","round","precision","add","rect","create","minX","min","minY","maxX","max","maxY","update","inflate","dx","dy","snapToGrid","gx","gy","translate","tx","ty","p","scale","sx","sy","pos","rotate","degree","p1","p2","p3","p4","rotateEx","rotate90","t","tmp","moveAndExpand","ref","getMaxScaleToFit","limit","ox","oy","sx1","Infinity","sx2","sx3","sx4","sy1","sy2","sy3","sy4","getMaxUniformScaleToFit","containsPoint","containsRect","b","x1","y1","w1","h1","x2","y2","w2","h2","intersectsWithLine","line","rectLines","points","dedupeArr","forEach","l","indexOf","toString","push","length","intersectsWithLineFromCenterToPoint","result","sides","connector","i","intersection","intersectsWithRect","isIntersectWithRect","myOrigin","myCorner","rOrigin","rCorner","xx","yy","normalize","newx","newy","newwidth","newheight","union","originX","originY","cornerX","cornerY","getNearestSideToPoint","distLeft","distRight","distTop","distBottom","closest","side","getNearestPointToPoint","adhereToRect","equals","toJSON","serialize","name","isRectangle","instance","tag","isRectangleLike","o","Array","isArray","fromSize","size","fromPositionAndSize","fromEllipse","ellipse","a"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/geometry/rectangle.ts"],"sourcesContent":["import { Size } from '../types'\nimport * as util from './util'\nimport { Angle } from './angle'\nimport { Line } from './line'\nimport { Point } from './point'\nimport { Ellipse } from './ellipse'\nimport { Geometry } from './geometry'\n\nexport class Rectangle extends Geometry implements Rectangle.RectangleLike {\n  x: number\n  y: number\n  width: number\n  height: number\n\n  protected get [Symbol.toStringTag]() {\n    return Rectangle.toStringTag\n  }\n\n  get left() {\n    return this.x\n  }\n\n  get top() {\n    return this.y\n  }\n\n  get right() {\n    return this.x + this.width\n  }\n\n  get bottom() {\n    return this.y + this.height\n  }\n\n  get origin() {\n    return new Point(this.x, this.y)\n  }\n\n  get topLeft() {\n    return new Point(this.x, this.y)\n  }\n\n  get topCenter() {\n    return new Point(this.x + this.width / 2, this.y)\n  }\n\n  get topRight() {\n    return new Point(this.x + this.width, this.y)\n  }\n\n  get center() {\n    return new Point(this.x + this.width / 2, this.y + this.height / 2)\n  }\n\n  get bottomLeft() {\n    return new Point(this.x, this.y + this.height)\n  }\n\n  get bottomCenter() {\n    return new Point(this.x + this.width / 2, this.y + this.height)\n  }\n\n  get bottomRight() {\n    return new Point(this.x + this.width, this.y + this.height)\n  }\n\n  get corner() {\n    return new Point(this.x + this.width, this.y + this.height)\n  }\n\n  get rightMiddle() {\n    return new Point(this.x + this.width, this.y + this.height / 2)\n  }\n\n  get leftMiddle() {\n    return new Point(this.x, this.y + this.height / 2)\n  }\n\n  get topLine() {\n    return new Line(this.topLeft, this.topRight)\n  }\n\n  get rightLine() {\n    return new Line(this.topRight, this.bottomRight)\n  }\n\n  get bottomLine() {\n    return new Line(this.bottomLeft, this.bottomRight)\n  }\n\n  get leftLine() {\n    return new Line(this.topLeft, this.bottomLeft)\n  }\n\n  constructor(x?: number, y?: number, width?: number, height?: number) {\n    super()\n    this.x = x == null ? 0 : x\n    this.y = y == null ? 0 : y\n    this.width = width == null ? 0 : width\n    this.height = height == null ? 0 : height\n  }\n\n  getOrigin() {\n    return this.origin\n  }\n\n  getTopLeft() {\n    return this.topLeft\n  }\n\n  getTopCenter() {\n    return this.topCenter\n  }\n\n  getTopRight() {\n    return this.topRight\n  }\n\n  getCenter() {\n    return this.center\n  }\n\n  getCenterX() {\n    return this.x + this.width / 2\n  }\n\n  getCenterY() {\n    return this.y + this.height / 2\n  }\n\n  getBottomLeft() {\n    return this.bottomLeft\n  }\n\n  getBottomCenter() {\n    return this.bottomCenter\n  }\n\n  getBottomRight() {\n    return this.bottomRight\n  }\n\n  getCorner() {\n    return this.corner\n  }\n\n  getRightMiddle() {\n    return this.rightMiddle\n  }\n\n  getLeftMiddle() {\n    return this.leftMiddle\n  }\n\n  getTopLine() {\n    return this.topLine\n  }\n\n  getRightLine() {\n    return this.rightLine\n  }\n\n  getBottomLine() {\n    return this.bottomLine\n  }\n\n  getLeftLine() {\n    return this.leftLine\n  }\n\n  /**\n   * Returns a rectangle that is the bounding box of the rectangle.\n   *\n   * If `angle` is specified, the bounding box calculation will take into\n   * account the rotation of the rectangle by angle degrees around its center.\n   */\n  bbox(angle?: number) {\n    if (!angle) {\n      return this.clone()\n    }\n\n    const rad = Angle.toRad(angle)\n    const st = Math.abs(Math.sin(rad))\n    const ct = Math.abs(Math.cos(rad))\n    const w = this.width * ct + this.height * st\n    const h = this.width * st + this.height * ct\n    return new Rectangle(\n      this.x + (this.width - w) / 2,\n      this.y + (this.height - h) / 2,\n      w,\n      h,\n    )\n  }\n\n  round(precision = 0) {\n    this.x = util.round(this.x, precision)\n    this.y = util.round(this.y, precision)\n    this.width = util.round(this.width, precision)\n    this.height = util.round(this.height, precision)\n    return this\n  }\n\n  add(x: number, y: number, width: number, height: number): this\n  add(rect: Rectangle.RectangleLike | Rectangle.RectangleData): this\n  add(\n    x: number | Rectangle.RectangleLike | Rectangle.RectangleData,\n    y?: number,\n    width?: number,\n    height?: number,\n  ): this {\n    const rect = Rectangle.create(x, y, width, height)\n    const minX = Math.min(this.x, rect.x)\n    const minY = Math.min(this.y, rect.y)\n    const maxX = Math.max(this.x + this.width, rect.x + rect.width)\n    const maxY = Math.max(this.y + this.height, rect.y + rect.height)\n\n    this.x = minX\n    this.y = minY\n    this.width = maxX - minX\n    this.height = maxY - minY\n\n    return this\n  }\n\n  update(x: number, y: number, width: number, height: number): this\n  update(rect: Rectangle.RectangleLike | Rectangle.RectangleData): this\n  update(\n    x: number | Rectangle.RectangleLike | Rectangle.RectangleData,\n    y?: number,\n    width?: number,\n    height?: number,\n  ): this {\n    const rect = Rectangle.create(x, y, width, height)\n    this.x = rect.x\n    this.y = rect.y\n    this.width = rect.width\n    this.height = rect.height\n    return this\n  }\n\n  inflate(amount: number): this\n  /**\n   * Returns a rectangle inflated in axis-x by `2*dx` and in axis-y by `2*dy`.\n   */\n  inflate(dx: number, dy: number): this\n  inflate(dx: number, dy?: number): this {\n    const w = dx\n    const h = dy != null ? dy : dx\n    this.x -= w\n    this.y -= h\n    this.width += 2 * w\n    this.height += 2 * h\n\n    return this\n  }\n\n  /**\n   * Adjust the position and dimensions of the rectangle such that its edges\n   * are on the nearest increment of `gx` on the x-axis and `gy` on the y-axis.\n   */\n  snapToGrid(gridSize: number): this\n  snapToGrid(gx: number, gy: number): this\n  snapToGrid(gx: number, gy?: number): this\n  snapToGrid(gx: number, gy?: number): this {\n    const origin = this.origin.snapToGrid(gx, gy)\n    const corner = this.corner.snapToGrid(gx, gy)\n    this.x = origin.x\n    this.y = origin.y\n    this.width = corner.x - origin.x\n    this.height = corner.y - origin.y\n    return this\n  }\n\n  translate(tx: number, ty: number): this\n  translate(p: Point.PointLike | Point.PointData): this\n  translate(tx: number | Point.PointLike | Point.PointData, ty?: number): this {\n    const p = Point.create(tx, ty)\n    this.x += p.x\n    this.y += p.y\n    return this\n  }\n\n  scale(\n    sx: number,\n    sy: number,\n    origin: Point.PointLike | Point.PointData = new Point(),\n  ) {\n    const pos = this.origin.scale(sx, sy, origin)\n    this.x = pos.x\n    this.y = pos.y\n    this.width *= sx\n    this.height *= sy\n    return this\n  }\n\n  rotate(\n    degree: number,\n    center: Point.PointLike | Point.PointData = this.getCenter(),\n  ) {\n    if (degree !== 0) {\n      const rad = Angle.toRad(degree)\n      const cos = Math.cos(rad)\n      const sin = Math.sin(rad)\n\n      let p1 = this.getOrigin()\n      let p2 = this.getTopRight()\n      let p3 = this.getBottomRight()\n      let p4 = this.getBottomLeft()\n\n      p1 = Point.rotateEx(p1, cos, sin, center)\n      p2 = Point.rotateEx(p2, cos, sin, center)\n      p3 = Point.rotateEx(p3, cos, sin, center)\n      p4 = Point.rotateEx(p4, cos, sin, center)\n\n      const rect = new Rectangle(p1.x, p1.y, 0, 0)\n      rect.add(p2.x, p2.y, 0, 0)\n      rect.add(p3.x, p3.y, 0, 0)\n      rect.add(p4.x, p4.y, 0, 0)\n\n      this.update(rect)\n    }\n    return this\n  }\n\n  rotate90() {\n    const t = (this.width - this.height) / 2\n    this.x += t\n    this.y -= t\n    const tmp = this.width\n    this.width = this.height\n    this.height = tmp\n\n    return this\n  }\n\n  /**\n   * Translates the rectangle by `rect.x` and `rect.y` and expand it by\n   * `rect.width` and `rect.height`.\n   */\n  moveAndExpand(rect: Rectangle.RectangleLike | Rectangle.RectangleData) {\n    const ref = Rectangle.clone(rect)\n    this.x += ref.x || 0\n    this.y += ref.y || 0\n    this.width += ref.width || 0\n    this.height += ref.height || 0\n    return this\n  }\n\n  /**\n   * Returns an object where `sx` and `sy` give the maximum scaling that can be\n   * applied to the rectangle so that it would still fit into `limit`. If\n   * `origin` is specified, the rectangle is scaled around it; otherwise, it is\n   * scaled around its center.\n   */\n  getMaxScaleToFit(\n    limit: Rectangle.RectangleLike | Rectangle.RectangleData,\n    origin: Point = this.center,\n  ) {\n    const rect = Rectangle.clone(limit)\n    const ox = origin.x\n    const oy = origin.y\n\n    // Find the maximal possible scale for all corners, so when the scale\n    // is applied the point is still inside the rectangle.\n    let sx1 = Infinity\n    let sx2 = Infinity\n    let sx3 = Infinity\n    let sx4 = Infinity\n    let sy1 = Infinity\n    let sy2 = Infinity\n    let sy3 = Infinity\n    let sy4 = Infinity\n\n    // Top Left\n    const p1 = rect.topLeft\n    if (p1.x < ox) {\n      sx1 = (this.x - ox) / (p1.x - ox)\n    }\n    if (p1.y < oy) {\n      sy1 = (this.y - oy) / (p1.y - oy)\n    }\n\n    // Bottom Right\n    const p2 = rect.bottomRight\n    if (p2.x > ox) {\n      sx2 = (this.x + this.width - ox) / (p2.x - ox)\n    }\n    if (p2.y > oy) {\n      sy2 = (this.y + this.height - oy) / (p2.y - oy)\n    }\n\n    // Top Right\n    const p3 = rect.topRight\n    if (p3.x > ox) {\n      sx3 = (this.x + this.width - ox) / (p3.x - ox)\n    }\n    if (p3.y < oy) {\n      sy3 = (this.y - oy) / (p3.y - oy)\n    }\n\n    // Bottom Left\n    const p4 = rect.bottomLeft\n    if (p4.x < ox) {\n      sx4 = (this.x - ox) / (p4.x - ox)\n    }\n    if (p4.y > oy) {\n      sy4 = (this.y + this.height - oy) / (p4.y - oy)\n    }\n\n    return {\n      sx: Math.min(sx1, sx2, sx3, sx4),\n      sy: Math.min(sy1, sy2, sy3, sy4),\n    }\n  }\n\n  /**\n   * Returns a number that specifies the maximum scaling that can be applied to\n   * the rectangle along both axes so that it would still fit into `limit`. If\n   * `origin` is specified, the rectangle is scaled around it; otherwise, it is\n   * scaled around its center.\n   */\n  getMaxUniformScaleToFit(\n    limit: Rectangle.RectangleLike | Rectangle.RectangleData,\n    origin: Point = this.center,\n  ) {\n    const scale = this.getMaxScaleToFit(limit, origin)\n    return Math.min(scale.sx, scale.sy)\n  }\n\n  /**\n   * Returns `true` if the point is inside the rectangle (inclusive).\n   * Returns `false` otherwise.\n   */\n  containsPoint(x: number, y: number): boolean\n  containsPoint(point: Point.PointLike | Point.PointData): boolean\n  containsPoint(\n    x: number | Point.PointLike | Point.PointData,\n    y?: number,\n  ): boolean {\n    return util.containsPoint(this, Point.create(x, y))\n  }\n\n  /**\n   * Returns `true` if the rectangle is (completely) inside the\n   * rectangle (inclusive). Returns `false` otherwise.\n   */\n  containsRect(x: number, y: number, w: number, h: number): boolean\n  containsRect(rect: Rectangle.RectangleLike | Rectangle.RectangleData): boolean\n  containsRect(\n    x: number | Rectangle.RectangleLike | Rectangle.RectangleData,\n    y?: number,\n    width?: number,\n    height?: number,\n  ) {\n    const b = Rectangle.create(x, y, width, height)\n    const x1 = this.x\n    const y1 = this.y\n    const w1 = this.width\n    const h1 = this.height\n\n    const x2 = b.x\n    const y2 = b.y\n    const w2 = b.width\n    const h2 = b.height\n\n    // one of the dimensions is 0\n    if (w1 === 0 || h1 === 0 || w2 === 0 || h2 === 0) {\n      return false\n    }\n\n    return x2 >= x1 && y2 >= y1 && x2 + w2 <= x1 + w1 && y2 + h2 <= y1 + h1\n  }\n\n  /**\n   * Returns an array of the intersection points of the rectangle and the line.\n   * Return `null` if no intersection exists.\n   */\n  intersectsWithLine(line: Line) {\n    const rectLines = [\n      this.topLine,\n      this.rightLine,\n      this.bottomLine,\n      this.leftLine,\n    ]\n    const points: Point[] = []\n    const dedupeArr: string[] = []\n    rectLines.forEach((l) => {\n      const p = line.intersectsWithLine(l)\n      if (p !== null && dedupeArr.indexOf(p.toString()) < 0) {\n        points.push(p)\n        dedupeArr.push(p.toString())\n      }\n    })\n\n    return points.length > 0 ? points : null\n  }\n\n  /**\n   * Returns the point on the boundary of the rectangle that is the intersection\n   * of the rectangle with a line starting in the center the rectangle ending in\n   * the point `p`.\n   *\n   * If `angle` is specified, the intersection will take into account the\n   * rotation of the rectangle by `angle` degrees around its center.\n   */\n  intersectsWithLineFromCenterToPoint(\n    p: Point.PointLike | Point.PointData,\n    angle?: number,\n  ) {\n    const ref = Point.clone(p)\n    const center = this.center\n    let result: Point | null = null\n\n    if (angle != null && angle !== 0) {\n      ref.rotate(angle, center)\n    }\n\n    const sides = [this.topLine, this.rightLine, this.bottomLine, this.leftLine]\n    const connector = new Line(center, ref)\n\n    for (let i = sides.length - 1; i >= 0; i -= 1) {\n      const intersection = sides[i].intersectsWithLine(connector)\n      if (intersection !== null) {\n        result = intersection\n        break\n      }\n    }\n    if (result && angle != null && angle !== 0) {\n      result.rotate(-angle, center)\n    }\n\n    return result\n  }\n\n  /**\n   * Returns a rectangle that is a subtraction of the two rectangles if such an\n   * object exists (the two rectangles intersect). Returns `null` otherwise.\n   */\n  intersectsWithRect(\n    x: number,\n    y: number,\n    w: number,\n    h: number,\n  ): Rectangle | null\n  intersectsWithRect(\n    rect: Rectangle.RectangleLike | Rectangle.RectangleData,\n  ): Rectangle | null\n  intersectsWithRect(\n    x: number | Rectangle.RectangleLike | Rectangle.RectangleData,\n    y?: number,\n    width?: number,\n    height?: number,\n  ) {\n    const ref = Rectangle.create(x, y, width, height)\n\n    // no intersection\n    if (!this.isIntersectWithRect(ref)) {\n      return null\n    }\n\n    const myOrigin = this.origin\n    const myCorner = this.corner\n    const rOrigin = ref.origin\n    const rCorner = ref.corner\n\n    const xx = Math.max(myOrigin.x, rOrigin.x)\n    const yy = Math.max(myOrigin.y, rOrigin.y)\n\n    return new Rectangle(\n      xx,\n      yy,\n      Math.min(myCorner.x, rCorner.x) - xx,\n      Math.min(myCorner.y, rCorner.y) - yy,\n    )\n  }\n\n  isIntersectWithRect(x: number, y: number, w: number, h: number): boolean\n  isIntersectWithRect(\n    rect: Rectangle.RectangleLike | Rectangle.RectangleData,\n  ): boolean\n  isIntersectWithRect(\n    x: number | Rectangle.RectangleLike | Rectangle.RectangleData,\n    y?: number,\n    width?: number,\n    height?: number,\n  ) {\n    const ref = Rectangle.create(x, y, width, height)\n    const myOrigin = this.origin\n    const myCorner = this.corner\n    const rOrigin = ref.origin\n    const rCorner = ref.corner\n\n    if (\n      rCorner.x <= myOrigin.x ||\n      rCorner.y <= myOrigin.y ||\n      rOrigin.x >= myCorner.x ||\n      rOrigin.y >= myCorner.y\n    ) {\n      return false\n    }\n    return true\n  }\n\n  /**\n   * Normalize the rectangle, i.e. make it so that it has non-negative\n   * width and height. If width is less than `0`, the function swaps left and\n   * right corners and if height is less than `0`, the top and bottom corners\n   * are swapped.\n   */\n  normalize() {\n    let newx = this.x\n    let newy = this.y\n    let newwidth = this.width\n    let newheight = this.height\n    if (this.width < 0) {\n      newx = this.x + this.width\n      newwidth = -this.width\n    }\n    if (this.height < 0) {\n      newy = this.y + this.height\n      newheight = -this.height\n    }\n    this.x = newx\n    this.y = newy\n    this.width = newwidth\n    this.height = newheight\n    return this\n  }\n\n  /**\n   * Returns a rectangle that is a union of this rectangle and rectangle `rect`.\n   */\n  union(rect: Rectangle.RectangleLike | Rectangle.RectangleData) {\n    const ref = Rectangle.clone(rect)\n    const myOrigin = this.origin\n    const myCorner = this.corner\n    const rOrigin = ref.origin\n    const rCorner = ref.corner\n\n    const originX = Math.min(myOrigin.x, rOrigin.x)\n    const originY = Math.min(myOrigin.y, rOrigin.y)\n    const cornerX = Math.max(myCorner.x, rCorner.x)\n    const cornerY = Math.max(myCorner.y, rCorner.y)\n\n    return new Rectangle(originX, originY, cornerX - originX, cornerY - originY)\n  }\n\n  /**\n   * Returns a string (\"top\", \"left\", \"right\" or \"bottom\") denoting the side of\n   * the rectangle which is nearest to the point `p`.\n   */\n  getNearestSideToPoint(p: Point.PointLike | Point.PointData): Rectangle.Side {\n    const ref = Point.clone(p)\n    const distLeft = ref.x - this.x\n    const distRight = this.x + this.width - ref.x\n    const distTop = ref.y - this.y\n    const distBottom = this.y + this.height - ref.y\n    let closest = distLeft\n    let side: Rectangle.Side = 'left'\n\n    if (distRight < closest) {\n      closest = distRight\n      side = 'right'\n    }\n\n    if (distTop < closest) {\n      closest = distTop\n      side = 'top'\n    }\n\n    if (distBottom < closest) {\n      side = 'bottom'\n    }\n\n    return side\n  }\n\n  /**\n   * Returns a point on the boundary of the rectangle nearest to the point `p`.\n   */\n  getNearestPointToPoint(p: Point.PointLike | Point.PointData) {\n    const ref = Point.clone(p)\n    if (this.containsPoint(ref)) {\n      const side = this.getNearestSideToPoint(ref)\n      switch (side) {\n        case 'right':\n          return new Point(this.x + this.width, ref.y)\n        case 'left':\n          return new Point(this.x, ref.y)\n        case 'bottom':\n          return new Point(ref.x, this.y + this.height)\n        case 'top':\n          return new Point(ref.x, this.y)\n        default:\n          break\n      }\n    }\n\n    return ref.adhereToRect(this)\n  }\n\n  equals(rect: Rectangle.RectangleLike) {\n    return (\n      rect != null &&\n      rect.x === this.x &&\n      rect.y === this.y &&\n      rect.width === this.width &&\n      rect.height === this.height\n    )\n  }\n\n  clone() {\n    return new Rectangle(this.x, this.y, this.width, this.height)\n  }\n\n  toJSON() {\n    return { x: this.x, y: this.y, width: this.width, height: this.height }\n  }\n\n  serialize() {\n    return `${this.x} ${this.y} ${this.width} ${this.height}`\n  }\n}\n\nexport namespace Rectangle {\n  export const toStringTag = `X6.Geometry.${Rectangle.name}`\n\n  export function isRectangle(instance: any): instance is Rectangle {\n    if (instance == null) {\n      return false\n    }\n\n    if (instance instanceof Rectangle) {\n      return true\n    }\n\n    const tag = instance[Symbol.toStringTag]\n    const rect = instance as Rectangle\n\n    if (\n      (tag == null || tag === toStringTag) &&\n      typeof rect.x === 'number' &&\n      typeof rect.y === 'number' &&\n      typeof rect.width === 'number' &&\n      typeof rect.height === 'number' &&\n      typeof rect.inflate === 'function' &&\n      typeof rect.moveAndExpand === 'function'\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n\nexport namespace Rectangle {\n  export type RectangleData = [number, number, number, number]\n\n  export interface RectangleLike extends Point.PointLike {\n    x: number\n    y: number\n    width: number\n    height: number\n  }\n\n  export function isRectangleLike(o: any): o is RectangleLike {\n    return (\n      o != null &&\n      typeof o === 'object' &&\n      typeof o.x === 'number' &&\n      typeof o.y === 'number' &&\n      typeof o.width === 'number' &&\n      typeof o.height === 'number'\n    )\n  }\n\n  export type Side = 'left' | 'right' | 'top' | 'bottom'\n\n  export type KeyPoint =\n    | 'center'\n    | 'origin'\n    | 'corner'\n    | 'topLeft'\n    | 'topCenter'\n    | 'topRight'\n    | 'bottomLeft'\n    | 'bottomCenter'\n    | 'bottomRight'\n    | 'rightMiddle'\n    | 'leftMiddle'\n}\n\nexport namespace Rectangle {\n  export function create(rect: RectangleLike | RectangleData): Rectangle\n  export function create(\n    x?: number,\n    y?: number,\n    width?: number,\n    height?: number,\n  ): Rectangle\n  export function create(\n    x?: number | RectangleLike | RectangleData,\n    y?: number,\n    width?: number,\n    height?: number,\n  ): Rectangle\n  export function create(\n    x?: number | RectangleLike | RectangleData,\n    y?: number,\n    width?: number,\n    height?: number,\n  ): Rectangle {\n    if (x == null || typeof x === 'number') {\n      return new Rectangle(x, y, width, height)\n    }\n\n    return clone(x)\n  }\n\n  export function clone(rect: RectangleLike | RectangleData) {\n    if (Rectangle.isRectangle(rect)) {\n      return rect.clone()\n    }\n\n    if (Array.isArray(rect)) {\n      return new Rectangle(rect[0], rect[1], rect[2], rect[3])\n    }\n\n    return new Rectangle(rect.x, rect.y, rect.width, rect.height)\n  }\n\n  export function fromSize(size: Size) {\n    return new Rectangle(0, 0, size.width, size.height)\n  }\n\n  export function fromPositionAndSize(pos: Point.PointLike, size: Size) {\n    return new Rectangle(pos.x, pos.y, size.width, size.height)\n  }\n\n  /**\n   * Returns a new rectangle from the given ellipse.\n   */\n  export function fromEllipse(ellipse: Ellipse) {\n    return new Rectangle(\n      ellipse.x - ellipse.a,\n      ellipse.y - ellipse.b,\n      2 * ellipse.a,\n      2 * ellipse.b,\n    )\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}