{"ast":null,"code":"import { FunctionExt } from '../util';\nexport class Events {\n  constructor() {\n    this.listeners = {};\n  }\n  on(name, handler, context) {\n    if (handler == null) {\n      return this;\n    }\n    if (!this.listeners[name]) {\n      this.listeners[name] = [];\n    }\n    const cache = this.listeners[name];\n    cache.push(handler, context);\n    return this;\n  }\n  once(name, handler, context) {\n    const cb = (...args) => {\n      this.off(name, cb);\n      return Private.call([handler, context], args);\n    };\n    return this.on(name, cb, this);\n  }\n  off(name, handler, context) {\n    // remove all events.\n    if (!(name || handler || context)) {\n      this.listeners = {};\n      return this;\n    }\n    const listeners = this.listeners;\n    const names = name ? [name] : Object.keys(listeners);\n    names.forEach(n => {\n      const cache = listeners[n];\n      if (!cache) {\n        return;\n      }\n      // remove all events with specified name.\n      if (!(handler || context)) {\n        delete listeners[n];\n        return;\n      }\n      for (let i = cache.length - 2; i >= 0; i -= 2) {\n        if (!(handler && cache[i] !== handler || context && cache[i + 1] !== context)) {\n          cache.splice(i, 2);\n        }\n      }\n    });\n    return this;\n  }\n  trigger(name, ...args) {\n    let returned = true;\n    if (name !== '*') {\n      const list = this.listeners[name];\n      if (list != null) {\n        returned = Private.call([...list], args);\n      }\n    }\n    const list = this.listeners['*'];\n    if (list != null) {\n      return FunctionExt.toAsyncBoolean([returned, Private.call([...list], [name, ...args])]);\n    }\n    return returned;\n  }\n  emit(name, ...args) {\n    return this.trigger(name, ...args);\n  }\n}\nvar Private;\n(function (Private) {\n  function call(list, args) {\n    const results = [];\n    for (let i = 0; i < list.length; i += 2) {\n      const handler = list[i];\n      const context = list[i + 1];\n      const params = Array.isArray(args) ? args : [args];\n      const ret = FunctionExt.apply(handler, context, params);\n      results.push(ret);\n    }\n    return FunctionExt.toAsyncBoolean(results);\n  }\n  Private.call = call;\n})(Private || (Private = {}));","map":{"version":3,"names":["FunctionExt","Events","constructor","listeners","on","name","handler","context","cache","push","once","cb","args","off","Private","call","names","Object","keys","forEach","n","i","length","splice","trigger","returned","list","toAsyncBoolean","emit","results","params","Array","isArray","ret","apply"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/common/events.ts"],"sourcesContent":["import {\n  RequiredKeys,\n  OptionalKeys,\n  PickByValue,\n  OmitByValue,\n} from 'utility-types'\nimport { FunctionExt } from '../util'\n\nexport class Events<EventArgs extends Events.EventArgs = any> {\n  private listeners: { [name: string]: any[] } = {}\n\n  on<Name extends Events.EventNames<EventArgs>>(\n    name: Name,\n    handler: Events.Handler<EventArgs[Name]>,\n    context?: any,\n  ): this\n  on<Name extends Events.UnknownNames<EventArgs>>(\n    name: Name,\n    handler: Events.Handler<any>,\n    context?: any,\n  ): this\n  on<Name extends Events.EventNames<EventArgs>>(\n    name: Name,\n    handler: Events.Handler<EventArgs[Name]>,\n    context?: any,\n  ) {\n    if (handler == null) {\n      return this\n    }\n\n    if (!this.listeners[name]) {\n      this.listeners[name] = []\n    }\n    const cache = this.listeners[name]\n    cache.push(handler, context)\n\n    return this\n  }\n\n  once<Name extends Events.EventNames<EventArgs>>(\n    name: Name,\n    handler: Events.Handler<EventArgs[Name]>,\n    context?: any,\n  ): this\n  once<Name extends Events.UnknownNames<EventArgs>>(\n    name: Name,\n    handler: Events.Handler<any>,\n    context?: any,\n  ): this\n  once<Name extends Events.EventNames<EventArgs>>(\n    name: Name,\n    handler: Events.Handler<EventArgs[Name]>,\n    context?: any,\n  ) {\n    const cb = (...args: any) => {\n      this.off(name, cb as any)\n      return Private.call([handler, context], args)\n    }\n\n    return this.on(name, cb as any, this)\n  }\n\n  off(): this\n  off(name: null, handler: Events.Handler<any>): this\n  off(name: null, handler: null, context: any): this\n  off<Name extends Events.EventNames<EventArgs>>(\n    name: Name,\n    handler?: Events.Handler<EventArgs[Name]>,\n    context?: any,\n  ): this\n  off<Name extends Events.UnknownNames<EventArgs>>(\n    name: Name,\n    handler?: Events.Handler<any>,\n    context?: any,\n  ): this\n  off(\n    name?: string | null,\n    handler?: Events.Handler<any> | null,\n    context?: any,\n  ) {\n    // remove all events.\n    if (!(name || handler || context)) {\n      this.listeners = {}\n      return this\n    }\n\n    const listeners = this.listeners\n    const names = name ? [name] : Object.keys(listeners)\n\n    names.forEach((n) => {\n      const cache = listeners[n]\n      if (!cache) {\n        return\n      }\n\n      // remove all events with specified name.\n      if (!(handler || context)) {\n        delete listeners[n]\n        return\n      }\n\n      for (let i = cache.length - 2; i >= 0; i -= 2) {\n        if (\n          !(\n            (handler && cache[i] !== handler) ||\n            (context && cache[i + 1] !== context)\n          )\n        ) {\n          cache.splice(i, 2)\n        }\n      }\n    })\n\n    return this\n  }\n\n  trigger<Name extends Events.OptionalNormalNames<EventArgs>>(\n    name: Name,\n  ): FunctionExt.AsyncBoolean\n  trigger<Name extends Events.RequiredNormalNames<EventArgs>>(\n    name: Name,\n    args: EventArgs[Name],\n  ): FunctionExt.AsyncBoolean\n  trigger<Name extends Events.NamesWithArrayArgs<EventArgs>>(\n    name: Name,\n    ...args: EventArgs[Name]\n  ): FunctionExt.AsyncBoolean\n  trigger<Name extends Events.OtherNames<EventArgs>>(\n    name: Name,\n    args?: EventArgs[Name],\n  ): FunctionExt.AsyncBoolean\n  trigger<Name extends Events.OtherNames<EventArgs>>(\n    name: Name,\n    ...args: EventArgs[Name]\n  ): FunctionExt.AsyncBoolean\n  trigger<Name extends Events.UnknownNames<EventArgs>>(\n    name: Name,\n    ...args: any[]\n  ): FunctionExt.AsyncBoolean\n  trigger<Name extends Events.EventNames<EventArgs>>(\n    name: Name,\n    ...args: any[]\n  ) {\n    let returned: FunctionExt.AsyncBoolean = true\n    if (name !== '*') {\n      const list = this.listeners[name]\n      if (list != null) {\n        returned = Private.call([...list], args)\n      }\n    }\n\n    const list = this.listeners['*']\n    if (list != null) {\n      return FunctionExt.toAsyncBoolean([\n        returned,\n        Private.call([...list], [name, ...args]),\n      ])\n    }\n\n    return returned\n  }\n\n  /**\n   * Triggers event with specified event name. Unknown names\n   * will cause a typescript type error.\n   */\n  protected emit<Name extends Events.OptionalNormalNames<EventArgs>>(\n    name: Name,\n  ): FunctionExt.AsyncBoolean\n  protected emit<Name extends Events.RequiredNormalNames<EventArgs>>(\n    name: Name,\n    args: EventArgs[Name],\n  ): FunctionExt.AsyncBoolean\n  protected emit<Name extends Events.NamesWithArrayArgs<EventArgs>>(\n    name: Name,\n    ...args: EventArgs[Name]\n  ): FunctionExt.AsyncBoolean\n  protected emit<Name extends Events.OtherNames<EventArgs>>(\n    name: Name,\n    args?: EventArgs[Name],\n  ): FunctionExt.AsyncBoolean\n  protected emit<Name extends Events.OtherNames<EventArgs>>(\n    name: Name,\n    ...args: EventArgs[Name]\n  ): FunctionExt.AsyncBoolean\n  protected emit(name: any, ...args: any[]) {\n    return this.trigger(name, ...args)\n  }\n}\n\nexport namespace Events {\n  export type Handler<Args> = Args extends null | undefined\n    ? () => any\n    : Args extends any[]\n    ? (...args: Args) => any\n    : (args: Args) => any\n\n  export type EventArgs = { [key: string]: any }\n\n  export type EventNames<M extends EventArgs> = Extract<keyof M, string>\n\n  /**\n   * Get union type of keys from `M` that value matching `any[]`.\n   */\n  export type NamesWithArrayArgs<M extends EventArgs> = RequiredKeys<\n    PickByValue<M, any[]>\n  >\n\n  export type NotArrayValueMap<M extends EventArgs> = OmitByValue<M, any[]>\n\n  export type OptionalNormalNames<M extends EventArgs> = OptionalKeys<\n    NotArrayValueMap<M>\n  >\n\n  export type RequiredNormalNames<M extends EventArgs> = RequiredKeys<\n    NotArrayValueMap<M>\n  >\n\n  export type OtherNames<M extends EventArgs> = EventNames<\n    PickByValue<M, undefined>\n  >\n\n  export type UnknownNames<M extends EventArgs> = Exclude<string, EventNames<M>>\n}\n\nnamespace Private {\n  export function call(list: any[], args?: any[]) {\n    const results: any[] = []\n    for (let i = 0; i < list.length; i += 2) {\n      const handler = list[i]\n      const context = list[i + 1]\n      const params = Array.isArray(args) ? args : [args]\n      const ret = FunctionExt.apply(handler, context, params)\n      results.push(ret)\n    }\n\n    return FunctionExt.toAsyncBoolean(results)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}