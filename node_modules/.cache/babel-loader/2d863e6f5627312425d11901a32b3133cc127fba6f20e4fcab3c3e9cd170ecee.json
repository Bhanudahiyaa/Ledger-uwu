{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { getDefaultDomain } from '@antv/l7-utils';\nimport BaseModel from \"../../core/BaseModel\";\nimport { RasterImageTriangulation } from \"../../core/triangulation\";\n/* babel-plugin-inline-import '../shaders/terrain/terrain_rgb_frag.glsl' */\nconst Raster_terrainFrag = \"uniform sampler2D u_texture;\\nuniform sampler2D u_colorTexture;\\n\\nlayout(std140) uniform commonUniforms {\\n vec4 u_unpack;\\n vec2 u_domain;\\n float u_opacity;\\n float u_noDataValue;\\n float u_clampLow;\\n float u_clampHigh;\\n};\\n\\nin vec2 v_texCoord;\\nout vec4 outputColor;\\n\\n\\nfloat getElevation(vec2 coord, float bias) {\\n    // Convert encoded elevation value to meters\\n    vec4 data =  texture(SAMPLER_2D(u_texture), coord,bias) * 255.0;\\n    data.a = -1.0;\\n    return dot(data, u_unpack);\\n}\\n\\nvec4 getColor(float value) {\\n   float normalisedValue =(value- u_domain[0]) / (u_domain[1] - u_domain[0]);\\n    vec2 coord = vec2(normalisedValue, 0);\\n    return  texture(SAMPLER_2D(u_colorTexture), coord);\\n}\\n\\nvoid main() {\\n  float value = getElevation(v_texCoord,0.0);\\n  if (value == u_noDataValue) {\\n    outputColor = vec4(0.0, 0, 0, 0.0);\\n  } else if ((u_clampLow < 0.5 && value < u_domain[0]) || (u_clampHigh < 0.5 && value > u_domain[1])) {\\n     outputColor = vec4(0.0, 0, 0, 0.0);\\n  } else {\\n   \\n    outputColor = getColor(value);\\n    outputColor.a =  outputColor.a * u_opacity ;\\n      if(outputColor.a < 0.01)\\n      discard;\\n  }\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/terrain/terrain_rgb_vert.glsl' */\nconst Raster_terrainVert = \"layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\\n\\nlayout(std140) uniform commonUniforms {\\n  vec4 u_unpack;\\n  vec2 u_domain;\\n  float u_opacity;\\n  float u_noDataValue;\\n  float u_clampLow;\\n  float u_clampHigh;\\n};\\nout vec2 v_texCoord;\\n#pragma include \\\"projection\\\"\\n\\nvoid main() {\\n  v_texCoord = a_Uv;\\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, 0.0, 1.0));\\n}\\n\";\nexport default class RasterTerrainRGB extends BaseModel {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"texture\", void 0);\n  }\n  get attributeLocation() {\n    return Object.assign(super.attributeLocation, {\n      MAX: super.attributeLocation.MAX,\n      UV: 9\n    });\n  }\n  getCommonUniformsInfo() {\n    const {\n      opacity,\n      clampLow = true,\n      clampHigh = true,\n      noDataValue = -9999999,\n      domain,\n      rampColors,\n      colorTexture,\n      rScaler = 6553.6,\n      gScaler = 25.6,\n      bScaler = 0.1,\n      offset = 10000\n    } = this.layer.getLayerConfig();\n    const newdomain = domain || getDefaultDomain(rampColors);\n    let texture = colorTexture;\n    if (!colorTexture) {\n      texture = this.layer.textureService.getColorTexture(rampColors, newdomain);\n    } else {\n      this.layer.textureService.setColorTexture(colorTexture, rampColors, newdomain);\n    }\n    const commonOptions = {\n      u_unpack: [rScaler, gScaler, bScaler, offset],\n      u_domain: newdomain,\n      u_opacity: opacity || 1,\n      u_noDataValue: noDataValue,\n      u_clampLow: clampLow,\n      u_clampHigh: typeof clampHigh !== 'undefined' ? clampHigh : clampLow,\n      u_texture: this.texture,\n      u_colorTexture: texture\n    };\n    this.textures = [this.texture, texture];\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.initUniformsBuffer();\n      const source = _this.layer.getSource();\n      const {\n        createTexture2D\n      } = _this.rendererService;\n      const imageData = yield source.data.images;\n      _this.texture = createTexture2D({\n        data: imageData[0],\n        width: imageData[0].width,\n        height: imageData[0].height,\n        min: gl.LINEAR,\n        mag: gl.LINEAR\n      });\n      const model = yield _this.layer.buildLayerModel({\n        moduleName: 'RasterTileDataImage',\n        vertexShader: Raster_terrainVert,\n        fragmentShader: Raster_terrainFrag,\n        defines: _this.getDefines(),\n        triangulation: RasterImageTriangulation,\n        primitive: gl.TRIANGLES,\n        depth: {\n          enable: false\n        }\n      });\n      return [model];\n    })();\n  }\n  clearModels() {\n    var _this$texture;\n    (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      return _this2.initModels();\n    })();\n  }\n  registerBuiltinAttributes() {\n    // 注册 Position 属性 64 位地位部分，经纬度数据开启双精度，避免大于 22 层级以上出现数据偏移\n    this.registerPosition64LowAttribute();\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'uv',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Uv',\n        shaderLocation: this.attributeLocation.UV,\n        buffer: {\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 2,\n        update: (feature, featureIdx, vertex) => {\n          return [vertex[3], vertex[4]];\n        }\n      }\n    });\n  }\n}","map":{"version":3,"names":["_asyncToGenerator","_defineProperty","AttributeType","gl","getDefaultDomain","BaseModel","RasterImageTriangulation","Raster_terrainFrag","Raster_terrainVert","RasterTerrainRGB","constructor","args","attributeLocation","Object","assign","MAX","UV","getCommonUniformsInfo","opacity","clampLow","clampHigh","noDataValue","domain","rampColors","colorTexture","rScaler","gScaler","bScaler","offset","layer","getLayerConfig","newdomain","texture","textureService","getColorTexture","setColorTexture","commonOptions","u_unpack","u_domain","u_opacity","u_noDataValue","u_clampLow","u_clampHigh","u_texture","u_colorTexture","textures","commonBufferInfo","getUniformsBufferInfo","initModels","_this","initUniformsBuffer","source","getSource","createTexture2D","rendererService","imageData","data","images","width","height","min","LINEAR","mag","model","buildLayerModel","moduleName","vertexShader","fragmentShader","defines","getDefines","triangulation","primitive","TRIANGLES","depth","enable","clearModels","_this$texture","destroy","buildModels","_this2","registerBuiltinAttributes","registerPosition64LowAttribute","styleAttributeService","registerStyleAttribute","name","type","Attribute","descriptor","shaderLocation","buffer","usage","DYNAMIC_DRAW","FLOAT","size","update","feature","featureIdx","vertex"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/l7-layers/es/raster/models/rasterTerrainRgb.js"],"sourcesContent":["import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { getDefaultDomain } from '@antv/l7-utils';\nimport BaseModel from \"../../core/BaseModel\";\nimport { RasterImageTriangulation } from \"../../core/triangulation\";\n/* babel-plugin-inline-import '../shaders/terrain/terrain_rgb_frag.glsl' */\nconst Raster_terrainFrag = \"uniform sampler2D u_texture;\\nuniform sampler2D u_colorTexture;\\n\\nlayout(std140) uniform commonUniforms {\\n vec4 u_unpack;\\n vec2 u_domain;\\n float u_opacity;\\n float u_noDataValue;\\n float u_clampLow;\\n float u_clampHigh;\\n};\\n\\nin vec2 v_texCoord;\\nout vec4 outputColor;\\n\\n\\nfloat getElevation(vec2 coord, float bias) {\\n    // Convert encoded elevation value to meters\\n    vec4 data =  texture(SAMPLER_2D(u_texture), coord,bias) * 255.0;\\n    data.a = -1.0;\\n    return dot(data, u_unpack);\\n}\\n\\nvec4 getColor(float value) {\\n   float normalisedValue =(value- u_domain[0]) / (u_domain[1] - u_domain[0]);\\n    vec2 coord = vec2(normalisedValue, 0);\\n    return  texture(SAMPLER_2D(u_colorTexture), coord);\\n}\\n\\nvoid main() {\\n  float value = getElevation(v_texCoord,0.0);\\n  if (value == u_noDataValue) {\\n    outputColor = vec4(0.0, 0, 0, 0.0);\\n  } else if ((u_clampLow < 0.5 && value < u_domain[0]) || (u_clampHigh < 0.5 && value > u_domain[1])) {\\n     outputColor = vec4(0.0, 0, 0, 0.0);\\n  } else {\\n   \\n    outputColor = getColor(value);\\n    outputColor.a =  outputColor.a * u_opacity ;\\n      if(outputColor.a < 0.01)\\n      discard;\\n  }\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/terrain/terrain_rgb_vert.glsl' */\nconst Raster_terrainVert = \"layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\\n\\nlayout(std140) uniform commonUniforms {\\n  vec4 u_unpack;\\n  vec2 u_domain;\\n  float u_opacity;\\n  float u_noDataValue;\\n  float u_clampLow;\\n  float u_clampHigh;\\n};\\nout vec2 v_texCoord;\\n#pragma include \\\"projection\\\"\\n\\nvoid main() {\\n  v_texCoord = a_Uv;\\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, 0.0, 1.0));\\n}\\n\";\nexport default class RasterTerrainRGB extends BaseModel {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"texture\", void 0);\n  }\n  get attributeLocation() {\n    return Object.assign(super.attributeLocation, {\n      MAX: super.attributeLocation.MAX,\n      UV: 9\n    });\n  }\n  getCommonUniformsInfo() {\n    const {\n      opacity,\n      clampLow = true,\n      clampHigh = true,\n      noDataValue = -9999999,\n      domain,\n      rampColors,\n      colorTexture,\n      rScaler = 6553.6,\n      gScaler = 25.6,\n      bScaler = 0.1,\n      offset = 10000\n    } = this.layer.getLayerConfig();\n    const newdomain = domain || getDefaultDomain(rampColors);\n    let texture = colorTexture;\n    if (!colorTexture) {\n      texture = this.layer.textureService.getColorTexture(rampColors, newdomain);\n    } else {\n      this.layer.textureService.setColorTexture(colorTexture, rampColors, newdomain);\n    }\n    const commonOptions = {\n      u_unpack: [rScaler, gScaler, bScaler, offset],\n      u_domain: newdomain,\n      u_opacity: opacity || 1,\n      u_noDataValue: noDataValue,\n      u_clampLow: clampLow,\n      u_clampHigh: typeof clampHigh !== 'undefined' ? clampHigh : clampLow,\n      u_texture: this.texture,\n      u_colorTexture: texture\n    };\n    this.textures = [this.texture, texture];\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.initUniformsBuffer();\n      const source = _this.layer.getSource();\n      const {\n        createTexture2D\n      } = _this.rendererService;\n      const imageData = yield source.data.images;\n      _this.texture = createTexture2D({\n        data: imageData[0],\n        width: imageData[0].width,\n        height: imageData[0].height,\n        min: gl.LINEAR,\n        mag: gl.LINEAR\n      });\n      const model = yield _this.layer.buildLayerModel({\n        moduleName: 'RasterTileDataImage',\n        vertexShader: Raster_terrainVert,\n        fragmentShader: Raster_terrainFrag,\n        defines: _this.getDefines(),\n        triangulation: RasterImageTriangulation,\n        primitive: gl.TRIANGLES,\n        depth: {\n          enable: false\n        }\n      });\n      return [model];\n    })();\n  }\n  clearModels() {\n    var _this$texture;\n    (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      return _this2.initModels();\n    })();\n  }\n  registerBuiltinAttributes() {\n    // 注册 Position 属性 64 位地位部分，经纬度数据开启双精度，避免大于 22 层级以上出现数据偏移\n    this.registerPosition64LowAttribute();\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'uv',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Uv',\n        shaderLocation: this.attributeLocation.UV,\n        buffer: {\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 2,\n        update: (feature, featureIdx, vertex) => {\n          return [vertex[3], vertex[4]];\n        }\n      }\n    });\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}