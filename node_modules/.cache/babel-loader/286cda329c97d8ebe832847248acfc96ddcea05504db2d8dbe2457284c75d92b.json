{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { rgb2arr } from '@antv/l7-utils';\nimport BaseModel from \"../../core/BaseModel\";\nimport { polygonTriangulation } from \"../../core/triangulation\";\n/* babel-plugin-inline-import '../shaders/ocean/ocean_frag.glsl' */\nconst ocean_frag = \"\\nlayout(std140) uniform commonUniforms {\\n  vec4 u_watercolor;\\n  vec4 u_watercolor2;\\n  float u_time;\\n};\\n\\nin vec2 v_uv;\\nin float v_opacity;\\nout vec4 outputColor;\\n\\nfloat coast2water_fadedepth = 0.10;\\nfloat large_waveheight      = .750; // change to adjust the \\\"heavy\\\" waves\\nfloat large_wavesize        = 3.4;  // factor to adjust the large wave size\\nfloat small_waveheight      = 0.6;  // change to adjust the small random waves\\nfloat small_wavesize        = 0.5;   // factor to ajust the small wave size\\nfloat water_softlight_fact  = 15.;  // range [1..200] (should be << smaller than glossy-fact)\\nfloat water_glossylight_fact= 120.; // range [1..200]\\nfloat particle_amount       = 70.;\\n\\nvec3 water_specularcolor    = vec3(1.3, 1.3, 0.9);    // specular Color (RGB) of the water-highlights\\n#define light                 vec3(-0., sin(u_time*0.5)*.5 + .35, 2.8) // position of the sun\\n\\nuniform sampler2D u_texture1;\\nuniform sampler2D u_texture2;\\nuniform sampler2D u_texture3;\\n\\n  \\n\\nfloat hash( float n ) {\\n    return fract(sin(n)*43758.5453123);\\n}\\n\\n// 2d noise function\\nfloat noise1( in vec2 x ) {\\n  vec2 p  = floor(x);\\n  vec2 f  = smoothstep(0.0, 1.0, fract(x));\\n  float n = p.x + p.y*57.0;\\n  return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\\n}\\n\\nfloat noise(vec2 p) {\\n    return texture(SAMPLER_2D(u_texture2),p*vec2(1./256.)).x;\\n}\\n\\nvec4 highness(vec2 p) {\\n    vec4 t = texture(SAMPLER_2D(u_texture1),fract(p));\\n    float clipped = -2.0-smoothstep(3.,10.,t.a)*6.9-smoothstep(10.,100.,t.a)*89.9-smoothstep(0.,10000.,t.a)*10000.0;\\n    return clamp(t, 0.0,3.0)+clamp(t/3.0-1.0, 0.0,1.0)+clamp(t/16.0-1.0, 0.0,1.0);\\n}\\n\\nfloat height_map( vec2 p ) {\\n    vec4 height=highness(p);\\n    /*\\n    height = -0.5+\\n        0.5*smoothstep(-100.,0.,-height)+\\n        2.75*smoothstep(0.,2.,height)+\\n        1.75*smoothstep(2.,4.,height)+\\n        2.75*smoothstep(4.,16.,height)+\\n        1.5*smoothstep(16.,1000.,height);\\n    */\\n\\n    mat2 m = mat2( 0.9563*1.4,  -0.2924*1.4,  0.2924*1.4,  0.9563*1.4 );\\n    //p = p*6.;\\n    float f = 0.6000*noise1( p ); p = m*p*1.1*6.;\\n    f += 0.2500*noise( p ); p = m*p*1.32;\\n    f += 0.1666*noise( p ); p = m*p*1.11;\\n    f += 0.0834*noise( p ); p = m*p*1.12;\\n    f += 0.0634*noise( p ); p = m*p*1.13;\\n    f += 0.0444*noise( p ); p = m*p*1.14;\\n    f += 0.0274*noise( p ); p = m*p*1.15;\\n    f += 0.0134*noise( p ); p = m*p*1.16;\\n    f += 0.0104*noise( p ); p = m*p*1.17;\\n    f += 0.0084*noise( p );\\n    f = .25*f+dot(height,vec4(-.03125,-.125,.25,.25))*.5;\\n        const float FLAT_LEVEL = 0.92525;\\n        //f = f*0.25+height*0.75;\\n    if (f<FLAT_LEVEL)\\n        f = f;\\n    else\\n        f = pow((f-FLAT_LEVEL)/(1.-FLAT_LEVEL), 2.)*(1.-FLAT_LEVEL)*2.0+FLAT_LEVEL; // makes a smooth coast-increase\\n    return clamp(f, 0., 10.);\\n}\\n\\nvec3 plasma_quintic( float x ) {\\n    x = clamp( x, 0.0, 1.0);\\n    vec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\\n    vec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\\n    return vec3(\\n        dot( x1.xyzw, vec4( +0.063861086, +1.992659096, -1.023901152, -0.490832805 ) ) + dot( x2.xy, vec2( +1.308442123, -0.914547012 ) ),\\n        dot( x1.xyzw, vec4( +0.049718590, -0.791144343, +2.892305078, +0.811726816 ) ) + dot( x2.xy, vec2( -4.686502417, +2.717794514 ) ),\\n        dot( x1.xyzw, vec4( +0.513275779, +1.580255060, -5.164414457, +4.559573646 ) ) + dot( x2.xy, vec2( -1.916810682, +0.570638854 ) ) );\\n}\\n\\nvec4 color(vec2 p){\\n    vec4 c1 = vec4(1.7,1.6,.9,1);\\n    vec4 c2 = vec4(.2,.94,.1,1);\\n    vec4 c3 = vec4(.3,.2,.0,1);\\n    vec4 c4 = vec4(.99,.99,1.6,1);\\n    vec4 v = highness(p);\\n    float los = smoothstep(0.1,1.1,v.b);\\n    float his = smoothstep(3.5,6.5,v.b);\\n    float ces = smoothstep(1.,5.,v.a);\\n    vec4 lo = mix(c1,c2,los);\\n    vec4 hi = mix(c3,c4,his);\\n    vec4 ce = mix(lo,hi,ces);\\n\\n    return vec4(plasma_quintic(ces),1).ragb;\\n}\\n\\nvec3 terrain_map( vec2 p )\\n{\\n  return color(p).rgb*0.75+0.25*vec3(0.7, .55, .4)+texture(SAMPLER_2D(u_texture3), fract(p*5.)).rgb*.5; // test-terrain is simply 'sandstone'\\n}\\n\\nconst mat2 m = mat2( 0.72, -1.60,  1.60,  0.72 );\\n\\nfloat water_map( vec2 p, float height ) {\\n    vec2 p2 = p*large_wavesize;\\n    vec2 shift1 = 0.001*vec2( u_time*160.0*2.0, u_time*120.0*2.0 );\\n    vec2 shift2 = 0.001*vec2( u_time*190.0*2.0, -u_time*130.0*2.0 );\\n\\n    // coarse crossing 'ocean' waves...\\n    float f = 0.6000*noise( p );\\n    f += 0.2500*noise( p*m );\\n    f += 0.1666*noise( p*m*m );\\n    float wave = sin(p2.x*0.622+p2.y*0.622+shift2.x*4.269)*large_waveheight*f*height*height ;\\n\\n    p *= small_wavesize;\\n    f = 0.;\\n    float amp = 1.0, s = .5;\\n    for (int i=0; i<9; i++)\\n    { p = m*p*.947; f -= amp*abs(sin((noise( p+shift1*s )-.5)*2.)); amp = amp*.59; s*=-1.329; }\\n    \\n    return wave+f*small_waveheight;\\n}\\n\\nfloat nautic(vec2 p) {\\n    p *= 18.;\\n    float f = 0.;\\n    float amp = 1.0, s = .5;\\n    for (int i=0; i<3; i++)\\n    { p = m*p*1.2; f += amp*abs(smoothstep(0., 1., noise( p+u_time*s ))-.5); amp = amp*.5; s*=-1.227; }\\n    return pow(1.-f, 5.);\\n}\\n\\nfloat particles(vec2 p) {\\n    p *= 200.;\\n    float f = 0.;\\n    float amp = 1.0, s = 1.5;\\n    for (int i=0; i<3; i++)\\n    { p = m*p*1.2; f += amp*noise( p+u_time*s ); amp = amp*.5; s*=-1.227; }\\n    return pow(f*.35, 7.)*particle_amount;\\n}\\n\\nfloat test_shadow( vec2 xy, float height) {\\n    vec3 r0 = vec3(xy, height);\\n    vec3 rd = normalize( light - r0 );\\n    \\n    float hit = 1.0;\\n    float t   = 0.001;\\n    for (int j=1; j<25; j++)\\n    {\\n        vec3 p = r0 + t*rd;\\n        float h = height_map( p.xy );\\n        float height_diff = p.z - h;\\n        if (height_diff<0.0)\\n        {\\n            return 0.0;\\n        }\\n        t += 0.01+height_diff*.02;\\n        hit = min(hit, 2.*height_diff/t); // soft shaddow   \\n    }\\n    return hit;\\n}\\n\\nvec3 CalcTerrain(vec2 uv, float height) {\\n    vec3 col = terrain_map( uv );\\n    vec2 iResolution = vec2(512.);\\n    float h1 = height_map(uv-vec2(0., 0.5)/ iResolution.xy);\\n    float h2 = height_map(uv+vec2(0., 0.5)/ iResolution.xy);\\n    float h3 = height_map(uv-vec2(0.5, 0.)/ iResolution.xy);\\n    float h4 = height_map(uv+vec2(0.5, 0.)/ iResolution.xy);\\n    vec3 norm = normalize(vec3(h3-h4, h1-h2, 1.));\\n    vec3 r0 = vec3(uv, height);\\n    vec3 rd = normalize( light - r0 );\\n    float grad = dot(norm, rd);\\n    col *= grad+pow(grad, 8.);\\n    float terrainshade = test_shadow( uv, height );\\n    col = mix(col*.25, col, terrainshade);\\n    return col;\\n}\\n\\n\\nvoid main() {\\n  vec3 watercolor = u_watercolor.rgb;\\n  vec3 watercolor2 = u_watercolor2.rgb;\\n  vec2 uv = v_uv;\\n  float WATER_LEVEL = 0.84; // Water level (range: 0.0 - 2.0)\\n  float deepwater_fadedepth   = 0.4 + coast2water_fadedepth;\\n  float height = height_map( uv );\\n  vec3 col;\\n\\n    float waveheight = clamp(WATER_LEVEL*3.-1.5, 0., 1.);\\n    float level = WATER_LEVEL + .2*water_map(uv*15. + vec2(u_time*.1), waveheight);\\n    if (height > level)\\n    {\\n        col = CalcTerrain(uv, height);\\n    }\\n    if (height <= level)\\n    {\\n        vec2 dif = vec2(.0, .01);\\n        vec2 pos = uv*15. + vec2(u_time*.01);\\n        float h1 = water_map(pos-dif,waveheight);\\n        float h2 = water_map(pos+dif,waveheight);\\n        float h3 = water_map(pos-dif.yx,waveheight);\\n        float h4 = water_map(pos+dif.yx,waveheight);\\n        vec3 normwater = normalize(vec3(h3-h4, h1-h2, .125)); // norm-vector of the 'bumpy' water-plane\\n        uv += normwater.xy*.002*(level-height);\\n        \\n        col = CalcTerrain(uv, height);\\n\\n        float coastfade = clamp((level-height)/coast2water_fadedepth, 0., 1.);\\n        float coastfade2= clamp((level-height)/deepwater_fadedepth, 0., 1.);\\n        float intensity = col.r*.2126+col.g*.7152+col.b*.0722;\\n        watercolor = mix(watercolor*intensity, watercolor2, smoothstep(0., 1., coastfade2));\\n\\n        vec3 r0 = vec3(uv, WATER_LEVEL);\\n        vec3 rd = normalize( light - r0 ); // ray-direction to the light from water-position\\n        float grad     = dot(normwater, rd); // dot-product of norm-vector and light-direction\\n        float specular = pow(grad, water_softlight_fact);  // used for soft highlights                          \\n        float specular2= pow(grad, water_glossylight_fact); // used for glossy highlights\\n        float gradpos  = dot(vec3(0., 0., 1.), rd);\\n        float specular1= smoothstep(0., 1., pow(gradpos, 5.));  // used for diffusity (some darker corona around light's specular reflections...)                          \\n        float watershade  = test_shadow( uv, level );\\n        watercolor *= 2.2+watershade;\\n        watercolor += (.2+.8*watershade) * ((grad-1.0)*.5+specular) * .25;\\n        watercolor /= (1.+specular1*1.25);\\n        watercolor += watershade*specular2*water_specularcolor;\\n        watercolor += watershade*coastfade*(1.-coastfade2)*(vec3(.5, .6, .7)*nautic(uv)+vec3(1., 1., 1.)*particles(uv));\\n        \\n        col = mix(col, watercolor, coastfade);\\n    }\\n    \\n  outputColor = vec4(col, v_opacity);  \\n}\\n\";\n/* babel-plugin-inline-import '../shaders/ocean/ocean_vert.glsl' */\nconst ocean_vert = \"layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_uv;\\n\\nlayout(std140) uniform commonUniforms {\\n  vec4 u_watercolor;\\n  vec4 u_watercolor2;\\n  float u_time;\\n};\\n\\nout vec2 v_uv;\\nout float v_opacity;\\n\\n#pragma include \\\"projection\\\"\\n\\nvoid main() {\\n  v_uv = a_uv;\\n  v_opacity = opacity;\\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\\n}\\n\\n\";\nexport default class OceanModel extends BaseModel {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"texture1\", void 0);\n    _defineProperty(this, \"texture2\", void 0);\n    _defineProperty(this, \"texture3\", void 0);\n  }\n  get attributeLocation() {\n    return Object.assign(super.attributeLocation, {\n      MAX: super.attributeLocation.MAX,\n      UV: 9\n    });\n  }\n  getUninforms() {\n    const commoninfo = this.getCommonUniformsInfo();\n    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());\n    this.updateStyleUnifoms();\n    return _objectSpread(_objectSpread({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);\n  }\n  getCommonUniformsInfo() {\n    const {\n      watercolor = '#6D99A8',\n      watercolor2 = '#0F121C'\n    } = this.layer.getLayerConfig();\n    const commonOptions = {\n      u_watercolor: rgb2arr(watercolor),\n      u_watercolor2: rgb2arr(watercolor2),\n      u_time: this.layer.getLayerAnimateTime(),\n      u_texture1: this.texture1,\n      u_texture2: this.texture2,\n      u_texture3: this.texture3\n    };\n\n    // u_opacity: isNumber(opacity) ? opacity : 1.0,\n    this.textures = [this.texture1, this.texture2, this.texture3];\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  getAnimateUniforms() {\n    return {\n      u_time: this.layer.getLayerAnimateTime()\n    };\n  }\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.loadTexture();\n      return _this.buildModels();\n    })();\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.initUniformsBuffer();\n      const model = yield _this2.layer.buildLayerModel({\n        moduleName: 'polygonOcean',\n        vertexShader: ocean_vert,\n        fragmentShader: ocean_frag,\n        defines: _this2.getDefines(),\n        inject: _this2.getInject(),\n        triangulation: polygonTriangulation,\n        primitive: gl.TRIANGLES,\n        depth: {\n          enable: false\n        }\n      });\n      return [model];\n    })();\n  }\n  clearModels() {\n    var _this$texture, _this$texture2, _this$texture3;\n    (_this$texture = this.texture1) === null || _this$texture === void 0 || _this$texture.destroy();\n    (_this$texture2 = this.texture2) === null || _this$texture2 === void 0 || _this$texture2.destroy();\n    (_this$texture3 = this.texture3) === null || _this$texture3 === void 0 || _this$texture3.destroy();\n  }\n  registerBuiltinAttributes() {\n    const bbox = this.layer.getSource().extent;\n    const [minLng, minLat, maxLng, maxLat] = bbox;\n    const lngLen = maxLng - minLng;\n    const latLen = maxLat - minLat;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'oceanUv',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_uv',\n        shaderLocation: this.attributeLocation.UV,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.STATIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 2,\n        update: (feature, featureIdx, vertex) => {\n          const [lng, lat] = vertex;\n          return [(lng - minLng) / lngLen, (lat - minLat) / latLen];\n        }\n      }\n    });\n  }\n  loadTexture() {\n    const {\n      createTexture2D\n    } = this.rendererService;\n    const defaultTextureOptions = {\n      height: 0,\n      width: 0\n    };\n    // 默认索引为 undefined，所以单独赋值\n    this.texture1 = createTexture2D(defaultTextureOptions);\n    this.texture2 = createTexture2D(defaultTextureOptions);\n    this.texture3 = createTexture2D(defaultTextureOptions);\n\n    // 加载完 image 后单独给 texture f赋值\n    initImage(images => {\n      this.texture1 = initTex(images[0]);\n      this.texture2 = initTex(images[1]);\n      this.texture3 = initTex(images[2]);\n      this.layerService.reRender();\n    });\n    function initImage(callback) {\n      let loadedCount = 0;\n      const loadedImages = [];\n      const images = ['https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*EojwT4VzSiYAAAAAAAAAAAAAARQnAQ', 'https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*MJ22QbpuCzIAAAAAAAAAAAAAARQnAQ', 'https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*-z2HSIVDsHIAAAAAAAAAAAAAARQnAQ'];\n      images.map(imgSrc => {\n        const image = new Image();\n        image.crossOrigin = '';\n        image.src = imgSrc;\n        loadedImages.push(image);\n        image.onload = () => {\n          loadedCount++;\n          if (loadedCount === 3) {\n            callback(loadedImages);\n          }\n        };\n      });\n    }\n    function initTex(image) {\n      return createTexture2D({\n        data: image,\n        width: image.width,\n        height: image.height,\n        wrapS: gl.MIRRORED_REPEAT,\n        wrapT: gl.MIRRORED_REPEAT,\n        min: gl.LINEAR,\n        mag: gl.LINEAR\n      });\n    }\n  }\n}","map":{"version":3,"names":["_asyncToGenerator","_objectSpread","_defineProperty","AttributeType","gl","rgb2arr","BaseModel","polygonTriangulation","ocean_frag","ocean_vert","OceanModel","constructor","args","attributeLocation","Object","assign","MAX","UV","getUninforms","commoninfo","getCommonUniformsInfo","attributeInfo","getUniformsBufferInfo","getStyleAttribute","updateStyleUnifoms","uniformsOption","watercolor","watercolor2","layer","getLayerConfig","commonOptions","u_watercolor","u_watercolor2","u_time","getLayerAnimateTime","u_texture1","texture1","u_texture2","texture2","u_texture3","texture3","textures","commonBufferInfo","getAnimateUniforms","initModels","_this","loadTexture","buildModels","_this2","initUniformsBuffer","model","buildLayerModel","moduleName","vertexShader","fragmentShader","defines","getDefines","inject","getInject","triangulation","primitive","TRIANGLES","depth","enable","clearModels","_this$texture","_this$texture2","_this$texture3","destroy","registerBuiltinAttributes","bbox","getSource","extent","minLng","minLat","maxLng","maxLat","lngLen","latLen","styleAttributeService","registerStyleAttribute","name","type","Attribute","descriptor","shaderLocation","buffer","usage","STATIC_DRAW","data","FLOAT","size","update","feature","featureIdx","vertex","lng","lat","createTexture2D","rendererService","defaultTextureOptions","height","width","initImage","images","initTex","layerService","reRender","callback","loadedCount","loadedImages","map","imgSrc","image","Image","crossOrigin","src","push","onload","wrapS","MIRRORED_REPEAT","wrapT","min","LINEAR","mag"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/l7-layers/es/polygon/models/ocean.js"],"sourcesContent":["import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { rgb2arr } from '@antv/l7-utils';\nimport BaseModel from \"../../core/BaseModel\";\nimport { polygonTriangulation } from \"../../core/triangulation\";\n/* babel-plugin-inline-import '../shaders/ocean/ocean_frag.glsl' */\nconst ocean_frag = \"\\nlayout(std140) uniform commonUniforms {\\n  vec4 u_watercolor;\\n  vec4 u_watercolor2;\\n  float u_time;\\n};\\n\\nin vec2 v_uv;\\nin float v_opacity;\\nout vec4 outputColor;\\n\\nfloat coast2water_fadedepth = 0.10;\\nfloat large_waveheight      = .750; // change to adjust the \\\"heavy\\\" waves\\nfloat large_wavesize        = 3.4;  // factor to adjust the large wave size\\nfloat small_waveheight      = 0.6;  // change to adjust the small random waves\\nfloat small_wavesize        = 0.5;   // factor to ajust the small wave size\\nfloat water_softlight_fact  = 15.;  // range [1..200] (should be << smaller than glossy-fact)\\nfloat water_glossylight_fact= 120.; // range [1..200]\\nfloat particle_amount       = 70.;\\n\\nvec3 water_specularcolor    = vec3(1.3, 1.3, 0.9);    // specular Color (RGB) of the water-highlights\\n#define light                 vec3(-0., sin(u_time*0.5)*.5 + .35, 2.8) // position of the sun\\n\\nuniform sampler2D u_texture1;\\nuniform sampler2D u_texture2;\\nuniform sampler2D u_texture3;\\n\\n  \\n\\nfloat hash( float n ) {\\n    return fract(sin(n)*43758.5453123);\\n}\\n\\n// 2d noise function\\nfloat noise1( in vec2 x ) {\\n  vec2 p  = floor(x);\\n  vec2 f  = smoothstep(0.0, 1.0, fract(x));\\n  float n = p.x + p.y*57.0;\\n  return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\\n}\\n\\nfloat noise(vec2 p) {\\n    return texture(SAMPLER_2D(u_texture2),p*vec2(1./256.)).x;\\n}\\n\\nvec4 highness(vec2 p) {\\n    vec4 t = texture(SAMPLER_2D(u_texture1),fract(p));\\n    float clipped = -2.0-smoothstep(3.,10.,t.a)*6.9-smoothstep(10.,100.,t.a)*89.9-smoothstep(0.,10000.,t.a)*10000.0;\\n    return clamp(t, 0.0,3.0)+clamp(t/3.0-1.0, 0.0,1.0)+clamp(t/16.0-1.0, 0.0,1.0);\\n}\\n\\nfloat height_map( vec2 p ) {\\n    vec4 height=highness(p);\\n    /*\\n    height = -0.5+\\n        0.5*smoothstep(-100.,0.,-height)+\\n        2.75*smoothstep(0.,2.,height)+\\n        1.75*smoothstep(2.,4.,height)+\\n        2.75*smoothstep(4.,16.,height)+\\n        1.5*smoothstep(16.,1000.,height);\\n    */\\n\\n    mat2 m = mat2( 0.9563*1.4,  -0.2924*1.4,  0.2924*1.4,  0.9563*1.4 );\\n    //p = p*6.;\\n    float f = 0.6000*noise1( p ); p = m*p*1.1*6.;\\n    f += 0.2500*noise( p ); p = m*p*1.32;\\n    f += 0.1666*noise( p ); p = m*p*1.11;\\n    f += 0.0834*noise( p ); p = m*p*1.12;\\n    f += 0.0634*noise( p ); p = m*p*1.13;\\n    f += 0.0444*noise( p ); p = m*p*1.14;\\n    f += 0.0274*noise( p ); p = m*p*1.15;\\n    f += 0.0134*noise( p ); p = m*p*1.16;\\n    f += 0.0104*noise( p ); p = m*p*1.17;\\n    f += 0.0084*noise( p );\\n    f = .25*f+dot(height,vec4(-.03125,-.125,.25,.25))*.5;\\n        const float FLAT_LEVEL = 0.92525;\\n        //f = f*0.25+height*0.75;\\n    if (f<FLAT_LEVEL)\\n        f = f;\\n    else\\n        f = pow((f-FLAT_LEVEL)/(1.-FLAT_LEVEL), 2.)*(1.-FLAT_LEVEL)*2.0+FLAT_LEVEL; // makes a smooth coast-increase\\n    return clamp(f, 0., 10.);\\n}\\n\\nvec3 plasma_quintic( float x ) {\\n    x = clamp( x, 0.0, 1.0);\\n    vec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\\n    vec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\\n    return vec3(\\n        dot( x1.xyzw, vec4( +0.063861086, +1.992659096, -1.023901152, -0.490832805 ) ) + dot( x2.xy, vec2( +1.308442123, -0.914547012 ) ),\\n        dot( x1.xyzw, vec4( +0.049718590, -0.791144343, +2.892305078, +0.811726816 ) ) + dot( x2.xy, vec2( -4.686502417, +2.717794514 ) ),\\n        dot( x1.xyzw, vec4( +0.513275779, +1.580255060, -5.164414457, +4.559573646 ) ) + dot( x2.xy, vec2( -1.916810682, +0.570638854 ) ) );\\n}\\n\\nvec4 color(vec2 p){\\n    vec4 c1 = vec4(1.7,1.6,.9,1);\\n    vec4 c2 = vec4(.2,.94,.1,1);\\n    vec4 c3 = vec4(.3,.2,.0,1);\\n    vec4 c4 = vec4(.99,.99,1.6,1);\\n    vec4 v = highness(p);\\n    float los = smoothstep(0.1,1.1,v.b);\\n    float his = smoothstep(3.5,6.5,v.b);\\n    float ces = smoothstep(1.,5.,v.a);\\n    vec4 lo = mix(c1,c2,los);\\n    vec4 hi = mix(c3,c4,his);\\n    vec4 ce = mix(lo,hi,ces);\\n\\n    return vec4(plasma_quintic(ces),1).ragb;\\n}\\n\\nvec3 terrain_map( vec2 p )\\n{\\n  return color(p).rgb*0.75+0.25*vec3(0.7, .55, .4)+texture(SAMPLER_2D(u_texture3), fract(p*5.)).rgb*.5; // test-terrain is simply 'sandstone'\\n}\\n\\nconst mat2 m = mat2( 0.72, -1.60,  1.60,  0.72 );\\n\\nfloat water_map( vec2 p, float height ) {\\n    vec2 p2 = p*large_wavesize;\\n    vec2 shift1 = 0.001*vec2( u_time*160.0*2.0, u_time*120.0*2.0 );\\n    vec2 shift2 = 0.001*vec2( u_time*190.0*2.0, -u_time*130.0*2.0 );\\n\\n    // coarse crossing 'ocean' waves...\\n    float f = 0.6000*noise( p );\\n    f += 0.2500*noise( p*m );\\n    f += 0.1666*noise( p*m*m );\\n    float wave = sin(p2.x*0.622+p2.y*0.622+shift2.x*4.269)*large_waveheight*f*height*height ;\\n\\n    p *= small_wavesize;\\n    f = 0.;\\n    float amp = 1.0, s = .5;\\n    for (int i=0; i<9; i++)\\n    { p = m*p*.947; f -= amp*abs(sin((noise( p+shift1*s )-.5)*2.)); amp = amp*.59; s*=-1.329; }\\n    \\n    return wave+f*small_waveheight;\\n}\\n\\nfloat nautic(vec2 p) {\\n    p *= 18.;\\n    float f = 0.;\\n    float amp = 1.0, s = .5;\\n    for (int i=0; i<3; i++)\\n    { p = m*p*1.2; f += amp*abs(smoothstep(0., 1., noise( p+u_time*s ))-.5); amp = amp*.5; s*=-1.227; }\\n    return pow(1.-f, 5.);\\n}\\n\\nfloat particles(vec2 p) {\\n    p *= 200.;\\n    float f = 0.;\\n    float amp = 1.0, s = 1.5;\\n    for (int i=0; i<3; i++)\\n    { p = m*p*1.2; f += amp*noise( p+u_time*s ); amp = amp*.5; s*=-1.227; }\\n    return pow(f*.35, 7.)*particle_amount;\\n}\\n\\nfloat test_shadow( vec2 xy, float height) {\\n    vec3 r0 = vec3(xy, height);\\n    vec3 rd = normalize( light - r0 );\\n    \\n    float hit = 1.0;\\n    float t   = 0.001;\\n    for (int j=1; j<25; j++)\\n    {\\n        vec3 p = r0 + t*rd;\\n        float h = height_map( p.xy );\\n        float height_diff = p.z - h;\\n        if (height_diff<0.0)\\n        {\\n            return 0.0;\\n        }\\n        t += 0.01+height_diff*.02;\\n        hit = min(hit, 2.*height_diff/t); // soft shaddow   \\n    }\\n    return hit;\\n}\\n\\nvec3 CalcTerrain(vec2 uv, float height) {\\n    vec3 col = terrain_map( uv );\\n    vec2 iResolution = vec2(512.);\\n    float h1 = height_map(uv-vec2(0., 0.5)/ iResolution.xy);\\n    float h2 = height_map(uv+vec2(0., 0.5)/ iResolution.xy);\\n    float h3 = height_map(uv-vec2(0.5, 0.)/ iResolution.xy);\\n    float h4 = height_map(uv+vec2(0.5, 0.)/ iResolution.xy);\\n    vec3 norm = normalize(vec3(h3-h4, h1-h2, 1.));\\n    vec3 r0 = vec3(uv, height);\\n    vec3 rd = normalize( light - r0 );\\n    float grad = dot(norm, rd);\\n    col *= grad+pow(grad, 8.);\\n    float terrainshade = test_shadow( uv, height );\\n    col = mix(col*.25, col, terrainshade);\\n    return col;\\n}\\n\\n\\nvoid main() {\\n  vec3 watercolor = u_watercolor.rgb;\\n  vec3 watercolor2 = u_watercolor2.rgb;\\n  vec2 uv = v_uv;\\n  float WATER_LEVEL = 0.84; // Water level (range: 0.0 - 2.0)\\n  float deepwater_fadedepth   = 0.4 + coast2water_fadedepth;\\n  float height = height_map( uv );\\n  vec3 col;\\n\\n    float waveheight = clamp(WATER_LEVEL*3.-1.5, 0., 1.);\\n    float level = WATER_LEVEL + .2*water_map(uv*15. + vec2(u_time*.1), waveheight);\\n    if (height > level)\\n    {\\n        col = CalcTerrain(uv, height);\\n    }\\n    if (height <= level)\\n    {\\n        vec2 dif = vec2(.0, .01);\\n        vec2 pos = uv*15. + vec2(u_time*.01);\\n        float h1 = water_map(pos-dif,waveheight);\\n        float h2 = water_map(pos+dif,waveheight);\\n        float h3 = water_map(pos-dif.yx,waveheight);\\n        float h4 = water_map(pos+dif.yx,waveheight);\\n        vec3 normwater = normalize(vec3(h3-h4, h1-h2, .125)); // norm-vector of the 'bumpy' water-plane\\n        uv += normwater.xy*.002*(level-height);\\n        \\n        col = CalcTerrain(uv, height);\\n\\n        float coastfade = clamp((level-height)/coast2water_fadedepth, 0., 1.);\\n        float coastfade2= clamp((level-height)/deepwater_fadedepth, 0., 1.);\\n        float intensity = col.r*.2126+col.g*.7152+col.b*.0722;\\n        watercolor = mix(watercolor*intensity, watercolor2, smoothstep(0., 1., coastfade2));\\n\\n        vec3 r0 = vec3(uv, WATER_LEVEL);\\n        vec3 rd = normalize( light - r0 ); // ray-direction to the light from water-position\\n        float grad     = dot(normwater, rd); // dot-product of norm-vector and light-direction\\n        float specular = pow(grad, water_softlight_fact);  // used for soft highlights                          \\n        float specular2= pow(grad, water_glossylight_fact); // used for glossy highlights\\n        float gradpos  = dot(vec3(0., 0., 1.), rd);\\n        float specular1= smoothstep(0., 1., pow(gradpos, 5.));  // used for diffusity (some darker corona around light's specular reflections...)                          \\n        float watershade  = test_shadow( uv, level );\\n        watercolor *= 2.2+watershade;\\n        watercolor += (.2+.8*watershade) * ((grad-1.0)*.5+specular) * .25;\\n        watercolor /= (1.+specular1*1.25);\\n        watercolor += watershade*specular2*water_specularcolor;\\n        watercolor += watershade*coastfade*(1.-coastfade2)*(vec3(.5, .6, .7)*nautic(uv)+vec3(1., 1., 1.)*particles(uv));\\n        \\n        col = mix(col, watercolor, coastfade);\\n    }\\n    \\n  outputColor = vec4(col, v_opacity);  \\n}\\n\";\n/* babel-plugin-inline-import '../shaders/ocean/ocean_vert.glsl' */\nconst ocean_vert = \"layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_uv;\\n\\nlayout(std140) uniform commonUniforms {\\n  vec4 u_watercolor;\\n  vec4 u_watercolor2;\\n  float u_time;\\n};\\n\\nout vec2 v_uv;\\nout float v_opacity;\\n\\n#pragma include \\\"projection\\\"\\n\\nvoid main() {\\n  v_uv = a_uv;\\n  v_opacity = opacity;\\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\\n}\\n\\n\";\nexport default class OceanModel extends BaseModel {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"texture1\", void 0);\n    _defineProperty(this, \"texture2\", void 0);\n    _defineProperty(this, \"texture3\", void 0);\n  }\n  get attributeLocation() {\n    return Object.assign(super.attributeLocation, {\n      MAX: super.attributeLocation.MAX,\n      UV: 9\n    });\n  }\n  getUninforms() {\n    const commoninfo = this.getCommonUniformsInfo();\n    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());\n    this.updateStyleUnifoms();\n    return _objectSpread(_objectSpread({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);\n  }\n  getCommonUniformsInfo() {\n    const {\n      watercolor = '#6D99A8',\n      watercolor2 = '#0F121C'\n    } = this.layer.getLayerConfig();\n    const commonOptions = {\n      u_watercolor: rgb2arr(watercolor),\n      u_watercolor2: rgb2arr(watercolor2),\n      u_time: this.layer.getLayerAnimateTime(),\n      u_texture1: this.texture1,\n      u_texture2: this.texture2,\n      u_texture3: this.texture3\n    };\n\n    // u_opacity: isNumber(opacity) ? opacity : 1.0,\n    this.textures = [this.texture1, this.texture2, this.texture3];\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  getAnimateUniforms() {\n    return {\n      u_time: this.layer.getLayerAnimateTime()\n    };\n  }\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.loadTexture();\n      return _this.buildModels();\n    })();\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.initUniformsBuffer();\n      const model = yield _this2.layer.buildLayerModel({\n        moduleName: 'polygonOcean',\n        vertexShader: ocean_vert,\n        fragmentShader: ocean_frag,\n        defines: _this2.getDefines(),\n        inject: _this2.getInject(),\n        triangulation: polygonTriangulation,\n        primitive: gl.TRIANGLES,\n        depth: {\n          enable: false\n        }\n      });\n      return [model];\n    })();\n  }\n  clearModels() {\n    var _this$texture, _this$texture2, _this$texture3;\n    (_this$texture = this.texture1) === null || _this$texture === void 0 || _this$texture.destroy();\n    (_this$texture2 = this.texture2) === null || _this$texture2 === void 0 || _this$texture2.destroy();\n    (_this$texture3 = this.texture3) === null || _this$texture3 === void 0 || _this$texture3.destroy();\n  }\n  registerBuiltinAttributes() {\n    const bbox = this.layer.getSource().extent;\n    const [minLng, minLat, maxLng, maxLat] = bbox;\n    const lngLen = maxLng - minLng;\n    const latLen = maxLat - minLat;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'oceanUv',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_uv',\n        shaderLocation: this.attributeLocation.UV,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.STATIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 2,\n        update: (feature, featureIdx, vertex) => {\n          const [lng, lat] = vertex;\n          return [(lng - minLng) / lngLen, (lat - minLat) / latLen];\n        }\n      }\n    });\n  }\n  loadTexture() {\n    const {\n      createTexture2D\n    } = this.rendererService;\n    const defaultTextureOptions = {\n      height: 0,\n      width: 0\n    };\n    // 默认索引为 undefined，所以单独赋值\n    this.texture1 = createTexture2D(defaultTextureOptions);\n    this.texture2 = createTexture2D(defaultTextureOptions);\n    this.texture3 = createTexture2D(defaultTextureOptions);\n\n    // 加载完 image 后单独给 texture f赋值\n    initImage(images => {\n      this.texture1 = initTex(images[0]);\n      this.texture2 = initTex(images[1]);\n      this.texture3 = initTex(images[2]);\n      this.layerService.reRender();\n    });\n    function initImage(callback) {\n      let loadedCount = 0;\n      const loadedImages = [];\n      const images = ['https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*EojwT4VzSiYAAAAAAAAAAAAAARQnAQ', 'https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*MJ22QbpuCzIAAAAAAAAAAAAAARQnAQ', 'https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*-z2HSIVDsHIAAAAAAAAAAAAAARQnAQ'];\n      images.map(imgSrc => {\n        const image = new Image();\n        image.crossOrigin = '';\n        image.src = imgSrc;\n        loadedImages.push(image);\n        image.onload = () => {\n          loadedCount++;\n          if (loadedCount === 3) {\n            callback(loadedImages);\n          }\n        };\n      });\n    }\n    function initTex(image) {\n      return createTexture2D({\n        data: image,\n        width: image.width,\n        height: image.height,\n        wrapS: gl.MIRRORED_REPEAT,\n        wrapT: gl.MIRRORED_REPEAT,\n        min: gl.LINEAR,\n        mag: gl.LINEAR\n      });\n    }\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}