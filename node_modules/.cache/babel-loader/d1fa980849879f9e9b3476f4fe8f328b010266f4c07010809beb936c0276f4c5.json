{"ast":null,"code":"import { NumberExt } from '../../util';\nimport { Base } from '../base';\nconst CYLINDER_TILT = 10;\nexport const Cylinder = Base.define({\n  shape: 'cylinder',\n  overwrite: true,\n  markup: [{\n    tagName: 'path',\n    selector: 'body'\n  }, {\n    tagName: 'ellipse',\n    selector: 'top'\n  }, {\n    tagName: 'text',\n    selector: 'label'\n  }],\n  attrs: {\n    body: Object.assign(Object.assign({}, Base.bodyAttr), {\n      lateral: CYLINDER_TILT\n    }),\n    top: Object.assign(Object.assign({}, Base.bodyAttr), {\n      refCx: '50%',\n      refRx: '50%',\n      cy: CYLINDER_TILT,\n      ry: CYLINDER_TILT\n    })\n  },\n  attrHooks: {\n    lateral: {\n      set(t, {\n        refBBox\n      }) {\n        const isPercentage = NumberExt.isPercentage(t);\n        if (isPercentage) {\n          // eslint-disable-next-line\n          t = parseFloat(t) / 100;\n        }\n        const x = refBBox.x;\n        const y = refBBox.y;\n        const w = refBBox.width;\n        const h = refBBox.height;\n        // curve control point variables\n        const rx = w / 2;\n        const ry = isPercentage ? h * t : t;\n        const kappa = 0.551784;\n        const cx = kappa * rx;\n        const cy = kappa * ry;\n        // shape variables\n        const xLeft = x;\n        const xCenter = x + w / 2;\n        const xRight = x + w;\n        const ySideTop = y + ry;\n        const yCurveTop = ySideTop - ry;\n        const ySideBottom = y + h - ry;\n        const yCurveBottom = y + h;\n        // return calculated shape\n        const data = ['M', xLeft, ySideTop, 'L', xLeft, ySideBottom, 'C', x, ySideBottom + cy, xCenter - cx, yCurveBottom, xCenter, yCurveBottom, 'C', xCenter + cx, yCurveBottom, xRight, ySideBottom + cy, xRight, ySideBottom, 'L', xRight, ySideTop, 'C', xRight, ySideTop - cy, xCenter + cx, yCurveTop, xCenter, yCurveTop, 'C', xCenter - cx, yCurveTop, xLeft, ySideTop - cy, xLeft, ySideTop, 'Z'];\n        return {\n          d: data.join(' ')\n        };\n      }\n    }\n  },\n  knob: {\n    enabled: true,\n    position({\n      node\n    }) {\n      const lateral = node.attr('body/lateral');\n      return {\n        x: 0,\n        y: lateral\n      };\n    },\n    onMouseMove({\n      node,\n      data,\n      deltaY\n    }) {\n      if (deltaY !== 0) {\n        const bbox = node.getBBox();\n        const previous = node.attr('body/lateral');\n        if (data.round == null) {\n          data.round = previous;\n        }\n        const min = 0;\n        const max = bbox.height / 2;\n        const current = NumberExt.clamp(data.round + deltaY, min, max);\n        if (current !== previous) {\n          node.attr({\n            body: {\n              lateral: current\n            },\n            top: {\n              cy: current,\n              ry: current\n            }\n          });\n        }\n      }\n    }\n  }\n});","map":{"version":3,"names":["NumberExt","Base","CYLINDER_TILT","Cylinder","define","shape","overwrite","markup","tagName","selector","attrs","body","Object","assign","bodyAttr","lateral","top","refCx","refRx","cy","ry","attrHooks","set","t","refBBox","isPercentage","parseFloat","x","y","w","width","h","height","rx","kappa","cx","xLeft","xCenter","xRight","ySideTop","yCurveTop","ySideBottom","yCurveBottom","data","d","join","knob","enabled","position","node","attr","onMouseMove","deltaY","bbox","getBBox","previous","round","min","max","current","clamp"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/shape/standard/cylinder.ts"],"sourcesContent":["import { NumberExt } from '../../util'\nimport { Base } from '../base'\n\nconst CYLINDER_TILT = 10\n\nexport const Cylinder = Base.define({\n  shape: 'cylinder',\n  overwrite: true,\n  markup: [\n    {\n      tagName: 'path',\n      selector: 'body',\n    },\n    {\n      tagName: 'ellipse',\n      selector: 'top',\n    },\n    {\n      tagName: 'text',\n      selector: 'label',\n    },\n  ],\n  attrs: {\n    body: {\n      ...Base.bodyAttr,\n      lateral: CYLINDER_TILT,\n    },\n    top: {\n      ...Base.bodyAttr,\n      refCx: '50%',\n      refRx: '50%',\n      cy: CYLINDER_TILT,\n      ry: CYLINDER_TILT,\n    },\n  },\n  attrHooks: {\n    lateral: {\n      set(t: number | string, { refBBox }) {\n        const isPercentage = NumberExt.isPercentage(t)\n        if (isPercentage) {\n          // eslint-disable-next-line\n          t = parseFloat(t as string) / 100\n        }\n\n        const x = refBBox.x\n        const y = refBBox.y\n        const w = refBBox.width\n        const h = refBBox.height\n\n        // curve control point variables\n        const rx = w / 2\n        const ry = isPercentage ? h * (t as number) : (t as number)\n\n        const kappa = 0.551784\n        const cx = kappa * rx\n        const cy = kappa * ry\n\n        // shape variables\n        const xLeft = x\n        const xCenter = x + w / 2\n        const xRight = x + w\n\n        const ySideTop = y + ry\n        const yCurveTop = ySideTop - ry\n        const ySideBottom = y + h - ry\n        const yCurveBottom = y + h\n\n        // return calculated shape\n        const data = [\n          'M',\n          xLeft,\n          ySideTop,\n          'L',\n          xLeft,\n          ySideBottom,\n          'C',\n          x,\n          ySideBottom + cy,\n          xCenter - cx,\n          yCurveBottom,\n          xCenter,\n          yCurveBottom,\n          'C',\n          xCenter + cx,\n          yCurveBottom,\n          xRight,\n          ySideBottom + cy,\n          xRight,\n          ySideBottom,\n          'L',\n          xRight,\n          ySideTop,\n          'C',\n          xRight,\n          ySideTop - cy,\n          xCenter + cx,\n          yCurveTop,\n          xCenter,\n          yCurveTop,\n          'C',\n          xCenter - cx,\n          yCurveTop,\n          xLeft,\n          ySideTop - cy,\n          xLeft,\n          ySideTop,\n          'Z',\n        ]\n\n        return { d: data.join(' ') }\n      },\n    },\n  },\n  knob: {\n    enabled: true,\n    position({ node }) {\n      const lateral = node.attr<number>('body/lateral')\n      return { x: 0, y: lateral }\n    },\n    onMouseMove({ node, data, deltaY }) {\n      if (deltaY !== 0) {\n        const bbox = node.getBBox()\n        const previous = node.attr<number>('body/lateral')\n\n        if (data.round == null) {\n          data.round = previous\n        }\n        const min = 0\n        const max = bbox.height / 2\n        const current = NumberExt.clamp(data.round + deltaY, min, max)\n        if (current !== previous) {\n          node.attr({\n            body: { lateral: current },\n            top: {\n              cy: current,\n              ry: current,\n            },\n          })\n        }\n      }\n    },\n  },\n})\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}