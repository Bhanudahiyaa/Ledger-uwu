{"ast":null,"code":"import { Path } from '../../geometry';\nimport * as Dom from '../dom/core';\nexport class Vector {\n  constructor(elem, attrs, children) {\n    if (!elem) {\n      throw new TypeError('Invalid element to create vector');\n    }\n    let node;\n    if (Vector.isVector(elem)) {\n      node = elem.node;\n    } else if (typeof elem === 'string') {\n      if (elem.toLowerCase() === 'svg') {\n        node = Dom.createSvgDocument();\n      } else if (elem[0] === '<') {\n        const doc = Dom.createSvgDocument(elem);\n        // only import the first child\n        node = document.importNode(doc.firstChild, true);\n      } else {\n        node = document.createElementNS(Dom.ns.svg, elem);\n      }\n    } else {\n      node = elem;\n    }\n    this.node = node;\n    if (attrs) {\n      this.setAttributes(attrs);\n    }\n    if (children) {\n      this.append(children);\n    }\n  }\n  get [Symbol.toStringTag]() {\n    return Vector.toStringTag;\n  }\n  get type() {\n    return this.node.nodeName;\n  }\n  get id() {\n    return this.node.id;\n  }\n  set id(id) {\n    this.node.id = id;\n  }\n  transform(matrix, options) {\n    if (matrix == null) {\n      return Dom.transform(this.node);\n    }\n    Dom.transform(this.node, matrix, options);\n    return this;\n  }\n  translate(tx, ty = 0, options = {}) {\n    if (tx == null) {\n      return Dom.translate(this.node);\n    }\n    Dom.translate(this.node, tx, ty, options);\n    return this;\n  }\n  rotate(angle, cx, cy, options = {}) {\n    if (angle == null) {\n      return Dom.rotate(this.node);\n    }\n    Dom.rotate(this.node, angle, cx, cy, options);\n    return this;\n  }\n  scale(sx, sy) {\n    if (sx == null) {\n      return Dom.scale(this.node);\n    }\n    Dom.scale(this.node, sx, sy);\n    return this;\n  }\n  /**\n   * Returns an SVGMatrix that specifies the transformation necessary\n   * to convert this coordinate system into `target` coordinate system.\n   */\n  getTransformToElement(target) {\n    const ref = Vector.toNode(target);\n    return Dom.getTransformToElement(this.node, ref);\n  }\n  removeAttribute(name) {\n    Dom.removeAttribute(this.node, name);\n    return this;\n  }\n  getAttribute(name) {\n    return Dom.getAttribute(this.node, name);\n  }\n  setAttribute(name, value) {\n    Dom.setAttribute(this.node, name, value);\n    return this;\n  }\n  setAttributes(attrs) {\n    Dom.setAttributes(this.node, attrs);\n    return this;\n  }\n  attr(name, value) {\n    if (name == null) {\n      return Dom.attr(this.node);\n    }\n    if (typeof name === 'string' && value === undefined) {\n      return Dom.attr(this.node, name);\n    }\n    if (typeof name === 'object') {\n      Dom.attr(this.node, name);\n    } else {\n      Dom.attr(this.node, name, value);\n    }\n    return this;\n  }\n  svg() {\n    return this.node instanceof SVGSVGElement ? this : Vector.create(this.node.ownerSVGElement);\n  }\n  defs() {\n    const context = this.svg() || this;\n    const defsNode = context.node.getElementsByTagName('defs')[0];\n    if (defsNode) {\n      return Vector.create(defsNode);\n    }\n    return Vector.create('defs').appendTo(context);\n  }\n  text(content, options = {}) {\n    Dom.text(this.node, content, options);\n    return this;\n  }\n  tagName() {\n    return Dom.tagName(this.node);\n  }\n  clone() {\n    return Vector.create(this.node.cloneNode(true));\n  }\n  remove() {\n    Dom.remove(this.node);\n    return this;\n  }\n  empty() {\n    Dom.empty(this.node);\n    return this;\n  }\n  append(elems) {\n    Dom.append(this.node, Vector.toNodes(elems));\n    return this;\n  }\n  appendTo(target) {\n    Dom.appendTo(this.node, Vector.isVector(target) ? target.node : target);\n    return this;\n  }\n  prepend(elems) {\n    Dom.prepend(this.node, Vector.toNodes(elems));\n    return this;\n  }\n  before(elems) {\n    Dom.before(this.node, Vector.toNodes(elems));\n    return this;\n  }\n  replace(elem) {\n    if (this.node.parentNode) {\n      this.node.parentNode.replaceChild(Vector.toNode(elem), this.node);\n    }\n    return Vector.create(elem);\n  }\n  first() {\n    return this.node.firstChild ? Vector.create(this.node.firstChild) : null;\n  }\n  last() {\n    return this.node.lastChild ? Vector.create(this.node.lastChild) : null;\n  }\n  get(index) {\n    const child = this.node.childNodes[index];\n    return child ? Vector.create(child) : null;\n  }\n  indexOf(elem) {\n    const children = Array.prototype.slice.call(this.node.childNodes);\n    return children.indexOf(Vector.toNode(elem));\n  }\n  find(selector) {\n    const vels = [];\n    const nodes = Dom.find(this.node, selector);\n    if (nodes) {\n      for (let i = 0, ii = nodes.length; i < ii; i += 1) {\n        vels.push(Vector.create(nodes[i]));\n      }\n    }\n    return vels;\n  }\n  findOne(selector) {\n    const found = Dom.findOne(this.node, selector);\n    return found ? Vector.create(found) : null;\n  }\n  findParentByClass(className, terminator) {\n    const node = Dom.findParentByClass(this.node, className, terminator);\n    return node ? Vector.create(node) : null;\n  }\n  matches(selector) {\n    const node = this.node;\n    const matches = this.node.matches;\n    const matcher = node.matches || node.matchesSelector || node.msMatchesSelector || node.mozMatchesSelector || node.webkitMatchesSelector || node.oMatchesSelector || null;\n    return matcher && matcher.call(node, selector);\n  }\n  contains(child) {\n    return Dom.contains(this.node, Vector.isVector(child) ? child.node : child);\n  }\n  wrap(node) {\n    const vel = Vector.create(node);\n    const parentNode = this.node.parentNode;\n    if (parentNode != null) {\n      parentNode.insertBefore(vel.node, this.node);\n    }\n    return vel.append(this);\n  }\n  parent(type) {\n    let parent = this; // eslint-disable-line @typescript-eslint/no-this-alias\n    // check for parent\n    if (parent.node.parentNode == null) {\n      return null;\n    }\n    // get parent element\n    parent = Vector.create(parent.node.parentNode);\n    if (type == null) {\n      return parent;\n    }\n    // loop trough ancestors if type is given\n    do {\n      if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) {\n        return parent;\n      }\n    } while (parent = Vector.create(parent.node.parentNode));\n    return parent;\n  }\n  children() {\n    const children = this.node.childNodes;\n    const vels = [];\n    for (let i = 0; i < children.length; i += 1) {\n      const currentChild = children[i];\n      if (currentChild.nodeType === 1) {\n        vels.push(Vector.create(children[i]));\n      }\n    }\n    return vels;\n  }\n  eachChild(fn, deep) {\n    const children = this.children();\n    for (let i = 0, l = children.length; i < l; i += 1) {\n      fn.call(children[i], children[i], i, children);\n      if (deep) {\n        children[i].eachChild(fn, deep);\n      }\n    }\n    return this;\n  }\n  index() {\n    return Dom.index(this.node);\n  }\n  hasClass(className) {\n    return Dom.hasClass(this.node, className);\n  }\n  addClass(className) {\n    Dom.addClass(this.node, className);\n    return this;\n  }\n  removeClass(className) {\n    Dom.removeClass(this.node, className);\n    return this;\n  }\n  toggleClass(className, stateVal) {\n    Dom.toggleClass(this.node, className, stateVal);\n    return this;\n  }\n  toLocalPoint(x, y) {\n    return Dom.toLocalPoint(this.node, x, y);\n  }\n  toGeometryShape() {\n    return Dom.toGeometryShape(this.node);\n  }\n  translateCenterToPoint(p) {\n    const bbox = this.getBBox({\n      target: this.svg()\n    });\n    const center = bbox.getCenter();\n    this.translate(p.x - center.x, p.y - center.y);\n    return this;\n  }\n  translateAndAutoOrient(position, reference, target) {\n    Dom.translateAndAutoOrient(this.node, position, reference, target);\n    return this;\n  }\n  animate(options) {\n    return Dom.animate(this.node, options);\n  }\n  animateTransform(options) {\n    return Dom.animateTransform(this.node, options);\n  }\n  animateAlongPath(options, path) {\n    return Dom.animateAlongPath(this.node, options, path);\n  }\n  /**\n   * Normalize this element's d attribute. SVGPathElements without\n   * a path data attribute obtain a value of 'M 0 0'.\n   */\n  normalizePath() {\n    const tagName = this.tagName();\n    if (tagName === 'path') {\n      this.attr('d', Path.normalize(this.attr('d')));\n    }\n    return this;\n  }\n  /**\n   * Returns the bounding box of the element after transformations are applied.\n   * If `withoutTransformations` is `true`, transformations of the element\n   * will not be considered when computing the bounding box. If `target` is\n   * specified, bounding box will be computed relatively to the target element.\n   */\n  bbox(withoutTransformations, target) {\n    return Dom.bbox(this.node, withoutTransformations, target);\n  }\n  getBBox(options = {}) {\n    return Dom.getBBox(this.node, {\n      recursive: options.recursive,\n      target: options.target ? Vector.toNode(options.target) : null\n    });\n  }\n  /**\n   * Samples the underlying SVG element (it currently works only on\n   * paths - where it is most useful anyway). Returns an array of objects\n   * of the form `{ x: Number, y: Number, distance: Number }`. Each of these\n   * objects represent a point on the path. This basically creates a discrete\n   * representation of the path (which is possible a curve). The sampling\n   * interval defines the accuracy of the sampling. In other words, we travel\n   * from the beginning of the path to the end by interval distance (on the\n   * path, not between the resulting points) and collect the discrete points\n   * on the path. This is very useful in many situations. For example, SVG\n   * does not provide a built-in mechanism to find intersections between two\n   * paths. Using sampling, we can just generate bunch of points for each of\n   * the path and find the closest ones from each set.\n   */\n  sample(interval = 1) {\n    if (this.node instanceof SVGPathElement) {\n      return Dom.sample(this.node, interval);\n    }\n    return [];\n  }\n  toPath() {\n    return Vector.create(Dom.toPath(this.node));\n  }\n  toPathData() {\n    return Dom.toPathData(this.node);\n  }\n}\n(function (Vector) {\n  Vector.toStringTag = `X6.${Vector.name}`;\n  function isVector(instance) {\n    if (instance == null) {\n      return false;\n    }\n    if (instance instanceof Vector) {\n      return true;\n    }\n    const tag = instance[Symbol.toStringTag];\n    const vector = instance;\n    if ((tag == null || tag === Vector.toStringTag) && vector.node instanceof SVGElement && typeof vector.animate === 'function' && typeof vector.sample === 'function' && typeof vector.normalizePath === 'function' && typeof vector.toPath === 'function') {\n      return true;\n    }\n    return false;\n  }\n  Vector.isVector = isVector;\n  function create(elem, attrs, children) {\n    return new Vector(elem, attrs, children);\n  }\n  Vector.create = create;\n  function createVectors(markup) {\n    if (markup[0] === '<') {\n      const svgDoc = Dom.createSvgDocument(markup);\n      const vels = [];\n      for (let i = 0, ii = svgDoc.childNodes.length; i < ii; i += 1) {\n        const childNode = svgDoc.childNodes[i];\n        vels.push(create(document.importNode(childNode, true)));\n      }\n      return vels;\n    }\n    return [create(markup)];\n  }\n  Vector.createVectors = createVectors;\n  function toNode(elem) {\n    if (isVector(elem)) {\n      return elem.node;\n    }\n    return elem;\n  }\n  Vector.toNode = toNode;\n  function toNodes(elems) {\n    if (Array.isArray(elems)) {\n      return elems.map(elem => toNode(elem));\n    }\n    return [toNode(elems)];\n  }\n  Vector.toNodes = toNodes;\n})(Vector || (Vector = {}));","map":{"version":3,"names":["Path","Dom","Vector","constructor","elem","attrs","children","TypeError","node","isVector","toLowerCase","createSvgDocument","doc","document","importNode","firstChild","createElementNS","ns","svg","setAttributes","append","Symbol","toStringTag","type","nodeName","id","transform","matrix","options","translate","tx","ty","rotate","angle","cx","cy","scale","sx","sy","getTransformToElement","target","ref","toNode","removeAttribute","name","getAttribute","setAttribute","value","attr","undefined","SVGSVGElement","create","ownerSVGElement","defs","context","defsNode","getElementsByTagName","appendTo","text","content","tagName","clone","cloneNode","remove","empty","elems","toNodes","prepend","before","replace","parentNode","replaceChild","first","last","lastChild","get","index","child","childNodes","indexOf","Array","prototype","slice","call","find","selector","vels","nodes","i","ii","length","push","findOne","found","findParentByClass","className","terminator","matches","matcher","matchesSelector","msMatchesSelector","mozMatchesSelector","webkitMatchesSelector","oMatchesSelector","contains","wrap","vel","insertBefore","parent","currentChild","nodeType","eachChild","fn","deep","l","hasClass","addClass","removeClass","toggleClass","stateVal","toLocalPoint","x","y","toGeometryShape","translateCenterToPoint","p","bbox","getBBox","center","getCenter","translateAndAutoOrient","position","reference","animate","animateTransform","animateAlongPath","path","normalizePath","normalize","withoutTransformations","recursive","sample","interval","SVGPathElement","toPath","toPathData","instance","tag","vector","SVGElement","createVectors","markup","svgDoc","childNode","isArray","map"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/util/vector/index.ts"],"sourcesContent":["import { Point, Path } from '../../geometry'\nimport * as Dom from '../dom/core'\n\nexport class Vector {\n  public node: SVGElement\n\n  protected get [Symbol.toStringTag]() {\n    return Vector.toStringTag\n  }\n\n  public get type() {\n    return this.node.nodeName\n  }\n\n  public get id() {\n    return this.node.id\n  }\n\n  public set id(id: string) {\n    this.node.id = id\n  }\n\n  constructor(\n    elem: Vector | SVGElement | string,\n    attrs?: Dom.Attributes,\n    children?: SVGElement | Vector | (SVGElement | Vector)[],\n  ) {\n    if (!elem) {\n      throw new TypeError('Invalid element to create vector')\n    }\n\n    let node: SVGElement\n    if (Vector.isVector(elem)) {\n      node = elem.node\n    } else if (typeof elem === 'string') {\n      if (elem.toLowerCase() === 'svg') {\n        node = Dom.createSvgDocument()\n      } else if (elem[0] === '<') {\n        const doc = Dom.createSvgDocument(elem)\n        // only import the first child\n        node = document.importNode(doc.firstChild!, true) as SVGElement\n      } else {\n        node = document.createElementNS(Dom.ns.svg, elem) as SVGElement\n      }\n    } else {\n      node = elem\n    }\n\n    this.node = node\n\n    if (attrs) {\n      this.setAttributes(attrs)\n    }\n\n    if (children) {\n      this.append(children)\n    }\n  }\n\n  /**\n   * Returns the current transformation matrix of the Vector element.\n   */\n  transform(): DOMMatrix\n  /**\n   * Applies the provided transformation matrix to the Vector element.\n   */\n  transform(matrix: DOMMatrix, options?: Dom.TransformOptions): this\n  transform(matrix?: DOMMatrix, options?: Dom.TransformOptions) {\n    if (matrix == null) {\n      return Dom.transform(this.node)\n    }\n\n    Dom.transform(this.node, matrix, options)\n\n    return this\n  }\n\n  /**\n   * Returns the current translate metadata of the Vector element.\n   */\n  translate(): Dom.Translation\n  /**\n   * Translates the element by `tx` pixels in x axis and `ty` pixels\n   * in y axis. `ty` is optional in which case the translation in y axis\n   * is considered zero.\n   */\n  translate(tx: number, ty?: number, options?: Dom.TransformOptions): this\n  translate(tx?: number, ty = 0, options: Dom.TransformOptions = {}) {\n    if (tx == null) {\n      return Dom.translate(this.node)\n    }\n\n    Dom.translate(this.node, tx, ty, options)\n    return this\n  }\n\n  /**\n   * Returns the current rotate metadata of the Vector element.\n   */\n  rotate(): Dom.Rotation\n  /**\n   * Rotates the element by `angle` degrees. If the optional `cx` and `cy`\n   * coordinates are passed, they will be used as an origin for the rotation.\n   */\n  rotate(\n    angle: number,\n    cx?: number,\n    cy?: number,\n    options?: Dom.TransformOptions,\n  ): this\n  rotate(\n    angle?: number,\n    cx?: number,\n    cy?: number,\n    options: Dom.TransformOptions = {},\n  ) {\n    if (angle == null) {\n      return Dom.rotate(this.node)\n    }\n\n    Dom.rotate(this.node, angle, cx, cy, options)\n    return this\n  }\n\n  /**\n   * Returns the current scale metadata of the Vector element.\n   */\n  scale(): Dom.Scale\n  /**\n   * Scale the element by `sx` and `sy` factors. If `sy` is not specified,\n   * it will be considered the same as `sx`.\n   */\n  scale(sx: number, sy?: number): this\n  scale(sx?: number, sy?: number) {\n    if (sx == null) {\n      return Dom.scale(this.node)\n    }\n    Dom.scale(this.node, sx, sy)\n    return this\n  }\n\n  /**\n   * Returns an SVGMatrix that specifies the transformation necessary\n   * to convert this coordinate system into `target` coordinate system.\n   */\n  getTransformToElement(target: SVGElement | Vector) {\n    const ref = Vector.toNode(target) as SVGGraphicsElement\n    return Dom.getTransformToElement(this.node, ref)\n  }\n\n  removeAttribute(name: string) {\n    Dom.removeAttribute(this.node, name)\n    return this\n  }\n\n  getAttribute(name: string) {\n    return Dom.getAttribute(this.node, name)\n  }\n\n  setAttribute(name: string, value?: string | number | null) {\n    Dom.setAttribute(this.node, name, value)\n    return this\n  }\n\n  setAttributes(attrs: { [attr: string]: string | number | null | undefined }) {\n    Dom.setAttributes(this.node, attrs)\n    return this\n  }\n\n  attr(): { [attr: string]: string }\n  attr(name: string): string\n  attr(attrs: { [attr: string]: string | number | null | undefined }): this\n  attr(name: string, value: string | number): this\n  attr(\n    name?: string | { [attr: string]: string | number | null | undefined },\n    value?: string | number | null,\n  ) {\n    if (name == null) {\n      return Dom.attr(this.node)\n    }\n\n    if (typeof name === 'string' && value === undefined) {\n      return Dom.attr(this.node, name)\n    }\n\n    if (typeof name === 'object') {\n      Dom.attr(this.node, name)\n    } else {\n      Dom.attr(this.node, name, value!)\n    }\n\n    return this\n  }\n\n  svg() {\n    return this.node instanceof SVGSVGElement\n      ? this\n      : Vector.create(this.node.ownerSVGElement as SVGSVGElement)\n  }\n\n  defs() {\n    const context = this.svg() || this\n    const defsNode = context.node.getElementsByTagName('defs')[0]\n    if (defsNode) {\n      return Vector.create(defsNode)\n    }\n\n    return Vector.create('defs').appendTo(context)\n  }\n\n  text(content: string, options: Dom.TextOptions = {}) {\n    Dom.text(this.node, content, options)\n    return this\n  }\n\n  tagName() {\n    return Dom.tagName(this.node)\n  }\n\n  clone() {\n    return Vector.create(this.node.cloneNode(true) as SVGElement)\n  }\n\n  remove() {\n    Dom.remove(this.node)\n    return this\n  }\n\n  empty() {\n    Dom.empty(this.node)\n    return this\n  }\n\n  append(\n    elems:\n      | SVGElement\n      | DocumentFragment\n      | Vector\n      | (SVGElement | DocumentFragment | Vector)[],\n  ) {\n    Dom.append(this.node, Vector.toNodes(elems))\n    return this\n  }\n\n  appendTo(target: Element | Vector) {\n    Dom.appendTo(this.node, Vector.isVector(target) ? target.node : target)\n    return this\n  }\n\n  prepend(\n    elems:\n      | SVGElement\n      | DocumentFragment\n      | Vector\n      | (SVGElement | DocumentFragment | Vector)[],\n  ) {\n    Dom.prepend(this.node, Vector.toNodes(elems))\n    return this\n  }\n\n  before(\n    elems:\n      | SVGElement\n      | DocumentFragment\n      | Vector\n      | (SVGElement | DocumentFragment | Vector)[],\n  ) {\n    Dom.before(this.node, Vector.toNodes(elems))\n    return this\n  }\n\n  replace(elem: SVGElement | Vector) {\n    if (this.node.parentNode) {\n      this.node.parentNode.replaceChild(Vector.toNode(elem), this.node)\n    }\n    return Vector.create(elem)\n  }\n\n  first() {\n    return this.node.firstChild\n      ? Vector.create(this.node.firstChild as SVGElement)\n      : null\n  }\n\n  last() {\n    return this.node.lastChild\n      ? Vector.create(this.node.lastChild as SVGElement)\n      : null\n  }\n\n  get(index: number) {\n    const child = this.node.childNodes[index] as SVGElement\n    return child ? Vector.create(child) : null\n  }\n\n  indexOf(elem: SVGElement | Vector) {\n    const children: SVGElement[] = Array.prototype.slice.call(\n      this.node.childNodes,\n    )\n    return children.indexOf(Vector.toNode(elem))\n  }\n\n  find(selector: string) {\n    const vels: Vector[] = []\n    const nodes = Dom.find(this.node, selector)\n    if (nodes) {\n      for (let i = 0, ii = nodes.length; i < ii; i += 1) {\n        vels.push(Vector.create(nodes[i] as SVGElement))\n      }\n    }\n\n    return vels\n  }\n\n  findOne(selector: string) {\n    const found = Dom.findOne(this.node, selector)\n    return found ? Vector.create(found as SVGElement) : null\n  }\n\n  findParentByClass(className: string, terminator?: SVGElement) {\n    const node = Dom.findParentByClass(this.node, className, terminator)\n    return node ? Vector.create(node as SVGElement) : null\n  }\n\n  matches(selector: string): boolean {\n    const node = this.node as any\n    const matches = this.node.matches\n    const matcher: typeof matches =\n      node.matches ||\n      node.matchesSelector ||\n      node.msMatchesSelector ||\n      node.mozMatchesSelector ||\n      node.webkitMatchesSelector ||\n      node.oMatchesSelector ||\n      null\n    return matcher && matcher.call(node, selector)\n  }\n\n  contains(child: SVGElement | Vector) {\n    return Dom.contains(this.node, Vector.isVector(child) ? child.node : child)\n  }\n\n  wrap(node: SVGElement | Vector) {\n    const vel = Vector.create(node)\n    const parentNode = this.node.parentNode as SVGElement\n    if (parentNode != null) {\n      parentNode.insertBefore(vel.node, this.node)\n    }\n    return vel.append(this)\n  }\n\n  parent(type?: string) {\n    let parent: Vector = this // eslint-disable-line @typescript-eslint/no-this-alias\n\n    // check for parent\n    if (parent.node.parentNode == null) {\n      return null\n    }\n\n    // get parent element\n    parent = Vector.create(parent.node.parentNode as SVGElement)\n\n    if (type == null) {\n      return parent\n    }\n\n    // loop trough ancestors if type is given\n    do {\n      if (\n        typeof type === 'string' ? parent.matches(type) : parent instanceof type\n      ) {\n        return parent\n      }\n    } while ((parent = Vector.create(parent.node.parentNode as SVGElement)))\n\n    return parent\n  }\n\n  children() {\n    const children = this.node.childNodes\n    const vels: Vector[] = []\n    for (let i = 0; i < children.length; i += 1) {\n      const currentChild = children[i]\n      if (currentChild.nodeType === 1) {\n        vels.push(Vector.create(children[i] as SVGElement))\n      }\n    }\n    return vels\n  }\n\n  eachChild(\n    fn: (\n      this: Vector,\n      currentValue: Vector,\n      index: number,\n      children: Vector[],\n    ) => void,\n    deep?: boolean,\n  ) {\n    const children = this.children()\n    for (let i = 0, l = children.length; i < l; i += 1) {\n      fn.call(children[i], children[i], i, children)\n      if (deep) {\n        children[i].eachChild(fn, deep)\n      }\n    }\n\n    return this\n  }\n\n  index() {\n    return Dom.index(this.node)\n  }\n\n  hasClass(className: string) {\n    return Dom.hasClass(this.node, className)\n  }\n\n  addClass(className: string) {\n    Dom.addClass(this.node, className)\n    return this\n  }\n\n  removeClass(className?: string) {\n    Dom.removeClass(this.node, className)\n    return this\n  }\n\n  toggleClass(className: string, stateVal?: boolean) {\n    Dom.toggleClass(this.node, className, stateVal)\n    return this\n  }\n\n  toLocalPoint(x: number, y: number) {\n    return Dom.toLocalPoint(this.node, x, y)\n  }\n\n  toGeometryShape() {\n    return Dom.toGeometryShape(this.node)\n  }\n\n  translateCenterToPoint(p: Point.PointLike) {\n    const bbox = this.getBBox({ target: this.svg() })\n    const center = bbox.getCenter()\n    this.translate(p.x - center.x, p.y - center.y)\n    return this\n  }\n\n  translateAndAutoOrient(\n    position: Point.PointLike | Point.PointData,\n    reference: Point.PointLike | Point.PointData,\n    target?: SVGElement,\n  ) {\n    Dom.translateAndAutoOrient(this.node, position, reference, target)\n    return this\n  }\n\n  animate(options: Dom.AnimationOptions) {\n    return Dom.animate(this.node, options)\n  }\n\n  animateTransform(options: Dom.AnimationOptions) {\n    return Dom.animateTransform(this.node, options)\n  }\n\n  animateAlongPath(options: Dom.AnimationOptions, path: SVGPathElement) {\n    return Dom.animateAlongPath(this.node, options, path)\n  }\n\n  /**\n   * Normalize this element's d attribute. SVGPathElements without\n   * a path data attribute obtain a value of 'M 0 0'.\n   */\n  normalizePath() {\n    const tagName = this.tagName()\n    if (tagName === 'path') {\n      this.attr('d', Path.normalize(this.attr('d')))\n    }\n\n    return this\n  }\n\n  /**\n   * Returns the bounding box of the element after transformations are applied.\n   * If `withoutTransformations` is `true`, transformations of the element\n   * will not be considered when computing the bounding box. If `target` is\n   * specified, bounding box will be computed relatively to the target element.\n   */\n  bbox(withoutTransformations?: boolean, target?: SVGElement) {\n    return Dom.bbox(this.node, withoutTransformations, target)\n  }\n\n  getBBox(\n    options: {\n      target?: SVGElement | Vector | null\n      recursive?: boolean\n    } = {},\n  ) {\n    return Dom.getBBox(this.node, {\n      recursive: options.recursive,\n      target: options.target ? Vector.toNode(options.target) : null,\n    })\n  }\n\n  /**\n   * Samples the underlying SVG element (it currently works only on\n   * paths - where it is most useful anyway). Returns an array of objects\n   * of the form `{ x: Number, y: Number, distance: Number }`. Each of these\n   * objects represent a point on the path. This basically creates a discrete\n   * representation of the path (which is possible a curve). The sampling\n   * interval defines the accuracy of the sampling. In other words, we travel\n   * from the beginning of the path to the end by interval distance (on the\n   * path, not between the resulting points) and collect the discrete points\n   * on the path. This is very useful in many situations. For example, SVG\n   * does not provide a built-in mechanism to find intersections between two\n   * paths. Using sampling, we can just generate bunch of points for each of\n   * the path and find the closest ones from each set.\n   */\n  sample(interval = 1) {\n    if (this.node instanceof SVGPathElement) {\n      return Dom.sample(this.node, interval)\n    }\n    return []\n  }\n\n  toPath() {\n    return Vector.create(Dom.toPath(this.node as any))\n  }\n\n  toPathData() {\n    return Dom.toPathData(this.node as any)\n  }\n}\n\nexport namespace Vector {\n  export const toStringTag = `X6.${Vector.name}`\n\n  export function isVector(instance: any): instance is Vector {\n    if (instance == null) {\n      return false\n    }\n\n    if (instance instanceof Vector) {\n      return true\n    }\n\n    const tag = instance[Symbol.toStringTag]\n    const vector = instance as Vector\n\n    if (\n      (tag == null || tag === toStringTag) &&\n      vector.node instanceof SVGElement &&\n      typeof vector.animate === 'function' &&\n      typeof vector.sample === 'function' &&\n      typeof vector.normalizePath === 'function' &&\n      typeof vector.toPath === 'function'\n    ) {\n      return true\n    }\n\n    return false\n  }\n\n  export function create(\n    elem: Vector | SVGElement | string,\n    attrs?: Dom.Attributes,\n    children?: SVGElement | Vector | (SVGElement | Vector)[],\n  ) {\n    return new Vector(elem, attrs, children)\n  }\n\n  export function createVectors(markup: string) {\n    if (markup[0] === '<') {\n      const svgDoc = Dom.createSvgDocument(markup)\n      const vels: Vector[] = []\n      for (let i = 0, ii = svgDoc.childNodes.length; i < ii; i += 1) {\n        const childNode = svgDoc.childNodes[i]!\n        vels.push(create(document.importNode(childNode, true) as SVGElement))\n      }\n\n      return vels\n    }\n\n    return [create(markup)]\n  }\n\n  export function toNode<T extends SVGElement = SVGElement>(\n    elem: SVGElement | DocumentFragment | Vector,\n  ): T {\n    if (isVector(elem)) {\n      return elem.node as T\n    }\n    return elem as T\n  }\n\n  export function toNodes(\n    elems:\n      | SVGElement\n      | DocumentFragment\n      | Vector\n      | (SVGElement | DocumentFragment | Vector)[],\n  ) {\n    if (Array.isArray(elems)) {\n      return elems.map((elem) => toNode(elem))\n    }\n\n    return [toNode(elems)]\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}