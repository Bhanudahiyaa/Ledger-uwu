{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport BaseModel from \"../../core/BaseModel\";\n/* babel-plugin-inline-import '../shaders/plane_frag.glsl' */\nconst planeFrag = \"uniform sampler2D u_texture;\\nlayout(std140) uniform commonUniforms {\\n  float u_opacity;\\n  float u_mapFlag;\\n  float u_terrainClipHeight;\\n};\\n\\nin vec3 v_Color;\\nin vec2 v_uv;\\nin float v_clip;\\nout vec4 outputColor;\\n\\n#pragma include \\\"picking\\\"\\nvoid main() {\\n  if (u_mapFlag > 0.0) {\\n    outputColor = texture(SAMPLER_2D(u_texture), vec2(v_uv.x, 1.0 - v_uv.y));\\n    outputColor.a *= u_opacity;\\n  } else {\\n    outputColor = vec4(v_Color, u_opacity);\\n  }\\n  outputColor.a *= v_clip;\\n  outputColor = filterColor(outputColor);\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/plane_vert.glsl' */\nconst planeVert = \"layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec3 a_Color;\\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\\n\\nlayout(std140) uniform commonUniforms {\\n  float u_opacity;\\n  float u_mapFlag;\\n  float u_terrainClipHeight;\\n};\\n\\nout vec3 v_Color;\\nout vec2 v_uv;\\nout float v_clip;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"picking\\\"\\nvoid main() {\\n  v_Color = a_Color;\\n  v_uv = a_Uv;\\n\\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\\n\\n  v_clip = 1.0;\\n  if (a_Position.z < u_terrainClipHeight) {\\n    v_clip = 0.0;\\n  }\\n\\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, a_Position.z, 1.0));\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\nexport default class PlaneModel extends BaseModel {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"texture\", void 0);\n    _defineProperty(this, \"terrainImage\", void 0);\n    _defineProperty(this, \"terrainImageLoaded\", false);\n    _defineProperty(this, \"mapTexture\", void 0);\n    _defineProperty(this, \"planeGeometryTriangulation\", () => {\n      const {\n        width = 1,\n        height = 1,\n        widthSegments = 1,\n        heightSegments = 1,\n        center = [120, 30],\n        terrainTexture,\n        rgb2height = (r, g, b) => r + g + b\n      } = this.layer.getLayerConfig();\n      const {\n        indices,\n        positions\n      } = this.initPlane(width, height, widthSegments, heightSegments, ...center);\n      if (terrainTexture) {\n        // 存在地形贴图的时候会根据地形贴图对顶点进行偏移\n        return this.translateVertex(positions, indices, this.terrainImage, widthSegments, heightSegments, rgb2height);\n      }\n      return {\n        vertices: positions,\n        indices,\n        size: 5\n      };\n    });\n  }\n  get attributeLocation() {\n    return Object.assign(super.attributeLocation, {\n      MAX: super.attributeLocation.MAX,\n      UV: 10\n    });\n  }\n  initPlane(width = 1, height = 1, widthSegments = 1, heightSegments = 1, lng = 120, lat = 30) {\n    // https://github.com/mrdoob/three.js/blob/dev/src/geometries/PlaneGeometry.js\n    const widthHalf = width / 2;\n    const heightHalf = height / 2;\n    const gridX = Math.floor(widthSegments);\n    const gridY = Math.floor(heightSegments);\n    const gridX1 = gridX + 1;\n    const gridY1 = gridY + 1;\n    const segmentWidth = width / gridX;\n    const segmentHeight = height / gridY;\n    const indices = [];\n    const positions = [];\n    for (let iy = 0; iy < gridY1; iy++) {\n      const y = iy * segmentHeight - heightHalf;\n      for (let ix = 0; ix < gridX1; ix++) {\n        const x = ix * segmentWidth - widthHalf;\n        positions.push(x + lng, -y + lat, 0);\n        positions.push(ix / gridX);\n        positions.push(1 - iy / gridY);\n      }\n    }\n    for (let iy = 0; iy < gridY; iy++) {\n      for (let ix = 0; ix < gridX; ix++) {\n        const a = ix + gridX1 * iy;\n        const b = ix + gridX1 * (iy + 1);\n        const c = ix + 1 + gridX1 * (iy + 1);\n        const d = ix + 1 + gridX1 * iy;\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    }\n    return {\n      indices,\n      positions\n    };\n  }\n  getUninforms() {\n    const commoninfo = this.getCommonUniformsInfo();\n    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());\n    this.updateStyleUnifoms();\n    return _objectSpread(_objectSpread({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);\n  }\n  getCommonUniformsInfo() {\n    const {\n      opacity,\n      mapTexture,\n      terrainClipHeight = 0,\n      terrainTexture\n    } = this.layer.getLayerConfig();\n    if (this.mapTexture !== mapTexture) {\n      var _this$texture;\n      this.mapTexture = mapTexture;\n      (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();\n      this.updateTexture(mapTexture);\n    }\n    const commonOptions = {\n      u_opacity: opacity || 1,\n      u_mapFlag: mapTexture ? 1 : 0,\n      u_terrainClipHeight: terrainTexture ? terrainClipHeight : -1,\n      u_texture: this.texture\n    };\n    this.textures = [this.texture];\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  clearModels() {\n    var _this$texture2;\n    // @ts-ignore\n    this.terrainImage = null;\n    (_this$texture2 = this.texture) === null || _this$texture2 === void 0 || _this$texture2.destroy();\n    this.textures = [];\n  }\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const {\n        mapTexture,\n        terrainTexture\n      } = _this.layer.getLayerConfig();\n      _this.mapTexture = mapTexture;\n      const {\n        createTexture2D\n      } = _this.rendererService;\n      _this.texture = createTexture2D({\n        height: 0,\n        width: 0\n      });\n      _this.updateTexture(mapTexture);\n      _this.initUniformsBuffer();\n      if (terrainTexture) {\n        _this.terrainImage = yield _this.loadTerrainImage(terrainTexture);\n      }\n      const model = yield _this.layer.buildLayerModel({\n        moduleName: 'geometryPlane',\n        vertexShader: planeVert,\n        fragmentShader: planeFrag,\n        triangulation: _this.planeGeometryTriangulation,\n        defines: _this.getDefines(),\n        inject: _this.getInject(),\n        primitive: gl.TRIANGLES,\n        depth: {\n          enable: true\n        },\n        cull: {\n          enable: true,\n          face: gl.BACK // gl.FRONT | gl.BACK;\n        }\n      });\n      return [model];\n    })();\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      return _this2.initModels();\n    })();\n  }\n  createModelData(options) {\n    if (options) {\n      const {\n        widthSegments: oldwidthSegments,\n        heightSegments: oldheightSegments,\n        width: oldwidth,\n        height: oldheight\n      } = this.layer.getLayerConfig();\n      const {\n        widthSegments,\n        heightSegments,\n        width,\n        height\n      } = options;\n      this.layer.style({\n        widthSegments: widthSegments !== undefined ? widthSegments : oldwidthSegments,\n        heightSegments: heightSegments !== undefined ? heightSegments : oldheightSegments,\n        width: width !== undefined ? width : oldwidth,\n        height: height !== undefined ? height : oldheight\n      });\n    }\n    const oldFeatures = this.layer.getEncodedData();\n    const res = this.styleAttributeService.createAttributesAndIndices(oldFeatures, this.planeGeometryTriangulation);\n    return res;\n  }\n  updateTexture(mapTexture) {\n    const {\n      createTexture2D\n    } = this.rendererService;\n    if (mapTexture) {\n      const img = new Image();\n      img.crossOrigin = 'anonymous';\n      img.onload = () => {\n        this.texture = createTexture2D({\n          data: img,\n          width: img.width,\n          height: img.height,\n          wrapS: gl.CLAMP_TO_EDGE,\n          wrapT: gl.CLAMP_TO_EDGE\n        });\n        this.layerService.reRender();\n      };\n      img.src = mapTexture;\n    } else {\n      this.texture = createTexture2D({\n        width: 0,\n        height: 0\n      });\n    }\n  }\n  getImageData(img) {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    const {\n      width,\n      height\n    } = img;\n    canvas.width = width;\n    canvas.height = height;\n    ctx.drawImage(img, 0, 0, width, height);\n    const imageData = ctx.getImageData(0, 0, width, height);\n    return imageData;\n  }\n  translateVertex(positions, indices, image, widthSegments, heightSegments, rgb2height) {\n    const imgWidth = image.width;\n    const imgHeight = image.height;\n    const imageData = this.getImageData(image).data;\n    const gridX = Math.floor(widthSegments);\n    const gridY = Math.floor(heightSegments);\n    const gridX1 = gridX + 1;\n    const gridY1 = gridY + 1;\n    const widthStep = imgWidth / gridX;\n    const heightStep = imgHeight / gridY;\n    for (let iy = 0; iy < gridY1; iy++) {\n      const imgIndexY = Math.floor(iy * heightStep);\n      const imgLen = imgIndexY * imgWidth;\n      for (let ix = 0; ix < gridX1; ix++) {\n        const imgIndexX = Math.floor(ix * widthStep);\n        const imgDataIndex = (imgLen + imgIndexX) * 4;\n        const r = imageData[imgDataIndex];\n        const g = imageData[imgDataIndex + 1];\n        const b = imageData[imgDataIndex + 2];\n        const z = (iy * gridX1 + ix) * 5 + 2;\n        positions[z] = rgb2height(r, g, b);\n      }\n    }\n    return {\n      vertices: positions,\n      indices,\n      size: 5\n    };\n  }\n  loadTerrainImage(terrainTexture) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (_this3.terrainImage) {\n        // 若当前已经存在 image，直接进行偏移计算（LOD）\n        if (_this3.terrainImageLoaded) {\n          return _this3.terrainImage;\n        } else {\n          return new Promise(resolve => {\n            _this3.terrainImage.onload = () => {\n              resolve(_this3.terrainImage);\n            };\n          });\n        }\n      } else {\n        // 加载地形贴图、根据地形贴图对 planeGeometry 进行偏移\n        const terrainImage = new Image();\n        terrainImage.crossOrigin = 'anonymous';\n        return new Promise(resolve => {\n          terrainImage.onload = () => {\n            _this3.terrainImageLoaded = true;\n            resolve(terrainImage);\n            // 图片加载完，触发事件，可以进行地形图的顶点计算存储\n            setTimeout(() => _this3.layer.emit('terrainImageLoaded', null));\n          };\n          terrainImage.src = terrainTexture;\n        });\n      }\n    })();\n  }\n  registerBuiltinAttributes() {\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'uv',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Uv',\n        shaderLocation: this.attributeLocation.UV,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 2,\n        update: (feature, featureIdx, vertex) => {\n          return [vertex[3], vertex[4]];\n        }\n      }\n    });\n  }\n}","map":{"version":3,"names":["_asyncToGenerator","_objectSpread","_defineProperty","AttributeType","gl","BaseModel","planeFrag","planeVert","PlaneModel","constructor","args","width","height","widthSegments","heightSegments","center","terrainTexture","rgb2height","r","g","b","layer","getLayerConfig","indices","positions","initPlane","translateVertex","terrainImage","vertices","size","attributeLocation","Object","assign","MAX","UV","lng","lat","widthHalf","heightHalf","gridX","Math","floor","gridY","gridX1","gridY1","segmentWidth","segmentHeight","iy","y","ix","x","push","a","c","d","getUninforms","commoninfo","getCommonUniformsInfo","attributeInfo","getUniformsBufferInfo","getStyleAttribute","updateStyleUnifoms","uniformsOption","opacity","mapTexture","terrainClipHeight","_this$texture","texture","destroy","updateTexture","commonOptions","u_opacity","u_mapFlag","u_terrainClipHeight","u_texture","textures","commonBufferInfo","clearModels","_this$texture2","initModels","_this","createTexture2D","rendererService","initUniformsBuffer","loadTerrainImage","model","buildLayerModel","moduleName","vertexShader","fragmentShader","triangulation","planeGeometryTriangulation","defines","getDefines","inject","getInject","primitive","TRIANGLES","depth","enable","cull","face","BACK","buildModels","_this2","createModelData","options","oldwidthSegments","oldheightSegments","oldwidth","oldheight","style","undefined","oldFeatures","getEncodedData","res","styleAttributeService","createAttributesAndIndices","img","Image","crossOrigin","onload","data","wrapS","CLAMP_TO_EDGE","wrapT","layerService","reRender","src","getImageData","canvas","document","createElement","ctx","getContext","drawImage","imageData","image","imgWidth","imgHeight","widthStep","heightStep","imgIndexY","imgLen","imgIndexX","imgDataIndex","z","_this3","terrainImageLoaded","Promise","resolve","setTimeout","emit","registerBuiltinAttributes","registerStyleAttribute","name","type","Attribute","descriptor","shaderLocation","buffer","usage","DYNAMIC_DRAW","FLOAT","update","feature","featureIdx","vertex"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/l7-layers/es/geometry/models/plane.js"],"sourcesContent":["import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport BaseModel from \"../../core/BaseModel\";\n/* babel-plugin-inline-import '../shaders/plane_frag.glsl' */\nconst planeFrag = \"uniform sampler2D u_texture;\\nlayout(std140) uniform commonUniforms {\\n  float u_opacity;\\n  float u_mapFlag;\\n  float u_terrainClipHeight;\\n};\\n\\nin vec3 v_Color;\\nin vec2 v_uv;\\nin float v_clip;\\nout vec4 outputColor;\\n\\n#pragma include \\\"picking\\\"\\nvoid main() {\\n  if (u_mapFlag > 0.0) {\\n    outputColor = texture(SAMPLER_2D(u_texture), vec2(v_uv.x, 1.0 - v_uv.y));\\n    outputColor.a *= u_opacity;\\n  } else {\\n    outputColor = vec4(v_Color, u_opacity);\\n  }\\n  outputColor.a *= v_clip;\\n  outputColor = filterColor(outputColor);\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/plane_vert.glsl' */\nconst planeVert = \"layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec3 a_Color;\\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\\n\\nlayout(std140) uniform commonUniforms {\\n  float u_opacity;\\n  float u_mapFlag;\\n  float u_terrainClipHeight;\\n};\\n\\nout vec3 v_Color;\\nout vec2 v_uv;\\nout float v_clip;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"picking\\\"\\nvoid main() {\\n  v_Color = a_Color;\\n  v_uv = a_Uv;\\n\\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\\n\\n  v_clip = 1.0;\\n  if (a_Position.z < u_terrainClipHeight) {\\n    v_clip = 0.0;\\n  }\\n\\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, a_Position.z, 1.0));\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\nexport default class PlaneModel extends BaseModel {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"texture\", void 0);\n    _defineProperty(this, \"terrainImage\", void 0);\n    _defineProperty(this, \"terrainImageLoaded\", false);\n    _defineProperty(this, \"mapTexture\", void 0);\n    _defineProperty(this, \"planeGeometryTriangulation\", () => {\n      const {\n        width = 1,\n        height = 1,\n        widthSegments = 1,\n        heightSegments = 1,\n        center = [120, 30],\n        terrainTexture,\n        rgb2height = (r, g, b) => r + g + b\n      } = this.layer.getLayerConfig();\n      const {\n        indices,\n        positions\n      } = this.initPlane(width, height, widthSegments, heightSegments, ...center);\n      if (terrainTexture) {\n        // 存在地形贴图的时候会根据地形贴图对顶点进行偏移\n        return this.translateVertex(positions, indices, this.terrainImage, widthSegments, heightSegments, rgb2height);\n      }\n      return {\n        vertices: positions,\n        indices,\n        size: 5\n      };\n    });\n  }\n  get attributeLocation() {\n    return Object.assign(super.attributeLocation, {\n      MAX: super.attributeLocation.MAX,\n      UV: 10\n    });\n  }\n  initPlane(width = 1, height = 1, widthSegments = 1, heightSegments = 1, lng = 120, lat = 30) {\n    // https://github.com/mrdoob/three.js/blob/dev/src/geometries/PlaneGeometry.js\n    const widthHalf = width / 2;\n    const heightHalf = height / 2;\n    const gridX = Math.floor(widthSegments);\n    const gridY = Math.floor(heightSegments);\n    const gridX1 = gridX + 1;\n    const gridY1 = gridY + 1;\n    const segmentWidth = width / gridX;\n    const segmentHeight = height / gridY;\n    const indices = [];\n    const positions = [];\n    for (let iy = 0; iy < gridY1; iy++) {\n      const y = iy * segmentHeight - heightHalf;\n      for (let ix = 0; ix < gridX1; ix++) {\n        const x = ix * segmentWidth - widthHalf;\n        positions.push(x + lng, -y + lat, 0);\n        positions.push(ix / gridX);\n        positions.push(1 - iy / gridY);\n      }\n    }\n    for (let iy = 0; iy < gridY; iy++) {\n      for (let ix = 0; ix < gridX; ix++) {\n        const a = ix + gridX1 * iy;\n        const b = ix + gridX1 * (iy + 1);\n        const c = ix + 1 + gridX1 * (iy + 1);\n        const d = ix + 1 + gridX1 * iy;\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    }\n    return {\n      indices,\n      positions\n    };\n  }\n  getUninforms() {\n    const commoninfo = this.getCommonUniformsInfo();\n    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());\n    this.updateStyleUnifoms();\n    return _objectSpread(_objectSpread({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);\n  }\n  getCommonUniformsInfo() {\n    const {\n      opacity,\n      mapTexture,\n      terrainClipHeight = 0,\n      terrainTexture\n    } = this.layer.getLayerConfig();\n    if (this.mapTexture !== mapTexture) {\n      var _this$texture;\n      this.mapTexture = mapTexture;\n      (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();\n      this.updateTexture(mapTexture);\n    }\n    const commonOptions = {\n      u_opacity: opacity || 1,\n      u_mapFlag: mapTexture ? 1 : 0,\n      u_terrainClipHeight: terrainTexture ? terrainClipHeight : -1,\n      u_texture: this.texture\n    };\n    this.textures = [this.texture];\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  clearModels() {\n    var _this$texture2;\n    // @ts-ignore\n    this.terrainImage = null;\n    (_this$texture2 = this.texture) === null || _this$texture2 === void 0 || _this$texture2.destroy();\n    this.textures = [];\n  }\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const {\n        mapTexture,\n        terrainTexture\n      } = _this.layer.getLayerConfig();\n      _this.mapTexture = mapTexture;\n      const {\n        createTexture2D\n      } = _this.rendererService;\n      _this.texture = createTexture2D({\n        height: 0,\n        width: 0\n      });\n      _this.updateTexture(mapTexture);\n      _this.initUniformsBuffer();\n      if (terrainTexture) {\n        _this.terrainImage = yield _this.loadTerrainImage(terrainTexture);\n      }\n      const model = yield _this.layer.buildLayerModel({\n        moduleName: 'geometryPlane',\n        vertexShader: planeVert,\n        fragmentShader: planeFrag,\n        triangulation: _this.planeGeometryTriangulation,\n        defines: _this.getDefines(),\n        inject: _this.getInject(),\n        primitive: gl.TRIANGLES,\n        depth: {\n          enable: true\n        },\n        cull: {\n          enable: true,\n          face: gl.BACK // gl.FRONT | gl.BACK;\n        }\n      });\n      return [model];\n    })();\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      return _this2.initModels();\n    })();\n  }\n  createModelData(options) {\n    if (options) {\n      const {\n        widthSegments: oldwidthSegments,\n        heightSegments: oldheightSegments,\n        width: oldwidth,\n        height: oldheight\n      } = this.layer.getLayerConfig();\n      const {\n        widthSegments,\n        heightSegments,\n        width,\n        height\n      } = options;\n      this.layer.style({\n        widthSegments: widthSegments !== undefined ? widthSegments : oldwidthSegments,\n        heightSegments: heightSegments !== undefined ? heightSegments : oldheightSegments,\n        width: width !== undefined ? width : oldwidth,\n        height: height !== undefined ? height : oldheight\n      });\n    }\n    const oldFeatures = this.layer.getEncodedData();\n    const res = this.styleAttributeService.createAttributesAndIndices(oldFeatures, this.planeGeometryTriangulation);\n    return res;\n  }\n  updateTexture(mapTexture) {\n    const {\n      createTexture2D\n    } = this.rendererService;\n    if (mapTexture) {\n      const img = new Image();\n      img.crossOrigin = 'anonymous';\n      img.onload = () => {\n        this.texture = createTexture2D({\n          data: img,\n          width: img.width,\n          height: img.height,\n          wrapS: gl.CLAMP_TO_EDGE,\n          wrapT: gl.CLAMP_TO_EDGE\n        });\n        this.layerService.reRender();\n      };\n      img.src = mapTexture;\n    } else {\n      this.texture = createTexture2D({\n        width: 0,\n        height: 0\n      });\n    }\n  }\n  getImageData(img) {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    const {\n      width,\n      height\n    } = img;\n    canvas.width = width;\n    canvas.height = height;\n    ctx.drawImage(img, 0, 0, width, height);\n    const imageData = ctx.getImageData(0, 0, width, height);\n    return imageData;\n  }\n  translateVertex(positions, indices, image, widthSegments, heightSegments, rgb2height) {\n    const imgWidth = image.width;\n    const imgHeight = image.height;\n    const imageData = this.getImageData(image).data;\n    const gridX = Math.floor(widthSegments);\n    const gridY = Math.floor(heightSegments);\n    const gridX1 = gridX + 1;\n    const gridY1 = gridY + 1;\n    const widthStep = imgWidth / gridX;\n    const heightStep = imgHeight / gridY;\n    for (let iy = 0; iy < gridY1; iy++) {\n      const imgIndexY = Math.floor(iy * heightStep);\n      const imgLen = imgIndexY * imgWidth;\n      for (let ix = 0; ix < gridX1; ix++) {\n        const imgIndexX = Math.floor(ix * widthStep);\n        const imgDataIndex = (imgLen + imgIndexX) * 4;\n        const r = imageData[imgDataIndex];\n        const g = imageData[imgDataIndex + 1];\n        const b = imageData[imgDataIndex + 2];\n        const z = (iy * gridX1 + ix) * 5 + 2;\n        positions[z] = rgb2height(r, g, b);\n      }\n    }\n    return {\n      vertices: positions,\n      indices,\n      size: 5\n    };\n  }\n  loadTerrainImage(terrainTexture) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (_this3.terrainImage) {\n        // 若当前已经存在 image，直接进行偏移计算（LOD）\n        if (_this3.terrainImageLoaded) {\n          return _this3.terrainImage;\n        } else {\n          return new Promise(resolve => {\n            _this3.terrainImage.onload = () => {\n              resolve(_this3.terrainImage);\n            };\n          });\n        }\n      } else {\n        // 加载地形贴图、根据地形贴图对 planeGeometry 进行偏移\n        const terrainImage = new Image();\n        terrainImage.crossOrigin = 'anonymous';\n        return new Promise(resolve => {\n          terrainImage.onload = () => {\n            _this3.terrainImageLoaded = true;\n            resolve(terrainImage);\n            // 图片加载完，触发事件，可以进行地形图的顶点计算存储\n            setTimeout(() => _this3.layer.emit('terrainImageLoaded', null));\n          };\n          terrainImage.src = terrainTexture;\n        });\n      }\n    })();\n  }\n  registerBuiltinAttributes() {\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'uv',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Uv',\n        shaderLocation: this.attributeLocation.UV,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 2,\n        update: (feature, featureIdx, vertex) => {\n          return [vertex[3], vertex[4]];\n        }\n      }\n    });\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}