{"ast":null,"code":"import { ObjectExt, ArrayExt, Dom, FunctionExt, StringExt, Scheduler } from '../util';\nimport { Point } from '../geometry';\nimport { Dictionary } from '../common';\nimport { Attr } from '../registry/attr';\nimport { View } from './view';\nexport class AttrManager {\n  constructor(view) {\n    this.view = view;\n  }\n  get cell() {\n    return this.view.cell;\n  }\n  getDefinition(attrName) {\n    return this.cell.getAttrDefinition(attrName);\n  }\n  processAttrs(elem, raw) {\n    let normal;\n    let set;\n    let offset;\n    let position;\n    let delay;\n    const specials = [];\n    // divide the attributes between normal and special\n    Object.keys(raw).forEach(name => {\n      const val = raw[name];\n      const definition = this.getDefinition(name);\n      const isValid = FunctionExt.call(Attr.isValidDefinition, this.view, definition, val, {\n        elem,\n        attrs: raw,\n        cell: this.cell,\n        view: this.view\n      });\n      if (definition && isValid) {\n        if (typeof definition === 'string') {\n          if (normal == null) {\n            normal = {};\n          }\n          normal[definition] = val;\n        } else if (val !== null) {\n          specials.push({\n            name,\n            definition\n          });\n        }\n      } else {\n        if (normal == null) {\n          normal = {};\n        }\n        const normalName = Dom.CASE_SENSITIVE_ATTR.includes(name) ? name : StringExt.kebabCase(name);\n        normal[normalName] = val;\n      }\n    });\n    specials.forEach(({\n      name,\n      definition\n    }) => {\n      const val = raw[name];\n      const setDefine = definition;\n      if (typeof setDefine.set === 'function') {\n        if (!Dom.isHTMLElement(elem) && AttrManager.DELAY_ATTRS.includes(name)) {\n          if (delay == null) {\n            delay = {};\n          }\n          delay[name] = val;\n        } else {\n          if (set == null) {\n            set = {};\n          }\n          set[name] = val;\n        }\n      }\n      const offsetDefine = definition;\n      if (typeof offsetDefine.offset === 'function') {\n        if (offset == null) {\n          offset = {};\n        }\n        offset[name] = val;\n      }\n      const positionDefine = definition;\n      if (typeof positionDefine.position === 'function') {\n        if (position == null) {\n          position = {};\n        }\n        position[name] = val;\n      }\n    });\n    return {\n      raw,\n      normal,\n      set,\n      offset,\n      position,\n      delay\n    };\n  }\n  mergeProcessedAttrs(allProcessedAttrs, roProcessedAttrs) {\n    allProcessedAttrs.set = Object.assign(Object.assign({}, allProcessedAttrs.set), roProcessedAttrs.set);\n    allProcessedAttrs.position = Object.assign(Object.assign({}, allProcessedAttrs.position), roProcessedAttrs.position);\n    allProcessedAttrs.offset = Object.assign(Object.assign({}, allProcessedAttrs.offset), roProcessedAttrs.offset);\n    // Handle also the special transform property.\n    const transform = allProcessedAttrs.normal && allProcessedAttrs.normal.transform;\n    if (transform != null && roProcessedAttrs.normal) {\n      roProcessedAttrs.normal.transform = transform;\n    }\n    allProcessedAttrs.normal = roProcessedAttrs.normal;\n  }\n  findAttrs(cellAttrs, rootNode, selectorCache, selectors) {\n    const merge = [];\n    const result = new Dictionary();\n    Object.keys(cellAttrs).forEach(selector => {\n      const attrs = cellAttrs[selector];\n      if (!ObjectExt.isPlainObject(attrs)) {\n        return;\n      }\n      const {\n        isCSSSelector,\n        elems\n      } = View.find(selector, rootNode, selectors);\n      selectorCache[selector] = elems;\n      for (let i = 0, l = elems.length; i < l; i += 1) {\n        const elem = elems[i];\n        const unique = selectors && selectors[selector] === elem;\n        const prev = result.get(elem);\n        if (prev) {\n          if (!prev.array) {\n            merge.push(elem);\n            prev.array = true;\n            prev.attrs = [prev.attrs];\n            prev.priority = [prev.priority];\n          }\n          const attributes = prev.attrs;\n          const selectedLength = prev.priority;\n          if (unique) {\n            // node referenced by `selector`\n            attributes.unshift(attrs);\n            selectedLength.unshift(-1);\n          } else {\n            // node referenced by `groupSelector` or CSSSelector\n            const sortIndex = ArrayExt.sortedIndex(selectedLength, isCSSSelector ? -1 : l);\n            attributes.splice(sortIndex, 0, attrs);\n            selectedLength.splice(sortIndex, 0, l);\n          }\n        } else {\n          result.set(elem, {\n            elem,\n            attrs,\n            priority: unique ? -1 : l,\n            array: false\n          });\n        }\n      }\n    });\n    merge.forEach(node => {\n      const item = result.get(node);\n      const arr = item.attrs;\n      item.attrs = arr.reduceRight((memo, attrs) => ObjectExt.merge(memo, attrs), {});\n    });\n    return result;\n  }\n  updateRelativeAttrs(elem, processedAttrs, refBBox, options) {\n    const rawAttrs = processedAttrs.raw || {};\n    let nodeAttrs = processedAttrs.normal || {};\n    const setAttrs = processedAttrs.set;\n    const positionAttrs = processedAttrs.position;\n    const offsetAttrs = processedAttrs.offset;\n    const delayAttrs = processedAttrs.delay;\n    const getOptions = () => ({\n      elem,\n      cell: this.cell,\n      view: this.view,\n      attrs: rawAttrs,\n      refBBox: refBBox.clone()\n    });\n    if (setAttrs != null) {\n      Object.keys(setAttrs).forEach(name => {\n        const val = setAttrs[name];\n        const def = this.getDefinition(name);\n        if (def != null) {\n          const ret = FunctionExt.call(def.set, this.view, val, getOptions());\n          if (typeof ret === 'object') {\n            nodeAttrs = Object.assign(Object.assign({}, nodeAttrs), ret);\n          } else if (ret != null) {\n            nodeAttrs[name] = ret;\n          }\n        }\n      });\n    }\n    if (Dom.isHTMLElement(elem)) {\n      // TODO: setting the `transform` attribute on HTMLElements\n      // via `node.style.transform = 'matrix(...)';` would introduce\n      // a breaking change (e.g. basic.TextBlock).\n      this.view.setAttrs(nodeAttrs, elem);\n      return;\n    }\n    // The final translation of the subelement.\n    const nodeTransform = nodeAttrs.transform;\n    const transform = nodeTransform ? `${nodeTransform}` : null;\n    const nodeMatrix = Dom.transformStringToMatrix(transform);\n    const nodePosition = new Point(nodeMatrix.e, nodeMatrix.f);\n    if (nodeTransform) {\n      delete nodeAttrs.transform;\n      nodeMatrix.e = 0;\n      nodeMatrix.f = 0;\n    }\n    // Calculates node scale determined by the scalable group.\n    let sx = 1;\n    let sy = 1;\n    if (positionAttrs || offsetAttrs) {\n      const scale = this.view.getScaleOfElement(elem, options.scalableNode);\n      sx = scale.sx;\n      sy = scale.sy;\n    }\n    let positioned = false;\n    if (positionAttrs != null) {\n      Object.keys(positionAttrs).forEach(name => {\n        const val = positionAttrs[name];\n        const def = this.getDefinition(name);\n        if (def != null) {\n          const ts = FunctionExt.call(def.position, this.view, val, getOptions());\n          if (ts != null) {\n            positioned = true;\n            nodePosition.translate(Point.create(ts).scale(sx, sy));\n          }\n        }\n      });\n    }\n    // The node bounding box could depend on the `size`\n    // set from the previous loop.\n    this.view.setAttrs(nodeAttrs, elem);\n    let offseted = false;\n    if (offsetAttrs != null) {\n      // Check if the node is visible\n      const nodeBoundingRect = this.view.getBoundingRectOfElement(elem);\n      if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n        const nodeBBox = Dom.transformRectangle(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);\n        Object.keys(offsetAttrs).forEach(name => {\n          const val = offsetAttrs[name];\n          const def = this.getDefinition(name);\n          if (def != null) {\n            const ts = FunctionExt.call(def.offset, this.view, val, {\n              elem,\n              cell: this.cell,\n              view: this.view,\n              attrs: rawAttrs,\n              refBBox: nodeBBox\n            });\n            if (ts != null) {\n              offseted = true;\n              nodePosition.translate(Point.create(ts).scale(sx, sy));\n            }\n          }\n        });\n      }\n    }\n    if (nodeTransform != null || positioned || offseted) {\n      nodePosition.round(1);\n      nodeMatrix.e = nodePosition.x;\n      nodeMatrix.f = nodePosition.y;\n      elem.setAttribute('transform', Dom.matrixToTransformString(nodeMatrix));\n    }\n    // delay render\n    const updateDelayAttrs = () => {\n      if (delayAttrs != null) {\n        Object.keys(delayAttrs).forEach(name => {\n          const val = delayAttrs[name];\n          const def = this.getDefinition(name);\n          if (def != null) {\n            const ret = FunctionExt.call(def.set, this.view, val, getOptions());\n            if (typeof ret === 'object') {\n              this.view.setAttrs(ret, elem);\n            } else if (ret != null) {\n              this.view.setAttrs({\n                [name]: ret\n              }, elem);\n            }\n          }\n        });\n      }\n    };\n    if (options.forceSync) {\n      updateDelayAttrs();\n    } else {\n      Scheduler.scheduleTask(updateDelayAttrs);\n    }\n  }\n  update(rootNode, attrs, options) {\n    const selectorCache = {};\n    const nodesAttrs = this.findAttrs(options.attrs || attrs, rootNode, selectorCache, options.selectors);\n    // `nodesAttrs` are different from all attributes, when\n    // rendering only attributes sent to this method.\n    const nodesAllAttrs = options.attrs ? this.findAttrs(attrs, rootNode, selectorCache, options.selectors) : nodesAttrs;\n    const specialItems = [];\n    nodesAttrs.each(data => {\n      const node = data.elem;\n      const nodeAttrs = data.attrs;\n      const processed = this.processAttrs(node, nodeAttrs);\n      if (processed.set == null && processed.position == null && processed.offset == null && processed.delay == null) {\n        this.view.setAttrs(processed.normal, node);\n      } else {\n        const data = nodesAllAttrs.get(node);\n        const nodeAllAttrs = data ? data.attrs : null;\n        const refSelector = nodeAllAttrs && nodeAttrs.ref == null ? nodeAllAttrs.ref : nodeAttrs.ref;\n        let refNode;\n        if (refSelector) {\n          refNode = (selectorCache[refSelector] || this.view.find(refSelector, rootNode, options.selectors))[0];\n          if (!refNode) {\n            throw new Error(`\"${refSelector}\" reference does not exist.`);\n          }\n        } else {\n          refNode = null;\n        }\n        const item = {\n          node,\n          refNode,\n          attributes: nodeAllAttrs,\n          processedAttributes: processed\n        };\n        // If an element in the list is positioned relative to this one, then\n        // we want to insert this one before it in the list.\n        const index = specialItems.findIndex(item => item.refNode === node);\n        if (index > -1) {\n          specialItems.splice(index, 0, item);\n        } else {\n          specialItems.push(item);\n        }\n      }\n    });\n    const bboxCache = new Dictionary();\n    let rotatableMatrix;\n    specialItems.forEach(item => {\n      const node = item.node;\n      const refNode = item.refNode;\n      let unrotatedRefBBox;\n      const isRefNodeRotatable = refNode != null && options.rotatableNode != null && Dom.contains(options.rotatableNode, refNode);\n      // Find the reference element bounding box. If no reference was\n      // provided, we use the optional bounding box.\n      if (refNode) {\n        unrotatedRefBBox = bboxCache.get(refNode);\n      }\n      if (!unrotatedRefBBox) {\n        const target = isRefNodeRotatable ? options.rotatableNode : rootNode;\n        unrotatedRefBBox = refNode ? Dom.getBBox(refNode, {\n          target\n        }) : options.rootBBox;\n        if (refNode) {\n          bboxCache.set(refNode, unrotatedRefBBox);\n        }\n      }\n      let processedAttrs;\n      if (options.attrs && item.attributes) {\n        // If there was a special attribute affecting the position amongst\n        // passed-in attributes we have to merge it with the rest of the\n        // element's attributes as they are necessary to update the position\n        // relatively (i.e `ref-x` && 'ref-dx').\n        processedAttrs = this.processAttrs(node, item.attributes);\n        this.mergeProcessedAttrs(processedAttrs, item.processedAttributes);\n      } else {\n        processedAttrs = item.processedAttributes;\n      }\n      let refBBox = unrotatedRefBBox;\n      if (isRefNodeRotatable && options.rotatableNode != null && !options.rotatableNode.contains(node)) {\n        // If the referenced node is inside the rotatable group while the\n        // updated node is outside, we need to take the rotatable node\n        // transformation into account.\n        if (!rotatableMatrix) {\n          rotatableMatrix = Dom.transformStringToMatrix(Dom.attr(options.rotatableNode, 'transform'));\n        }\n        refBBox = Dom.transformRectangle(unrotatedRefBBox, rotatableMatrix);\n      }\n      const caller = specialItems.find(item => item.refNode === node);\n      if (caller) {\n        options.forceSync = true;\n      }\n      this.updateRelativeAttrs(node, processedAttrs, refBBox, options);\n    });\n  }\n}\n(function (AttrManager) {\n  AttrManager.DELAY_ATTRS = ['text', 'textWrap', 'sourceMarker', 'targetMarker'];\n})(AttrManager || (AttrManager = {}));","map":{"version":3,"names":["ObjectExt","ArrayExt","Dom","FunctionExt","StringExt","Scheduler","Point","Dictionary","Attr","View","AttrManager","constructor","view","cell","getDefinition","attrName","getAttrDefinition","processAttrs","elem","raw","normal","set","offset","position","delay","specials","Object","keys","forEach","name","val","definition","isValid","call","isValidDefinition","attrs","push","normalName","CASE_SENSITIVE_ATTR","includes","kebabCase","setDefine","isHTMLElement","DELAY_ATTRS","offsetDefine","positionDefine","mergeProcessedAttrs","allProcessedAttrs","roProcessedAttrs","assign","transform","findAttrs","cellAttrs","rootNode","selectorCache","selectors","merge","result","selector","isPlainObject","isCSSSelector","elems","find","i","l","length","unique","prev","get","array","priority","attributes","selectedLength","unshift","sortIndex","sortedIndex","splice","node","item","arr","reduceRight","memo","updateRelativeAttrs","processedAttrs","refBBox","options","rawAttrs","nodeAttrs","setAttrs","positionAttrs","offsetAttrs","delayAttrs","getOptions","clone","def","ret","nodeTransform","nodeMatrix","transformStringToMatrix","nodePosition","e","f","sx","sy","scale","getScaleOfElement","scalableNode","positioned","ts","translate","create","offseted","nodeBoundingRect","getBoundingRectOfElement","width","height","nodeBBox","transformRectangle","round","x","y","setAttribute","matrixToTransformString","updateDelayAttrs","forceSync","scheduleTask","update","nodesAttrs","nodesAllAttrs","specialItems","each","data","processed","nodeAllAttrs","refSelector","ref","refNode","Error","processedAttributes","index","findIndex","bboxCache","rotatableMatrix","unrotatedRefBBox","isRefNodeRotatable","rotatableNode","contains","target","getBBox","rootBBox","attr","caller"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/view/attr.ts"],"sourcesContent":["import {\n  ObjectExt,\n  ArrayExt,\n  Dom,\n  FunctionExt,\n  StringExt,\n  Scheduler,\n} from '../util'\nimport { Rectangle, Point } from '../geometry'\nimport { Dictionary } from '../common'\nimport { Attr } from '../registry/attr'\nimport { View } from './view'\nimport { Markup } from './markup'\nimport { CellView } from './cell'\n\nexport class AttrManager {\n  constructor(protected view: CellView) {}\n\n  protected get cell() {\n    return this.view.cell\n  }\n\n  protected getDefinition(attrName: string): Attr.Definition | null {\n    return this.cell.getAttrDefinition(attrName)\n  }\n\n  protected processAttrs(\n    elem: Element,\n    raw: Attr.ComplexAttrs,\n  ): AttrManager.ProcessedAttrs {\n    let normal: Attr.SimpleAttrs | undefined\n    let set: Attr.ComplexAttrs | undefined\n    let offset: Attr.ComplexAttrs | undefined\n    let position: Attr.ComplexAttrs | undefined\n    let delay: Attr.ComplexAttrs | undefined\n\n    const specials: { name: string; definition: Attr.Definition }[] = []\n\n    // divide the attributes between normal and special\n    Object.keys(raw).forEach((name) => {\n      const val = raw[name]\n      const definition = this.getDefinition(name)\n      const isValid = FunctionExt.call(\n        Attr.isValidDefinition,\n        this.view,\n        definition,\n        val,\n        {\n          elem,\n          attrs: raw,\n          cell: this.cell,\n          view: this.view,\n        },\n      )\n\n      if (definition && isValid) {\n        if (typeof definition === 'string') {\n          if (normal == null) {\n            normal = {}\n          }\n          normal[definition] = val as Attr.SimpleAttrValue\n        } else if (val !== null) {\n          specials.push({ name, definition })\n        }\n      } else {\n        if (normal == null) {\n          normal = {}\n        }\n        const normalName = Dom.CASE_SENSITIVE_ATTR.includes(name)\n          ? name\n          : StringExt.kebabCase(name)\n        normal[normalName] = val as Attr.SimpleAttrValue\n      }\n    })\n\n    specials.forEach(({ name, definition }) => {\n      const val = raw[name]\n\n      const setDefine = definition as Attr.SetDefinition\n      if (typeof setDefine.set === 'function') {\n        if (\n          !Dom.isHTMLElement(elem) &&\n          AttrManager.DELAY_ATTRS.includes(name)\n        ) {\n          if (delay == null) {\n            delay = {}\n          }\n          delay[name] = val\n        } else {\n          if (set == null) {\n            set = {}\n          }\n          set[name] = val\n        }\n      }\n\n      const offsetDefine = definition as Attr.OffsetDefinition\n      if (typeof offsetDefine.offset === 'function') {\n        if (offset == null) {\n          offset = {}\n        }\n        offset[name] = val\n      }\n\n      const positionDefine = definition as Attr.PositionDefinition\n      if (typeof positionDefine.position === 'function') {\n        if (position == null) {\n          position = {}\n        }\n        position[name] = val\n      }\n    })\n\n    return {\n      raw,\n      normal,\n      set,\n      offset,\n      position,\n      delay,\n    }\n  }\n\n  protected mergeProcessedAttrs(\n    allProcessedAttrs: AttrManager.ProcessedAttrs,\n    roProcessedAttrs: AttrManager.ProcessedAttrs,\n  ) {\n    allProcessedAttrs.set = {\n      ...allProcessedAttrs.set,\n      ...roProcessedAttrs.set,\n    }\n\n    allProcessedAttrs.position = {\n      ...allProcessedAttrs.position,\n      ...roProcessedAttrs.position,\n    }\n\n    allProcessedAttrs.offset = {\n      ...allProcessedAttrs.offset,\n      ...roProcessedAttrs.offset,\n    }\n\n    // Handle also the special transform property.\n    const transform =\n      allProcessedAttrs.normal && allProcessedAttrs.normal.transform\n    if (transform != null && roProcessedAttrs.normal) {\n      roProcessedAttrs.normal.transform = transform\n    }\n    allProcessedAttrs.normal = roProcessedAttrs.normal\n  }\n\n  protected findAttrs(\n    cellAttrs: Attr.CellAttrs,\n    rootNode: Element,\n    selectorCache: { [selector: string]: Element[] },\n    selectors: Markup.Selectors,\n  ) {\n    const merge: Element[] = []\n    const result: Dictionary<\n      Element,\n      {\n        elem: Element\n        array: boolean\n        priority: number | number[]\n        attrs: Attr.ComplexAttrs | Attr.ComplexAttrs[]\n      }\n    > = new Dictionary()\n\n    Object.keys(cellAttrs).forEach((selector) => {\n      const attrs = cellAttrs[selector]\n      if (!ObjectExt.isPlainObject(attrs)) {\n        return\n      }\n\n      const { isCSSSelector, elems } = View.find(selector, rootNode, selectors)\n      selectorCache[selector] = elems\n      for (let i = 0, l = elems.length; i < l; i += 1) {\n        const elem = elems[i]\n        const unique = selectors && selectors[selector] === elem\n        const prev = result.get(elem)\n        if (prev) {\n          if (!prev.array) {\n            merge.push(elem)\n            prev.array = true\n            prev.attrs = [prev.attrs as Attr.ComplexAttrs]\n            prev.priority = [prev.priority as number]\n          }\n\n          const attributes = prev.attrs as Attr.ComplexAttrs[]\n          const selectedLength = prev.priority as number[]\n          if (unique) {\n            // node referenced by `selector`\n            attributes.unshift(attrs)\n            selectedLength.unshift(-1)\n          } else {\n            // node referenced by `groupSelector` or CSSSelector\n            const sortIndex = ArrayExt.sortedIndex(\n              selectedLength,\n              isCSSSelector ? -1 : l,\n            )\n\n            attributes.splice(sortIndex, 0, attrs)\n            selectedLength.splice(sortIndex, 0, l)\n          }\n        } else {\n          result.set(elem, {\n            elem,\n            attrs,\n            priority: unique ? -1 : l,\n            array: false,\n          })\n        }\n      }\n    })\n\n    merge.forEach((node) => {\n      const item = result.get(node)!\n      const arr = item.attrs as Attr.ComplexAttrs[]\n      item.attrs = arr.reduceRight(\n        (memo, attrs) => ObjectExt.merge(memo, attrs),\n        {},\n      )\n    })\n\n    return result as Dictionary<\n      Element,\n      {\n        elem: Element\n        array: boolean\n        priority: number | number[]\n        attrs: Attr.ComplexAttrs\n      }\n    >\n  }\n\n  protected updateRelativeAttrs(\n    elem: Element,\n    processedAttrs: AttrManager.ProcessedAttrs,\n    refBBox: Rectangle,\n    options: AttrManager.UpdateOptions,\n  ) {\n    const rawAttrs = processedAttrs.raw || {}\n    let nodeAttrs = processedAttrs.normal || {}\n    const setAttrs = processedAttrs.set\n    const positionAttrs = processedAttrs.position\n    const offsetAttrs = processedAttrs.offset\n    const delayAttrs = processedAttrs.delay\n\n    const getOptions = () => ({\n      elem,\n      cell: this.cell,\n      view: this.view,\n      attrs: rawAttrs,\n      refBBox: refBBox.clone(),\n    })\n\n    if (setAttrs != null) {\n      Object.keys(setAttrs).forEach((name) => {\n        const val = setAttrs[name]\n        const def = this.getDefinition(name)\n        if (def != null) {\n          const ret = FunctionExt.call(\n            (def as Attr.SetDefinition).set,\n            this.view,\n            val,\n            getOptions(),\n          )\n          if (typeof ret === 'object') {\n            nodeAttrs = {\n              ...nodeAttrs,\n              ...ret,\n            }\n          } else if (ret != null) {\n            nodeAttrs[name] = ret\n          }\n        }\n      })\n    }\n\n    if (Dom.isHTMLElement(elem)) {\n      // TODO: setting the `transform` attribute on HTMLElements\n      // via `node.style.transform = 'matrix(...)';` would introduce\n      // a breaking change (e.g. basic.TextBlock).\n      this.view.setAttrs(nodeAttrs, elem)\n      return\n    }\n\n    // The final translation of the subelement.\n    const nodeTransform = nodeAttrs.transform\n    const transform = nodeTransform ? `${nodeTransform}` : null\n    const nodeMatrix = Dom.transformStringToMatrix(transform)\n    const nodePosition = new Point(nodeMatrix.e, nodeMatrix.f)\n    if (nodeTransform) {\n      delete nodeAttrs.transform\n      nodeMatrix.e = 0\n      nodeMatrix.f = 0\n    }\n\n    // Calculates node scale determined by the scalable group.\n    let sx = 1\n    let sy = 1\n    if (positionAttrs || offsetAttrs) {\n      const scale = this.view.getScaleOfElement(\n        elem,\n        options.scalableNode as SVGElement,\n      )\n      sx = scale.sx\n      sy = scale.sy\n    }\n\n    let positioned = false\n    if (positionAttrs != null) {\n      Object.keys(positionAttrs).forEach((name) => {\n        const val = positionAttrs[name]\n        const def = this.getDefinition(name)\n        if (def != null) {\n          const ts = FunctionExt.call(\n            (def as Attr.PositionDefinition).position,\n            this.view,\n            val,\n            getOptions(),\n          )\n\n          if (ts != null) {\n            positioned = true\n            nodePosition.translate(Point.create(ts).scale(sx, sy))\n          }\n        }\n      })\n    }\n\n    // The node bounding box could depend on the `size`\n    // set from the previous loop.\n    this.view.setAttrs(nodeAttrs, elem)\n\n    let offseted = false\n    if (offsetAttrs != null) {\n      // Check if the node is visible\n      const nodeBoundingRect = this.view.getBoundingRectOfElement(elem)\n      if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n        const nodeBBox = Dom.transformRectangle(\n          nodeBoundingRect,\n          nodeMatrix,\n        ).scale(1 / sx, 1 / sy)\n\n        Object.keys(offsetAttrs).forEach((name) => {\n          const val = offsetAttrs[name]\n          const def = this.getDefinition(name)\n          if (def != null) {\n            const ts = FunctionExt.call(\n              (def as Attr.OffsetDefinition).offset,\n              this.view,\n              val,\n              {\n                elem,\n                cell: this.cell,\n                view: this.view,\n                attrs: rawAttrs,\n                refBBox: nodeBBox,\n              },\n            )\n\n            if (ts != null) {\n              offseted = true\n              nodePosition.translate(Point.create(ts).scale(sx, sy))\n            }\n          }\n        })\n      }\n    }\n\n    if (nodeTransform != null || positioned || offseted) {\n      nodePosition.round(1)\n      nodeMatrix.e = nodePosition.x\n      nodeMatrix.f = nodePosition.y\n      elem.setAttribute('transform', Dom.matrixToTransformString(nodeMatrix))\n    }\n\n    // delay render\n    const updateDelayAttrs = () => {\n      if (delayAttrs != null) {\n        Object.keys(delayAttrs).forEach((name) => {\n          const val = delayAttrs[name]\n          const def = this.getDefinition(name)\n          if (def != null) {\n            const ret = FunctionExt.call(\n              (def as Attr.SetDefinition).set,\n              this.view,\n              val,\n              getOptions(),\n            )\n            if (typeof ret === 'object') {\n              this.view.setAttrs(ret, elem)\n            } else if (ret != null) {\n              this.view.setAttrs(\n                {\n                  [name]: ret,\n                },\n                elem,\n              )\n            }\n          }\n        })\n      }\n    }\n    if (options.forceSync) {\n      updateDelayAttrs()\n    } else {\n      Scheduler.scheduleTask(updateDelayAttrs)\n    }\n  }\n\n  update(\n    rootNode: Element,\n    attrs: Attr.CellAttrs,\n    options: AttrManager.UpdateOptions,\n  ) {\n    const selectorCache: { [selector: string]: Element[] } = {}\n    const nodesAttrs = this.findAttrs(\n      options.attrs || attrs,\n      rootNode,\n      selectorCache,\n      options.selectors,\n    )\n\n    // `nodesAttrs` are different from all attributes, when\n    // rendering only attributes sent to this method.\n    const nodesAllAttrs = options.attrs\n      ? this.findAttrs(attrs, rootNode, selectorCache, options.selectors)\n      : nodesAttrs\n\n    const specialItems: {\n      node: Element\n      refNode: Element | null\n      attributes: Attr.ComplexAttrs | null\n      processedAttributes: AttrManager.ProcessedAttrs\n    }[] = []\n\n    nodesAttrs.each((data) => {\n      const node = data.elem\n      const nodeAttrs = data.attrs\n      const processed = this.processAttrs(node, nodeAttrs)\n      if (\n        processed.set == null &&\n        processed.position == null &&\n        processed.offset == null &&\n        processed.delay == null\n      ) {\n        this.view.setAttrs(processed.normal, node)\n      } else {\n        const data = nodesAllAttrs.get(node)\n        const nodeAllAttrs = data ? data.attrs : null\n        const refSelector =\n          nodeAllAttrs && nodeAttrs.ref == null\n            ? nodeAllAttrs.ref\n            : nodeAttrs.ref\n\n        let refNode: Element | null\n        if (refSelector) {\n          refNode = (selectorCache[refSelector as string] ||\n            this.view.find(\n              refSelector as string,\n              rootNode,\n              options.selectors,\n            ))[0]\n          if (!refNode) {\n            throw new Error(`\"${refSelector}\" reference does not exist.`)\n          }\n        } else {\n          refNode = null\n        }\n\n        const item = {\n          node,\n          refNode,\n          attributes: nodeAllAttrs,\n          processedAttributes: processed,\n        }\n\n        // If an element in the list is positioned relative to this one, then\n        // we want to insert this one before it in the list.\n        const index = specialItems.findIndex((item) => item.refNode === node)\n        if (index > -1) {\n          specialItems.splice(index, 0, item)\n        } else {\n          specialItems.push(item)\n        }\n      }\n    })\n\n    const bboxCache: Dictionary<Element, Rectangle> = new Dictionary()\n    let rotatableMatrix: DOMMatrix\n    specialItems.forEach((item) => {\n      const node = item.node\n      const refNode = item.refNode\n\n      let unrotatedRefBBox: Rectangle | undefined\n      const isRefNodeRotatable =\n        refNode != null &&\n        options.rotatableNode != null &&\n        Dom.contains(options.rotatableNode, refNode)\n\n      // Find the reference element bounding box. If no reference was\n      // provided, we use the optional bounding box.\n      if (refNode) {\n        unrotatedRefBBox = bboxCache.get(refNode)\n      }\n\n      if (!unrotatedRefBBox) {\n        const target = (\n          isRefNodeRotatable ? options.rotatableNode! : rootNode\n        ) as SVGElement\n\n        unrotatedRefBBox = refNode\n          ? Dom.getBBox(refNode as SVGElement, { target })\n          : options.rootBBox\n\n        if (refNode) {\n          bboxCache.set(refNode, unrotatedRefBBox!)\n        }\n      }\n\n      let processedAttrs\n      if (options.attrs && item.attributes) {\n        // If there was a special attribute affecting the position amongst\n        // passed-in attributes we have to merge it with the rest of the\n        // element's attributes as they are necessary to update the position\n        // relatively (i.e `ref-x` && 'ref-dx').\n        processedAttrs = this.processAttrs(node, item.attributes)\n        this.mergeProcessedAttrs(processedAttrs, item.processedAttributes)\n      } else {\n        processedAttrs = item.processedAttributes\n      }\n\n      let refBBox = unrotatedRefBBox!\n      if (\n        isRefNodeRotatable &&\n        options.rotatableNode != null &&\n        !options.rotatableNode.contains(node)\n      ) {\n        // If the referenced node is inside the rotatable group while the\n        // updated node is outside, we need to take the rotatable node\n        // transformation into account.\n        if (!rotatableMatrix) {\n          rotatableMatrix = Dom.transformStringToMatrix(\n            Dom.attr(options.rotatableNode, 'transform'),\n          )\n        }\n        refBBox = Dom.transformRectangle(unrotatedRefBBox!, rotatableMatrix)\n      }\n\n      const caller = specialItems.find((item) => item.refNode === node)\n      if (caller) {\n        options.forceSync = true\n      }\n\n      this.updateRelativeAttrs(node, processedAttrs, refBBox, options)\n    })\n  }\n}\n\nexport namespace AttrManager {\n  export interface UpdateOptions {\n    rootBBox: Rectangle\n    selectors: Markup.Selectors\n    scalableNode?: Element | null\n    rotatableNode?: Element | null\n    /**\n     * Rendering only the specified attributes.\n     */\n    attrs?: Attr.CellAttrs | null\n    /**\n     * Whether to force synchronous rendering\n     */\n    forceSync?: boolean\n  }\n\n  export interface ProcessedAttrs {\n    raw: Attr.ComplexAttrs\n    normal?: Attr.SimpleAttrs | undefined\n    set?: Attr.ComplexAttrs | undefined\n    offset?: Attr.ComplexAttrs | undefined\n    position?: Attr.ComplexAttrs | undefined\n    delay?: Attr.ComplexAttrs | undefined\n  }\n\n  export const DELAY_ATTRS = [\n    'text',\n    'textWrap',\n    'sourceMarker',\n    'targetMarker',\n  ]\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}