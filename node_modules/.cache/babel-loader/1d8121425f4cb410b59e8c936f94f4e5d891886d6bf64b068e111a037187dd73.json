{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Point, Line, Rectangle, Polyline, Ellipse, Path } from '../../geometry';\nimport { attr } from './attr';\nimport { sample, toPath, getPointsFromSvgElement } from './path';\nimport { ensureId, isSVGGraphicsElement, createSvgElement, isHTMLElement } from './elem';\nimport { getComputedStyle } from './style';\nimport { createSVGPoint, createSVGMatrix, decomposeMatrix, transformRectangle, transformStringToMatrix } from './matrix';\n/**\n * Returns the bounding box of the element after transformations are\n * applied. If `withoutTransformations` is `true`, transformations of\n * the element will not be considered when computing the bounding box.\n * If `target` is specified, bounding box will be computed relatively\n * to the `target` element.\n */\nexport function bbox(elem, withoutTransformations, target) {\n  let box;\n  const ownerSVGElement = elem.ownerSVGElement;\n  // If the element is not in the live DOM, it does not have a bounding\n  // box defined and so fall back to 'zero' dimension element.\n  if (!ownerSVGElement) {\n    return new Rectangle(0, 0, 0, 0);\n  }\n  try {\n    box = elem.getBBox();\n  } catch (e) {\n    // Fallback for IE.\n    box = {\n      x: elem.clientLeft,\n      y: elem.clientTop,\n      width: elem.clientWidth,\n      height: elem.clientHeight\n    };\n  }\n  if (withoutTransformations) {\n    return Rectangle.create(box);\n  }\n  const matrix = getTransformToElement(elem, target || ownerSVGElement);\n  return transformRectangle(box, matrix);\n}\n/**\n * Returns the bounding box of the element after transformations are\n * applied. Unlike `bbox()`, this function fixes a browser implementation\n * bug to return the correct bounding box if this elemenent is a group of\n * svg elements (if `options.recursive` is specified).\n */\nexport function getBBox(elem, options = {}) {\n  let outputBBox;\n  const ownerSVGElement = elem.ownerSVGElement;\n  // If the element is not in the live DOM, it does not have a bounding box\n  // defined and so fall back to 'zero' dimension element.\n  // If the element is not an SVGGraphicsElement, we could not measure the\n  // bounding box either\n  if (!ownerSVGElement || !isSVGGraphicsElement(elem)) {\n    if (isHTMLElement(elem)) {\n      // If the element is a HTMLElement, return the position relative to the body\n      const {\n        left,\n        top,\n        width,\n        height\n      } = getBoundingOffsetRect(elem);\n      return new Rectangle(left, top, width, height);\n    }\n    return new Rectangle(0, 0, 0, 0);\n  }\n  let target = options.target;\n  const recursive = options.recursive;\n  if (!recursive) {\n    try {\n      outputBBox = elem.getBBox();\n    } catch (e) {\n      outputBBox = {\n        x: elem.clientLeft,\n        y: elem.clientTop,\n        width: elem.clientWidth,\n        height: elem.clientHeight\n      };\n    }\n    if (!target) {\n      return Rectangle.create(outputBBox);\n    }\n    // transform like target\n    const matrix = getTransformToElement(elem, target);\n    return transformRectangle(outputBBox, matrix);\n  }\n  // recursive\n  {\n    const children = elem.childNodes;\n    const n = children.length;\n    if (n === 0) {\n      return getBBox(elem, {\n        target\n      });\n    }\n    if (!target) {\n      target = elem; // eslint-disable-line\n    }\n    for (let i = 0; i < n; i += 1) {\n      const child = children[i];\n      let childBBox;\n      if (child.childNodes.length === 0) {\n        childBBox = getBBox(child, {\n          target\n        });\n      } else {\n        // if child is a group element, enter it with a recursive call\n        childBBox = getBBox(child, {\n          target,\n          recursive: true\n        });\n      }\n      if (!outputBBox) {\n        outputBBox = childBBox;\n      } else {\n        outputBBox = outputBBox.union(childBBox);\n      }\n    }\n    return outputBBox;\n  }\n}\n// BBox is calculated by the attribute on the node\nexport function getBBoxByElementAttr(elem) {\n  let node = elem;\n  let tagName = node ? node.tagName.toLowerCase() : '';\n  // find shape node\n  while (tagName === 'g') {\n    node = node.firstElementChild;\n    tagName = node ? node.tagName.toLowerCase() : '';\n  }\n  const attr = name => {\n    const s = node.getAttribute(name);\n    const v = s ? parseFloat(s) : 0;\n    return Number.isNaN(v) ? 0 : v;\n  };\n  let r;\n  let bbox;\n  switch (tagName) {\n    case 'rect':\n      bbox = new Rectangle(attr('x'), attr('y'), attr('width'), attr('height'));\n      break;\n    case 'circle':\n      r = attr('r');\n      bbox = new Rectangle(attr('cx') - r, attr('cy') - r, 2 * r, 2 * r);\n      break;\n    default:\n      break;\n  }\n  return bbox;\n}\n// Matrix is calculated by the transform attribute on the node\nexport function getMatrixByElementAttr(elem, target) {\n  let matrix = createSVGMatrix();\n  if (isSVGGraphicsElement(target) && isSVGGraphicsElement(elem)) {\n    let node = elem;\n    const matrixList = [];\n    while (node && node !== target) {\n      const transform = node.getAttribute('transform') || null;\n      const nodeMatrix = transformStringToMatrix(transform);\n      matrixList.push(nodeMatrix);\n      node = node.parentNode;\n    }\n    matrixList.reverse().forEach(m => {\n      matrix = matrix.multiply(m);\n    });\n  }\n  return matrix;\n}\n/**\n * Returns an DOMMatrix that specifies the transformation necessary\n * to convert `elem` coordinate system into `target` coordinate system.\n */\nexport function getTransformToElement(elem, target) {\n  if (isSVGGraphicsElement(target) && isSVGGraphicsElement(elem)) {\n    const targetCTM = target.getScreenCTM();\n    const nodeCTM = elem.getScreenCTM();\n    if (targetCTM && nodeCTM) {\n      return targetCTM.inverse().multiply(nodeCTM);\n    }\n  }\n  // Could not get actual transformation matrix\n  return createSVGMatrix();\n}\n/**\n * Converts a global point with coordinates `x` and `y` into the\n * coordinate space of the element.\n */\nexport function toLocalPoint(elem, x, y) {\n  const svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;\n  const p = svg.createSVGPoint();\n  p.x = x;\n  p.y = y;\n  try {\n    const ctm = svg.getScreenCTM();\n    const globalPoint = p.matrixTransform(ctm.inverse());\n    const globalToLocalMatrix = getTransformToElement(elem, svg).inverse();\n    return globalPoint.matrixTransform(globalToLocalMatrix);\n  } catch (e) {\n    return p;\n  }\n}\n/**\n * Convert the SVGElement to an equivalent geometric shape. The element's\n * transformations are not taken into account.\n *\n * SVGRectElement      => Rectangle\n *\n * SVGLineElement      => Line\n *\n * SVGCircleElement    => Ellipse\n *\n * SVGEllipseElement   => Ellipse\n *\n * SVGPolygonElement   => Polyline\n *\n * SVGPolylineElement  => Polyline\n *\n * SVGPathElement      => Path\n *\n * others              => Rectangle\n */\nexport function toGeometryShape(elem) {\n  const attr = name => {\n    const s = elem.getAttribute(name);\n    const v = s ? parseFloat(s) : 0;\n    return Number.isNaN(v) ? 0 : v;\n  };\n  switch (elem instanceof SVGElement && elem.nodeName.toLowerCase()) {\n    case 'rect':\n      return new Rectangle(attr('x'), attr('y'), attr('width'), attr('height'));\n    case 'circle':\n      return new Ellipse(attr('cx'), attr('cy'), attr('r'), attr('r'));\n    case 'ellipse':\n      return new Ellipse(attr('cx'), attr('cy'), attr('rx'), attr('ry'));\n    case 'polyline':\n      {\n        const points = getPointsFromSvgElement(elem);\n        return new Polyline(points);\n      }\n    case 'polygon':\n      {\n        const points = getPointsFromSvgElement(elem);\n        if (points.length > 1) {\n          points.push(points[0]);\n        }\n        return new Polyline(points);\n      }\n    case 'path':\n      {\n        let d = elem.getAttribute('d');\n        if (!Path.isValid(d)) {\n          d = Path.normalize(d);\n        }\n        return Path.parse(d);\n      }\n    case 'line':\n      {\n        return new Line(attr('x1'), attr('y1'), attr('x2'), attr('y2'));\n      }\n    default:\n      break;\n  }\n  // Anything else is a rectangle\n  return getBBox(elem);\n}\nexport function getIntersection(elem, ref, target) {\n  const svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;\n  target = target || svg; // eslint-disable-line\n  const bbox = getBBox(target);\n  const center = bbox.getCenter();\n  if (!bbox.intersectsWithLineFromCenterToPoint(ref)) {\n    return null;\n  }\n  let spot = null;\n  const tagName = elem.tagName.toLowerCase();\n  // Little speed up optimization for `<rect>` element. We do not do convert\n  // to path element and sampling but directly calculate the intersection\n  // through a transformed geometrical rectangle.\n  if (tagName === 'rect') {\n    const gRect = new Rectangle(parseFloat(elem.getAttribute('x') || '0'), parseFloat(elem.getAttribute('y') || '0'), parseFloat(elem.getAttribute('width') || '0'), parseFloat(elem.getAttribute('height') || '0'));\n    // Get the rect transformation matrix with regards to the SVG document.\n    const rectMatrix = getTransformToElement(elem, target);\n    const rectMatrixComponents = decomposeMatrix(rectMatrix);\n    // Rotate the rectangle back so that we can use\n    // `intersectsWithLineFromCenterToPoint()`.\n    const reseted = svg.createSVGTransform();\n    reseted.setRotate(-rectMatrixComponents.rotation, center.x, center.y);\n    const rect = transformRectangle(gRect, reseted.matrix.multiply(rectMatrix));\n    spot = Rectangle.create(rect).intersectsWithLineFromCenterToPoint(ref, rectMatrixComponents.rotation);\n  } else if (tagName === 'path' || tagName === 'polygon' || tagName === 'polyline' || tagName === 'circle' || tagName === 'ellipse') {\n    const pathNode = tagName === 'path' ? elem : toPath(elem);\n    const samples = sample(pathNode);\n    let minDistance = Infinity;\n    let closestSamples = [];\n    for (let i = 0, ii = samples.length; i < ii; i += 1) {\n      const sample = samples[i];\n      // Convert the sample point in the local coordinate system\n      // to the global coordinate system.\n      let gp = createSVGPoint(sample.x, sample.y);\n      gp = gp.matrixTransform(getTransformToElement(elem, target));\n      const ggp = Point.create(gp);\n      const centerDistance = ggp.distance(center);\n      // Penalize a higher distance to the reference point by 10%.\n      // This gives better results. This is due to\n      // inaccuracies introduced by rounding errors and getPointAtLength() returns.\n      const refDistance = ggp.distance(ref) * 1.1;\n      const distance = centerDistance + refDistance;\n      if (distance < minDistance) {\n        minDistance = distance;\n        closestSamples = [{\n          sample,\n          refDistance\n        }];\n      } else if (distance < minDistance + 1) {\n        closestSamples.push({\n          sample,\n          refDistance\n        });\n      }\n    }\n    closestSamples.sort((a, b) => a.refDistance - b.refDistance);\n    if (closestSamples[0]) {\n      spot = Point.create(closestSamples[0].sample);\n    }\n  }\n  return spot;\n}\nexport function animate(elem, options) {\n  return createAnimation(elem, options, 'animate');\n}\nexport function animateTransform(elem, options) {\n  return createAnimation(elem, options, 'animateTransform');\n}\nfunction createAnimation(elem, options, type) {\n  // @see\n  // https://www.w3.org/TR/SVG11/animate.html#AnimateElement\n  // https://developer.mozilla.org/en-US/docs/Web/API/SVGAnimateElement\n  // https://developer.mozilla.org/en-US/docs/Web/API/SVGAnimateTransformElement\n  const animate = createSvgElement(type);\n  elem.appendChild(animate);\n  try {\n    return setupAnimation(animate, options);\n  } catch (error) {\n    // pass\n  }\n  return () => {};\n}\nfunction setupAnimation(animate, options) {\n  const {\n      start,\n      complete,\n      repeat\n    } = options,\n    attrs = __rest(options, [\"start\", \"complete\", \"repeat\"]);\n  attr(animate, attrs);\n  start && animate.addEventListener('beginEvent', start);\n  complete && animate.addEventListener('endEvent', complete);\n  repeat && animate.addEventListener('repeatEvent', repeat);\n  const ani = animate;\n  setTimeout(() => {\n    ani.beginElement();\n  });\n  return () => ani.endElement();\n}\n/**\n * Animate the element along the path SVG element (or Vector object).\n * `attrs` contain Animation Timing attributes describing the animation.\n */\nexport function animateAlongPath(elem, options, path) {\n  const id = ensureId(path);\n  // https://developer.mozilla.org/en-US/docs/Web/API/SVGAnimationElement\n  const animate = createSvgElement('animateMotion');\n  const mpath = createSvgElement('mpath');\n  attr(mpath, {\n    'xlink:href': `#${id}`\n  });\n  animate.appendChild(mpath);\n  elem.appendChild(animate);\n  try {\n    return setupAnimation(animate, options);\n  } catch (e) {\n    // Fallback for IE 9.\n    if (document.documentElement.getAttribute('smiling') === 'fake') {\n      // Register the animation. (See `https://answers.launchpad.net/smil/+question/203333`)\n      const ani = animate;\n      ani.animators = [];\n      const win = window;\n      const animationID = ani.getAttribute('id');\n      if (animationID) {\n        win.id2anim[animationID] = ani;\n      }\n      const targets = win.getTargets(ani);\n      for (let i = 0, ii = targets.length; i < ii; i += 1) {\n        const target = targets[i];\n        const animator = new win.Animator(ani, target, i);\n        win.animators.push(animator);\n        ani.animators[i] = animator;\n        animator.register();\n      }\n    }\n  }\n  return () => {};\n}\nexport function getBoundingOffsetRect(elem) {\n  let left = 0;\n  let top = 0;\n  let width = 0;\n  let height = 0;\n  if (elem) {\n    let current = elem;\n    while (current) {\n      left += current.offsetLeft;\n      top += current.offsetTop;\n      current = current.offsetParent;\n      if (current) {\n        left += parseInt(getComputedStyle(current, 'borderLeft'), 10);\n        top += parseInt(getComputedStyle(current, 'borderTop'), 10);\n      }\n    }\n    width = elem.offsetWidth;\n    height = elem.offsetHeight;\n  }\n  return {\n    left,\n    top,\n    width,\n    height\n  };\n}","map":{"version":3,"names":["Point","Line","Rectangle","Polyline","Ellipse","Path","attr","sample","toPath","getPointsFromSvgElement","ensureId","isSVGGraphicsElement","createSvgElement","isHTMLElement","getComputedStyle","createSVGPoint","createSVGMatrix","decomposeMatrix","transformRectangle","transformStringToMatrix","bbox","elem","withoutTransformations","target","box","ownerSVGElement","getBBox","e","x","clientLeft","y","clientTop","width","clientWidth","height","clientHeight","create","matrix","getTransformToElement","options","outputBBox","left","top","getBoundingOffsetRect","recursive","children","childNodes","n","length","i","child","childBBox","union","getBBoxByElementAttr","node","tagName","toLowerCase","firstElementChild","name","s","getAttribute","v","parseFloat","Number","isNaN","r","getMatrixByElementAttr","matrixList","transform","nodeMatrix","push","parentNode","reverse","forEach","m","multiply","targetCTM","getScreenCTM","nodeCTM","inverse","toLocalPoint","svg","SVGSVGElement","p","ctm","globalPoint","matrixTransform","globalToLocalMatrix","toGeometryShape","SVGElement","nodeName","points","d","isValid","normalize","parse","getIntersection","ref","center","getCenter","intersectsWithLineFromCenterToPoint","spot","gRect","rectMatrix","rectMatrixComponents","reseted","createSVGTransform","setRotate","rotation","rect","pathNode","samples","minDistance","Infinity","closestSamples","ii","gp","ggp","centerDistance","distance","refDistance","sort","a","b","animate","createAnimation","animateTransform","type","appendChild","setupAnimation","error","start","complete","repeat","attrs","__rest","addEventListener","ani","setTimeout","beginElement","endElement","animateAlongPath","path","id","mpath","document","documentElement","animators","win","window","animationID","id2anim","targets","getTargets","animator","Animator","register","current","offsetLeft","offsetTop","offsetParent","parseInt","offsetWidth","offsetHeight"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/util/dom/geom.ts"],"sourcesContent":["import { Point, Line, Rectangle, Polyline, Ellipse, Path } from '../../geometry'\nimport { attr } from './attr'\nimport { sample, toPath, getPointsFromSvgElement } from './path'\nimport {\n  ensureId,\n  isSVGGraphicsElement,\n  createSvgElement,\n  isHTMLElement,\n} from './elem'\nimport { getComputedStyle } from './style'\nimport {\n  createSVGPoint,\n  createSVGMatrix,\n  decomposeMatrix,\n  transformRectangle,\n  transformStringToMatrix,\n} from './matrix'\n\n/**\n * Returns the bounding box of the element after transformations are\n * applied. If `withoutTransformations` is `true`, transformations of\n * the element will not be considered when computing the bounding box.\n * If `target` is specified, bounding box will be computed relatively\n * to the `target` element.\n */\nexport function bbox(\n  elem: SVGElement,\n  withoutTransformations?: boolean,\n  target?: SVGElement,\n): Rectangle {\n  let box\n  const ownerSVGElement = elem.ownerSVGElement\n\n  // If the element is not in the live DOM, it does not have a bounding\n  // box defined and so fall back to 'zero' dimension element.\n  if (!ownerSVGElement) {\n    return new Rectangle(0, 0, 0, 0)\n  }\n\n  try {\n    box = (elem as SVGGraphicsElement).getBBox()\n  } catch (e) {\n    // Fallback for IE.\n    box = {\n      x: elem.clientLeft,\n      y: elem.clientTop,\n      width: elem.clientWidth,\n      height: elem.clientHeight,\n    }\n  }\n\n  if (withoutTransformations) {\n    return Rectangle.create(box)\n  }\n\n  const matrix = getTransformToElement(elem, target || ownerSVGElement)\n  return transformRectangle(box, matrix)\n}\n\n/**\n * Returns the bounding box of the element after transformations are\n * applied. Unlike `bbox()`, this function fixes a browser implementation\n * bug to return the correct bounding box if this elemenent is a group of\n * svg elements (if `options.recursive` is specified).\n */\nexport function getBBox(\n  elem: SVGElement,\n  options: {\n    target?: SVGElement | null\n    recursive?: boolean\n  } = {},\n): Rectangle {\n  let outputBBox\n  const ownerSVGElement = elem.ownerSVGElement\n\n  // If the element is not in the live DOM, it does not have a bounding box\n  // defined and so fall back to 'zero' dimension element.\n  // If the element is not an SVGGraphicsElement, we could not measure the\n  // bounding box either\n  if (!ownerSVGElement || !isSVGGraphicsElement(elem)) {\n    if (isHTMLElement(elem)) {\n      // If the element is a HTMLElement, return the position relative to the body\n      const { left, top, width, height } = getBoundingOffsetRect(elem as any)\n      return new Rectangle(left, top, width, height)\n    }\n    return new Rectangle(0, 0, 0, 0)\n  }\n\n  let target = options.target\n  const recursive = options.recursive\n\n  if (!recursive) {\n    try {\n      outputBBox = elem.getBBox()\n    } catch (e) {\n      outputBBox = {\n        x: elem.clientLeft,\n        y: elem.clientTop,\n        width: elem.clientWidth,\n        height: elem.clientHeight,\n      }\n    }\n\n    if (!target) {\n      return Rectangle.create(outputBBox)\n    }\n\n    // transform like target\n    const matrix = getTransformToElement(elem, target)\n    return transformRectangle(outputBBox, matrix)\n  }\n\n  // recursive\n  {\n    const children = elem.childNodes\n    const n = children.length\n\n    if (n === 0) {\n      return getBBox(elem, { target })\n    }\n\n    if (!target) {\n      target = elem // eslint-disable-line\n    }\n\n    for (let i = 0; i < n; i += 1) {\n      const child = children[i] as SVGElement\n      let childBBox\n\n      if (child.childNodes.length === 0) {\n        childBBox = getBBox(child, { target })\n      } else {\n        // if child is a group element, enter it with a recursive call\n        childBBox = getBBox(child, { target, recursive: true })\n      }\n\n      if (!outputBBox) {\n        outputBBox = childBBox\n      } else {\n        outputBBox = outputBBox.union(childBBox)\n      }\n    }\n\n    return outputBBox as Rectangle\n  }\n}\n\n// BBox is calculated by the attribute on the node\nexport function getBBoxByElementAttr(elem: SVGElement) {\n  let node = elem\n  let tagName = node ? node.tagName.toLowerCase() : ''\n\n  // find shape node\n  while (tagName === 'g') {\n    node = node.firstElementChild as SVGElement\n    tagName = node ? node.tagName.toLowerCase() : ''\n  }\n\n  const attr = (name: string) => {\n    const s = node.getAttribute(name)\n    const v = s ? parseFloat(s) : 0\n    return Number.isNaN(v) ? 0 : v\n  }\n\n  let r\n  let bbox\n  switch (tagName) {\n    case 'rect':\n      bbox = new Rectangle(attr('x'), attr('y'), attr('width'), attr('height'))\n      break\n    case 'circle':\n      r = attr('r')\n      bbox = new Rectangle(attr('cx') - r, attr('cy') - r, 2 * r, 2 * r)\n      break\n    default:\n      break\n  }\n\n  return bbox\n}\n\n// Matrix is calculated by the transform attribute on the node\nexport function getMatrixByElementAttr(elem: SVGElement, target: SVGElement) {\n  let matrix = createSVGMatrix()\n\n  if (isSVGGraphicsElement(target) && isSVGGraphicsElement(elem)) {\n    let node = elem\n    const matrixList = []\n    while (node && node !== target) {\n      const transform = node.getAttribute('transform') || null\n      const nodeMatrix = transformStringToMatrix(transform)\n      matrixList.push(nodeMatrix)\n      node = node.parentNode as SVGGraphicsElement\n    }\n    matrixList.reverse().forEach((m) => {\n      matrix = matrix.multiply(m)\n    })\n  }\n\n  return matrix\n}\n\n/**\n * Returns an DOMMatrix that specifies the transformation necessary\n * to convert `elem` coordinate system into `target` coordinate system.\n */\nexport function getTransformToElement(elem: SVGElement, target: SVGElement) {\n  if (isSVGGraphicsElement(target) && isSVGGraphicsElement(elem)) {\n    const targetCTM = target.getScreenCTM()\n    const nodeCTM = elem.getScreenCTM()\n    if (targetCTM && nodeCTM) {\n      return targetCTM.inverse().multiply(nodeCTM)\n    }\n  }\n\n  // Could not get actual transformation matrix\n  return createSVGMatrix()\n}\n\n/**\n * Converts a global point with coordinates `x` and `y` into the\n * coordinate space of the element.\n */\nexport function toLocalPoint(\n  elem: SVGElement | SVGSVGElement,\n  x: number,\n  y: number,\n) {\n  const svg =\n    elem instanceof SVGSVGElement\n      ? elem\n      : (elem.ownerSVGElement as SVGSVGElement)\n\n  const p = svg.createSVGPoint()\n  p.x = x\n  p.y = y\n\n  try {\n    const ctm = svg.getScreenCTM()!\n    const globalPoint = p.matrixTransform(ctm.inverse())\n    const globalToLocalMatrix = getTransformToElement(elem, svg).inverse()\n    return globalPoint.matrixTransform(globalToLocalMatrix)\n  } catch (e) {\n    return p\n  }\n}\n\n/**\n * Convert the SVGElement to an equivalent geometric shape. The element's\n * transformations are not taken into account.\n *\n * SVGRectElement      => Rectangle\n *\n * SVGLineElement      => Line\n *\n * SVGCircleElement    => Ellipse\n *\n * SVGEllipseElement   => Ellipse\n *\n * SVGPolygonElement   => Polyline\n *\n * SVGPolylineElement  => Polyline\n *\n * SVGPathElement      => Path\n *\n * others              => Rectangle\n */\nexport function toGeometryShape(elem: SVGElement) {\n  const attr = (name: string) => {\n    const s = elem.getAttribute(name)\n    const v = s ? parseFloat(s) : 0\n    return Number.isNaN(v) ? 0 : v\n  }\n\n  switch (elem instanceof SVGElement && elem.nodeName.toLowerCase()) {\n    case 'rect':\n      return new Rectangle(attr('x'), attr('y'), attr('width'), attr('height'))\n    case 'circle':\n      return new Ellipse(attr('cx'), attr('cy'), attr('r'), attr('r'))\n    case 'ellipse':\n      return new Ellipse(attr('cx'), attr('cy'), attr('rx'), attr('ry'))\n    case 'polyline': {\n      const points = getPointsFromSvgElement(elem as SVGPolylineElement)\n      return new Polyline(points)\n    }\n    case 'polygon': {\n      const points = getPointsFromSvgElement(elem as SVGPolygonElement)\n      if (points.length > 1) {\n        points.push(points[0])\n      }\n      return new Polyline(points)\n    }\n    case 'path': {\n      let d = elem.getAttribute('d') as string\n      if (!Path.isValid(d)) {\n        d = Path.normalize(d)\n      }\n      return Path.parse(d)\n    }\n    case 'line': {\n      return new Line(attr('x1'), attr('y1'), attr('x2'), attr('y2'))\n    }\n    default:\n      break\n  }\n\n  // Anything else is a rectangle\n  return getBBox(elem)\n}\n\nexport function getIntersection(\n  elem: SVGElement | SVGSVGElement,\n  ref: Point | Point.PointLike | Point.PointData,\n  target?: SVGElement,\n) {\n  const svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement!\n  target = target || svg // eslint-disable-line\n  const bbox = getBBox(target)\n  const center = bbox.getCenter()\n\n  if (!bbox.intersectsWithLineFromCenterToPoint(ref)) {\n    return null\n  }\n\n  let spot: Point | null = null\n  const tagName = elem.tagName.toLowerCase()\n\n  // Little speed up optimization for `<rect>` element. We do not do convert\n  // to path element and sampling but directly calculate the intersection\n  // through a transformed geometrical rectangle.\n  if (tagName === 'rect') {\n    const gRect = new Rectangle(\n      parseFloat(elem.getAttribute('x') || '0'),\n      parseFloat(elem.getAttribute('y') || '0'),\n      parseFloat(elem.getAttribute('width') || '0'),\n      parseFloat(elem.getAttribute('height') || '0'),\n    )\n    // Get the rect transformation matrix with regards to the SVG document.\n    const rectMatrix = getTransformToElement(elem, target)\n    const rectMatrixComponents = decomposeMatrix(rectMatrix)\n    // Rotate the rectangle back so that we can use\n    // `intersectsWithLineFromCenterToPoint()`.\n    const reseted = svg.createSVGTransform()\n    reseted.setRotate(-rectMatrixComponents.rotation, center.x, center.y)\n    const rect = transformRectangle(gRect, reseted.matrix.multiply(rectMatrix))\n\n    spot = Rectangle.create(rect).intersectsWithLineFromCenterToPoint(\n      ref,\n      rectMatrixComponents.rotation,\n    )\n  } else if (\n    tagName === 'path' ||\n    tagName === 'polygon' ||\n    tagName === 'polyline' ||\n    tagName === 'circle' ||\n    tagName === 'ellipse'\n  ) {\n    const pathNode = tagName === 'path' ? elem : toPath(elem as any)\n    const samples = sample(pathNode as SVGPathElement)\n    let minDistance = Infinity\n    let closestSamples: any[] = []\n\n    for (let i = 0, ii = samples.length; i < ii; i += 1) {\n      const sample = samples[i]\n\n      // Convert the sample point in the local coordinate system\n      // to the global coordinate system.\n      let gp = createSVGPoint(sample.x, sample.y)\n      gp = gp.matrixTransform(getTransformToElement(elem, target))\n      const ggp = Point.create(gp)\n      const centerDistance = ggp.distance(center)\n      // Penalize a higher distance to the reference point by 10%.\n      // This gives better results. This is due to\n      // inaccuracies introduced by rounding errors and getPointAtLength() returns.\n      const refDistance = ggp.distance(ref) * 1.1\n      const distance = centerDistance + refDistance\n\n      if (distance < minDistance) {\n        minDistance = distance\n        closestSamples = [{ sample, refDistance }]\n      } else if (distance < minDistance + 1) {\n        closestSamples.push({ sample, refDistance })\n      }\n    }\n\n    closestSamples.sort((a, b) => a.refDistance - b.refDistance)\n\n    if (closestSamples[0]) {\n      spot = Point.create(closestSamples[0].sample)\n    }\n  }\n\n  return spot\n}\n\nexport interface AnimateCallbacks {\n  start?: (e: Event) => void\n  repeat?: (e: Event) => void\n  complete?: (e: Event) => void\n}\n\nexport type AnimationOptions = AnimateCallbacks & {\n  [name: string]: any\n}\n\nexport function animate(elem: SVGElement, options: AnimationOptions) {\n  return createAnimation(elem, options, 'animate')\n}\n\nexport function animateTransform(elem: SVGElement, options: AnimationOptions) {\n  return createAnimation(elem, options, 'animateTransform')\n}\n\nfunction createAnimation(\n  elem: SVGElement,\n  options: AnimationOptions,\n  type: 'animate' | 'animateTransform',\n) {\n  // @see\n  // https://www.w3.org/TR/SVG11/animate.html#AnimateElement\n  // https://developer.mozilla.org/en-US/docs/Web/API/SVGAnimateElement\n  // https://developer.mozilla.org/en-US/docs/Web/API/SVGAnimateTransformElement\n\n  const animate = createSvgElement<SVGAnimationElement>(type)\n  elem.appendChild(animate)\n  try {\n    return setupAnimation(animate, options)\n  } catch (error) {\n    // pass\n  }\n\n  return () => {}\n}\n\nfunction setupAnimation(\n  animate: SVGAnimationElement,\n  options: AnimationOptions,\n) {\n  const { start, complete, repeat, ...attrs } = options\n\n  attr(animate, attrs)\n\n  start && animate.addEventListener('beginEvent', start)\n  complete && animate.addEventListener('endEvent', complete)\n  repeat && animate.addEventListener('repeatEvent', repeat)\n\n  const ani = animate as any\n\n  setTimeout(() => {\n    ani.beginElement()\n  })\n\n  return () => ani.endElement()\n}\n\n/**\n * Animate the element along the path SVG element (or Vector object).\n * `attrs` contain Animation Timing attributes describing the animation.\n */\nexport function animateAlongPath(\n  elem: SVGElement,\n  options: AnimationOptions,\n  path: SVGPathElement,\n): () => void {\n  const id = ensureId(path)\n  // https://developer.mozilla.org/en-US/docs/Web/API/SVGAnimationElement\n  const animate = createSvgElement<SVGAnimateMotionElement>('animateMotion')\n  const mpath = createSvgElement('mpath')\n  attr(mpath, { 'xlink:href': `#${id}` })\n\n  animate.appendChild(mpath)\n  elem.appendChild(animate)\n\n  try {\n    return setupAnimation(animate, options)\n  } catch (e) {\n    // Fallback for IE 9.\n    if (document.documentElement.getAttribute('smiling') === 'fake') {\n      // Register the animation. (See `https://answers.launchpad.net/smil/+question/203333`)\n      const ani = animate as any\n      ani.animators = []\n\n      const win = window as any\n      const animationID = ani.getAttribute('id')\n      if (animationID) {\n        win.id2anim[animationID] = ani\n      }\n\n      const targets = win.getTargets(ani)\n      for (let i = 0, ii = targets.length; i < ii; i += 1) {\n        const target = targets[i]\n        const animator = new win.Animator(ani, target, i)\n        win.animators.push(animator)\n        ani.animators[i] = animator\n        animator.register()\n      }\n    }\n  }\n\n  return () => {}\n}\n\nexport function getBoundingOffsetRect(elem: HTMLElement) {\n  let left = 0\n  let top = 0\n  let width = 0\n  let height = 0\n  if (elem) {\n    let current = elem as any\n    while (current) {\n      left += current.offsetLeft\n      top += current.offsetTop\n      current = current.offsetParent\n      if (current) {\n        left += parseInt(getComputedStyle(current, 'borderLeft'), 10)\n        top += parseInt(getComputedStyle(current, 'borderTop'), 10)\n      }\n    }\n    width = elem.offsetWidth\n    height = elem.offsetHeight\n  }\n  return { left, top, width, height }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}