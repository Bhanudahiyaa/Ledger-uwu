{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { gl } from '@antv/l7-core';\nimport BaseModel from \"../../core/BaseModel\";\n/* babel-plugin-inline-import '../shaders/sprite_frag.glsl' */\nconst spriteFrag = \"\\nlayout(std140) uniform commonUniforms {\\n  float u_opacity;\\n  float u_mapFlag;\\n  float u_Scale;\\n};\\nuniform sampler2D u_texture;\\n\\nin vec3 v_Color;\\nin float v_d;\\nout vec4 outputColor;\\n\\nvoid main() {\\n\\n  if(v_d < 0.0) {\\n    discard;\\n  }\\n\\n  if(u_mapFlag > 0.0) {\\n    outputColor = texture(SAMPLER_2D(u_texture), gl_PointCoord);\\n    outputColor.a *= u_opacity;\\n  } else {\\n    outputColor = vec4(v_Color, u_opacity);\\n  }\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/sprite_vert.glsl' */\nconst spriteVert = \"layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec3 a_Color;\\n\\nlayout(std140) uniform commonUniforms {\\n  float u_opacity;\\n  float u_mapFlag;\\n  float u_Scale;\\n};\\n\\nout vec3 v_Color;\\nout float v_d;\\n\\n#pragma include \\\"projection\\\"\\nvoid main() {\\n  v_Color = a_Color.xyz;\\n  v_d = a_Position.z;\\n\\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, a_Position.z, 1.0));\\n  gl_PointSize = pow(u_Zoom - 1.0, 2.0) * u_Scale;\\n}\\n\";\nvar SPRITE_ANIMATE_DIR = /*#__PURE__*/function (SPRITE_ANIMATE_DIR) {\n  SPRITE_ANIMATE_DIR[\"UP\"] = \"up\";\n  SPRITE_ANIMATE_DIR[\"DOWN\"] = \"down\";\n  return SPRITE_ANIMATE_DIR;\n}(SPRITE_ANIMATE_DIR || {});\nexport default class SpriteModel extends BaseModel {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"texture\", void 0);\n    _defineProperty(this, \"mapTexture\", void 0);\n    _defineProperty(this, \"positions\", void 0);\n    _defineProperty(this, \"indices\", void 0);\n    _defineProperty(this, \"timer\", void 0);\n    _defineProperty(this, \"spriteTop\", void 0);\n    _defineProperty(this, \"spriteUpdate\", void 0);\n    _defineProperty(this, \"spriteAnimate\", void 0);\n    _defineProperty(this, \"planeGeometryUpdateTriangulation\", () => {\n      const {\n        spriteBottom = -10\n      } = this.layer.getLayerConfig();\n      const updateZ = this.spriteUpdate;\n      const bottomZ = spriteBottom;\n      const topZ = this.spriteTop;\n      for (let i = 0; i < this.positions.length; i += 5) {\n        if (this.spriteAnimate === SPRITE_ANIMATE_DIR.UP) {\n          this.positions[i + 2] += updateZ;\n          if (this.positions[i + 2] > topZ) {\n            this.positions[i + 2] = bottomZ;\n          }\n        } else {\n          this.positions[i + 2] -= updateZ;\n          if (this.positions[i + 2] < bottomZ) {\n            this.positions[i + 2] = topZ;\n          }\n        }\n      }\n      return {\n        vertices: this.positions,\n        indices: this.indices,\n        size: 5\n      };\n    });\n    /**\n     * Recalculate and update position attribute.\n     */\n    _defineProperty(this, \"updatePosition\", () => {\n      var _this$styleAttributeS;\n      this.planeGeometryUpdateTriangulation();\n      const vertexAttribute = (_this$styleAttributeS = this.styleAttributeService.getLayerStyleAttribute('position')) === null || _this$styleAttributeS === void 0 ? void 0 : _this$styleAttributeS.vertexAttribute;\n      if (vertexAttribute) {\n        // [x1, y1, z1, x2, y2, z2...]\n        const updated = [];\n        for (let i = 0; i < this.positions.length; i += 5) {\n          updated.push(this.positions[i], this.positions[i + 1], this.positions[i + 2]);\n        }\n        vertexAttribute.updateBuffer({\n          data: updated,\n          offset: 0\n        });\n      }\n      this.layerService.throttleRenderLayers();\n      this.timer = requestAnimationFrame(this.updatePosition);\n    });\n    _defineProperty(this, \"planeGeometryTriangulation\", () => {\n      const {\n        center = [120, 30],\n        spriteCount = 100,\n        spriteRadius = 10\n      } = this.layer.getLayerConfig();\n      const {\n        indices,\n        positions\n      } = this.initSprite(spriteRadius, spriteCount, ...center);\n      this.positions = positions;\n      this.indices = indices;\n      return {\n        vertices: positions,\n        indices,\n        size: 5\n      };\n    });\n  }\n  initSprite(radius = 10, spriteCount = 100, lng = 120, lat = 30) {\n    const indices = [];\n    const positions = [];\n    const heightLimit = this.spriteAnimate === SPRITE_ANIMATE_DIR.UP ? -this.spriteTop : this.spriteTop;\n    for (let i = 0; i < spriteCount; i++) {\n      const height = Math.random() * heightLimit;\n      positions.push(...getPos(height));\n    }\n    for (let i = 0; i < spriteCount; i++) {\n      indices.push(i);\n    }\n    function getPos(z) {\n      const randomX = radius * Math.random();\n      const randomY = radius * Math.random();\n      const x = -radius / 2 + randomX;\n      const y = -radius / 2 + randomY;\n      return [x + lng, -y + lat, z, 0, 0];\n    }\n    return {\n      indices,\n      positions\n    };\n  }\n  getUninforms() {\n    const commoninfo = this.getCommonUniformsInfo();\n    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());\n    this.updateStyleUnifoms();\n    return _objectSpread(_objectSpread({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);\n  }\n  getCommonUniformsInfo() {\n    const {\n      opacity,\n      mapTexture,\n      spriteScale = 1\n    } = this.layer.getLayerConfig();\n    if (this.mapTexture !== mapTexture) {\n      var _this$texture;\n      this.mapTexture = mapTexture;\n      (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();\n      this.textures = [];\n      this.updateTexture(mapTexture);\n    }\n    const commonOptions = {\n      u_opacity: opacity || 1,\n      u_mapFlag: mapTexture ? 1 : 0,\n      u_Scale: spriteScale,\n      u_texture: this.texture\n    };\n    this.textures = [this.texture];\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  clearModels() {\n    var _this$texture2;\n    cancelAnimationFrame(this.timer);\n    (_this$texture2 = this.texture) === null || _this$texture2 === void 0 || _this$texture2.destroy();\n    this.textures = [];\n  }\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const {\n        mapTexture,\n        spriteTop = 300,\n        spriteUpdate = 10,\n        spriteAnimate = SPRITE_ANIMATE_DIR.DOWN\n      } = _this.layer.getLayerConfig();\n      _this.initUniformsBuffer();\n      _this.mapTexture = mapTexture;\n      _this.spriteTop = spriteTop;\n      _this.spriteUpdate = spriteUpdate;\n      spriteAnimate === 'up' ? _this.spriteAnimate = SPRITE_ANIMATE_DIR.UP : _this.spriteAnimate = SPRITE_ANIMATE_DIR.DOWN;\n      const {\n        createTexture2D\n      } = _this.rendererService;\n      _this.texture = createTexture2D({\n        height: 0,\n        width: 0\n      });\n      _this.updateTexture(mapTexture);\n      setTimeout(() => {\n        _this.updatePosition();\n      }, 100);\n      const model = yield _this.layer.buildLayerModel({\n        moduleName: 'geometrySprite',\n        vertexShader: spriteVert,\n        fragmentShader: spriteFrag,\n        triangulation: _this.planeGeometryTriangulation,\n        defines: _this.getDefines(),\n        inject: _this.getInject(),\n        primitive: gl.POINTS,\n        depth: {\n          enable: false\n        },\n        blend: _this.getBlend()\n      });\n      return [model];\n    })();\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      return _this2.initModels();\n    })();\n  }\n  updateTexture(mapTexture) {\n    const {\n      createTexture2D\n    } = this.rendererService;\n    if (mapTexture) {\n      const img = new Image();\n      img.crossOrigin = 'anonymous';\n      img.onload = () => {\n        this.texture = createTexture2D({\n          data: img,\n          width: img.width,\n          height: img.height,\n          wrapS: gl.CLAMP_TO_EDGE,\n          wrapT: gl.CLAMP_TO_EDGE\n        });\n        this.layerService.reRender();\n      };\n      img.src = mapTexture;\n    } else {\n      this.texture = createTexture2D({\n        width: 1,\n        height: 1\n      });\n    }\n  }\n  registerBuiltinAttributes() {\n    return '';\n  }\n}","map":{"version":3,"names":["_asyncToGenerator","_objectSpread","_defineProperty","gl","BaseModel","spriteFrag","spriteVert","SPRITE_ANIMATE_DIR","SpriteModel","constructor","args","spriteBottom","layer","getLayerConfig","updateZ","spriteUpdate","bottomZ","topZ","spriteTop","i","positions","length","spriteAnimate","UP","vertices","indices","size","_this$styleAttributeS","planeGeometryUpdateTriangulation","vertexAttribute","styleAttributeService","getLayerStyleAttribute","updated","push","updateBuffer","data","offset","layerService","throttleRenderLayers","timer","requestAnimationFrame","updatePosition","center","spriteCount","spriteRadius","initSprite","radius","lng","lat","heightLimit","height","Math","random","getPos","z","randomX","randomY","x","y","getUninforms","commoninfo","getCommonUniformsInfo","attributeInfo","getUniformsBufferInfo","getStyleAttribute","updateStyleUnifoms","uniformsOption","opacity","mapTexture","spriteScale","_this$texture","texture","destroy","textures","updateTexture","commonOptions","u_opacity","u_mapFlag","u_Scale","u_texture","commonBufferInfo","clearModels","_this$texture2","cancelAnimationFrame","initModels","_this","DOWN","initUniformsBuffer","createTexture2D","rendererService","width","setTimeout","model","buildLayerModel","moduleName","vertexShader","fragmentShader","triangulation","planeGeometryTriangulation","defines","getDefines","inject","getInject","primitive","POINTS","depth","enable","blend","getBlend","buildModels","_this2","img","Image","crossOrigin","onload","wrapS","CLAMP_TO_EDGE","wrapT","reRender","src","registerBuiltinAttributes"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/l7-layers/es/geometry/models/sprite.js"],"sourcesContent":["import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { gl } from '@antv/l7-core';\nimport BaseModel from \"../../core/BaseModel\";\n/* babel-plugin-inline-import '../shaders/sprite_frag.glsl' */\nconst spriteFrag = \"\\nlayout(std140) uniform commonUniforms {\\n  float u_opacity;\\n  float u_mapFlag;\\n  float u_Scale;\\n};\\nuniform sampler2D u_texture;\\n\\nin vec3 v_Color;\\nin float v_d;\\nout vec4 outputColor;\\n\\nvoid main() {\\n\\n  if(v_d < 0.0) {\\n    discard;\\n  }\\n\\n  if(u_mapFlag > 0.0) {\\n    outputColor = texture(SAMPLER_2D(u_texture), gl_PointCoord);\\n    outputColor.a *= u_opacity;\\n  } else {\\n    outputColor = vec4(v_Color, u_opacity);\\n  }\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/sprite_vert.glsl' */\nconst spriteVert = \"layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec3 a_Color;\\n\\nlayout(std140) uniform commonUniforms {\\n  float u_opacity;\\n  float u_mapFlag;\\n  float u_Scale;\\n};\\n\\nout vec3 v_Color;\\nout float v_d;\\n\\n#pragma include \\\"projection\\\"\\nvoid main() {\\n  v_Color = a_Color.xyz;\\n  v_d = a_Position.z;\\n\\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, a_Position.z, 1.0));\\n  gl_PointSize = pow(u_Zoom - 1.0, 2.0) * u_Scale;\\n}\\n\";\nvar SPRITE_ANIMATE_DIR = /*#__PURE__*/function (SPRITE_ANIMATE_DIR) {\n  SPRITE_ANIMATE_DIR[\"UP\"] = \"up\";\n  SPRITE_ANIMATE_DIR[\"DOWN\"] = \"down\";\n  return SPRITE_ANIMATE_DIR;\n}(SPRITE_ANIMATE_DIR || {});\nexport default class SpriteModel extends BaseModel {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"texture\", void 0);\n    _defineProperty(this, \"mapTexture\", void 0);\n    _defineProperty(this, \"positions\", void 0);\n    _defineProperty(this, \"indices\", void 0);\n    _defineProperty(this, \"timer\", void 0);\n    _defineProperty(this, \"spriteTop\", void 0);\n    _defineProperty(this, \"spriteUpdate\", void 0);\n    _defineProperty(this, \"spriteAnimate\", void 0);\n    _defineProperty(this, \"planeGeometryUpdateTriangulation\", () => {\n      const {\n        spriteBottom = -10\n      } = this.layer.getLayerConfig();\n      const updateZ = this.spriteUpdate;\n      const bottomZ = spriteBottom;\n      const topZ = this.spriteTop;\n      for (let i = 0; i < this.positions.length; i += 5) {\n        if (this.spriteAnimate === SPRITE_ANIMATE_DIR.UP) {\n          this.positions[i + 2] += updateZ;\n          if (this.positions[i + 2] > topZ) {\n            this.positions[i + 2] = bottomZ;\n          }\n        } else {\n          this.positions[i + 2] -= updateZ;\n          if (this.positions[i + 2] < bottomZ) {\n            this.positions[i + 2] = topZ;\n          }\n        }\n      }\n      return {\n        vertices: this.positions,\n        indices: this.indices,\n        size: 5\n      };\n    });\n    /**\n     * Recalculate and update position attribute.\n     */\n    _defineProperty(this, \"updatePosition\", () => {\n      var _this$styleAttributeS;\n      this.planeGeometryUpdateTriangulation();\n      const vertexAttribute = (_this$styleAttributeS = this.styleAttributeService.getLayerStyleAttribute('position')) === null || _this$styleAttributeS === void 0 ? void 0 : _this$styleAttributeS.vertexAttribute;\n      if (vertexAttribute) {\n        // [x1, y1, z1, x2, y2, z2...]\n        const updated = [];\n        for (let i = 0; i < this.positions.length; i += 5) {\n          updated.push(this.positions[i], this.positions[i + 1], this.positions[i + 2]);\n        }\n        vertexAttribute.updateBuffer({\n          data: updated,\n          offset: 0\n        });\n      }\n      this.layerService.throttleRenderLayers();\n      this.timer = requestAnimationFrame(this.updatePosition);\n    });\n    _defineProperty(this, \"planeGeometryTriangulation\", () => {\n      const {\n        center = [120, 30],\n        spriteCount = 100,\n        spriteRadius = 10\n      } = this.layer.getLayerConfig();\n      const {\n        indices,\n        positions\n      } = this.initSprite(spriteRadius, spriteCount, ...center);\n      this.positions = positions;\n      this.indices = indices;\n      return {\n        vertices: positions,\n        indices,\n        size: 5\n      };\n    });\n  }\n  initSprite(radius = 10, spriteCount = 100, lng = 120, lat = 30) {\n    const indices = [];\n    const positions = [];\n    const heightLimit = this.spriteAnimate === SPRITE_ANIMATE_DIR.UP ? -this.spriteTop : this.spriteTop;\n    for (let i = 0; i < spriteCount; i++) {\n      const height = Math.random() * heightLimit;\n      positions.push(...getPos(height));\n    }\n    for (let i = 0; i < spriteCount; i++) {\n      indices.push(i);\n    }\n    function getPos(z) {\n      const randomX = radius * Math.random();\n      const randomY = radius * Math.random();\n      const x = -radius / 2 + randomX;\n      const y = -radius / 2 + randomY;\n      return [x + lng, -y + lat, z, 0, 0];\n    }\n    return {\n      indices,\n      positions\n    };\n  }\n  getUninforms() {\n    const commoninfo = this.getCommonUniformsInfo();\n    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());\n    this.updateStyleUnifoms();\n    return _objectSpread(_objectSpread({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);\n  }\n  getCommonUniformsInfo() {\n    const {\n      opacity,\n      mapTexture,\n      spriteScale = 1\n    } = this.layer.getLayerConfig();\n    if (this.mapTexture !== mapTexture) {\n      var _this$texture;\n      this.mapTexture = mapTexture;\n      (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();\n      this.textures = [];\n      this.updateTexture(mapTexture);\n    }\n    const commonOptions = {\n      u_opacity: opacity || 1,\n      u_mapFlag: mapTexture ? 1 : 0,\n      u_Scale: spriteScale,\n      u_texture: this.texture\n    };\n    this.textures = [this.texture];\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  clearModels() {\n    var _this$texture2;\n    cancelAnimationFrame(this.timer);\n    (_this$texture2 = this.texture) === null || _this$texture2 === void 0 || _this$texture2.destroy();\n    this.textures = [];\n  }\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const {\n        mapTexture,\n        spriteTop = 300,\n        spriteUpdate = 10,\n        spriteAnimate = SPRITE_ANIMATE_DIR.DOWN\n      } = _this.layer.getLayerConfig();\n      _this.initUniformsBuffer();\n      _this.mapTexture = mapTexture;\n      _this.spriteTop = spriteTop;\n      _this.spriteUpdate = spriteUpdate;\n      spriteAnimate === 'up' ? _this.spriteAnimate = SPRITE_ANIMATE_DIR.UP : _this.spriteAnimate = SPRITE_ANIMATE_DIR.DOWN;\n      const {\n        createTexture2D\n      } = _this.rendererService;\n      _this.texture = createTexture2D({\n        height: 0,\n        width: 0\n      });\n      _this.updateTexture(mapTexture);\n      setTimeout(() => {\n        _this.updatePosition();\n      }, 100);\n      const model = yield _this.layer.buildLayerModel({\n        moduleName: 'geometrySprite',\n        vertexShader: spriteVert,\n        fragmentShader: spriteFrag,\n        triangulation: _this.planeGeometryTriangulation,\n        defines: _this.getDefines(),\n        inject: _this.getInject(),\n        primitive: gl.POINTS,\n        depth: {\n          enable: false\n        },\n        blend: _this.getBlend()\n      });\n      return [model];\n    })();\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      return _this2.initModels();\n    })();\n  }\n  updateTexture(mapTexture) {\n    const {\n      createTexture2D\n    } = this.rendererService;\n    if (mapTexture) {\n      const img = new Image();\n      img.crossOrigin = 'anonymous';\n      img.onload = () => {\n        this.texture = createTexture2D({\n          data: img,\n          width: img.width,\n          height: img.height,\n          wrapS: gl.CLAMP_TO_EDGE,\n          wrapT: gl.CLAMP_TO_EDGE\n        });\n        this.layerService.reRender();\n      };\n      img.src = mapTexture;\n    } else {\n      this.texture = createTexture2D({\n        width: 1,\n        height: 1\n      });\n    }\n  }\n  registerBuiltinAttributes() {\n    return '';\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}