{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport Point from '@mapbox/point-geometry';\nimport { LngLat } from \"./geo/lng_lat\";\nimport { LngLatBounds } from \"./geo/lng_lat_bounds\";\nimport { MercatorCoordinate } from \"./geo/mercator_coordinate\";\nimport { browser } from \"./util/browser\";\nimport { Event, Evented } from \"./util/evented\";\nimport { clamp, defaultEasing, degreesToRadians, extend, interpolates, pick, warnOnce, wrap } from \"./util/util\";\n\n/**\n * A [Point](https://github.com/mapbox/point-geometry) or an array of two numbers representing `x` and `y` screen coordinates in pixels.\n *\n * @group Geography and Geometry\n *\n * @example\n * ```ts\n * let p1 = new Point(-77, 38); // a PointLike which is a Point\n * let p2 = [-77, 38]; // a PointLike which is an array of two numbers\n * ```\n */\n\n/**\n * A helper to allow require of at least one property\n */\n\n/**\n * Options common to {@link Map#jumpTo}, {@link Map#easeTo}, and {@link Map#flyTo}, controlling the desired location,\n * zoom, bearing, and pitch of the camera. All properties are optional, and when a property is omitted, the current\n * camera value for that property will remain unchanged.\n *\n * @example\n * Set the map's initial perspective with CameraOptions\n * ```ts\n * let map = new Map({\n *   container: 'map',\n *   style: 'https://demotiles.maplibre.org/style.json',\n *   center: [-73.5804, 45.53483],\n *   pitch: 60,\n *   bearing: -60,\n *   zoom: 10\n * });\n * ```\n * @see [Set pitch and bearing](https://maplibre.org/maplibre-gl-js/docs/examples/set-perspective/)\n * @see [Jump to a series of locations](https://maplibre.org/maplibre-gl-js/docs/examples/jump-to/)\n * @see [Fly to a location](https://maplibre.org/maplibre-gl-js/docs/examples/flyto/)\n * @see [Display buildings in 3D](https://maplibre.org/maplibre-gl-js/docs/examples/3d-buildings/)\n */\n\n/**\n * Holds center, zoom and bearing properties\n */\n\n/**\n * The options object related to the {@link Map#jumpTo} method\n */\n\n/**\n * A options object for the {@link Map#cameraForBounds} method\n */\n\n/**\n * The {@link Map#flyTo} options object\n */\n\n/**\n * Options for {@link Map#fitBounds} method\n */\n\n/**\n * Options common to map movement methods that involve animation, such as {@link Map#panBy} and\n * {@link Map#easeTo}, controlling the duration and easing function of the animation. All properties\n * are optional.\n *\n */\n\n/**\n * A callback hook that allows manipulating the camera and being notified about camera updates before they happen\n */\n\nexport class Camera extends Evented {\n  constructor(transform, options) {\n    super();\n    _defineProperty(this, \"transform\", void 0);\n    _defineProperty(this, \"handlers\", void 0);\n    _defineProperty(this, \"_moving\", void 0);\n    _defineProperty(this, \"_zooming\", void 0);\n    _defineProperty(this, \"_rotating\", void 0);\n    _defineProperty(this, \"_pitching\", void 0);\n    _defineProperty(this, \"_padding\", void 0);\n    _defineProperty(this, \"_bearingSnap\", void 0);\n    _defineProperty(this, \"_easeStart\", void 0);\n    _defineProperty(this, \"_easeOptions\", void 0);\n    _defineProperty(this, \"_easeId\", void 0);\n    _defineProperty(this, \"_onEaseFrame\", void 0);\n    _defineProperty(this, \"_onEaseEnd\", void 0);\n    _defineProperty(this, \"_easeFrameId\", void 0);\n    /**\n     * @internal\n     * Used to track accumulated changes during continuous interaction\n     */\n    _defineProperty(this, \"_requestedCameraState\", void 0);\n    /**\n     * A callback used to defer camera updates or apply arbitrary constraints.\n     * If specified, this Camera instance can be used as a stateless component in React etc.\n     */\n    _defineProperty(this, \"transformCameraUpdate\", void 0);\n    // Callback for map._requestRenderFrame\n    _defineProperty(this, \"_renderFrameCallback\", () => {\n      const t = Math.min((browser.now() - this._easeStart) / this._easeOptions.duration, 1);\n      this._onEaseFrame(this._easeOptions.easing(t));\n\n      // if _stop is called during _onEaseFrame from _fireMoveEvents we should avoid a new _requestRenderFrame, checking it by ensuring _easeFrameId was not deleted\n      if (t < 1 && this._easeFrameId) {\n        this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback);\n      } else {\n        this.stop();\n      }\n    });\n    this._moving = false;\n    this._zooming = false;\n    this.transform = transform;\n    this._bearingSnap = options.bearingSnap;\n    this.on('moveend', () => {\n      delete this._requestedCameraState;\n    });\n  }\n\n  /**\n   * Returns the map's geographical centerpoint.\n   *\n   * @returns The map's geographical centerpoint.\n   * @example\n   * Return a LngLat object such as `{lng: 0, lat: 0}`\n   * ```ts\n   * let center = map.getCenter();\n   * // access longitude and latitude values directly\n   * let {lng, lat} = map.getCenter();\n   * ```\n   */\n  getCenter() {\n    return new LngLat(this.transform.center.lng, this.transform.center.lat);\n  }\n\n  /**\n   * Sets the map's geographical centerpoint. Equivalent to `jumpTo({center: center})`.\n   *\n   * Triggers the following events: `movestart` and `moveend`.\n   *\n   * @param center - The centerpoint to set.\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @example\n   * ```ts\n   * map.setCenter([-74, 38]);\n   * ```\n   */\n  setCenter(center, eventData) {\n    return this.jumpTo({\n      center\n    }, eventData);\n  }\n\n  /**\n   * Pans the map by the specified offset.\n   *\n   * Triggers the following events: `movestart` and `moveend`.\n   *\n   * @param offset - `x` and `y` coordinates by which to pan the map.\n   * @param options - Options object\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @see [Navigate the map with game-like controls](https://maplibre.org/maplibre-gl-js/docs/examples/game-controls/)\n   */\n  panBy(offset, options, eventData) {\n    offset = Point.convert(offset).mult(-1);\n    return this.panTo(this.transform.center, extend({\n      offset\n    }, options), eventData);\n  }\n\n  /**\n   * Pans the map to the specified location with an animated transition.\n   *\n   * Triggers the following events: `movestart` and `moveend`.\n   *\n   * @param lnglat - The location to pan the map to.\n   * @param options - Options describing the destination and animation of the transition.\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @example\n   * ```ts\n   * map.panTo([-74, 38]);\n   * // Specify that the panTo animation should last 5000 milliseconds.\n   * map.panTo([-74, 38], {duration: 5000});\n   * ```\n   * @see [Update a feature in realtime](https://maplibre.org/maplibre-gl-js/docs/examples/live-update-feature/)\n   */\n  panTo(lnglat, options, eventData) {\n    return this.easeTo(extend({\n      center: lnglat\n    }, options), eventData);\n  }\n\n  /**\n   * Returns the map's current zoom level.\n   *\n   * @returns The map's current zoom level.\n   * @example\n   * ```ts\n   * map.getZoom();\n   * ```\n   */\n  getZoom() {\n    return this.transform.zoom;\n  }\n\n  /**\n   * Sets the map's zoom level. Equivalent to `jumpTo({zoom: zoom})`.\n   *\n   * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, and `zoomend`.\n   *\n   * @param zoom - The zoom level to set (0-20).\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @example\n   * Zoom to the zoom level 5 without an animated transition\n   * ```ts\n   * map.setZoom(5);\n   * ```\n   */\n  setZoom(zoom, eventData) {\n    this.jumpTo({\n      zoom\n    }, eventData);\n    return this;\n  }\n\n  /**\n   * Zooms the map to the specified zoom level, with an animated transition.\n   *\n   * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, and `zoomend`.\n   *\n   * @param zoom - The zoom level to transition to.\n   * @param options - Options object\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @example\n   * ```ts\n   * // Zoom to the zoom level 5 without an animated transition\n   * map.zoomTo(5);\n   * // Zoom to the zoom level 8 with an animated transition\n   * map.zoomTo(8, {\n   *   duration: 2000,\n   *   offset: [100, 50]\n   * });\n   * ```\n   */\n  zoomTo(zoom, options, eventData) {\n    return this.easeTo(extend({\n      zoom\n    }, options), eventData);\n  }\n\n  /**\n   * Increases the map's zoom level by 1.\n   *\n   * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, and `zoomend`.\n   *\n   * @param options - Options object\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @example\n   * Zoom the map in one level with a custom animation duration\n   * ```ts\n   * map.zoomIn({duration: 1000});\n   * ```\n   */\n  zoomIn(options, eventData) {\n    this.zoomTo(this.getZoom() + 1, options, eventData);\n    return this;\n  }\n\n  /**\n   * Decreases the map's zoom level by 1.\n   *\n   * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, and `zoomend`.\n   *\n   * @param options - Options object\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @example\n   * Zoom the map out one level with a custom animation offset\n   * ```ts\n   * map.zoomOut({offset: [80, 60]});\n   * ```\n   */\n  zoomOut(options, eventData) {\n    this.zoomTo(this.getZoom() - 1, options, eventData);\n    return this;\n  }\n\n  /**\n   * Returns the map's current bearing. The bearing is the compass direction that is \"up\"; for example, a bearing\n   * of 90° orients the map so that east is up.\n   *\n   * @returns The map's current bearing.\n   * @see [Navigate the map with game-like controls](https://maplibre.org/maplibre-gl-js/docs/examples/game-controls/)\n   */\n  getBearing() {\n    return this.transform.bearing;\n  }\n\n  /**\n   * Sets the map's bearing (rotation). The bearing is the compass direction that is \"up\"; for example, a bearing\n   * of 90° orients the map so that east is up.\n   *\n   * Equivalent to `jumpTo({bearing: bearing})`.\n   *\n   * Triggers the following events: `movestart`, `moveend`, and `rotate`.\n   *\n   * @param bearing - The desired bearing.\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @example\n   * Rotate the map to 90 degrees\n   * ```ts\n   * map.setBearing(90);\n   * ```\n   */\n  setBearing(bearing, eventData) {\n    this.jumpTo({\n      bearing\n    }, eventData);\n    return this;\n  }\n\n  /**\n   * Returns the current padding applied around the map viewport.\n   *\n   * @returns The current padding around the map viewport.\n   */\n  getPadding() {\n    return this.transform.padding;\n  }\n\n  /**\n   * Sets the padding in pixels around the viewport.\n   *\n   * Equivalent to `jumpTo({padding: padding})`.\n   *\n   * Triggers the following events: `movestart` and `moveend`.\n   *\n   * @param padding - The desired padding.\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @example\n   * Sets a left padding of 300px, and a top padding of 50px\n   * ```ts\n   * map.setPadding({ left: 300, top: 50 });\n   * ```\n   */\n  setPadding(padding, eventData) {\n    this.jumpTo({\n      padding\n    }, eventData);\n    return this;\n  }\n\n  /**\n   * Rotates the map to the specified bearing, with an animated transition. The bearing is the compass direction\n   * that is \"up\"; for example, a bearing of 90° orients the map so that east is up.\n   *\n   * Triggers the following events: `movestart`, `moveend`, and `rotate`.\n   *\n   * @param bearing - The desired bearing.\n   * @param options - Options object\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   */\n  rotateTo(bearing, options, eventData) {\n    return this.easeTo(extend({\n      bearing\n    }, options), eventData);\n  }\n\n  /**\n   * Rotates the map so that north is up (0° bearing), with an animated transition.\n   *\n   * Triggers the following events: `movestart`, `moveend`, and `rotate`.\n   *\n   * @param options - Options object\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   */\n  resetNorth(options, eventData) {\n    this.rotateTo(0, extend({\n      duration: 1000\n    }, options), eventData);\n    return this;\n  }\n\n  /**\n   * Rotates and pitches the map so that north is up (0° bearing) and pitch is 0°, with an animated transition.\n   *\n   * Triggers the following events: `movestart`, `move`, `moveend`, `pitchstart`, `pitch`, `pitchend`, and `rotate`.\n   *\n   * @param options - Options object\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   */\n  resetNorthPitch(options, eventData) {\n    this.easeTo(extend({\n      bearing: 0,\n      pitch: 0,\n      duration: 1000\n    }, options), eventData);\n    return this;\n  }\n\n  /**\n   * Snaps the map so that north is up (0° bearing), if the current bearing is close enough to it (i.e. within the\n   * `bearingSnap` threshold).\n   *\n   * Triggers the following events: `movestart`, `moveend`, and `rotate`.\n   *\n   * @param options - Options object\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   */\n  snapToNorth(options, eventData) {\n    if (Math.abs(this.getBearing()) < this._bearingSnap) {\n      return this.resetNorth(options, eventData);\n    }\n    return this;\n  }\n\n  /**\n   * Returns the map's current pitch (tilt).\n   *\n   * @returns The map's current pitch, measured in degrees away from the plane of the screen.\n   */\n  getPitch() {\n    return this.transform.pitch;\n  }\n\n  /**\n   * Sets the map's pitch (tilt). Equivalent to `jumpTo({pitch: pitch})`.\n   *\n   * Triggers the following events: `movestart`, `moveend`, `pitchstart`, and `pitchend`.\n   *\n   * @param pitch - The pitch to set, measured in degrees away from the plane of the screen (0-60).\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   */\n  setPitch(pitch, eventData) {\n    this.jumpTo({\n      pitch\n    }, eventData);\n    return this;\n  }\n\n  /**\n   * @param bounds - Calculate the center for these bounds in the viewport and use\n   * the highest zoom level up to and including `Map#getMaxZoom()` that fits\n   * in the viewport. LngLatBounds represent a box that is always axis-aligned with bearing 0.\n   * @param options - Options object\n   * @returns If map is able to fit to provided bounds, returns `center`, `zoom`, and `bearing`.\n   * If map is unable to fit, method will warn and return undefined.\n   * @example\n   * ```ts\n   * let bbox = [[-79, 43], [-73, 45]];\n   * let newCameraTransform = map.cameraForBounds(bbox, {\n   *   padding: {top: 10, bottom:25, left: 15, right: 5}\n   * });\n   * ```\n   */\n  cameraForBounds(bounds, options) {\n    bounds = LngLatBounds.convert(bounds);\n    const bearing = options && options.bearing || 0;\n    return this._cameraForBoxAndBearing(bounds.getNorthWest(), bounds.getSouthEast(), bearing, options);\n  }\n\n  /**\n   * @internal\n   * Calculate the center of these two points in the viewport and use\n   * the highest zoom level up to and including `Map#getMaxZoom()` that fits\n   * the points in the viewport at the specified bearing.\n   * @param p0 - First point\n   * @param p1 - Second point\n   * @param bearing - Desired map bearing at end of animation, in degrees\n   * @param options - the camera options\n   * @returns If map is able to fit to provided bounds, returns `center`, `zoom`, and `bearing`.\n   *      If map is unable to fit, method will warn and return undefined.\n   * @example\n   * ```ts\n   * let p0 = [-79, 43];\n   * let p1 = [-73, 45];\n   * let bearing = 90;\n   * let newCameraTransform = map._cameraForBoxAndBearing(p0, p1, bearing, {\n   *   padding: {top: 10, bottom:25, left: 15, right: 5}\n   * });\n   * ```\n   */\n  _cameraForBoxAndBearing(p0, p1, bearing, options) {\n    const defaultPadding = {\n      top: 0,\n      bottom: 0,\n      right: 0,\n      left: 0\n    };\n    options = extend({\n      padding: defaultPadding,\n      offset: [0, 0],\n      maxZoom: this.transform.maxZoom\n    }, options);\n    if (typeof options.padding === 'number') {\n      const p = options.padding;\n      options.padding = {\n        top: p,\n        bottom: p,\n        right: p,\n        left: p\n      };\n    }\n    options.padding = extend(defaultPadding, options.padding);\n    const tr = this.transform;\n    const edgePadding = tr.padding;\n\n    // Consider all corners of the rotated bounding box derived from the given points\n    // when find the camera position that fits the given points.\n    const bounds = new LngLatBounds(p0, p1);\n    const nwWorld = tr.project(bounds.getNorthWest());\n    const neWorld = tr.project(bounds.getNorthEast());\n    const seWorld = tr.project(bounds.getSouthEast());\n    const swWorld = tr.project(bounds.getSouthWest());\n    const bearingRadians = degreesToRadians(-bearing);\n    const nwRotatedWorld = nwWorld.rotate(bearingRadians);\n    const neRotatedWorld = neWorld.rotate(bearingRadians);\n    const seRotatedWorld = seWorld.rotate(bearingRadians);\n    const swRotatedWorld = swWorld.rotate(bearingRadians);\n    const upperRight = new Point(Math.max(nwRotatedWorld.x, neRotatedWorld.x, swRotatedWorld.x, seRotatedWorld.x), Math.max(nwRotatedWorld.y, neRotatedWorld.y, swRotatedWorld.y, seRotatedWorld.y));\n    const lowerLeft = new Point(Math.min(nwRotatedWorld.x, neRotatedWorld.x, swRotatedWorld.x, seRotatedWorld.x), Math.min(nwRotatedWorld.y, neRotatedWorld.y, swRotatedWorld.y, seRotatedWorld.y));\n\n    // Calculate zoom: consider the original bbox and padding.\n    const size = upperRight.sub(lowerLeft);\n    const scaleX = (tr.width - (edgePadding.left + edgePadding.right + options.padding.left + options.padding.right)) / size.x;\n    const scaleY = (tr.height - (edgePadding.top + edgePadding.bottom + options.padding.top + options.padding.bottom)) / size.y;\n    if (scaleY < 0 || scaleX < 0) {\n      warnOnce('Map cannot fit within canvas with the given bounds, padding, and/or offset.');\n      return undefined;\n    }\n    const zoom = Math.min(tr.scaleZoom(tr.scale * Math.min(scaleX, scaleY)), options.maxZoom);\n\n    // Calculate center: apply the zoom, the configured offset, as well as offset that exists as a result of padding.\n    const offset = Point.convert(options.offset);\n    const paddingOffsetX = (options.padding.left - options.padding.right) / 2;\n    const paddingOffsetY = (options.padding.top - options.padding.bottom) / 2;\n    const paddingOffset = new Point(paddingOffsetX, paddingOffsetY);\n    const rotatedPaddingOffset = paddingOffset.rotate(degreesToRadians(bearing));\n    const offsetAtInitialZoom = offset.add(rotatedPaddingOffset);\n    const offsetAtFinalZoom = offsetAtInitialZoom.mult(tr.scale / tr.zoomScale(zoom));\n    const center = tr.unproject(\n    // either world diagonal can be used (NW-SE or NE-SW)\n    nwWorld.add(seWorld).div(2).sub(offsetAtFinalZoom));\n    return {\n      center,\n      zoom,\n      bearing\n    };\n  }\n\n  /**\n   * Pans and zooms the map to contain its visible area within the specified geographical bounds.\n   * This function will also reset the map's bearing to 0 if bearing is nonzero.\n   *\n   * Triggers the following events: `movestart` and `moveend`.\n   *\n   * @param bounds - Center these bounds in the viewport and use the highest\n   * zoom level up to and including `Map#getMaxZoom()` that fits them in the viewport.\n   * @param options - Options supports all properties from {@link AnimationOptions} and {@link CameraOptions} in addition to the fields below.\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @example\n   * ```ts\n   * let bbox = [[-79, 43], [-73, 45]];\n   * map.fitBounds(bbox, {\n   *   padding: {top: 10, bottom:25, left: 15, right: 5}\n   * });\n   * ```\n   * @see [Fit a map to a bounding box](https://maplibre.org/maplibre-gl-js/docs/examples/fitbounds/)\n   */\n  fitBounds(bounds, options, eventData) {\n    return this._fitInternal(this.cameraForBounds(bounds, options), options, eventData);\n  }\n\n  /**\n   * Pans, rotates and zooms the map to to fit the box made by points p0 and p1\n   * once the map is rotated to the specified bearing. To zoom without rotating,\n   * pass in the current map bearing.\n   *\n   * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, `zoomend` and `rotate`.\n   *\n   * @param p0 - First point on screen, in pixel coordinates\n   * @param p1 - Second point on screen, in pixel coordinates\n   * @param bearing - Desired map bearing at end of animation, in degrees\n   * @param options - Options object\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @example\n   * ```ts\n   * let p0 = [220, 400];\n   * let p1 = [500, 900];\n   * map.fitScreenCoordinates(p0, p1, map.getBearing(), {\n   *   padding: {top: 10, bottom:25, left: 15, right: 5}\n   * });\n   * ```\n   * @see Used by {@link BoxZoomHandler}\n   */\n  fitScreenCoordinates(p0, p1, bearing, options, eventData) {\n    return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(Point.convert(p0)), this.transform.pointLocation(Point.convert(p1)), bearing, options), options, eventData);\n  }\n  _fitInternal(calculatedOptions, options, eventData) {\n    // cameraForBounds warns + returns undefined if unable to fit:\n    if (!calculatedOptions) return this;\n    options = extend(calculatedOptions, options);\n    // Explicitly remove the padding field because, calculatedOptions already accounts for padding by setting zoom and center accordingly.\n    delete options.padding;\n    return options.linear ? this.easeTo(options, eventData) : this.flyTo(options, eventData);\n  }\n\n  /**\n   * Changes any combination of center, zoom, bearing, and pitch, without\n   * an animated transition. The map will retain its current values for any\n   * details not specified in `options`.\n   *\n   * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, `zoomend`, `pitchstart`,\n   * `pitch`, `pitchend`, and `rotate`.\n   *\n   * @param options - Options object\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @example\n   * ```ts\n   * // jump to coordinates at current zoom\n   * map.jumpTo({center: [0, 0]});\n   * // jump with zoom, pitch, and bearing options\n   * map.jumpTo({\n   *   center: [0, 0],\n   *   zoom: 8,\n   *   pitch: 45,\n   *   bearing: 90\n   * });\n   * ```\n   * @see [Jump to a series of locations](https://maplibre.org/maplibre-gl-js/docs/examples/jump-to/)\n   * @see [Update a feature in realtime](https://maplibre.org/maplibre-gl-js/docs/examples/live-update-feature/)\n   */\n  jumpTo(options, eventData) {\n    this.stop();\n    const tr = this._getTransformForUpdate();\n    let zoomChanged = false,\n      bearingChanged = false,\n      pitchChanged = false;\n    if ('zoom' in options && tr.zoom !== +options.zoom) {\n      zoomChanged = true;\n      tr.zoom = +options.zoom;\n    }\n    if (options.center !== undefined) {\n      tr.center = LngLat.convert(options.center);\n    }\n    if ('bearing' in options && tr.bearing !== +options.bearing) {\n      bearingChanged = true;\n      tr.bearing = +options.bearing;\n    }\n    if ('pitch' in options && tr.pitch !== +options.pitch) {\n      pitchChanged = true;\n      tr.pitch = +options.pitch;\n    }\n    if (options.padding != null && !tr.isPaddingEqual(options.padding)) {\n      tr.padding = options.padding;\n    }\n    this._applyUpdatedTransform(tr);\n    this.fire(new Event('movestart', eventData)).fire(new Event('move', eventData));\n    if (zoomChanged) {\n      this.fire(new Event('zoomstart', eventData)).fire(new Event('zoom', eventData)).fire(new Event('zoomend', eventData));\n    }\n    if (bearingChanged) {\n      this.fire(new Event('rotatestart', eventData)).fire(new Event('rotate', eventData)).fire(new Event('rotateend', eventData));\n    }\n    if (pitchChanged) {\n      this.fire(new Event('pitchstart', eventData)).fire(new Event('pitch', eventData)).fire(new Event('pitchend', eventData));\n    }\n    return this.fire(new Event('moveend', eventData));\n  }\n\n  /**\n   * Calculates pitch, zoom and bearing for looking at `newCenter` with the camera position being `newCenter`\n   * and returns them as {@link CameraOptions}.\n   * @param from - The camera to look from\n   * @param altitudeFrom - The altitude of the camera to look from\n   * @param to - The center to look at\n   * @param altitudeTo - Optional altitude of the center to look at. If none given the ground height will be used.\n   * @returns the calculated camera options\n   */\n  calculateCameraOptionsFromTo(from, altitudeFrom, to, altitudeTo = 0) {\n    const fromMerc = MercatorCoordinate.fromLngLat(from, altitudeFrom);\n    const toMerc = MercatorCoordinate.fromLngLat(to, altitudeTo);\n    const dx = toMerc.x - fromMerc.x;\n    const dy = toMerc.y - fromMerc.y;\n    const dz = toMerc.z - fromMerc.z;\n    const distance3D = Math.hypot(dx, dy, dz);\n    if (distance3D === 0) throw new Error(\"Can't calculate camera options with same From and To\");\n    const groundDistance = Math.hypot(dx, dy);\n    const zoom = this.transform.scaleZoom(this.transform.cameraToCenterDistance / distance3D / this.transform.tileSize);\n    const bearing = Math.atan2(dx, -dy) * 180 / Math.PI;\n    let pitch = Math.acos(groundDistance / distance3D) * 180 / Math.PI;\n    pitch = dz < 0 ? 90 - pitch : 90 + pitch;\n    return {\n      center: toMerc.toLngLat(),\n      zoom,\n      pitch,\n      bearing\n    };\n  }\n\n  /**\n   * Changes any combination of `center`, `zoom`, `bearing`, `pitch`, and `padding` with an animated transition\n   * between old and new values. The map will retain its current values for any\n   * details not specified in `options`.\n   *\n   * Note: The transition will happen instantly if the user has enabled\n   * the `reduced motion` accessibility feature enabled in their operating system,\n   * unless `options` includes `essential: true`.\n   *\n   * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, `zoomend`, `pitchstart`,\n   * `pitch`, `pitchend`, and `rotate`.\n   *\n   * @param options - Options describing the destination and animation of the transition.\n   * Accepts {@link CameraOptions} and {@link AnimationOptions}.\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @see [Navigate the map with game-like controls](https://maplibre.org/maplibre-gl-js/docs/examples/game-controls/)\n   */\n  easeTo(options, eventData) {\n    var _options$zoom;\n    this._stop(false, options.easeId);\n    options = extend({\n      offset: [0, 0],\n      duration: 500,\n      easing: defaultEasing\n    }, options);\n    if (options.animate === false || !options.essential && browser.prefersReducedMotion) options.duration = 0;\n    const tr = this._getTransformForUpdate(),\n      startZoom = this.getZoom(),\n      startBearing = this.getBearing(),\n      startPitch = this.getPitch(),\n      startPadding = this.getPadding(),\n      bearing = 'bearing' in options ? this._normalizeBearing(options.bearing, startBearing) : startBearing,\n      pitch = 'pitch' in options ? +options.pitch : startPitch,\n      padding = 'padding' in options ? options.padding : tr.padding;\n    const offsetAsPoint = Point.convert(options.offset);\n    let pointAtOffset = tr.centerPoint.add(offsetAsPoint);\n    const locationAtOffset = tr.pointLocation(pointAtOffset);\n    const {\n      center,\n      zoom\n    } = tr.getConstrained(LngLat.convert(options.center || locationAtOffset), (_options$zoom = options.zoom) !== null && _options$zoom !== void 0 ? _options$zoom : startZoom);\n    this._normalizeCenter(center);\n    const from = tr.project(locationAtOffset);\n    const delta = tr.project(center).sub(from);\n    const finalScale = tr.zoomScale(zoom - startZoom);\n    let around, aroundPoint;\n    if (options.around) {\n      around = LngLat.convert(options.around);\n      aroundPoint = tr.locationPoint(around);\n    }\n    const currently = {\n      moving: this._moving,\n      zooming: this._zooming,\n      rotating: this._rotating,\n      pitching: this._pitching\n    };\n    this._zooming = this._zooming || zoom !== startZoom;\n    this._rotating = this._rotating || startBearing !== bearing;\n    this._pitching = this._pitching || pitch !== startPitch;\n    this._padding = !tr.isPaddingEqual(padding);\n    this._easeId = options.easeId;\n    this._prepareEase(eventData, options.noMoveStart, currently);\n    this._ease(k => {\n      if (this._zooming) {\n        tr.zoom = interpolates.number(startZoom, zoom, k);\n      }\n      if (this._rotating) {\n        tr.bearing = interpolates.number(startBearing, bearing, k);\n      }\n      if (this._pitching) {\n        tr.pitch = interpolates.number(startPitch, pitch, k);\n      }\n      if (this._padding) {\n        tr.interpolatePadding(startPadding, padding, k);\n        // When padding is being applied, Transform#centerPoint is changing continuously,\n        // thus we need to recalculate offsetPoint every frame\n        pointAtOffset = tr.centerPoint.add(offsetAsPoint);\n      }\n      if (around) {\n        tr.setLocationAtPoint(around, aroundPoint);\n      } else {\n        const scale = tr.zoomScale(tr.zoom - startZoom);\n        const base = zoom > startZoom ? Math.min(2, finalScale) : Math.max(0.5, finalScale);\n        const speedup = Math.pow(base, 1 - k);\n        const newCenter = tr.unproject(from.add(delta.mult(k * speedup)).mult(scale));\n        tr.setLocationAtPoint(tr.renderWorldCopies ? newCenter.wrap() : newCenter, pointAtOffset);\n      }\n      this._applyUpdatedTransform(tr);\n      this._fireMoveEvents(eventData);\n    }, interruptingEaseId => {\n      this._afterEase(eventData, interruptingEaseId);\n    }, options);\n    return this;\n  }\n  _prepareEase(eventData, noMoveStart, currently = {}) {\n    this._moving = true;\n    if (!noMoveStart && !currently.moving) {\n      this.fire(new Event('movestart', eventData));\n    }\n    if (this._zooming && !currently.zooming) {\n      this.fire(new Event('zoomstart', eventData));\n    }\n    if (this._rotating && !currently.rotating) {\n      this.fire(new Event('rotatestart', eventData));\n    }\n    if (this._pitching && !currently.pitching) {\n      this.fire(new Event('pitchstart', eventData));\n    }\n  }\n\n  /**\n   * @internal\n   * Called when the camera is about to be manipulated.\n   * If `transformCameraUpdate` is specified, a copy of the current transform is created to track the accumulated changes.\n   * This underlying transform represents the \"desired state\" proposed by input handlers / animations / UI controls.\n   * It may differ from the state used for rendering (`this.transform`).\n   * @returns Transform to apply changes to\n   */\n  _getTransformForUpdate() {\n    if (!this.transformCameraUpdate) return this.transform;\n    if (!this._requestedCameraState) {\n      this._requestedCameraState = this.transform.clone();\n    }\n    return this._requestedCameraState;\n  }\n\n  /**\n   * @internal\n   * Called after the camera is done being manipulated.\n   * @param tr - the requested camera end state\n   * Call `transformCameraUpdate` if present, and then apply the \"approved\" changes.\n   */\n  _applyUpdatedTransform(tr) {\n    if (!this.transformCameraUpdate) return;\n    const nextTransform = tr.clone();\n    const {\n      center,\n      zoom,\n      pitch,\n      bearing,\n      elevation\n    } = this.transformCameraUpdate(nextTransform);\n    if (center) nextTransform.center = center;\n    if (zoom !== undefined) nextTransform.zoom = zoom;\n    if (pitch !== undefined) nextTransform.pitch = pitch;\n    if (bearing !== undefined) nextTransform.bearing = bearing;\n    if (elevation !== undefined) nextTransform.elevation = elevation;\n    this.transform.apply(nextTransform);\n  }\n  _fireMoveEvents(eventData) {\n    this.fire(new Event('move', eventData));\n    if (this._zooming) {\n      this.fire(new Event('zoom', eventData));\n    }\n    if (this._rotating) {\n      this.fire(new Event('rotate', eventData));\n    }\n    if (this._pitching) {\n      this.fire(new Event('pitch', eventData));\n    }\n  }\n  _afterEase(eventData, easeId) {\n    // if this easing is being stopped to start another easing with\n    // the same id then don't fire any events to avoid extra start/stop events\n    if (this._easeId && easeId && this._easeId === easeId) {\n      return;\n    }\n    delete this._easeId;\n    const wasZooming = this._zooming;\n    const wasRotating = this._rotating;\n    const wasPitching = this._pitching;\n    this._moving = false;\n    this._zooming = false;\n    this._rotating = false;\n    this._pitching = false;\n    this._padding = false;\n    if (wasZooming) {\n      this.fire(new Event('zoomend', eventData));\n    }\n    if (wasRotating) {\n      this.fire(new Event('rotateend', eventData));\n    }\n    if (wasPitching) {\n      this.fire(new Event('pitchend', eventData));\n    }\n    this.fire(new Event('moveend', eventData));\n  }\n\n  /**\n   * Changes any combination of center, zoom, bearing, and pitch, animating the transition along a curve that\n   * evokes flight. The animation seamlessly incorporates zooming and panning to help\n   * the user maintain her bearings even after traversing a great distance.\n   *\n   * Note: The animation will be skipped, and this will behave equivalently to `jumpTo`\n   * if the user has the `reduced motion` accessibility feature enabled in their operating system,\n   * unless 'options' includes `essential: true`.\n   *\n   * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, `zoomend`, `pitchstart`,\n   * `pitch`, `pitchend`, and `rotate`.\n   *\n   * @param options - Options describing the destination and animation of the transition.\n   * Accepts {@link CameraOptions}, {@link AnimationOptions},\n   * and the following additional options.\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @example\n   * ```ts\n   * // fly with default options to null island\n   * map.flyTo({center: [0, 0], zoom: 9});\n   * // using flyTo options\n   * map.flyTo({\n   *   center: [0, 0],\n   *   zoom: 9,\n   *   speed: 0.2,\n   *   curve: 1,\n   *   easing(t) {\n   *     return t;\n   *   }\n   * });\n   * ```\n   * @see [Fly to a location](https://maplibre.org/maplibre-gl-js/docs/examples/flyto/)\n   * @see [Slowly fly to a location](https://maplibre.org/maplibre-gl-js/docs/examples/flyto-options/)\n   * @see [Fly to a location based on scroll position](https://maplibre.org/maplibre-gl-js/docs/examples/scroll-fly-to/)\n   */\n  flyTo(options, eventData) {\n    var _options$zoom2;\n    // Fall through to jumpTo if user has set prefers-reduced-motion\n    if (!options.essential && browser.prefersReducedMotion) {\n      const coercedOptions = pick(options, ['center', 'zoom', 'bearing', 'pitch', 'around']);\n      return this.jumpTo(coercedOptions, eventData);\n    }\n\n    // This method implements an “optimal path” animation, as detailed in:\n    //\n    // Van Wijk, Jarke J.; Nuij, Wim A. A. “Smooth and efficient zooming and panning.” INFOVIS\n    //   ’03. pp. 15–22. <https://www.win.tue.nl/~vanwijk/zoompan.pdf#page=5>.\n    //\n    // Where applicable, local variable documentation begins with the associated variable or\n    // function in van Wijk (2003).\n\n    this.stop();\n    options = extend({\n      offset: [0, 0],\n      speed: 1.2,\n      curve: 1.42,\n      easing: defaultEasing\n    }, options);\n    const tr = this._getTransformForUpdate(),\n      startZoom = this.getZoom(),\n      startBearing = this.getBearing(),\n      startPitch = this.getPitch(),\n      startPadding = this.getPadding();\n    const bearing = 'bearing' in options ? this._normalizeBearing(options.bearing, startBearing) : startBearing;\n    const pitch = 'pitch' in options ? +options.pitch : startPitch;\n    const padding = 'padding' in options ? options.padding : tr.padding;\n    const offsetAsPoint = Point.convert(options.offset);\n    let pointAtOffset = tr.centerPoint.add(offsetAsPoint);\n    const locationAtOffset = tr.pointLocation(pointAtOffset);\n    const {\n      center,\n      zoom\n    } = tr.getConstrained(LngLat.convert(options.center || locationAtOffset), (_options$zoom2 = options.zoom) !== null && _options$zoom2 !== void 0 ? _options$zoom2 : startZoom);\n    this._normalizeCenter(center);\n    const scale = tr.zoomScale(zoom - startZoom);\n    const from = tr.project(locationAtOffset);\n    const delta = tr.project(center).sub(from);\n    let rho = options.curve;\n\n    // w₀: Initial visible span, measured in pixels at the initial scale.\n    const w0 = Math.max(tr.width, tr.height),\n      // w₁: Final visible span, measured in pixels with respect to the initial scale.\n      w1 = w0 / scale,\n      // Length of the flight path as projected onto the ground plane, measured in pixels from\n      // the world image origin at the initial scale.\n      u1 = delta.mag();\n    if ('minZoom' in options) {\n      const minZoom = clamp(Math.min(options.minZoom, startZoom, zoom), tr.minZoom, tr.maxZoom);\n      // w<sub>m</sub>: Maximum visible span, measured in pixels with respect to the initial\n      // scale.\n      const wMax = w0 / tr.zoomScale(minZoom - startZoom);\n      rho = Math.sqrt(wMax / u1 * 2);\n    }\n\n    // ρ²\n    const rho2 = rho * rho;\n\n    /**\n     * rᵢ: Returns the zoom-out factor at one end of the animation.\n     *\n     * @param descent - `true` for the descent, `false` for the ascent\n     */\n    function zoomOutFactor(descent) {\n      const b = (w1 * w1 - w0 * w0 + (descent ? -1 : 1) * rho2 * rho2 * u1 * u1) / (2 * (descent ? w1 : w0) * rho2 * u1);\n      return Math.log(Math.sqrt(b * b + 1) - b);\n    }\n    function sinh(n) {\n      return (Math.exp(n) - Math.exp(-n)) / 2;\n    }\n    function cosh(n) {\n      return (Math.exp(n) + Math.exp(-n)) / 2;\n    }\n    function tanh(n) {\n      return sinh(n) / cosh(n);\n    }\n\n    // r₀: Zoom-out factor during ascent.\n    const r0 = zoomOutFactor(false);\n\n    // w(s): Returns the visible span on the ground, measured in pixels with respect to the\n    // initial scale. Assumes an angular field of view of 2 arctan ½ ≈ 53°.\n    let w = function (s) {\n      return cosh(r0) / cosh(r0 + rho * s);\n    };\n\n    // u(s): Returns the distance along the flight path as projected onto the ground plane,\n    // measured in pixels from the world image origin at the initial scale.\n    let u = function (s) {\n      return w0 * ((cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2) / u1;\n    };\n\n    // S: Total length of the flight path, measured in ρ-screenfuls.\n    let S = (zoomOutFactor(true) - r0) / rho;\n\n    // When u₀ = u₁, the optimal path doesn’t require both ascent and descent.\n    if (Math.abs(u1) < 0.000001 || !isFinite(S)) {\n      // Perform a more or less instantaneous transition if the path is too short.\n      if (Math.abs(w0 - w1) < 0.000001) return this.easeTo(options, eventData);\n      const k = w1 < w0 ? -1 : 1;\n      S = Math.abs(Math.log(w1 / w0)) / rho;\n      u = () => 0;\n      w = s => Math.exp(k * rho * s);\n    }\n    if ('duration' in options) {\n      options.duration = +options.duration;\n    } else {\n      const V = 'screenSpeed' in options ? +options.screenSpeed / rho : +options.speed;\n      options.duration = 1000 * S / V;\n    }\n    if (options.maxDuration && options.duration > options.maxDuration) {\n      options.duration = 0;\n    }\n    this._zooming = true;\n    this._rotating = startBearing !== bearing;\n    this._pitching = pitch !== startPitch;\n    this._padding = !tr.isPaddingEqual(padding);\n    this._prepareEase(eventData, false);\n    this._ease(k => {\n      // s: The distance traveled along the flight path, measured in ρ-screenfuls.\n      const s = k * S;\n      const scale = 1 / w(s);\n      tr.zoom = k === 1 ? zoom : startZoom + tr.scaleZoom(scale);\n      if (this._rotating) {\n        tr.bearing = interpolates.number(startBearing, bearing, k);\n      }\n      if (this._pitching) {\n        tr.pitch = interpolates.number(startPitch, pitch, k);\n      }\n      if (this._padding) {\n        tr.interpolatePadding(startPadding, padding, k);\n        // When padding is being applied, Transform#centerPoint is changing continuously,\n        // thus we need to recalculate offsetPoint every frame\n        pointAtOffset = tr.centerPoint.add(offsetAsPoint);\n      }\n      const newCenter = k === 1 ? center : tr.unproject(from.add(delta.mult(u(s))).mult(scale));\n      tr.setLocationAtPoint(tr.renderWorldCopies ? newCenter.wrap() : newCenter, pointAtOffset);\n      this._applyUpdatedTransform(tr);\n      this._fireMoveEvents(eventData);\n    }, () => {\n      this._afterEase(eventData);\n    }, options);\n    return this;\n  }\n  isEasing() {\n    return !!this._easeFrameId;\n  }\n\n  /**\n   * Stops any animated transition underway.\n   */\n  stop() {\n    return this._stop();\n  }\n  _stop(allowGestures, easeId) {\n    if (this._easeFrameId) {\n      this._cancelRenderFrame(this._easeFrameId);\n      delete this._easeFrameId;\n      delete this._onEaseFrame;\n    }\n    if (this._onEaseEnd) {\n      // The _onEaseEnd function might emit events which trigger new\n      // animation, which sets a new _onEaseEnd. Ensure we don't delete\n      // it unintentionally.\n      const onEaseEnd = this._onEaseEnd;\n      delete this._onEaseEnd;\n      onEaseEnd.call(this, easeId);\n    }\n    if (!allowGestures) {\n      var _this$handlers;\n      (_this$handlers = this.handlers) === null || _this$handlers === void 0 || _this$handlers.stop(false);\n    }\n    return this;\n  }\n  _ease(frame, finish, options) {\n    if (options.animate === false || options.duration === 0) {\n      frame(1);\n      finish();\n    } else {\n      this._easeStart = browser.now();\n      this._easeOptions = options;\n      this._onEaseFrame = frame;\n      this._onEaseEnd = finish;\n      this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback);\n    }\n  }\n  // convert bearing so that it's numerically close to the current one so that it interpolates properly\n  _normalizeBearing(bearing, currentBearing) {\n    bearing = wrap(bearing, -180, 180);\n    const diff = Math.abs(bearing - currentBearing);\n    if (Math.abs(bearing - 360 - currentBearing) < diff) bearing -= 360;\n    if (Math.abs(bearing + 360 - currentBearing) < diff) bearing += 360;\n    return bearing;\n  }\n\n  // If a path crossing the antimeridian would be shorter, extend the final coordinate so that\n  // interpolating between the two endpoints will cross it.\n  _normalizeCenter(center) {\n    const tr = this.transform;\n    if (!tr.renderWorldCopies || tr.lngRange) return;\n    const delta = center.lng - tr.center.lng;\n    center.lng += delta > 180 ? -360 : delta < -180 ? 360 : 0;\n  }\n}","map":{"version":3,"names":["_defineProperty","Point","LngLat","LngLatBounds","MercatorCoordinate","browser","Event","Evented","clamp","defaultEasing","degreesToRadians","extend","interpolates","pick","warnOnce","wrap","Camera","constructor","transform","options","t","Math","min","now","_easeStart","_easeOptions","duration","_onEaseFrame","easing","_easeFrameId","_requestRenderFrame","_renderFrameCallback","stop","_moving","_zooming","_bearingSnap","bearingSnap","on","_requestedCameraState","getCenter","center","lng","lat","setCenter","eventData","jumpTo","panBy","offset","convert","mult","panTo","lnglat","easeTo","getZoom","zoom","setZoom","zoomTo","zoomIn","zoomOut","getBearing","bearing","setBearing","getPadding","padding","setPadding","rotateTo","resetNorth","resetNorthPitch","pitch","snapToNorth","abs","getPitch","setPitch","cameraForBounds","bounds","_cameraForBoxAndBearing","getNorthWest","getSouthEast","p0","p1","defaultPadding","top","bottom","right","left","maxZoom","p","tr","edgePadding","nwWorld","project","neWorld","getNorthEast","seWorld","swWorld","getSouthWest","bearingRadians","nwRotatedWorld","rotate","neRotatedWorld","seRotatedWorld","swRotatedWorld","upperRight","max","x","y","lowerLeft","size","sub","scaleX","width","scaleY","height","undefined","scaleZoom","scale","paddingOffsetX","paddingOffsetY","paddingOffset","rotatedPaddingOffset","offsetAtInitialZoom","add","offsetAtFinalZoom","zoomScale","unproject","div","fitBounds","_fitInternal","fitScreenCoordinates","pointLocation","calculatedOptions","linear","flyTo","_getTransformForUpdate","zoomChanged","bearingChanged","pitchChanged","isPaddingEqual","_applyUpdatedTransform","fire","calculateCameraOptionsFromTo","from","altitudeFrom","to","altitudeTo","fromMerc","fromLngLat","toMerc","dx","dy","dz","z","distance3D","hypot","Error","groundDistance","cameraToCenterDistance","tileSize","atan2","PI","acos","toLngLat","_options$zoom","_stop","easeId","animate","essential","prefersReducedMotion","startZoom","startBearing","startPitch","startPadding","_normalizeBearing","offsetAsPoint","pointAtOffset","centerPoint","locationAtOffset","getConstrained","_normalizeCenter","delta","finalScale","around","aroundPoint","locationPoint","currently","moving","zooming","rotating","_rotating","pitching","_pitching","_padding","_easeId","_prepareEase","noMoveStart","_ease","k","number","interpolatePadding","setLocationAtPoint","base","speedup","pow","newCenter","renderWorldCopies","_fireMoveEvents","interruptingEaseId","_afterEase","transformCameraUpdate","clone","nextTransform","elevation","apply","wasZooming","wasRotating","wasPitching","_options$zoom2","coercedOptions","speed","curve","rho","w0","w1","u1","mag","minZoom","wMax","sqrt","rho2","zoomOutFactor","descent","b","log","sinh","n","exp","cosh","tanh","r0","w","s","u","S","isFinite","V","screenSpeed","maxDuration","isEasing","allowGestures","_cancelRenderFrame","_onEaseEnd","onEaseEnd","call","_this$handlers","handlers","frame","finish","currentBearing","diff","lngRange"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/l7-map/es/map/camera.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport Point from '@mapbox/point-geometry';\nimport { LngLat } from \"./geo/lng_lat\";\nimport { LngLatBounds } from \"./geo/lng_lat_bounds\";\nimport { MercatorCoordinate } from \"./geo/mercator_coordinate\";\nimport { browser } from \"./util/browser\";\nimport { Event, Evented } from \"./util/evented\";\nimport { clamp, defaultEasing, degreesToRadians, extend, interpolates, pick, warnOnce, wrap } from \"./util/util\";\n\n/**\n * A [Point](https://github.com/mapbox/point-geometry) or an array of two numbers representing `x` and `y` screen coordinates in pixels.\n *\n * @group Geography and Geometry\n *\n * @example\n * ```ts\n * let p1 = new Point(-77, 38); // a PointLike which is a Point\n * let p2 = [-77, 38]; // a PointLike which is an array of two numbers\n * ```\n */\n\n/**\n * A helper to allow require of at least one property\n */\n\n/**\n * Options common to {@link Map#jumpTo}, {@link Map#easeTo}, and {@link Map#flyTo}, controlling the desired location,\n * zoom, bearing, and pitch of the camera. All properties are optional, and when a property is omitted, the current\n * camera value for that property will remain unchanged.\n *\n * @example\n * Set the map's initial perspective with CameraOptions\n * ```ts\n * let map = new Map({\n *   container: 'map',\n *   style: 'https://demotiles.maplibre.org/style.json',\n *   center: [-73.5804, 45.53483],\n *   pitch: 60,\n *   bearing: -60,\n *   zoom: 10\n * });\n * ```\n * @see [Set pitch and bearing](https://maplibre.org/maplibre-gl-js/docs/examples/set-perspective/)\n * @see [Jump to a series of locations](https://maplibre.org/maplibre-gl-js/docs/examples/jump-to/)\n * @see [Fly to a location](https://maplibre.org/maplibre-gl-js/docs/examples/flyto/)\n * @see [Display buildings in 3D](https://maplibre.org/maplibre-gl-js/docs/examples/3d-buildings/)\n */\n\n/**\n * Holds center, zoom and bearing properties\n */\n\n/**\n * The options object related to the {@link Map#jumpTo} method\n */\n\n/**\n * A options object for the {@link Map#cameraForBounds} method\n */\n\n/**\n * The {@link Map#flyTo} options object\n */\n\n/**\n * Options for {@link Map#fitBounds} method\n */\n\n/**\n * Options common to map movement methods that involve animation, such as {@link Map#panBy} and\n * {@link Map#easeTo}, controlling the duration and easing function of the animation. All properties\n * are optional.\n *\n */\n\n/**\n * A callback hook that allows manipulating the camera and being notified about camera updates before they happen\n */\n\nexport class Camera extends Evented {\n  constructor(transform, options) {\n    super();\n    _defineProperty(this, \"transform\", void 0);\n    _defineProperty(this, \"handlers\", void 0);\n    _defineProperty(this, \"_moving\", void 0);\n    _defineProperty(this, \"_zooming\", void 0);\n    _defineProperty(this, \"_rotating\", void 0);\n    _defineProperty(this, \"_pitching\", void 0);\n    _defineProperty(this, \"_padding\", void 0);\n    _defineProperty(this, \"_bearingSnap\", void 0);\n    _defineProperty(this, \"_easeStart\", void 0);\n    _defineProperty(this, \"_easeOptions\", void 0);\n    _defineProperty(this, \"_easeId\", void 0);\n    _defineProperty(this, \"_onEaseFrame\", void 0);\n    _defineProperty(this, \"_onEaseEnd\", void 0);\n    _defineProperty(this, \"_easeFrameId\", void 0);\n    /**\n     * @internal\n     * Used to track accumulated changes during continuous interaction\n     */\n    _defineProperty(this, \"_requestedCameraState\", void 0);\n    /**\n     * A callback used to defer camera updates or apply arbitrary constraints.\n     * If specified, this Camera instance can be used as a stateless component in React etc.\n     */\n    _defineProperty(this, \"transformCameraUpdate\", void 0);\n    // Callback for map._requestRenderFrame\n    _defineProperty(this, \"_renderFrameCallback\", () => {\n      const t = Math.min((browser.now() - this._easeStart) / this._easeOptions.duration, 1);\n      this._onEaseFrame(this._easeOptions.easing(t));\n\n      // if _stop is called during _onEaseFrame from _fireMoveEvents we should avoid a new _requestRenderFrame, checking it by ensuring _easeFrameId was not deleted\n      if (t < 1 && this._easeFrameId) {\n        this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback);\n      } else {\n        this.stop();\n      }\n    });\n    this._moving = false;\n    this._zooming = false;\n    this.transform = transform;\n    this._bearingSnap = options.bearingSnap;\n    this.on('moveend', () => {\n      delete this._requestedCameraState;\n    });\n  }\n\n  /**\n   * Returns the map's geographical centerpoint.\n   *\n   * @returns The map's geographical centerpoint.\n   * @example\n   * Return a LngLat object such as `{lng: 0, lat: 0}`\n   * ```ts\n   * let center = map.getCenter();\n   * // access longitude and latitude values directly\n   * let {lng, lat} = map.getCenter();\n   * ```\n   */\n  getCenter() {\n    return new LngLat(this.transform.center.lng, this.transform.center.lat);\n  }\n\n  /**\n   * Sets the map's geographical centerpoint. Equivalent to `jumpTo({center: center})`.\n   *\n   * Triggers the following events: `movestart` and `moveend`.\n   *\n   * @param center - The centerpoint to set.\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @example\n   * ```ts\n   * map.setCenter([-74, 38]);\n   * ```\n   */\n  setCenter(center, eventData) {\n    return this.jumpTo({\n      center\n    }, eventData);\n  }\n\n  /**\n   * Pans the map by the specified offset.\n   *\n   * Triggers the following events: `movestart` and `moveend`.\n   *\n   * @param offset - `x` and `y` coordinates by which to pan the map.\n   * @param options - Options object\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @see [Navigate the map with game-like controls](https://maplibre.org/maplibre-gl-js/docs/examples/game-controls/)\n   */\n  panBy(offset, options, eventData) {\n    offset = Point.convert(offset).mult(-1);\n    return this.panTo(this.transform.center, extend({\n      offset\n    }, options), eventData);\n  }\n\n  /**\n   * Pans the map to the specified location with an animated transition.\n   *\n   * Triggers the following events: `movestart` and `moveend`.\n   *\n   * @param lnglat - The location to pan the map to.\n   * @param options - Options describing the destination and animation of the transition.\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @example\n   * ```ts\n   * map.panTo([-74, 38]);\n   * // Specify that the panTo animation should last 5000 milliseconds.\n   * map.panTo([-74, 38], {duration: 5000});\n   * ```\n   * @see [Update a feature in realtime](https://maplibre.org/maplibre-gl-js/docs/examples/live-update-feature/)\n   */\n  panTo(lnglat, options, eventData) {\n    return this.easeTo(extend({\n      center: lnglat\n    }, options), eventData);\n  }\n\n  /**\n   * Returns the map's current zoom level.\n   *\n   * @returns The map's current zoom level.\n   * @example\n   * ```ts\n   * map.getZoom();\n   * ```\n   */\n  getZoom() {\n    return this.transform.zoom;\n  }\n\n  /**\n   * Sets the map's zoom level. Equivalent to `jumpTo({zoom: zoom})`.\n   *\n   * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, and `zoomend`.\n   *\n   * @param zoom - The zoom level to set (0-20).\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @example\n   * Zoom to the zoom level 5 without an animated transition\n   * ```ts\n   * map.setZoom(5);\n   * ```\n   */\n  setZoom(zoom, eventData) {\n    this.jumpTo({\n      zoom\n    }, eventData);\n    return this;\n  }\n\n  /**\n   * Zooms the map to the specified zoom level, with an animated transition.\n   *\n   * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, and `zoomend`.\n   *\n   * @param zoom - The zoom level to transition to.\n   * @param options - Options object\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @example\n   * ```ts\n   * // Zoom to the zoom level 5 without an animated transition\n   * map.zoomTo(5);\n   * // Zoom to the zoom level 8 with an animated transition\n   * map.zoomTo(8, {\n   *   duration: 2000,\n   *   offset: [100, 50]\n   * });\n   * ```\n   */\n  zoomTo(zoom, options, eventData) {\n    return this.easeTo(extend({\n      zoom\n    }, options), eventData);\n  }\n\n  /**\n   * Increases the map's zoom level by 1.\n   *\n   * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, and `zoomend`.\n   *\n   * @param options - Options object\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @example\n   * Zoom the map in one level with a custom animation duration\n   * ```ts\n   * map.zoomIn({duration: 1000});\n   * ```\n   */\n  zoomIn(options, eventData) {\n    this.zoomTo(this.getZoom() + 1, options, eventData);\n    return this;\n  }\n\n  /**\n   * Decreases the map's zoom level by 1.\n   *\n   * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, and `zoomend`.\n   *\n   * @param options - Options object\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @example\n   * Zoom the map out one level with a custom animation offset\n   * ```ts\n   * map.zoomOut({offset: [80, 60]});\n   * ```\n   */\n  zoomOut(options, eventData) {\n    this.zoomTo(this.getZoom() - 1, options, eventData);\n    return this;\n  }\n\n  /**\n   * Returns the map's current bearing. The bearing is the compass direction that is \"up\"; for example, a bearing\n   * of 90° orients the map so that east is up.\n   *\n   * @returns The map's current bearing.\n   * @see [Navigate the map with game-like controls](https://maplibre.org/maplibre-gl-js/docs/examples/game-controls/)\n   */\n  getBearing() {\n    return this.transform.bearing;\n  }\n\n  /**\n   * Sets the map's bearing (rotation). The bearing is the compass direction that is \"up\"; for example, a bearing\n   * of 90° orients the map so that east is up.\n   *\n   * Equivalent to `jumpTo({bearing: bearing})`.\n   *\n   * Triggers the following events: `movestart`, `moveend`, and `rotate`.\n   *\n   * @param bearing - The desired bearing.\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @example\n   * Rotate the map to 90 degrees\n   * ```ts\n   * map.setBearing(90);\n   * ```\n   */\n  setBearing(bearing, eventData) {\n    this.jumpTo({\n      bearing\n    }, eventData);\n    return this;\n  }\n\n  /**\n   * Returns the current padding applied around the map viewport.\n   *\n   * @returns The current padding around the map viewport.\n   */\n  getPadding() {\n    return this.transform.padding;\n  }\n\n  /**\n   * Sets the padding in pixels around the viewport.\n   *\n   * Equivalent to `jumpTo({padding: padding})`.\n   *\n   * Triggers the following events: `movestart` and `moveend`.\n   *\n   * @param padding - The desired padding.\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @example\n   * Sets a left padding of 300px, and a top padding of 50px\n   * ```ts\n   * map.setPadding({ left: 300, top: 50 });\n   * ```\n   */\n  setPadding(padding, eventData) {\n    this.jumpTo({\n      padding\n    }, eventData);\n    return this;\n  }\n\n  /**\n   * Rotates the map to the specified bearing, with an animated transition. The bearing is the compass direction\n   * that is \"up\"; for example, a bearing of 90° orients the map so that east is up.\n   *\n   * Triggers the following events: `movestart`, `moveend`, and `rotate`.\n   *\n   * @param bearing - The desired bearing.\n   * @param options - Options object\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   */\n  rotateTo(bearing, options, eventData) {\n    return this.easeTo(extend({\n      bearing\n    }, options), eventData);\n  }\n\n  /**\n   * Rotates the map so that north is up (0° bearing), with an animated transition.\n   *\n   * Triggers the following events: `movestart`, `moveend`, and `rotate`.\n   *\n   * @param options - Options object\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   */\n  resetNorth(options, eventData) {\n    this.rotateTo(0, extend({\n      duration: 1000\n    }, options), eventData);\n    return this;\n  }\n\n  /**\n   * Rotates and pitches the map so that north is up (0° bearing) and pitch is 0°, with an animated transition.\n   *\n   * Triggers the following events: `movestart`, `move`, `moveend`, `pitchstart`, `pitch`, `pitchend`, and `rotate`.\n   *\n   * @param options - Options object\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   */\n  resetNorthPitch(options, eventData) {\n    this.easeTo(extend({\n      bearing: 0,\n      pitch: 0,\n      duration: 1000\n    }, options), eventData);\n    return this;\n  }\n\n  /**\n   * Snaps the map so that north is up (0° bearing), if the current bearing is close enough to it (i.e. within the\n   * `bearingSnap` threshold).\n   *\n   * Triggers the following events: `movestart`, `moveend`, and `rotate`.\n   *\n   * @param options - Options object\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   */\n  snapToNorth(options, eventData) {\n    if (Math.abs(this.getBearing()) < this._bearingSnap) {\n      return this.resetNorth(options, eventData);\n    }\n    return this;\n  }\n\n  /**\n   * Returns the map's current pitch (tilt).\n   *\n   * @returns The map's current pitch, measured in degrees away from the plane of the screen.\n   */\n  getPitch() {\n    return this.transform.pitch;\n  }\n\n  /**\n   * Sets the map's pitch (tilt). Equivalent to `jumpTo({pitch: pitch})`.\n   *\n   * Triggers the following events: `movestart`, `moveend`, `pitchstart`, and `pitchend`.\n   *\n   * @param pitch - The pitch to set, measured in degrees away from the plane of the screen (0-60).\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   */\n  setPitch(pitch, eventData) {\n    this.jumpTo({\n      pitch\n    }, eventData);\n    return this;\n  }\n\n  /**\n   * @param bounds - Calculate the center for these bounds in the viewport and use\n   * the highest zoom level up to and including `Map#getMaxZoom()` that fits\n   * in the viewport. LngLatBounds represent a box that is always axis-aligned with bearing 0.\n   * @param options - Options object\n   * @returns If map is able to fit to provided bounds, returns `center`, `zoom`, and `bearing`.\n   * If map is unable to fit, method will warn and return undefined.\n   * @example\n   * ```ts\n   * let bbox = [[-79, 43], [-73, 45]];\n   * let newCameraTransform = map.cameraForBounds(bbox, {\n   *   padding: {top: 10, bottom:25, left: 15, right: 5}\n   * });\n   * ```\n   */\n  cameraForBounds(bounds, options) {\n    bounds = LngLatBounds.convert(bounds);\n    const bearing = options && options.bearing || 0;\n    return this._cameraForBoxAndBearing(bounds.getNorthWest(), bounds.getSouthEast(), bearing, options);\n  }\n\n  /**\n   * @internal\n   * Calculate the center of these two points in the viewport and use\n   * the highest zoom level up to and including `Map#getMaxZoom()` that fits\n   * the points in the viewport at the specified bearing.\n   * @param p0 - First point\n   * @param p1 - Second point\n   * @param bearing - Desired map bearing at end of animation, in degrees\n   * @param options - the camera options\n   * @returns If map is able to fit to provided bounds, returns `center`, `zoom`, and `bearing`.\n   *      If map is unable to fit, method will warn and return undefined.\n   * @example\n   * ```ts\n   * let p0 = [-79, 43];\n   * let p1 = [-73, 45];\n   * let bearing = 90;\n   * let newCameraTransform = map._cameraForBoxAndBearing(p0, p1, bearing, {\n   *   padding: {top: 10, bottom:25, left: 15, right: 5}\n   * });\n   * ```\n   */\n  _cameraForBoxAndBearing(p0, p1, bearing, options) {\n    const defaultPadding = {\n      top: 0,\n      bottom: 0,\n      right: 0,\n      left: 0\n    };\n    options = extend({\n      padding: defaultPadding,\n      offset: [0, 0],\n      maxZoom: this.transform.maxZoom\n    }, options);\n    if (typeof options.padding === 'number') {\n      const p = options.padding;\n      options.padding = {\n        top: p,\n        bottom: p,\n        right: p,\n        left: p\n      };\n    }\n    options.padding = extend(defaultPadding, options.padding);\n    const tr = this.transform;\n    const edgePadding = tr.padding;\n\n    // Consider all corners of the rotated bounding box derived from the given points\n    // when find the camera position that fits the given points.\n    const bounds = new LngLatBounds(p0, p1);\n    const nwWorld = tr.project(bounds.getNorthWest());\n    const neWorld = tr.project(bounds.getNorthEast());\n    const seWorld = tr.project(bounds.getSouthEast());\n    const swWorld = tr.project(bounds.getSouthWest());\n    const bearingRadians = degreesToRadians(-bearing);\n    const nwRotatedWorld = nwWorld.rotate(bearingRadians);\n    const neRotatedWorld = neWorld.rotate(bearingRadians);\n    const seRotatedWorld = seWorld.rotate(bearingRadians);\n    const swRotatedWorld = swWorld.rotate(bearingRadians);\n    const upperRight = new Point(Math.max(nwRotatedWorld.x, neRotatedWorld.x, swRotatedWorld.x, seRotatedWorld.x), Math.max(nwRotatedWorld.y, neRotatedWorld.y, swRotatedWorld.y, seRotatedWorld.y));\n    const lowerLeft = new Point(Math.min(nwRotatedWorld.x, neRotatedWorld.x, swRotatedWorld.x, seRotatedWorld.x), Math.min(nwRotatedWorld.y, neRotatedWorld.y, swRotatedWorld.y, seRotatedWorld.y));\n\n    // Calculate zoom: consider the original bbox and padding.\n    const size = upperRight.sub(lowerLeft);\n    const scaleX = (tr.width - (edgePadding.left + edgePadding.right + options.padding.left + options.padding.right)) / size.x;\n    const scaleY = (tr.height - (edgePadding.top + edgePadding.bottom + options.padding.top + options.padding.bottom)) / size.y;\n    if (scaleY < 0 || scaleX < 0) {\n      warnOnce('Map cannot fit within canvas with the given bounds, padding, and/or offset.');\n      return undefined;\n    }\n    const zoom = Math.min(tr.scaleZoom(tr.scale * Math.min(scaleX, scaleY)), options.maxZoom);\n\n    // Calculate center: apply the zoom, the configured offset, as well as offset that exists as a result of padding.\n    const offset = Point.convert(options.offset);\n    const paddingOffsetX = (options.padding.left - options.padding.right) / 2;\n    const paddingOffsetY = (options.padding.top - options.padding.bottom) / 2;\n    const paddingOffset = new Point(paddingOffsetX, paddingOffsetY);\n    const rotatedPaddingOffset = paddingOffset.rotate(degreesToRadians(bearing));\n    const offsetAtInitialZoom = offset.add(rotatedPaddingOffset);\n    const offsetAtFinalZoom = offsetAtInitialZoom.mult(tr.scale / tr.zoomScale(zoom));\n    const center = tr.unproject(\n    // either world diagonal can be used (NW-SE or NE-SW)\n    nwWorld.add(seWorld).div(2).sub(offsetAtFinalZoom));\n    return {\n      center,\n      zoom,\n      bearing\n    };\n  }\n\n  /**\n   * Pans and zooms the map to contain its visible area within the specified geographical bounds.\n   * This function will also reset the map's bearing to 0 if bearing is nonzero.\n   *\n   * Triggers the following events: `movestart` and `moveend`.\n   *\n   * @param bounds - Center these bounds in the viewport and use the highest\n   * zoom level up to and including `Map#getMaxZoom()` that fits them in the viewport.\n   * @param options - Options supports all properties from {@link AnimationOptions} and {@link CameraOptions} in addition to the fields below.\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @example\n   * ```ts\n   * let bbox = [[-79, 43], [-73, 45]];\n   * map.fitBounds(bbox, {\n   *   padding: {top: 10, bottom:25, left: 15, right: 5}\n   * });\n   * ```\n   * @see [Fit a map to a bounding box](https://maplibre.org/maplibre-gl-js/docs/examples/fitbounds/)\n   */\n  fitBounds(bounds, options, eventData) {\n    return this._fitInternal(this.cameraForBounds(bounds, options), options, eventData);\n  }\n\n  /**\n   * Pans, rotates and zooms the map to to fit the box made by points p0 and p1\n   * once the map is rotated to the specified bearing. To zoom without rotating,\n   * pass in the current map bearing.\n   *\n   * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, `zoomend` and `rotate`.\n   *\n   * @param p0 - First point on screen, in pixel coordinates\n   * @param p1 - Second point on screen, in pixel coordinates\n   * @param bearing - Desired map bearing at end of animation, in degrees\n   * @param options - Options object\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @example\n   * ```ts\n   * let p0 = [220, 400];\n   * let p1 = [500, 900];\n   * map.fitScreenCoordinates(p0, p1, map.getBearing(), {\n   *   padding: {top: 10, bottom:25, left: 15, right: 5}\n   * });\n   * ```\n   * @see Used by {@link BoxZoomHandler}\n   */\n  fitScreenCoordinates(p0, p1, bearing, options, eventData) {\n    return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(Point.convert(p0)), this.transform.pointLocation(Point.convert(p1)), bearing, options), options, eventData);\n  }\n  _fitInternal(calculatedOptions, options, eventData) {\n    // cameraForBounds warns + returns undefined if unable to fit:\n    if (!calculatedOptions) return this;\n    options = extend(calculatedOptions, options);\n    // Explicitly remove the padding field because, calculatedOptions already accounts for padding by setting zoom and center accordingly.\n    delete options.padding;\n    return options.linear ? this.easeTo(options, eventData) : this.flyTo(options, eventData);\n  }\n\n  /**\n   * Changes any combination of center, zoom, bearing, and pitch, without\n   * an animated transition. The map will retain its current values for any\n   * details not specified in `options`.\n   *\n   * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, `zoomend`, `pitchstart`,\n   * `pitch`, `pitchend`, and `rotate`.\n   *\n   * @param options - Options object\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @example\n   * ```ts\n   * // jump to coordinates at current zoom\n   * map.jumpTo({center: [0, 0]});\n   * // jump with zoom, pitch, and bearing options\n   * map.jumpTo({\n   *   center: [0, 0],\n   *   zoom: 8,\n   *   pitch: 45,\n   *   bearing: 90\n   * });\n   * ```\n   * @see [Jump to a series of locations](https://maplibre.org/maplibre-gl-js/docs/examples/jump-to/)\n   * @see [Update a feature in realtime](https://maplibre.org/maplibre-gl-js/docs/examples/live-update-feature/)\n   */\n  jumpTo(options, eventData) {\n    this.stop();\n    const tr = this._getTransformForUpdate();\n    let zoomChanged = false,\n      bearingChanged = false,\n      pitchChanged = false;\n    if ('zoom' in options && tr.zoom !== +options.zoom) {\n      zoomChanged = true;\n      tr.zoom = +options.zoom;\n    }\n    if (options.center !== undefined) {\n      tr.center = LngLat.convert(options.center);\n    }\n    if ('bearing' in options && tr.bearing !== +options.bearing) {\n      bearingChanged = true;\n      tr.bearing = +options.bearing;\n    }\n    if ('pitch' in options && tr.pitch !== +options.pitch) {\n      pitchChanged = true;\n      tr.pitch = +options.pitch;\n    }\n    if (options.padding != null && !tr.isPaddingEqual(options.padding)) {\n      tr.padding = options.padding;\n    }\n    this._applyUpdatedTransform(tr);\n    this.fire(new Event('movestart', eventData)).fire(new Event('move', eventData));\n    if (zoomChanged) {\n      this.fire(new Event('zoomstart', eventData)).fire(new Event('zoom', eventData)).fire(new Event('zoomend', eventData));\n    }\n    if (bearingChanged) {\n      this.fire(new Event('rotatestart', eventData)).fire(new Event('rotate', eventData)).fire(new Event('rotateend', eventData));\n    }\n    if (pitchChanged) {\n      this.fire(new Event('pitchstart', eventData)).fire(new Event('pitch', eventData)).fire(new Event('pitchend', eventData));\n    }\n    return this.fire(new Event('moveend', eventData));\n  }\n\n  /**\n   * Calculates pitch, zoom and bearing for looking at `newCenter` with the camera position being `newCenter`\n   * and returns them as {@link CameraOptions}.\n   * @param from - The camera to look from\n   * @param altitudeFrom - The altitude of the camera to look from\n   * @param to - The center to look at\n   * @param altitudeTo - Optional altitude of the center to look at. If none given the ground height will be used.\n   * @returns the calculated camera options\n   */\n  calculateCameraOptionsFromTo(from, altitudeFrom, to, altitudeTo = 0) {\n    const fromMerc = MercatorCoordinate.fromLngLat(from, altitudeFrom);\n    const toMerc = MercatorCoordinate.fromLngLat(to, altitudeTo);\n    const dx = toMerc.x - fromMerc.x;\n    const dy = toMerc.y - fromMerc.y;\n    const dz = toMerc.z - fromMerc.z;\n    const distance3D = Math.hypot(dx, dy, dz);\n    if (distance3D === 0) throw new Error(\"Can't calculate camera options with same From and To\");\n    const groundDistance = Math.hypot(dx, dy);\n    const zoom = this.transform.scaleZoom(this.transform.cameraToCenterDistance / distance3D / this.transform.tileSize);\n    const bearing = Math.atan2(dx, -dy) * 180 / Math.PI;\n    let pitch = Math.acos(groundDistance / distance3D) * 180 / Math.PI;\n    pitch = dz < 0 ? 90 - pitch : 90 + pitch;\n    return {\n      center: toMerc.toLngLat(),\n      zoom,\n      pitch,\n      bearing\n    };\n  }\n\n  /**\n   * Changes any combination of `center`, `zoom`, `bearing`, `pitch`, and `padding` with an animated transition\n   * between old and new values. The map will retain its current values for any\n   * details not specified in `options`.\n   *\n   * Note: The transition will happen instantly if the user has enabled\n   * the `reduced motion` accessibility feature enabled in their operating system,\n   * unless `options` includes `essential: true`.\n   *\n   * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, `zoomend`, `pitchstart`,\n   * `pitch`, `pitchend`, and `rotate`.\n   *\n   * @param options - Options describing the destination and animation of the transition.\n   * Accepts {@link CameraOptions} and {@link AnimationOptions}.\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @see [Navigate the map with game-like controls](https://maplibre.org/maplibre-gl-js/docs/examples/game-controls/)\n   */\n  easeTo(options, eventData) {\n    var _options$zoom;\n    this._stop(false, options.easeId);\n    options = extend({\n      offset: [0, 0],\n      duration: 500,\n      easing: defaultEasing\n    }, options);\n    if (options.animate === false || !options.essential && browser.prefersReducedMotion) options.duration = 0;\n    const tr = this._getTransformForUpdate(),\n      startZoom = this.getZoom(),\n      startBearing = this.getBearing(),\n      startPitch = this.getPitch(),\n      startPadding = this.getPadding(),\n      bearing = 'bearing' in options ? this._normalizeBearing(options.bearing, startBearing) : startBearing,\n      pitch = 'pitch' in options ? +options.pitch : startPitch,\n      padding = 'padding' in options ? options.padding : tr.padding;\n    const offsetAsPoint = Point.convert(options.offset);\n    let pointAtOffset = tr.centerPoint.add(offsetAsPoint);\n    const locationAtOffset = tr.pointLocation(pointAtOffset);\n    const {\n      center,\n      zoom\n    } = tr.getConstrained(LngLat.convert(options.center || locationAtOffset), (_options$zoom = options.zoom) !== null && _options$zoom !== void 0 ? _options$zoom : startZoom);\n    this._normalizeCenter(center);\n    const from = tr.project(locationAtOffset);\n    const delta = tr.project(center).sub(from);\n    const finalScale = tr.zoomScale(zoom - startZoom);\n    let around, aroundPoint;\n    if (options.around) {\n      around = LngLat.convert(options.around);\n      aroundPoint = tr.locationPoint(around);\n    }\n    const currently = {\n      moving: this._moving,\n      zooming: this._zooming,\n      rotating: this._rotating,\n      pitching: this._pitching\n    };\n    this._zooming = this._zooming || zoom !== startZoom;\n    this._rotating = this._rotating || startBearing !== bearing;\n    this._pitching = this._pitching || pitch !== startPitch;\n    this._padding = !tr.isPaddingEqual(padding);\n    this._easeId = options.easeId;\n    this._prepareEase(eventData, options.noMoveStart, currently);\n    this._ease(k => {\n      if (this._zooming) {\n        tr.zoom = interpolates.number(startZoom, zoom, k);\n      }\n      if (this._rotating) {\n        tr.bearing = interpolates.number(startBearing, bearing, k);\n      }\n      if (this._pitching) {\n        tr.pitch = interpolates.number(startPitch, pitch, k);\n      }\n      if (this._padding) {\n        tr.interpolatePadding(startPadding, padding, k);\n        // When padding is being applied, Transform#centerPoint is changing continuously,\n        // thus we need to recalculate offsetPoint every frame\n        pointAtOffset = tr.centerPoint.add(offsetAsPoint);\n      }\n      if (around) {\n        tr.setLocationAtPoint(around, aroundPoint);\n      } else {\n        const scale = tr.zoomScale(tr.zoom - startZoom);\n        const base = zoom > startZoom ? Math.min(2, finalScale) : Math.max(0.5, finalScale);\n        const speedup = Math.pow(base, 1 - k);\n        const newCenter = tr.unproject(from.add(delta.mult(k * speedup)).mult(scale));\n        tr.setLocationAtPoint(tr.renderWorldCopies ? newCenter.wrap() : newCenter, pointAtOffset);\n      }\n      this._applyUpdatedTransform(tr);\n      this._fireMoveEvents(eventData);\n    }, interruptingEaseId => {\n      this._afterEase(eventData, interruptingEaseId);\n    }, options);\n    return this;\n  }\n  _prepareEase(eventData, noMoveStart, currently = {}) {\n    this._moving = true;\n    if (!noMoveStart && !currently.moving) {\n      this.fire(new Event('movestart', eventData));\n    }\n    if (this._zooming && !currently.zooming) {\n      this.fire(new Event('zoomstart', eventData));\n    }\n    if (this._rotating && !currently.rotating) {\n      this.fire(new Event('rotatestart', eventData));\n    }\n    if (this._pitching && !currently.pitching) {\n      this.fire(new Event('pitchstart', eventData));\n    }\n  }\n\n  /**\n   * @internal\n   * Called when the camera is about to be manipulated.\n   * If `transformCameraUpdate` is specified, a copy of the current transform is created to track the accumulated changes.\n   * This underlying transform represents the \"desired state\" proposed by input handlers / animations / UI controls.\n   * It may differ from the state used for rendering (`this.transform`).\n   * @returns Transform to apply changes to\n   */\n  _getTransformForUpdate() {\n    if (!this.transformCameraUpdate) return this.transform;\n    if (!this._requestedCameraState) {\n      this._requestedCameraState = this.transform.clone();\n    }\n    return this._requestedCameraState;\n  }\n\n  /**\n   * @internal\n   * Called after the camera is done being manipulated.\n   * @param tr - the requested camera end state\n   * Call `transformCameraUpdate` if present, and then apply the \"approved\" changes.\n   */\n  _applyUpdatedTransform(tr) {\n    if (!this.transformCameraUpdate) return;\n    const nextTransform = tr.clone();\n    const {\n      center,\n      zoom,\n      pitch,\n      bearing,\n      elevation\n    } = this.transformCameraUpdate(nextTransform);\n    if (center) nextTransform.center = center;\n    if (zoom !== undefined) nextTransform.zoom = zoom;\n    if (pitch !== undefined) nextTransform.pitch = pitch;\n    if (bearing !== undefined) nextTransform.bearing = bearing;\n    if (elevation !== undefined) nextTransform.elevation = elevation;\n    this.transform.apply(nextTransform);\n  }\n  _fireMoveEvents(eventData) {\n    this.fire(new Event('move', eventData));\n    if (this._zooming) {\n      this.fire(new Event('zoom', eventData));\n    }\n    if (this._rotating) {\n      this.fire(new Event('rotate', eventData));\n    }\n    if (this._pitching) {\n      this.fire(new Event('pitch', eventData));\n    }\n  }\n  _afterEase(eventData, easeId) {\n    // if this easing is being stopped to start another easing with\n    // the same id then don't fire any events to avoid extra start/stop events\n    if (this._easeId && easeId && this._easeId === easeId) {\n      return;\n    }\n    delete this._easeId;\n    const wasZooming = this._zooming;\n    const wasRotating = this._rotating;\n    const wasPitching = this._pitching;\n    this._moving = false;\n    this._zooming = false;\n    this._rotating = false;\n    this._pitching = false;\n    this._padding = false;\n    if (wasZooming) {\n      this.fire(new Event('zoomend', eventData));\n    }\n    if (wasRotating) {\n      this.fire(new Event('rotateend', eventData));\n    }\n    if (wasPitching) {\n      this.fire(new Event('pitchend', eventData));\n    }\n    this.fire(new Event('moveend', eventData));\n  }\n\n  /**\n   * Changes any combination of center, zoom, bearing, and pitch, animating the transition along a curve that\n   * evokes flight. The animation seamlessly incorporates zooming and panning to help\n   * the user maintain her bearings even after traversing a great distance.\n   *\n   * Note: The animation will be skipped, and this will behave equivalently to `jumpTo`\n   * if the user has the `reduced motion` accessibility feature enabled in their operating system,\n   * unless 'options' includes `essential: true`.\n   *\n   * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, `zoomend`, `pitchstart`,\n   * `pitch`, `pitchend`, and `rotate`.\n   *\n   * @param options - Options describing the destination and animation of the transition.\n   * Accepts {@link CameraOptions}, {@link AnimationOptions},\n   * and the following additional options.\n   * @param eventData - Additional properties to be added to event objects of events triggered by this method.\n   * @example\n   * ```ts\n   * // fly with default options to null island\n   * map.flyTo({center: [0, 0], zoom: 9});\n   * // using flyTo options\n   * map.flyTo({\n   *   center: [0, 0],\n   *   zoom: 9,\n   *   speed: 0.2,\n   *   curve: 1,\n   *   easing(t) {\n   *     return t;\n   *   }\n   * });\n   * ```\n   * @see [Fly to a location](https://maplibre.org/maplibre-gl-js/docs/examples/flyto/)\n   * @see [Slowly fly to a location](https://maplibre.org/maplibre-gl-js/docs/examples/flyto-options/)\n   * @see [Fly to a location based on scroll position](https://maplibre.org/maplibre-gl-js/docs/examples/scroll-fly-to/)\n   */\n  flyTo(options, eventData) {\n    var _options$zoom2;\n    // Fall through to jumpTo if user has set prefers-reduced-motion\n    if (!options.essential && browser.prefersReducedMotion) {\n      const coercedOptions = pick(options, ['center', 'zoom', 'bearing', 'pitch', 'around']);\n      return this.jumpTo(coercedOptions, eventData);\n    }\n\n    // This method implements an “optimal path” animation, as detailed in:\n    //\n    // Van Wijk, Jarke J.; Nuij, Wim A. A. “Smooth and efficient zooming and panning.” INFOVIS\n    //   ’03. pp. 15–22. <https://www.win.tue.nl/~vanwijk/zoompan.pdf#page=5>.\n    //\n    // Where applicable, local variable documentation begins with the associated variable or\n    // function in van Wijk (2003).\n\n    this.stop();\n    options = extend({\n      offset: [0, 0],\n      speed: 1.2,\n      curve: 1.42,\n      easing: defaultEasing\n    }, options);\n    const tr = this._getTransformForUpdate(),\n      startZoom = this.getZoom(),\n      startBearing = this.getBearing(),\n      startPitch = this.getPitch(),\n      startPadding = this.getPadding();\n    const bearing = 'bearing' in options ? this._normalizeBearing(options.bearing, startBearing) : startBearing;\n    const pitch = 'pitch' in options ? +options.pitch : startPitch;\n    const padding = 'padding' in options ? options.padding : tr.padding;\n    const offsetAsPoint = Point.convert(options.offset);\n    let pointAtOffset = tr.centerPoint.add(offsetAsPoint);\n    const locationAtOffset = tr.pointLocation(pointAtOffset);\n    const {\n      center,\n      zoom\n    } = tr.getConstrained(LngLat.convert(options.center || locationAtOffset), (_options$zoom2 = options.zoom) !== null && _options$zoom2 !== void 0 ? _options$zoom2 : startZoom);\n    this._normalizeCenter(center);\n    const scale = tr.zoomScale(zoom - startZoom);\n    const from = tr.project(locationAtOffset);\n    const delta = tr.project(center).sub(from);\n    let rho = options.curve;\n\n    // w₀: Initial visible span, measured in pixels at the initial scale.\n    const w0 = Math.max(tr.width, tr.height),\n      // w₁: Final visible span, measured in pixels with respect to the initial scale.\n      w1 = w0 / scale,\n      // Length of the flight path as projected onto the ground plane, measured in pixels from\n      // the world image origin at the initial scale.\n      u1 = delta.mag();\n    if ('minZoom' in options) {\n      const minZoom = clamp(Math.min(options.minZoom, startZoom, zoom), tr.minZoom, tr.maxZoom);\n      // w<sub>m</sub>: Maximum visible span, measured in pixels with respect to the initial\n      // scale.\n      const wMax = w0 / tr.zoomScale(minZoom - startZoom);\n      rho = Math.sqrt(wMax / u1 * 2);\n    }\n\n    // ρ²\n    const rho2 = rho * rho;\n\n    /**\n     * rᵢ: Returns the zoom-out factor at one end of the animation.\n     *\n     * @param descent - `true` for the descent, `false` for the ascent\n     */\n    function zoomOutFactor(descent) {\n      const b = (w1 * w1 - w0 * w0 + (descent ? -1 : 1) * rho2 * rho2 * u1 * u1) / (2 * (descent ? w1 : w0) * rho2 * u1);\n      return Math.log(Math.sqrt(b * b + 1) - b);\n    }\n    function sinh(n) {\n      return (Math.exp(n) - Math.exp(-n)) / 2;\n    }\n    function cosh(n) {\n      return (Math.exp(n) + Math.exp(-n)) / 2;\n    }\n    function tanh(n) {\n      return sinh(n) / cosh(n);\n    }\n\n    // r₀: Zoom-out factor during ascent.\n    const r0 = zoomOutFactor(false);\n\n    // w(s): Returns the visible span on the ground, measured in pixels with respect to the\n    // initial scale. Assumes an angular field of view of 2 arctan ½ ≈ 53°.\n    let w = function (s) {\n      return cosh(r0) / cosh(r0 + rho * s);\n    };\n\n    // u(s): Returns the distance along the flight path as projected onto the ground plane,\n    // measured in pixels from the world image origin at the initial scale.\n    let u = function (s) {\n      return w0 * ((cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2) / u1;\n    };\n\n    // S: Total length of the flight path, measured in ρ-screenfuls.\n    let S = (zoomOutFactor(true) - r0) / rho;\n\n    // When u₀ = u₁, the optimal path doesn’t require both ascent and descent.\n    if (Math.abs(u1) < 0.000001 || !isFinite(S)) {\n      // Perform a more or less instantaneous transition if the path is too short.\n      if (Math.abs(w0 - w1) < 0.000001) return this.easeTo(options, eventData);\n      const k = w1 < w0 ? -1 : 1;\n      S = Math.abs(Math.log(w1 / w0)) / rho;\n      u = () => 0;\n      w = s => Math.exp(k * rho * s);\n    }\n    if ('duration' in options) {\n      options.duration = +options.duration;\n    } else {\n      const V = 'screenSpeed' in options ? +options.screenSpeed / rho : +options.speed;\n      options.duration = 1000 * S / V;\n    }\n    if (options.maxDuration && options.duration > options.maxDuration) {\n      options.duration = 0;\n    }\n    this._zooming = true;\n    this._rotating = startBearing !== bearing;\n    this._pitching = pitch !== startPitch;\n    this._padding = !tr.isPaddingEqual(padding);\n    this._prepareEase(eventData, false);\n    this._ease(k => {\n      // s: The distance traveled along the flight path, measured in ρ-screenfuls.\n      const s = k * S;\n      const scale = 1 / w(s);\n      tr.zoom = k === 1 ? zoom : startZoom + tr.scaleZoom(scale);\n      if (this._rotating) {\n        tr.bearing = interpolates.number(startBearing, bearing, k);\n      }\n      if (this._pitching) {\n        tr.pitch = interpolates.number(startPitch, pitch, k);\n      }\n      if (this._padding) {\n        tr.interpolatePadding(startPadding, padding, k);\n        // When padding is being applied, Transform#centerPoint is changing continuously,\n        // thus we need to recalculate offsetPoint every frame\n        pointAtOffset = tr.centerPoint.add(offsetAsPoint);\n      }\n      const newCenter = k === 1 ? center : tr.unproject(from.add(delta.mult(u(s))).mult(scale));\n      tr.setLocationAtPoint(tr.renderWorldCopies ? newCenter.wrap() : newCenter, pointAtOffset);\n      this._applyUpdatedTransform(tr);\n      this._fireMoveEvents(eventData);\n    }, () => {\n      this._afterEase(eventData);\n    }, options);\n    return this;\n  }\n  isEasing() {\n    return !!this._easeFrameId;\n  }\n\n  /**\n   * Stops any animated transition underway.\n   */\n  stop() {\n    return this._stop();\n  }\n  _stop(allowGestures, easeId) {\n    if (this._easeFrameId) {\n      this._cancelRenderFrame(this._easeFrameId);\n      delete this._easeFrameId;\n      delete this._onEaseFrame;\n    }\n    if (this._onEaseEnd) {\n      // The _onEaseEnd function might emit events which trigger new\n      // animation, which sets a new _onEaseEnd. Ensure we don't delete\n      // it unintentionally.\n      const onEaseEnd = this._onEaseEnd;\n      delete this._onEaseEnd;\n      onEaseEnd.call(this, easeId);\n    }\n    if (!allowGestures) {\n      var _this$handlers;\n      (_this$handlers = this.handlers) === null || _this$handlers === void 0 || _this$handlers.stop(false);\n    }\n    return this;\n  }\n  _ease(frame, finish, options) {\n    if (options.animate === false || options.duration === 0) {\n      frame(1);\n      finish();\n    } else {\n      this._easeStart = browser.now();\n      this._easeOptions = options;\n      this._onEaseFrame = frame;\n      this._onEaseEnd = finish;\n      this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback);\n    }\n  }\n  // convert bearing so that it's numerically close to the current one so that it interpolates properly\n  _normalizeBearing(bearing, currentBearing) {\n    bearing = wrap(bearing, -180, 180);\n    const diff = Math.abs(bearing - currentBearing);\n    if (Math.abs(bearing - 360 - currentBearing) < diff) bearing -= 360;\n    if (Math.abs(bearing + 360 - currentBearing) < diff) bearing += 360;\n    return bearing;\n  }\n\n  // If a path crossing the antimeridian would be shorter, extend the final coordinate so that\n  // interpolating between the two endpoints will cross it.\n  _normalizeCenter(center) {\n    const tr = this.transform;\n    if (!tr.renderWorldCopies || tr.lngRange) return;\n    const delta = center.lng - tr.center.lng;\n    center.lng += delta > 180 ? -360 : delta < -180 ? 360 : 0;\n  }\n}"],"mappings":"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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEY,MAAMA,CAACF,IAAI,EAAEnC,OAAO,EAAEyB,SAAS,EAAE;IAC/B,OAAO,IAAI,CAACQ,MAAM,CAACzC,MAAM,CAAC;MACxB2C;IACF,CAAC,EAAEnC,OAAO,CAAC,EAAEyB,SAAS,CAAC;EACzB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEa,MAAMA,CAACtC,OAAO,EAAEyB,SAAS,EAAE;IACzB,IAAI,CAACY,MAAM,CAAC,IAAI,CAACH,OAAO,CAAC,CAAC,GAAG,CAAC,EAAElC,OAAO,EAAEyB,SAAS,CAAC;IACnD,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEc,OAAOA,CAACvC,OAAO,EAAEyB,SAAS,EAAE;IAC1B,IAAI,CAACY,MAAM,CAAC,IAAI,CAACH,OAAO,CAAC,CAAC,GAAG,CAAC,EAAElC,OAAO,EAAEyB,SAAS,CAAC;IACnD,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEe,UAAUA,CAAA,EAAG;IACX,OAAO,IAAI,CAACzC,SAAS,CAAC0C,OAAO;EAC/B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,UAAUA,CAACD,OAAO,EAAEhB,SAAS,EAAE;IAC7B,IAAI,CAACC,MAAM,CAAC;MACVe;IACF,CAAC,EAAEhB,SAAS,CAAC;IACb,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;EACEkB,UAAUA,CAAA,EAAG;IACX,OAAO,IAAI,CAAC5C,SAAS,CAAC6C,OAAO;EAC/B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,UAAUA,CAACD,OAAO,EAAEnB,SAAS,EAAE;IAC7B,IAAI,CAACC,MAAM,CAAC;MACVkB;IACF,CAAC,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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}