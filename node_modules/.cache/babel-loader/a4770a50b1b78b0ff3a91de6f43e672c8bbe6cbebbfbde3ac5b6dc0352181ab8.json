{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { calculateCentroid, lodashUtil, rgb2arr } from '@antv/l7-utils';\nimport BaseModel from \"../../core/BaseModel\";\nimport { PointExtrudeTriangulation } from \"../../core/triangulation\";\nimport { lglt2xyz } from \"../../earth/utils\";\n/* babel-plugin-inline-import '../shaders/earthExtrude/earthExtrude_frag.glsl' */\nconst pointExtrudeFrag = \"precision highp float;\\nin vec4 v_color;\\n\\n#pragma include \\\"picking\\\"\\n\\nlayout(std140) uniform commonUniform {\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  float u_linearColor: 0;\\n  float u_heightfixed: 0.0; // \\u9ED8\\u8BA4\\u4E0D\\u56FA\\u5B9A\\n  float u_globel;\\n  float u_r;\\n  float u_pickLight: 0.0;\\n  float u_opacitylinear: 0.0;\\n  float u_opacitylinear_dir: 1.0;\\n  float u_lightEnable: 1.0;\\n};\\nin float v_lightWeight;\\nin float v_barLinearZ;\\nout vec4 outputColor;\\nvoid main() {\\n\\n   outputColor = v_color;\\n\\n  // \\u5F00\\u542F\\u900F\\u660E\\u5EA6\\u6E10\\u53D8\\n  if(u_opacitylinear > 0.0) {\\n    outputColor.a *= u_opacitylinear_dir > 0.0 ? (1.0 - v_barLinearZ): v_barLinearZ;\\n  }\\n\\n  // picking\\n  if(u_pickLight > 0.0) {\\n    outputColor = filterColorAlpha(outputColor, v_lightWeight);\\n  } else {\\n    outputColor = filterColor(outputColor);\\n  }\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/earthExtrude/earthExtrude_vert.glsl' */\nconst pointExtrudeVert = \"precision highp float;\\n\\n#define pi 3.1415926535\\n#define ambientRatio 0.5\\n#define diffuseRatio 0.3\\n#define specularRatio 0.2\\n\\nlayout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in vec3 a_Size;\\nlayout(location = ATTRIBUTE_LOCATION_POS) in vec3 a_Pos;\\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\\n\\nlayout(std140) uniform commonUniform {\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  float u_linearColor: 0;\\n  float u_heightfixed: 0.0; // \\u9ED8\\u8BA4\\u4E0D\\u56FA\\u5B9A\\n  float u_globel;\\n  float u_r;\\n  float u_pickLight: 0.0;\\n  float u_opacitylinear: 0.0;\\n  float u_opacitylinear_dir: 1.0;\\n  float u_lightEnable: 1.0;\\n};\\n\\nout vec4 v_color;\\nout float v_lightWeight;\\nout float v_barLinearZ;\\n// \\u7528\\u4E8E\\u5C06\\u5728\\u9876\\u70B9\\u7740\\u8272\\u5668\\u4E2D\\u8BA1\\u7B97\\u597D\\u7684\\u6837\\u5F0F\\u503C\\u4F20\\u9012\\u7ED9\\u7247\\u5143\\n\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"light\\\"\\n#pragma include \\\"picking\\\"\\n\\nfloat getYRadian(float x, float z) {\\n  if(x > 0.0 && z > 0.0) {\\n    return atan(x/z);\\n  } else if(x > 0.0 && z <= 0.0){\\n    return atan(-z/x) + pi/2.0;\\n  } else if(x <= 0.0 && z <= 0.0) {\\n    return  pi + atan(x/z); //atan(x/z) +\\n  } else {\\n    return atan(z/-x) + pi*3.0/2.0;\\n  }\\n}\\n\\nfloat getXRadian(float y, float r) {\\n  return atan(y/r);\\n}\\n\\nvoid main() {\\n\\n  // cal style mapping - \\u6570\\u636E\\u7EB9\\u7406\\u6620\\u5C04\\u90E8\\u5206\\u7684\\u8BA1\\u7B97\\n  vec3 size = a_Size * a_Position;\\n\\n  // a_Position.z \\u662F\\u5728\\u6784\\u5EFA\\u7F51\\u683C\\u7684\\u65F6\\u5019\\u4F20\\u5165\\u7684\\u6807\\u51C6\\u503C 0 - 1\\uFF0C\\u5728\\u63D2\\u503C\\u5668\\u63D2\\u503C\\u53EF\\u4EE5\\u83B7\\u53D6 0\\uFF5E1 \\u7EBF\\u6027\\u6E10\\u53D8\\u7684\\u503C\\n  v_barLinearZ =  a_Position.z;\\n\\n  vec3 offset = size; // \\u63A7\\u5236\\u5706\\u67F1\\u4F53\\u7684\\u5927\\u5C0F - \\u4ECE\\u6807\\u51C6\\u5355\\u4F4D\\u5706\\u67F1\\u4F53\\u8FDB\\u884C\\u504F\\u79FB\\n  if(u_heightfixed < 1.0) { // \\u5706\\u67F1\\u4F53\\u4E0D\\u56FA\\u5B9A\\u9AD8\\u5EA6\\n    //\\n  } else {// \\u5706\\u67F1\\u4F53\\u56FA\\u5B9A\\u9AD8\\u5EA6 \\uFF08 \\u5904\\u7406 mapbox \\uFF09\\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\\n      offset *= 4.0/pow(2.0, 21.0 - u_Zoom);\\n    }\\n  }\\n\\n\\n  vec4 project_pos = project_position(vec4(a_Pos.xy, 0., 1.0));\\n\\n  // u_r \\u63A7\\u5236\\u5706\\u67F1\\u7684\\u751F\\u957F\\n  vec4 pos = vec4(project_pos.xy + offset.xy, offset.z * u_r, 1.0);\\n\\n  // \\u5706\\u67F1\\u5149\\u7167\\u6548\\u679C\\n  float lightWeight = 1.0;\\n  if(u_lightEnable > 0.0) { // \\u53D6\\u6D88\\u4E09\\u5143\\u8868\\u8FBE\\u5F0F\\uFF0C\\u589E\\u5F3A\\u5065\\u58EE\\u6027\\n    lightWeight = calc_lighting(pos);\\n  }\\n  v_lightWeight = lightWeight;\\n  // \\u8BBE\\u7F6E\\u5706\\u67F1\\u7684\\u5E95\\u8272\\n  if(u_linearColor == 1.0) { // \\u4F7F\\u7528\\u6E10\\u53D8\\u989C\\u8272\\n    v_color = mix(u_sourceColor, u_targetColor, v_barLinearZ);\\n    v_color.rgb *= lightWeight;\\n  } else { // \\u4F7F\\u7528 color \\u65B9\\u6CD5\\u4F20\\u5165\\u7684\\u989C\\u8272\\n     v_color = a_Color;\\n  }\\n  v_color.a *= u_opacity;\\n\\n\\n  // \\u5728\\u5730\\u7403\\u6A21\\u5F0F\\u4E0B\\uFF0C\\u5C06\\u539F\\u672C\\u5782\\u76F4\\u4E8E xy \\u5E73\\u9762\\u7684\\u5706\\u67F1\\u8C03\\u6574\\u59FF\\u6001\\u5230\\u9002\\u5E94\\u5706\\u7684\\u89D2\\u5EA6\\n  //\\u65CB\\u8F6C\\u77E9\\u9635mx\\uFF0C\\u521B\\u5EFA\\u7ED5x\\u8F74\\u65CB\\u8F6C\\u77E9\\u9635\\n  float r = sqrt(a_Pos.z*a_Pos.z + a_Pos.x*a_Pos.x);\\n  float xRadian = getXRadian(a_Pos.y, r);\\n  float xcos = cos(xRadian);//\\u6C42\\u89E3\\u65CB\\u8F6C\\u89D2\\u5EA6\\u4F59\\u5F26\\u503C\\n  float xsin = sin(xRadian);//\\u6C42\\u89E3\\u65CB\\u8F6C\\u89D2\\u5EA6\\u6B63\\u5F26\\u503C\\n  mat4 mx = mat4(\\n    1,0,0,0,\\n    0,xcos,-xsin,0,\\n    0,xsin,xcos,0,\\n    0,0,0,1);\\n\\n  //\\u65CB\\u8F6C\\u77E9\\u9635my\\uFF0C\\u521B\\u5EFA\\u7ED5y\\u8F74\\u65CB\\u8F6C\\u77E9\\u9635\\n  float yRadian = getYRadian(a_Pos.x, a_Pos.z);\\n  float ycos = cos(yRadian);//\\u6C42\\u89E3\\u65CB\\u8F6C\\u89D2\\u5EA6\\u4F59\\u5F26\\u503C\\n  float ysin = sin(yRadian);//\\u6C42\\u89E3\\u65CB\\u8F6C\\u89D2\\u5EA6\\u6B63\\u5F26\\u503C\\n  mat4 my = mat4(\\n    ycos,0,-ysin,0,\\n    0,1,0,0,\\n    ysin,0,ycos,0,\\n    0,0,0,1);\\n\\n  gl_Position = u_ViewProjectionMatrix * vec4(( my * mx *  vec4(a_Position * a_Size, 1.0)).xyz + a_Pos, 1.0);\\n\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\nconst {\n  isNumber\n} = lodashUtil;\nexport default class ExtrudeModel extends BaseModel {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"raiseCount\", 0);\n    _defineProperty(this, \"raiseRepeat\", 0);\n  }\n  get attributeLocation() {\n    return Object.assign(super.attributeLocation, {\n      MAX: super.attributeLocation.MAX,\n      SIZE: 9,\n      POS: 10,\n      NORMAL: 11\n    });\n  }\n  getCommonUniformsInfo() {\n    const {\n      animateOption = {\n        enable: false,\n        speed: 0.01,\n        repeat: false\n      },\n      opacity = 1,\n      sourceColor,\n      targetColor,\n      pickLight = false,\n      heightfixed = true,\n      opacityLinear = {\n        enable: false,\n        dir: 'up'\n      },\n      lightEnable = true\n    } = this.layer.getLayerConfig();\n\n    // 转化渐变色\n    let useLinearColor = 0; // 默认不生效\n    let sourceColorArr = [0, 0, 0, 0];\n    let targetColorArr = [0, 0, 0, 0];\n    if (sourceColor && targetColor) {\n      sourceColorArr = rgb2arr(sourceColor);\n      targetColorArr = rgb2arr(targetColor);\n      useLinearColor = 1;\n    }\n    if (this.raiseCount < 1 && this.raiseRepeat > 0) {\n      if (animateOption.enable) {\n        const {\n          speed = 0.01\n        } = animateOption;\n        this.raiseCount += speed;\n        if (this.raiseCount >= 1) {\n          if (this.raiseRepeat > 1) {\n            this.raiseCount = 0;\n            this.raiseRepeat--;\n          } else {\n            this.raiseCount = 1;\n          }\n        }\n      }\n    }\n    const commonOptions = {\n      u_sourceColor: sourceColorArr,\n      u_targetColor: targetColorArr,\n      // 渐变色支持参数\n      u_linearColor: useLinearColor,\n      // 圆柱体的拾取高亮是否要计算光照\n      u_pickLight: Number(pickLight),\n      // 圆柱体是否固定高度\n      u_heightfixed: Number(heightfixed),\n      u_r: animateOption.enable && this.raiseRepeat > 0 ? this.raiseCount : 1.0,\n      u_opacity: isNumber(opacity) ? opacity : 1.0,\n      // 透明度渐变\n      u_opacitylinear: Number(opacityLinear.enable),\n      u_opacitylinear_dir: opacityLinear.dir === 'up' ? 1.0 : 0.0,\n      // 光照计算开关\n      u_lightEnable: Number(lightEnable)\n    };\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.initUniformsBuffer();\n      return _this.buildModels();\n    })();\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        animateOption: {\n          repeat = 1\n        }\n      } = _this2.layer.getLayerConfig();\n      _this2.raiseRepeat = repeat;\n      const model = yield _this2.layer.buildLayerModel({\n        moduleName: 'pointEarthExtrude',\n        vertexShader: pointExtrudeVert,\n        fragmentShader: pointExtrudeFrag,\n        triangulation: PointExtrudeTriangulation,\n        depth: {\n          enable: true\n        },\n        defines: _this2.getDefines(),\n        inject: _this2.getInject(),\n        cull: {\n          enable: true,\n          face: gl.FRONT\n        },\n        blend: _this2.getBlend()\n      });\n      return [model];\n    })();\n  }\n  registerBuiltinAttributes() {\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Size',\n        shaderLocation: this.attributeLocation.SIZE,\n        buffer: {\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        update: feature => {\n          const {\n            size\n          } = feature;\n          if (size) {\n            let buffersize = [];\n            if (Array.isArray(size)) {\n              buffersize = size.length === 2 ? [size[0], size[0], size[1]] : size;\n            }\n            if (!Array.isArray(size)) {\n              buffersize = [size, size, size];\n            }\n            return buffersize;\n          } else {\n            return [2, 2, 2];\n          }\n        }\n      }\n    });\n\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'normal',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Normal',\n        shaderLocation: this.attributeLocation.NORMAL,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.STATIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        update: (feature, featureIdx, vertex, attributeIdx, normal) => {\n          return normal;\n        }\n      }\n    });\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'pos',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Pos',\n        shaderLocation: this.attributeLocation.POS,\n        buffer: {\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        update: feature => {\n          const coordinates = calculateCentroid(feature.coordinates);\n          return lglt2xyz([coordinates[0], coordinates[1]]);\n        }\n      }\n    });\n  }\n}","map":{"version":3,"names":["_asyncToGenerator","_defineProperty","AttributeType","gl","calculateCentroid","lodashUtil","rgb2arr","BaseModel","PointExtrudeTriangulation","lglt2xyz","pointExtrudeFrag","pointExtrudeVert","isNumber","ExtrudeModel","constructor","args","attributeLocation","Object","assign","MAX","SIZE","POS","NORMAL","getCommonUniformsInfo","animateOption","enable","speed","repeat","opacity","sourceColor","targetColor","pickLight","heightfixed","opacityLinear","dir","lightEnable","layer","getLayerConfig","useLinearColor","sourceColorArr","targetColorArr","raiseCount","raiseRepeat","commonOptions","u_sourceColor","u_targetColor","u_linearColor","u_pickLight","Number","u_heightfixed","u_r","u_opacity","u_opacitylinear","u_opacitylinear_dir","u_lightEnable","commonBufferInfo","getUniformsBufferInfo","initModels","_this","initUniformsBuffer","buildModels","_this2","model","buildLayerModel","moduleName","vertexShader","fragmentShader","triangulation","depth","defines","getDefines","inject","getInject","cull","face","FRONT","blend","getBlend","registerBuiltinAttributes","styleAttributeService","registerStyleAttribute","name","type","Attribute","descriptor","shaderLocation","buffer","usage","DYNAMIC_DRAW","data","FLOAT","size","update","feature","buffersize","Array","isArray","length","STATIC_DRAW","featureIdx","vertex","attributeIdx","normal","coordinates"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/l7-layers/es/point/models/earthExtrude.js"],"sourcesContent":["import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { calculateCentroid, lodashUtil, rgb2arr } from '@antv/l7-utils';\nimport BaseModel from \"../../core/BaseModel\";\nimport { PointExtrudeTriangulation } from \"../../core/triangulation\";\nimport { lglt2xyz } from \"../../earth/utils\";\n/* babel-plugin-inline-import '../shaders/earthExtrude/earthExtrude_frag.glsl' */\nconst pointExtrudeFrag = \"precision highp float;\\nin vec4 v_color;\\n\\n#pragma include \\\"picking\\\"\\n\\nlayout(std140) uniform commonUniform {\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  float u_linearColor: 0;\\n  float u_heightfixed: 0.0; // \\u9ED8\\u8BA4\\u4E0D\\u56FA\\u5B9A\\n  float u_globel;\\n  float u_r;\\n  float u_pickLight: 0.0;\\n  float u_opacitylinear: 0.0;\\n  float u_opacitylinear_dir: 1.0;\\n  float u_lightEnable: 1.0;\\n};\\nin float v_lightWeight;\\nin float v_barLinearZ;\\nout vec4 outputColor;\\nvoid main() {\\n\\n   outputColor = v_color;\\n\\n  // \\u5F00\\u542F\\u900F\\u660E\\u5EA6\\u6E10\\u53D8\\n  if(u_opacitylinear > 0.0) {\\n    outputColor.a *= u_opacitylinear_dir > 0.0 ? (1.0 - v_barLinearZ): v_barLinearZ;\\n  }\\n\\n  // picking\\n  if(u_pickLight > 0.0) {\\n    outputColor = filterColorAlpha(outputColor, v_lightWeight);\\n  } else {\\n    outputColor = filterColor(outputColor);\\n  }\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/earthExtrude/earthExtrude_vert.glsl' */\nconst pointExtrudeVert = \"precision highp float;\\n\\n#define pi 3.1415926535\\n#define ambientRatio 0.5\\n#define diffuseRatio 0.3\\n#define specularRatio 0.2\\n\\nlayout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in vec3 a_Size;\\nlayout(location = ATTRIBUTE_LOCATION_POS) in vec3 a_Pos;\\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\\n\\nlayout(std140) uniform commonUniform {\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  float u_linearColor: 0;\\n  float u_heightfixed: 0.0; // \\u9ED8\\u8BA4\\u4E0D\\u56FA\\u5B9A\\n  float u_globel;\\n  float u_r;\\n  float u_pickLight: 0.0;\\n  float u_opacitylinear: 0.0;\\n  float u_opacitylinear_dir: 1.0;\\n  float u_lightEnable: 1.0;\\n};\\n\\nout vec4 v_color;\\nout float v_lightWeight;\\nout float v_barLinearZ;\\n// \\u7528\\u4E8E\\u5C06\\u5728\\u9876\\u70B9\\u7740\\u8272\\u5668\\u4E2D\\u8BA1\\u7B97\\u597D\\u7684\\u6837\\u5F0F\\u503C\\u4F20\\u9012\\u7ED9\\u7247\\u5143\\n\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"light\\\"\\n#pragma include \\\"picking\\\"\\n\\nfloat getYRadian(float x, float z) {\\n  if(x > 0.0 && z > 0.0) {\\n    return atan(x/z);\\n  } else if(x > 0.0 && z <= 0.0){\\n    return atan(-z/x) + pi/2.0;\\n  } else if(x <= 0.0 && z <= 0.0) {\\n    return  pi + atan(x/z); //atan(x/z) +\\n  } else {\\n    return atan(z/-x) + pi*3.0/2.0;\\n  }\\n}\\n\\nfloat getXRadian(float y, float r) {\\n  return atan(y/r);\\n}\\n\\nvoid main() {\\n\\n  // cal style mapping - \\u6570\\u636E\\u7EB9\\u7406\\u6620\\u5C04\\u90E8\\u5206\\u7684\\u8BA1\\u7B97\\n  vec3 size = a_Size * a_Position;\\n\\n  // a_Position.z \\u662F\\u5728\\u6784\\u5EFA\\u7F51\\u683C\\u7684\\u65F6\\u5019\\u4F20\\u5165\\u7684\\u6807\\u51C6\\u503C 0 - 1\\uFF0C\\u5728\\u63D2\\u503C\\u5668\\u63D2\\u503C\\u53EF\\u4EE5\\u83B7\\u53D6 0\\uFF5E1 \\u7EBF\\u6027\\u6E10\\u53D8\\u7684\\u503C\\n  v_barLinearZ =  a_Position.z;\\n\\n  vec3 offset = size; // \\u63A7\\u5236\\u5706\\u67F1\\u4F53\\u7684\\u5927\\u5C0F - \\u4ECE\\u6807\\u51C6\\u5355\\u4F4D\\u5706\\u67F1\\u4F53\\u8FDB\\u884C\\u504F\\u79FB\\n  if(u_heightfixed < 1.0) { // \\u5706\\u67F1\\u4F53\\u4E0D\\u56FA\\u5B9A\\u9AD8\\u5EA6\\n    //\\n  } else {// \\u5706\\u67F1\\u4F53\\u56FA\\u5B9A\\u9AD8\\u5EA6 \\uFF08 \\u5904\\u7406 mapbox \\uFF09\\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\\n      offset *= 4.0/pow(2.0, 21.0 - u_Zoom);\\n    }\\n  }\\n\\n\\n  vec4 project_pos = project_position(vec4(a_Pos.xy, 0., 1.0));\\n\\n  // u_r \\u63A7\\u5236\\u5706\\u67F1\\u7684\\u751F\\u957F\\n  vec4 pos = vec4(project_pos.xy + offset.xy, offset.z * u_r, 1.0);\\n\\n  // \\u5706\\u67F1\\u5149\\u7167\\u6548\\u679C\\n  float lightWeight = 1.0;\\n  if(u_lightEnable > 0.0) { // \\u53D6\\u6D88\\u4E09\\u5143\\u8868\\u8FBE\\u5F0F\\uFF0C\\u589E\\u5F3A\\u5065\\u58EE\\u6027\\n    lightWeight = calc_lighting(pos);\\n  }\\n  v_lightWeight = lightWeight;\\n  // \\u8BBE\\u7F6E\\u5706\\u67F1\\u7684\\u5E95\\u8272\\n  if(u_linearColor == 1.0) { // \\u4F7F\\u7528\\u6E10\\u53D8\\u989C\\u8272\\n    v_color = mix(u_sourceColor, u_targetColor, v_barLinearZ);\\n    v_color.rgb *= lightWeight;\\n  } else { // \\u4F7F\\u7528 color \\u65B9\\u6CD5\\u4F20\\u5165\\u7684\\u989C\\u8272\\n     v_color = a_Color;\\n  }\\n  v_color.a *= u_opacity;\\n\\n\\n  // \\u5728\\u5730\\u7403\\u6A21\\u5F0F\\u4E0B\\uFF0C\\u5C06\\u539F\\u672C\\u5782\\u76F4\\u4E8E xy \\u5E73\\u9762\\u7684\\u5706\\u67F1\\u8C03\\u6574\\u59FF\\u6001\\u5230\\u9002\\u5E94\\u5706\\u7684\\u89D2\\u5EA6\\n  //\\u65CB\\u8F6C\\u77E9\\u9635mx\\uFF0C\\u521B\\u5EFA\\u7ED5x\\u8F74\\u65CB\\u8F6C\\u77E9\\u9635\\n  float r = sqrt(a_Pos.z*a_Pos.z + a_Pos.x*a_Pos.x);\\n  float xRadian = getXRadian(a_Pos.y, r);\\n  float xcos = cos(xRadian);//\\u6C42\\u89E3\\u65CB\\u8F6C\\u89D2\\u5EA6\\u4F59\\u5F26\\u503C\\n  float xsin = sin(xRadian);//\\u6C42\\u89E3\\u65CB\\u8F6C\\u89D2\\u5EA6\\u6B63\\u5F26\\u503C\\n  mat4 mx = mat4(\\n    1,0,0,0,\\n    0,xcos,-xsin,0,\\n    0,xsin,xcos,0,\\n    0,0,0,1);\\n\\n  //\\u65CB\\u8F6C\\u77E9\\u9635my\\uFF0C\\u521B\\u5EFA\\u7ED5y\\u8F74\\u65CB\\u8F6C\\u77E9\\u9635\\n  float yRadian = getYRadian(a_Pos.x, a_Pos.z);\\n  float ycos = cos(yRadian);//\\u6C42\\u89E3\\u65CB\\u8F6C\\u89D2\\u5EA6\\u4F59\\u5F26\\u503C\\n  float ysin = sin(yRadian);//\\u6C42\\u89E3\\u65CB\\u8F6C\\u89D2\\u5EA6\\u6B63\\u5F26\\u503C\\n  mat4 my = mat4(\\n    ycos,0,-ysin,0,\\n    0,1,0,0,\\n    ysin,0,ycos,0,\\n    0,0,0,1);\\n\\n  gl_Position = u_ViewProjectionMatrix * vec4(( my * mx *  vec4(a_Position * a_Size, 1.0)).xyz + a_Pos, 1.0);\\n\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\nconst {\n  isNumber\n} = lodashUtil;\nexport default class ExtrudeModel extends BaseModel {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"raiseCount\", 0);\n    _defineProperty(this, \"raiseRepeat\", 0);\n  }\n  get attributeLocation() {\n    return Object.assign(super.attributeLocation, {\n      MAX: super.attributeLocation.MAX,\n      SIZE: 9,\n      POS: 10,\n      NORMAL: 11\n    });\n  }\n  getCommonUniformsInfo() {\n    const {\n      animateOption = {\n        enable: false,\n        speed: 0.01,\n        repeat: false\n      },\n      opacity = 1,\n      sourceColor,\n      targetColor,\n      pickLight = false,\n      heightfixed = true,\n      opacityLinear = {\n        enable: false,\n        dir: 'up'\n      },\n      lightEnable = true\n    } = this.layer.getLayerConfig();\n\n    // 转化渐变色\n    let useLinearColor = 0; // 默认不生效\n    let sourceColorArr = [0, 0, 0, 0];\n    let targetColorArr = [0, 0, 0, 0];\n    if (sourceColor && targetColor) {\n      sourceColorArr = rgb2arr(sourceColor);\n      targetColorArr = rgb2arr(targetColor);\n      useLinearColor = 1;\n    }\n    if (this.raiseCount < 1 && this.raiseRepeat > 0) {\n      if (animateOption.enable) {\n        const {\n          speed = 0.01\n        } = animateOption;\n        this.raiseCount += speed;\n        if (this.raiseCount >= 1) {\n          if (this.raiseRepeat > 1) {\n            this.raiseCount = 0;\n            this.raiseRepeat--;\n          } else {\n            this.raiseCount = 1;\n          }\n        }\n      }\n    }\n    const commonOptions = {\n      u_sourceColor: sourceColorArr,\n      u_targetColor: targetColorArr,\n      // 渐变色支持参数\n      u_linearColor: useLinearColor,\n      // 圆柱体的拾取高亮是否要计算光照\n      u_pickLight: Number(pickLight),\n      // 圆柱体是否固定高度\n      u_heightfixed: Number(heightfixed),\n      u_r: animateOption.enable && this.raiseRepeat > 0 ? this.raiseCount : 1.0,\n      u_opacity: isNumber(opacity) ? opacity : 1.0,\n      // 透明度渐变\n      u_opacitylinear: Number(opacityLinear.enable),\n      u_opacitylinear_dir: opacityLinear.dir === 'up' ? 1.0 : 0.0,\n      // 光照计算开关\n      u_lightEnable: Number(lightEnable)\n    };\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.initUniformsBuffer();\n      return _this.buildModels();\n    })();\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        animateOption: {\n          repeat = 1\n        }\n      } = _this2.layer.getLayerConfig();\n      _this2.raiseRepeat = repeat;\n      const model = yield _this2.layer.buildLayerModel({\n        moduleName: 'pointEarthExtrude',\n        vertexShader: pointExtrudeVert,\n        fragmentShader: pointExtrudeFrag,\n        triangulation: PointExtrudeTriangulation,\n        depth: {\n          enable: true\n        },\n        defines: _this2.getDefines(),\n        inject: _this2.getInject(),\n        cull: {\n          enable: true,\n          face: gl.FRONT\n        },\n        blend: _this2.getBlend()\n      });\n      return [model];\n    })();\n  }\n  registerBuiltinAttributes() {\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Size',\n        shaderLocation: this.attributeLocation.SIZE,\n        buffer: {\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        update: feature => {\n          const {\n            size\n          } = feature;\n          if (size) {\n            let buffersize = [];\n            if (Array.isArray(size)) {\n              buffersize = size.length === 2 ? [size[0], size[0], size[1]] : size;\n            }\n            if (!Array.isArray(size)) {\n              buffersize = [size, size, size];\n            }\n            return buffersize;\n          } else {\n            return [2, 2, 2];\n          }\n        }\n      }\n    });\n\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'normal',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Normal',\n        shaderLocation: this.attributeLocation.NORMAL,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.STATIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        update: (feature, featureIdx, vertex, attributeIdx, normal) => {\n          return normal;\n        }\n      }\n    });\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'pos',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Pos',\n        shaderLocation: this.attributeLocation.POS,\n        buffer: {\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        update: feature => {\n          const coordinates = calculateCentroid(feature.coordinates);\n          return lglt2xyz([coordinates[0], coordinates[1]]);\n        }\n      }\n    });\n  }\n}"],"mappings":"AAAA,OAAOA,iBAAiB,MAAM,6CAA6C;AAC3E,OAAOC,eAAe,MAAM,2CAA2C;AACvE,SAASC,aAAa,EAAEC,EAAE,QAAQ,eAAe;AACjD,SAASC,iBAAiB,EAAEC,UAAU,EAAEC,OAAO,QAAQ,gBAAgB;AACvE,OAAOC,SAAS,MAAM,sBAAsB;AAC5C,SAASC,yBAAyB,QAAQ,0BAA0B;AACpE,SAASC,QAAQ,QAAQ,mBAAmB;AAC5C;AACA,MAAMC,gBAAgB,GAAG,02BAA02B;AACn4B;AACA,MAAMC,gBAAgB,GAAG,gwIAAgwI;AACzxI,MAAM;EACJC;AACF,CAAC,GAAGP,UAAU;AACd,eAAe,MAAMQ,YAAY,SAASN,SAAS,CAAC;EAClDO,WAAWA,CAAC,GAAGC,IAAI,EAAE;IACnB,KAAK,CAAC,GAAGA,IAAI,CAAC;IACdd,eAAe,CAAC,IAAI,EAAE,YAAY,EAAE,CAAC,CAAC;IACtCA,eAAe,CAAC,IAAI,EAAE,aAAa,EAAE,CAAC,CAAC;EACzC;EACA,IAAIe,iBAAiBA,CAAA,EAAG;IACtB,OAAOC,MAAM,CAACC,MAAM,CAAC,KAAK,CAACF,iBAAiB,EAAE;MAC5CG,GAAG,EAAE,KAAK,CAACH,iBAAiB,CAACG,GAAG;MAChCC,IAAI,EAAE,CAAC;MACPC,GAAG,EAAE,EAAE;MACPC,MAAM,EAAE;IACV,CAAC,CAAC;EACJ;EACAC,qBAAqBA,CAAA,EAAG;IACtB,MAAM;MACJC,aAAa,GAAG;QACdC,MAAM,EAAE,KAAK;QACbC,KAAK,EAAE,IAAI;QACXC,MAAM,EAAE;MACV,CAAC;MACDC,OAAO,GAAG,CAAC;MACXC,WAAW;MACXC,WAAW;MACXC,SAAS,GAAG,KAAK;MACjBC,WAAW,GAAG,IAAI;MAClBC,aAAa,GAAG;QACdR,MAAM,EAAE,KAAK;QACbS,GAAG,EAAE;MACP,CAAC;MACDC,WAAW,GAAG;IAChB,CAAC,GAAG,IAAI,CAACC,KAAK,CAACC,cAAc,CAAC,CAAC;;IAE/B;IACA,IAAIC,cAAc,GAAG,CAAC,CAAC,CAAC;IACxB,IAAIC,cAAc,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACjC,IAAIC,cAAc,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACjC,IAAIX,WAAW,IAAIC,WAAW,EAAE;MAC9BS,cAAc,GAAGjC,OAAO,CAACuB,WAAW,CAAC;MACrCW,cAAc,GAAGlC,OAAO,CAACwB,WAAW,CAAC;MACrCQ,cAAc,GAAG,CAAC;IACpB;IACA,IAAI,IAAI,CAACG,UAAU,GAAG,CAAC,IAAI,IAAI,CAACC,WAAW,GAAG,CAAC,EAAE;MAC/C,IAAIlB,aAAa,CAACC,MAAM,EAAE;QACxB,MAAM;UACJC,KAAK,GAAG;QACV,CAAC,GAAGF,aAAa;QACjB,IAAI,CAACiB,UAAU,IAAIf,KAAK;QACxB,IAAI,IAAI,CAACe,UAAU,IAAI,CAAC,EAAE;UACxB,IAAI,IAAI,CAACC,WAAW,GAAG,CAAC,EAAE;YACxB,IAAI,CAACD,UAAU,GAAG,CAAC;YACnB,IAAI,CAACC,WAAW,EAAE;UACpB,CAAC,MAAM;YACL,IAAI,CAACD,UAAU,GAAG,CAAC;UACrB;QACF;MACF;IACF;IACA,MAAME,aAAa,GAAG;MACpBC,aAAa,EAAEL,cAAc;MAC7BM,aAAa,EAAEL,cAAc;MAC7B;MACAM,aAAa,EAAER,cAAc;MAC7B;MACAS,WAAW,EAAEC,MAAM,CAACjB,SAAS,CAAC;MAC9B;MACAkB,aAAa,EAAED,MAAM,CAAChB,WAAW,CAAC;MAClCkB,GAAG,EAAE1B,aAAa,CAACC,MAAM,IAAI,IAAI,CAACiB,WAAW,GAAG,CAAC,GAAG,IAAI,CAACD,UAAU,GAAG,GAAG;MACzEU,SAAS,EAAEvC,QAAQ,CAACgB,OAAO,CAAC,GAAGA,OAAO,GAAG,GAAG;MAC5C;MACAwB,eAAe,EAAEJ,MAAM,CAACf,aAAa,CAACR,MAAM,CAAC;MAC7C4B,mBAAmB,EAAEpB,aAAa,CAACC,GAAG,KAAK,IAAI,GAAG,GAAG,GAAG,GAAG;MAC3D;MACAoB,aAAa,EAAEN,MAAM,CAACb,WAAW;IACnC,CAAC;IACD,MAAMoB,gBAAgB,GAAG,IAAI,CAACC,qBAAqB,CAACb,aAAa,CAAC;IAClE,OAAOY,gBAAgB;EACzB;EACAE,UAAUA,CAAA,EAAG;IACX,IAAIC,KAAK,GAAG,IAAI;IAChB,OAAO1D,iBAAiB,CAAC,aAAa;MACpC0D,KAAK,CAACC,kBAAkB,CAAC,CAAC;MAC1B,OAAOD,KAAK,CAACE,WAAW,CAAC,CAAC;IAC5B,CAAC,CAAC,CAAC,CAAC;EACN;EACAA,WAAWA,CAAA,EAAG;IACZ,IAAIC,MAAM,GAAG,IAAI;IACjB,OAAO7D,iBAAiB,CAAC,aAAa;MACpC,MAAM;QACJwB,aAAa,EAAE;UACbG,MAAM,GAAG;QACX;MACF,CAAC,GAAGkC,MAAM,CAACzB,KAAK,CAACC,cAAc,CAAC,CAAC;MACjCwB,MAAM,CAACnB,WAAW,GAAGf,MAAM;MAC3B,MAAMmC,KAAK,GAAG,MAAMD,MAAM,CAACzB,KAAK,CAAC2B,eAAe,CAAC;QAC/CC,UAAU,EAAE,mBAAmB;QAC/BC,YAAY,EAAEtD,gBAAgB;QAC9BuD,cAAc,EAAExD,gBAAgB;QAChCyD,aAAa,EAAE3D,yBAAyB;QACxC4D,KAAK,EAAE;UACL3C,MAAM,EAAE;QACV,CAAC;QACD4C,OAAO,EAAER,MAAM,CAACS,UAAU,CAAC,CAAC;QAC5BC,MAAM,EAAEV,MAAM,CAACW,SAAS,CAAC,CAAC;QAC1BC,IAAI,EAAE;UACJhD,MAAM,EAAE,IAAI;UACZiD,IAAI,EAAEvE,EAAE,CAACwE;QACX,CAAC;QACDC,KAAK,EAAEf,MAAM,CAACgB,QAAQ,CAAC;MACzB,CAAC,CAAC;MACF,OAAO,CAACf,KAAK,CAAC;IAChB,CAAC,CAAC,CAAC,CAAC;EACN;EACAgB,yBAAyBA,CAAA,EAAG;IAC1B,IAAI,CAACC,qBAAqB,CAACC,sBAAsB,CAAC;MAChDC,IAAI,EAAE,MAAM;MACZC,IAAI,EAAEhF,aAAa,CAACiF,SAAS;MAC7BC,UAAU,EAAE;QACVH,IAAI,EAAE,QAAQ;QACdI,cAAc,EAAE,IAAI,CAACrE,iBAAiB,CAACI,IAAI;QAC3CkE,MAAM,EAAE;UACNC,KAAK,EAAEpF,EAAE,CAACqF,YAAY;UACtBC,IAAI,EAAE,EAAE;UACRP,IAAI,EAAE/E,EAAE,CAACuF;QACX,CAAC;QACDC,IAAI,EAAE,CAAC;QACPC,MAAM,EAAEC,OAAO,IAAI;UACjB,MAAM;YACJF;UACF,CAAC,GAAGE,OAAO;UACX,IAAIF,IAAI,EAAE;YACR,IAAIG,UAAU,GAAG,EAAE;YACnB,IAAIC,KAAK,CAACC,OAAO,CAACL,IAAI,CAAC,EAAE;cACvBG,UAAU,GAAGH,IAAI,CAACM,MAAM,KAAK,CAAC,GAAG,CAACN,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC,GAAGA,IAAI;YACrE;YACA,IAAI,CAACI,KAAK,CAACC,OAAO,CAACL,IAAI,CAAC,EAAE;cACxBG,UAAU,GAAG,CAACH,IAAI,EAAEA,IAAI,EAAEA,IAAI,CAAC;YACjC;YACA,OAAOG,UAAU;UACnB,CAAC,MAAM;YACL,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;UAClB;QACF;MACF;IACF,CAAC,CAAC;;IAEF;IACA,IAAI,CAACf,qBAAqB,CAACC,sBAAsB,CAAC;MAChDC,IAAI,EAAE,QAAQ;MACdC,IAAI,EAAEhF,aAAa,CAACiF,SAAS;MAC7BC,UAAU,EAAE;QACVH,IAAI,EAAE,UAAU;QAChBI,cAAc,EAAE,IAAI,CAACrE,iBAAiB,CAACM,MAAM;QAC7CgE,MAAM,EAAE;UACN;UACAC,KAAK,EAAEpF,EAAE,CAAC+F,WAAW;UACrBT,IAAI,EAAE,EAAE;UACRP,IAAI,EAAE/E,EAAE,CAACuF;QACX,CAAC;QACDC,IAAI,EAAE,CAAC;QACPC,MAAM,EAAEA,CAACC,OAAO,EAAEM,UAAU,EAAEC,MAAM,EAAEC,YAAY,EAAEC,MAAM,KAAK;UAC7D,OAAOA,MAAM;QACf;MACF;IACF,CAAC,CAAC;IACF,IAAI,CAACvB,qBAAqB,CAACC,sBAAsB,CAAC;MAChDC,IAAI,EAAE,KAAK;MACXC,IAAI,EAAEhF,aAAa,CAACiF,SAAS;MAC7BC,UAAU,EAAE;QACVH,IAAI,EAAE,OAAO;QACbI,cAAc,EAAE,IAAI,CAACrE,iBAAiB,CAACK,GAAG;QAC1CiE,MAAM,EAAE;UACNC,KAAK,EAAEpF,EAAE,CAACqF,YAAY;UACtBC,IAAI,EAAE,EAAE;UACRP,IAAI,EAAE/E,EAAE,CAACuF;QACX,CAAC;QACDC,IAAI,EAAE,CAAC;QACPC,MAAM,EAAEC,OAAO,IAAI;UACjB,MAAMU,WAAW,GAAGnG,iBAAiB,CAACyF,OAAO,CAACU,WAAW,CAAC;UAC1D,OAAO9F,QAAQ,CAAC,CAAC8F,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;QACnD;MACF;IACF,CAAC,CAAC;EACJ;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}