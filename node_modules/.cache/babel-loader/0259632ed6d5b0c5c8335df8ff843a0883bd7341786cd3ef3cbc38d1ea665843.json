{"ast":null,"code":"import { Point } from './point';\nimport { Geometry } from './geometry';\nimport { Rectangle } from './rectangle';\nexport class Line extends Geometry {\n  constructor(x1, y1, x2, y2) {\n    super();\n    if (typeof x1 === 'number' && typeof y1 === 'number') {\n      this.start = new Point(x1, y1);\n      this.end = new Point(x2, y2);\n    } else {\n      this.start = Point.create(x1);\n      this.end = Point.create(y1);\n    }\n  }\n  get [Symbol.toStringTag]() {\n    return Line.toStringTag;\n  }\n  get center() {\n    return new Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);\n  }\n  getCenter() {\n    return this.center;\n  }\n  /**\n   * Rounds the line to the given `precision`.\n   */\n  round(precision = 0) {\n    this.start.round(precision);\n    this.end.round(precision);\n    return this;\n  }\n  translate(tx, ty) {\n    if (typeof tx === 'number') {\n      this.start.translate(tx, ty);\n      this.end.translate(tx, ty);\n    } else {\n      this.start.translate(tx);\n      this.end.translate(tx);\n    }\n    return this;\n  }\n  /**\n   * Rotate the line by `angle` around `origin`.\n   */\n  rotate(angle, origin) {\n    this.start.rotate(angle, origin);\n    this.end.rotate(angle, origin);\n    return this;\n  }\n  /**\n   * Scale the line by `sx` and `sy` about the given `origin`. If origin is not\n   * specified, the line is scaled around `0,0`.\n   */\n  scale(sx, sy, origin) {\n    this.start.scale(sx, sy, origin);\n    this.end.scale(sx, sy, origin);\n    return this;\n  }\n  /**\n   * Returns the length of the line.\n   */\n  length() {\n    return Math.sqrt(this.squaredLength());\n  }\n  /**\n   * Useful for distance comparisons in which real length is not necessary\n   * (saves one `Math.sqrt()` operation).\n   */\n  squaredLength() {\n    const dx = this.start.x - this.end.x;\n    const dy = this.start.y - this.end.y;\n    return dx * dx + dy * dy;\n  }\n  /**\n   * Scale the line so that it has the requested length. The start point of\n   * the line is preserved.\n   */\n  setLength(length) {\n    const total = this.length();\n    if (!total) {\n      return this;\n    }\n    const scale = length / total;\n    return this.scale(scale, scale, this.start);\n  }\n  parallel(distance) {\n    const line = this.clone();\n    if (!line.isDifferentiable()) {\n      return line;\n    }\n    const {\n      start,\n      end\n    } = line;\n    const eRef = start.clone().rotate(270, end);\n    const sRef = end.clone().rotate(90, start);\n    start.move(sRef, distance);\n    end.move(eRef, distance);\n    return line;\n  }\n  /**\n   * Returns the vector of the line with length equal to length of the line.\n   */\n  vector() {\n    return new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n  }\n  /**\n   * Returns the angle of incline of the line.\n   *\n   * The function returns `NaN` if the start and end endpoints of the line\n   * both lie at the same coordinates(it is impossible to determine the angle\n   * of incline of a line that appears to be a point). The\n   * `line.isDifferentiable()` function may be used in advance to determine\n   * whether the angle of incline can be computed for a given line.\n   */\n  angle() {\n    const horizontal = new Point(this.start.x + 1, this.start.y);\n    return this.start.angleBetween(this.end, horizontal);\n  }\n  /**\n   * Returns a rectangle that is the bounding box of the line.\n   */\n  bbox() {\n    const left = Math.min(this.start.x, this.end.x);\n    const top = Math.min(this.start.y, this.end.y);\n    const right = Math.max(this.start.x, this.end.x);\n    const bottom = Math.max(this.start.y, this.end.y);\n    return new Rectangle(left, top, right - left, bottom - top);\n  }\n  /**\n   * Returns the bearing (cardinal direction) of the line.\n   *\n   * The return value is one of the following strings:\n   * 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW' and 'N'.\n   *\n   * The function returns 'N' if the two endpoints of the line are coincident.\n   */\n  bearing() {\n    return this.start.bearing(this.end);\n  }\n  /**\n   * Returns the point on the line that lies closest to point `p`.\n   */\n  closestPoint(p) {\n    return this.pointAt(this.closestPointNormalizedLength(p));\n  }\n  /**\n   * Returns the length of the line up to the point that lies closest to point `p`.\n   */\n  closestPointLength(p) {\n    return this.closestPointNormalizedLength(p) * this.length();\n  }\n  /**\n   * Returns a line that is tangent to the line at the point that lies closest\n   * to point `p`.\n   */\n  closestPointTangent(p) {\n    return this.tangentAt(this.closestPointNormalizedLength(p));\n  }\n  /**\n   * Returns the normalized length (distance from the start of the line / total\n   * line length) of the line up to the point that lies closest to point.\n   */\n  closestPointNormalizedLength(p) {\n    const product = this.vector().dot(new Line(this.start, p).vector());\n    const normalized = Math.min(1, Math.max(0, product / this.squaredLength()));\n    // normalized returns `NaN` if this line has zero length\n    if (Number.isNaN(normalized)) {\n      return 0;\n    }\n    return normalized;\n  }\n  /**\n   * Returns a point on the line that lies `rate` (normalized length) away from\n   * the beginning of the line.\n   */\n  pointAt(ratio) {\n    const start = this.start;\n    const end = this.end;\n    if (ratio <= 0) {\n      return start.clone();\n    }\n    if (ratio >= 1) {\n      return end.clone();\n    }\n    return start.lerp(end, ratio);\n  }\n  /**\n   * Returns a point on the line that lies length away from the beginning of\n   * the line.\n   */\n  pointAtLength(length) {\n    const start = this.start;\n    const end = this.end;\n    let fromStart = true;\n    if (length < 0) {\n      fromStart = false; // start calculation from end point\n      length = -length; // eslint-disable-line\n    }\n    const total = this.length();\n    if (length >= total) {\n      return fromStart ? end.clone() : start.clone();\n    }\n    const rate = (fromStart ? length : total - length) / total;\n    return this.pointAt(rate);\n  }\n  /**\n   * Divides the line into two lines at the point that lies `rate` (normalized\n   * length) away from the beginning of the line.\n   */\n  divideAt(ratio) {\n    const dividerPoint = this.pointAt(ratio);\n    return [new Line(this.start, dividerPoint), new Line(dividerPoint, this.end)];\n  }\n  /**\n   * Divides the line into two lines at the point that lies length away from\n   * the beginning of the line.\n   */\n  divideAtLength(length) {\n    const dividerPoint = this.pointAtLength(length);\n    return [new Line(this.start, dividerPoint), new Line(dividerPoint, this.end)];\n  }\n  /**\n   * Returns `true` if the point `p` lies on the line. Return `false` otherwise.\n   */\n  containsPoint(p) {\n    const start = this.start;\n    const end = this.end;\n    // cross product of 0 indicates that this line and\n    // the vector to `p` are collinear.\n    if (start.cross(p, end) !== 0) {\n      return false;\n    }\n    const length = this.length();\n    if (new Line(start, p).length() > length) {\n      return false;\n    }\n    if (new Line(p, end).length() > length) {\n      return false;\n    }\n    return true;\n  }\n  intersect(shape, options) {\n    const ret = shape.intersectsWithLine(this, options);\n    if (ret) {\n      return Array.isArray(ret) ? ret : [ret];\n    }\n    return null;\n  }\n  /**\n   * Returns the intersection point of the line with another line. Returns\n   * `null` if no intersection exists.\n   */\n  intersectsWithLine(line) {\n    const pt1Dir = new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n    const pt2Dir = new Point(line.end.x - line.start.x, line.end.y - line.start.y);\n    const det = pt1Dir.x * pt2Dir.y - pt1Dir.y * pt2Dir.x;\n    const deltaPt = new Point(line.start.x - this.start.x, line.start.y - this.start.y);\n    const alpha = deltaPt.x * pt2Dir.y - deltaPt.y * pt2Dir.x;\n    const beta = deltaPt.x * pt1Dir.y - deltaPt.y * pt1Dir.x;\n    if (det === 0 || alpha * det < 0 || beta * det < 0) {\n      return null;\n    }\n    if (det > 0) {\n      if (alpha > det || beta > det) {\n        return null;\n      }\n    } else if (alpha < det || beta < det) {\n      return null;\n    }\n    return new Point(this.start.x + alpha * pt1Dir.x / det, this.start.y + alpha * pt1Dir.y / det);\n  }\n  /**\n   * Returns `true` if a tangent line can be found for the line.\n   *\n   * Tangents cannot be found if both of the line endpoints are coincident\n   * (the line appears to be a point).\n   */\n  isDifferentiable() {\n    return !this.start.equals(this.end);\n  }\n  /**\n   * Returns the perpendicular distance between the line and point. The\n   * distance is positive if the point lies to the right of the line, negative\n   * if the point lies to the left of the line, and `0` if the point lies on\n   * the line.\n   */\n  pointOffset(p) {\n    const ref = Point.clone(p);\n    const start = this.start;\n    const end = this.end;\n    const determinant = (end.x - start.x) * (ref.y - start.y) - (end.y - start.y) * (ref.x - start.x);\n    return determinant / this.length();\n  }\n  pointSquaredDistance(x, y) {\n    const p = Point.create(x, y);\n    return this.closestPoint(p).squaredDistance(p);\n  }\n  pointDistance(x, y) {\n    const p = Point.create(x, y);\n    return this.closestPoint(p).distance(p);\n  }\n  /**\n   * Returns a line tangent to the line at point that lies `rate` (normalized\n   * length) away from the beginning of the line.\n   */\n  tangentAt(ratio) {\n    if (!this.isDifferentiable()) {\n      return null;\n    }\n    const start = this.start;\n    const end = this.end;\n    const tangentStart = this.pointAt(ratio);\n    const tangentLine = new Line(start, end);\n    tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y);\n    return tangentLine;\n  }\n  /**\n   * Returns a line tangent to the line at point that lies `length` away from\n   * the beginning of the line.\n   */\n  tangentAtLength(length) {\n    if (!this.isDifferentiable()) {\n      return null;\n    }\n    const start = this.start;\n    const end = this.end;\n    const tangentStart = this.pointAtLength(length);\n    const tangentLine = new Line(start, end);\n    tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y);\n    return tangentLine;\n  }\n  relativeCcw(x, y) {\n    const ref = Point.create(x, y);\n    let dx1 = ref.x - this.start.x;\n    let dy1 = ref.y - this.start.y;\n    const dx2 = this.end.x - this.start.x;\n    const dy2 = this.end.y - this.start.y;\n    let ccw = dx1 * dy2 - dy1 * dx2;\n    if (ccw === 0) {\n      ccw = dx1 * dx2 + dy1 * dy2;\n      if (ccw > 0.0) {\n        dx1 -= dx2;\n        dy1 -= dy2;\n        ccw = dx1 * dx2 + dy1 * dy2;\n        if (ccw < 0.0) {\n          ccw = 0.0;\n        }\n      }\n    }\n    return ccw < 0.0 ? -1 : ccw > 0.0 ? 1 : 0;\n  }\n  /**\n   * Return `true` if the line equals the other line.\n   */\n  equals(l) {\n    return l != null && this.start.x === l.start.x && this.start.y === l.start.y && this.end.x === l.end.x && this.end.y === l.end.y;\n  }\n  /**\n   * Returns another line which is a clone of the line.\n   */\n  clone() {\n    return new Line(this.start, this.end);\n  }\n  toJSON() {\n    return {\n      start: this.start.toJSON(),\n      end: this.end.toJSON()\n    };\n  }\n  serialize() {\n    return [this.start.serialize(), this.end.serialize()].join(' ');\n  }\n}\n(function (Line) {\n  Line.toStringTag = `X6.Geometry.${Line.name}`;\n  function isLine(instance) {\n    if (instance == null) {\n      return false;\n    }\n    if (instance instanceof Line) {\n      return true;\n    }\n    const tag = instance[Symbol.toStringTag];\n    const line = instance;\n    try {\n      if ((tag == null || tag === Line.toStringTag) && Point.isPoint(line.start) && Point.isPoint(line.end) && typeof line.vector === 'function' && typeof line.bearing === 'function' && typeof line.parallel === 'function' && typeof line.intersect === 'function') {\n        return true;\n      }\n    } catch (e) {\n      return false;\n    }\n    return false;\n  }\n  Line.isLine = isLine;\n})(Line || (Line = {}));","map":{"version":3,"names":["Point","Geometry","Rectangle","Line","constructor","x1","y1","x2","y2","start","end","create","Symbol","toStringTag","center","x","y","getCenter","round","precision","translate","tx","ty","rotate","angle","origin","scale","sx","sy","length","Math","sqrt","squaredLength","dx","dy","setLength","total","parallel","distance","line","clone","isDifferentiable","eRef","sRef","move","vector","horizontal","angleBetween","bbox","left","min","top","right","max","bottom","bearing","closestPoint","p","pointAt","closestPointNormalizedLength","closestPointLength","closestPointTangent","tangentAt","product","dot","normalized","Number","isNaN","ratio","lerp","pointAtLength","fromStart","rate","divideAt","dividerPoint","divideAtLength","containsPoint","cross","intersect","shape","options","ret","intersectsWithLine","Array","isArray","pt1Dir","pt2Dir","det","deltaPt","alpha","beta","equals","pointOffset","ref","determinant","pointSquaredDistance","squaredDistance","pointDistance","tangentStart","tangentLine","tangentAtLength","relativeCcw","dx1","dy1","dx2","dy2","ccw","l","toJSON","serialize","join","name","isLine","instance","tag","isPoint","e"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/geometry/line.ts"],"sourcesContent":["import { Path } from './path'\nimport { Point } from './point'\nimport { Ellipse } from './ellipse'\nimport { Geometry } from './geometry'\nimport { Polyline } from './polyline'\nimport { Rectangle } from './rectangle'\n\nexport class Line extends Geometry {\n  public start: Point\n  public end: Point\n\n  protected get [Symbol.toStringTag]() {\n    return Line.toStringTag\n  }\n\n  get center() {\n    return new Point(\n      (this.start.x + this.end.x) / 2,\n      (this.start.y + this.end.y) / 2,\n    )\n  }\n\n  constructor(x1: number, y1: number, x2: number, y2: number)\n  constructor(\n    p1: Point.PointLike | Point.PointData,\n    p2: Point.PointLike | Point.PointData,\n  )\n  constructor(\n    x1: number | Point.PointLike | Point.PointData,\n    y1: number | Point.PointLike | Point.PointData,\n    x2?: number,\n    y2?: number,\n  ) {\n    super()\n    if (typeof x1 === 'number' && typeof y1 === 'number') {\n      this.start = new Point(x1, y1)\n      this.end = new Point(x2, y2)\n    } else {\n      this.start = Point.create(x1)\n      this.end = Point.create(y1)\n    }\n  }\n\n  getCenter() {\n    return this.center\n  }\n\n  /**\n   * Rounds the line to the given `precision`.\n   */\n  round(precision = 0) {\n    this.start.round(precision)\n    this.end.round(precision)\n    return this\n  }\n\n  translate(tx: number, ty: number): this\n  translate(p: Point.PointLike | Point.PointData): this\n  translate(tx: number | Point.PointLike | Point.PointData, ty?: number) {\n    if (typeof tx === 'number') {\n      this.start.translate(tx, ty as number)\n      this.end.translate(tx, ty as number)\n    } else {\n      this.start.translate(tx)\n      this.end.translate(tx)\n    }\n\n    return this\n  }\n\n  /**\n   * Rotate the line by `angle` around `origin`.\n   */\n  rotate(angle: number, origin?: Point.PointLike | Point.PointData) {\n    this.start.rotate(angle, origin)\n    this.end.rotate(angle, origin)\n    return this\n  }\n\n  /**\n   * Scale the line by `sx` and `sy` about the given `origin`. If origin is not\n   * specified, the line is scaled around `0,0`.\n   */\n  scale(sx: number, sy: number, origin?: Point.PointLike | Point.PointData) {\n    this.start.scale(sx, sy, origin)\n    this.end.scale(sx, sy, origin)\n    return this\n  }\n\n  /**\n   * Returns the length of the line.\n   */\n  length() {\n    return Math.sqrt(this.squaredLength())\n  }\n\n  /**\n   * Useful for distance comparisons in which real length is not necessary\n   * (saves one `Math.sqrt()` operation).\n   */\n  squaredLength() {\n    const dx = this.start.x - this.end.x\n    const dy = this.start.y - this.end.y\n    return dx * dx + dy * dy\n  }\n\n  /**\n   * Scale the line so that it has the requested length. The start point of\n   * the line is preserved.\n   */\n  setLength(length: number) {\n    const total = this.length()\n    if (!total) {\n      return this\n    }\n\n    const scale = length / total\n    return this.scale(scale, scale, this.start)\n  }\n\n  parallel(distance: number) {\n    const line = this.clone()\n    if (!line.isDifferentiable()) {\n      return line\n    }\n\n    const { start, end } = line\n    const eRef = start.clone().rotate(270, end)\n    const sRef = end.clone().rotate(90, start)\n    start.move(sRef, distance)\n    end.move(eRef, distance)\n    return line\n  }\n\n  /**\n   * Returns the vector of the line with length equal to length of the line.\n   */\n  vector() {\n    return new Point(this.end.x - this.start.x, this.end.y - this.start.y)\n  }\n\n  /**\n   * Returns the angle of incline of the line.\n   *\n   * The function returns `NaN` if the start and end endpoints of the line\n   * both lie at the same coordinates(it is impossible to determine the angle\n   * of incline of a line that appears to be a point). The\n   * `line.isDifferentiable()` function may be used in advance to determine\n   * whether the angle of incline can be computed for a given line.\n   */\n  angle() {\n    const horizontal = new Point(this.start.x + 1, this.start.y)\n    return this.start.angleBetween(this.end, horizontal)\n  }\n\n  /**\n   * Returns a rectangle that is the bounding box of the line.\n   */\n  bbox() {\n    const left = Math.min(this.start.x, this.end.x)\n    const top = Math.min(this.start.y, this.end.y)\n    const right = Math.max(this.start.x, this.end.x)\n    const bottom = Math.max(this.start.y, this.end.y)\n\n    return new Rectangle(left, top, right - left, bottom - top)\n  }\n\n  /**\n   * Returns the bearing (cardinal direction) of the line.\n   *\n   * The return value is one of the following strings:\n   * 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW' and 'N'.\n   *\n   * The function returns 'N' if the two endpoints of the line are coincident.\n   */\n  bearing() {\n    return this.start.bearing(this.end)\n  }\n\n  /**\n   * Returns the point on the line that lies closest to point `p`.\n   */\n  closestPoint(p: Point.PointLike | Point.PointData) {\n    return this.pointAt(this.closestPointNormalizedLength(p))\n  }\n\n  /**\n   * Returns the length of the line up to the point that lies closest to point `p`.\n   */\n  closestPointLength(p: Point.PointLike | Point.PointData) {\n    return this.closestPointNormalizedLength(p) * this.length()\n  }\n\n  /**\n   * Returns a line that is tangent to the line at the point that lies closest\n   * to point `p`.\n   */\n  closestPointTangent(p: Point.PointLike | Point.PointData) {\n    return this.tangentAt(this.closestPointNormalizedLength(p))\n  }\n\n  /**\n   * Returns the normalized length (distance from the start of the line / total\n   * line length) of the line up to the point that lies closest to point.\n   */\n  closestPointNormalizedLength(p: Point.PointLike | Point.PointData) {\n    const product = this.vector().dot(new Line(this.start, p).vector())\n    const normalized = Math.min(1, Math.max(0, product / this.squaredLength()))\n\n    // normalized returns `NaN` if this line has zero length\n    if (Number.isNaN(normalized)) {\n      return 0\n    }\n\n    return normalized\n  }\n\n  /**\n   * Returns a point on the line that lies `rate` (normalized length) away from\n   * the beginning of the line.\n   */\n  pointAt(ratio: number) {\n    const start = this.start\n    const end = this.end\n\n    if (ratio <= 0) {\n      return start.clone()\n    }\n\n    if (ratio >= 1) {\n      return end.clone()\n    }\n\n    return start.lerp(end, ratio)\n  }\n\n  /**\n   * Returns a point on the line that lies length away from the beginning of\n   * the line.\n   */\n  pointAtLength(length: number) {\n    const start = this.start\n    const end = this.end\n\n    let fromStart = true\n\n    if (length < 0) {\n      fromStart = false // start calculation from end point\n      length = -length // eslint-disable-line\n    }\n\n    const total = this.length()\n    if (length >= total) {\n      return fromStart ? end.clone() : start.clone()\n    }\n\n    const rate = (fromStart ? length : total - length) / total\n    return this.pointAt(rate)\n  }\n\n  /**\n   * Divides the line into two lines at the point that lies `rate` (normalized\n   * length) away from the beginning of the line.\n   */\n  divideAt(ratio: number) {\n    const dividerPoint = this.pointAt(ratio)\n    return [\n      new Line(this.start, dividerPoint),\n      new Line(dividerPoint, this.end),\n    ]\n  }\n\n  /**\n   * Divides the line into two lines at the point that lies length away from\n   * the beginning of the line.\n   */\n  divideAtLength(length: number) {\n    const dividerPoint = this.pointAtLength(length)\n    return [\n      new Line(this.start, dividerPoint),\n      new Line(dividerPoint, this.end),\n    ]\n  }\n\n  /**\n   * Returns `true` if the point `p` lies on the line. Return `false` otherwise.\n   */\n  containsPoint(p: Point.PointLike | Point.PointData) {\n    const start = this.start\n    const end = this.end\n\n    // cross product of 0 indicates that this line and\n    // the vector to `p` are collinear.\n    if (start.cross(p, end) !== 0) {\n      return false\n    }\n\n    const length = this.length()\n    if (new Line(start, p).length() > length) {\n      return false\n    }\n\n    if (new Line(p, end).length() > length) {\n      return false\n    }\n\n    return true\n  }\n\n  /**\n   * Returns an array of the intersection points of the line with another\n   * geometry shape.\n   */\n  intersect(shape: Line | Rectangle | Polyline | Ellipse): Point[] | null\n  intersect(shape: Path, options?: Path.Options): Point[] | null\n  intersect(\n    shape: Line | Rectangle | Polyline | Ellipse | Path,\n    options?: Path.Options,\n  ): Point[] | null {\n    const ret = shape.intersectsWithLine(this, options)\n    if (ret) {\n      return Array.isArray(ret) ? ret : [ret]\n    }\n\n    return null\n  }\n\n  /**\n   * Returns the intersection point of the line with another line. Returns\n   * `null` if no intersection exists.\n   */\n  intersectsWithLine(line: Line) {\n    const pt1Dir = new Point(\n      this.end.x - this.start.x,\n      this.end.y - this.start.y,\n    )\n    const pt2Dir = new Point(\n      line.end.x - line.start.x,\n      line.end.y - line.start.y,\n    )\n    const det = pt1Dir.x * pt2Dir.y - pt1Dir.y * pt2Dir.x\n    const deltaPt = new Point(\n      line.start.x - this.start.x,\n      line.start.y - this.start.y,\n    )\n    const alpha = deltaPt.x * pt2Dir.y - deltaPt.y * pt2Dir.x\n    const beta = deltaPt.x * pt1Dir.y - deltaPt.y * pt1Dir.x\n\n    if (det === 0 || alpha * det < 0 || beta * det < 0) {\n      return null\n    }\n\n    if (det > 0) {\n      if (alpha > det || beta > det) {\n        return null\n      }\n    } else if (alpha < det || beta < det) {\n      return null\n    }\n\n    return new Point(\n      this.start.x + (alpha * pt1Dir.x) / det,\n      this.start.y + (alpha * pt1Dir.y) / det,\n    )\n  }\n\n  /**\n   * Returns `true` if a tangent line can be found for the line.\n   *\n   * Tangents cannot be found if both of the line endpoints are coincident\n   * (the line appears to be a point).\n   */\n  isDifferentiable() {\n    return !this.start.equals(this.end)\n  }\n\n  /**\n   * Returns the perpendicular distance between the line and point. The\n   * distance is positive if the point lies to the right of the line, negative\n   * if the point lies to the left of the line, and `0` if the point lies on\n   * the line.\n   */\n  pointOffset(p: Point.PointLike | Point.PointData) {\n    const ref = Point.clone(p)\n    const start = this.start\n    const end = this.end\n    const determinant =\n      (end.x - start.x) * (ref.y - start.y) -\n      (end.y - start.y) * (ref.x - start.x)\n\n    return determinant / this.length()\n  }\n\n  /**\n   * Returns the squared distance between the line and the point.\n   */\n  pointSquaredDistance(x: number, y: number): number\n  pointSquaredDistance(p: Point.PointLike | Point.PointData): number\n  pointSquaredDistance(\n    x: number | Point.PointLike | Point.PointData,\n    y?: number,\n  ) {\n    const p = Point.create(x, y)\n    return this.closestPoint(p).squaredDistance(p)\n  }\n\n  /**\n   * Returns the distance between the line and the point.\n   */\n  pointDistance(x: number, y: number): number\n  pointDistance(p: Point.PointLike | Point.PointData): number\n  pointDistance(x: number | Point.PointLike | Point.PointData, y?: number) {\n    const p = Point.create(x, y)\n    return this.closestPoint(p).distance(p)\n  }\n\n  /**\n   * Returns a line tangent to the line at point that lies `rate` (normalized\n   * length) away from the beginning of the line.\n   */\n  tangentAt(ratio: number) {\n    if (!this.isDifferentiable()) {\n      return null\n    }\n\n    const start = this.start\n    const end = this.end\n\n    const tangentStart = this.pointAt(ratio)\n    const tangentLine = new Line(start, end)\n    tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y)\n\n    return tangentLine\n  }\n\n  /**\n   * Returns a line tangent to the line at point that lies `length` away from\n   * the beginning of the line.\n   */\n  tangentAtLength(length: number) {\n    if (!this.isDifferentiable()) {\n      return null\n    }\n\n    const start = this.start\n    const end = this.end\n\n    const tangentStart = this.pointAtLength(length)\n    const tangentLine = new Line(start, end)\n    tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y)\n\n    return tangentLine\n  }\n\n  /**\n   * Returns which direction the line would have to rotate in order to direct\n   * itself at a point.\n   *\n   * Returns 1 if the given point on the right side of the segment, 0 if its\n   * on the segment, and -1 if the point is on the left side of the segment.\n   *\n   * @see https://softwareengineering.stackexchange.com/questions/165776/what-do-ptlinedist-and-relativeccw-do\n   */\n  relativeCcw(x: number, y: number): -1 | 0 | 1\n  relativeCcw(p: Point.PointLike | Point.PointData): -1 | 0 | 1\n  relativeCcw(x: number | Point.PointLike | Point.PointData, y?: number) {\n    const ref = Point.create(x, y)\n\n    let dx1 = ref.x - this.start.x\n    let dy1 = ref.y - this.start.y\n    const dx2 = this.end.x - this.start.x\n    const dy2 = this.end.y - this.start.y\n\n    let ccw = dx1 * dy2 - dy1 * dx2\n    if (ccw === 0) {\n      ccw = dx1 * dx2 + dy1 * dy2\n      if (ccw > 0.0) {\n        dx1 -= dx2\n        dy1 -= dy2\n        ccw = dx1 * dx2 + dy1 * dy2\n        if (ccw < 0.0) {\n          ccw = 0.0\n        }\n      }\n    }\n\n    return ccw < 0.0 ? -1 : ccw > 0.0 ? 1 : 0\n  }\n\n  /**\n   * Return `true` if the line equals the other line.\n   */\n  equals(l: Line) {\n    return (\n      l != null &&\n      this.start.x === l.start.x &&\n      this.start.y === l.start.y &&\n      this.end.x === l.end.x &&\n      this.end.y === l.end.y\n    )\n  }\n\n  /**\n   * Returns another line which is a clone of the line.\n   */\n  clone() {\n    return new Line(this.start, this.end)\n  }\n\n  toJSON() {\n    return { start: this.start.toJSON(), end: this.end.toJSON() }\n  }\n\n  serialize() {\n    return [this.start.serialize(), this.end.serialize()].join(' ')\n  }\n}\n\nexport namespace Line {\n  export const toStringTag = `X6.Geometry.${Line.name}`\n\n  export function isLine(instance: any): instance is Line {\n    if (instance == null) {\n      return false\n    }\n\n    if (instance instanceof Line) {\n      return true\n    }\n\n    const tag = instance[Symbol.toStringTag]\n    const line = instance as Line\n\n    try {\n      if (\n        (tag == null || tag === toStringTag) &&\n        Point.isPoint(line.start) &&\n        Point.isPoint(line.end) &&\n        typeof line.vector === 'function' &&\n        typeof line.bearing === 'function' &&\n        typeof line.parallel === 'function' &&\n        typeof line.intersect === 'function'\n      ) {\n        return true\n      }\n    } catch (e) {\n      return false\n    }\n\n    return false\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}