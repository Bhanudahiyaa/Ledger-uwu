{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { rgb2arr } from '@antv/l7-utils';\nimport BaseModel from \"../../core/BaseModel\";\nimport { PolygonExtrudeTriangulation } from \"../../core/triangulation\";\nimport { loadImage } from \"../../utils/load-image\";\n/* babel-plugin-inline-import '../shaders/extrude/polygon_extrude_frag.glsl' */\nconst polygonExtrudeFrag = \"layout(std140) uniform commonUniforms {\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  float u_linearColor;\\n  float u_topsurface;\\n  float u_sidesurface;\\n  float u_heightfixed; // \\u9ED8\\u8BA4\\u4E0D\\u56FA\\u5B9A\\n  float u_raisingHeight;\\n};\\n\\nin vec4 v_Color;\\n#pragma include \\\"scene_uniforms\\\"\\n#pragma include \\\"picking\\\"\\nout vec4 outputColor;\\nvoid main() {\\n\\n     // top face\\n    if(u_topsurface < 1.0) {\\n      discard;\\n    }\\n\\n    outputColor = v_Color;\\n  \\n  outputColor = filterColor(outputColor);\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/extrude/polygon_extrude_picklight_frag.glsl' */\nconst polygonExtrudePickLightFrag = \"\\nlayout(std140) uniform commonUniforms {\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  float u_linearColor;\\n  float u_topsurface;\\n  float u_sidesurface;\\n  float u_heightfixed; // \\u9ED8\\u8BA4\\u4E0D\\u56FA\\u5B9A\\n  float u_raisingHeight;\\n};\\n\\nin vec4 v_Color;\\nin vec3 v_uvs;\\nin vec2 v_texture_data;\\nout vec4 outputColor;\\n\\n#pragma include \\\"scene_uniforms\\\"\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  float isSide =  v_texture_data.x;\\n  float sidey = v_uvs[2];\\n  float lightWeight = v_texture_data.y;\\n\\n  // Tip: \\u90E8\\u5206\\u673A\\u578B GPU \\u8BA1\\u7B97\\u7CBE\\u5EA6\\u517C\\u5BB9\\n  if(isSide < 0.999) {\\n    // side face\\n    if(u_sidesurface < 1.0) {\\n      discard;\\n    }\\n    \\n    if( u_linearColor == 1.0) {\\n      // side use linear\\n      vec4 linearColor = mix(u_targetColor, u_sourceColor, sidey);\\n      linearColor.rgb *= lightWeight;\\n      outputColor = linearColor;\\n    } else {\\n      // side notuse linear\\n       outputColor = v_Color;\\n    }\\n  } else {\\n    // top face\\n    if(u_topsurface < 1.0) {\\n      discard;\\n    }\\n    outputColor = v_Color;\\n  }\\n\\n  outputColor = filterColorAlpha(outputColor, lightWeight);\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/extrude/polygon_extrude_picklight_vert.glsl' */\nconst polygonExtrudePickLightVert = \"layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec3 a_uvs;\\n\\nlayout(std140) uniform commonUniforms {\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  float u_linearColor;\\n  float u_topsurface;\\n  float u_sidesurface;\\n  float u_heightfixed; // \\u9ED8\\u8BA4\\u4E0D\\u56FA\\u5B9A\\n  float u_raisingHeight;\\n};\\n\\nout vec4 v_Color;\\nout vec3 v_uvs;\\nout vec2 v_texture_data;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"light\\\"\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  v_uvs = a_uvs;\\n  // cal style mapping - \\u6570\\u636E\\u7EB9\\u7406\\u6620\\u5C04\\u90E8\\u5206\\u7684\\u8BA1\\u7B97\\n  vec4 pos = vec4(a_Position.xy, a_Position.z * a_Size, 1.0);\\n  vec4 project_pos = project_position(pos, a_Position64Low);\\n\\n  if (u_heightfixed > 0.0) {\\n    // \\u5224\\u65AD\\u51E0\\u4F55\\u4F53\\u662F\\u5426\\u56FA\\u5B9A\\u9AD8\\u5EA6\\n    project_pos.z = a_Position.z * a_Size;\\n    project_pos.z += u_raisingHeight;\\n    if (\\n      u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\\n      u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\\n    ) {\\n      float mapboxZoomScale = 4.0 / pow(2.0, 21.0 - u_Zoom);\\n      project_pos.z *= mapboxZoomScale;\\n      project_pos.z += u_raisingHeight * mapboxZoomScale;\\n    }\\n  }\\n\\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\\n  float lightWeight = calc_lighting(project_pos);\\n  v_texture_data = vec2(a_Position.z, lightWeight);\\n\\n  v_Color = vec4(a_Color.rgb * lightWeight, a_Color.w * opacity);\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/extrude/polygon_extrude_vert.glsl' */\nconst polygonExtrudeVert = \"layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec3 a_uvs;\\n\\nlayout(std140) uniform commonUniforms {\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  float u_linearColor;\\n  float u_topsurface;\\n  float u_sidesurface;\\n  float u_heightfixed; // \\u9ED8\\u8BA4\\u4E0D\\u56FA\\u5B9A\\n  float u_raisingHeight;\\n};\\n\\nout vec4 v_Color;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"light\\\"\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  float isSide = a_Position.z;\\n  float topU = a_uvs[0];\\n  float topV = 1.0 - a_uvs[1];\\n  float sidey = a_uvs[2];\\n\\n  vec4 pos = vec4(a_Position.xy, a_Position.z * a_Size, 1.0);\\n\\n  vec4 project_pos = project_position(pos, a_Position64Low);\\n  float lightWeight = calc_lighting(project_pos);\\n\\n  if (u_heightfixed > 0.0) {\\n    // \\u5224\\u65AD\\u51E0\\u4F55\\u4F53\\u662F\\u5426\\u56FA\\u5B9A\\u9AD8\\u5EA6\\n    project_pos.z = a_Position.z * a_Size;\\n    project_pos.z += u_raisingHeight;\\n\\n    if (\\n      u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\\n      u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\\n    ) {\\n      float mapboxZoomScale = 4.0 / pow(2.0, 21.0 - u_Zoom);\\n      project_pos.z *= mapboxZoomScale;\\n      project_pos.z += u_raisingHeight * mapboxZoomScale;\\n    }\\n  }\\n\\n gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\\n\\n  // Tip: \\u90E8\\u5206\\u673A\\u578B GPU \\u8BA1\\u7B97\\u7CBE\\u5EA6\\u517C\\u5BB9\\n  if (isSide < 0.999) {\\n    // side face\\n    // if(u_sidesurface < 1.0) {\\n    //   discard;\\n    // }\\n\\n    if (u_linearColor == 1.0) {\\n      vec4 linearColor = mix(u_targetColor, u_sourceColor, sidey);\\n      linearColor.rgb *= lightWeight;\\n      v_Color = linearColor;\\n    } else {\\n      v_Color = a_Color;\\n    }\\n\\n  } else {\\n    v_Color = a_Color;\\n  }\\n\\n  v_Color = vec4(v_Color.rgb * lightWeight, v_Color.w * opacity);\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/extrude/polygon_extrudetex_frag.glsl' */\nconst polygonExtrudeTexFrag = \"uniform sampler2D u_texture;\\n\\nlayout(std140) uniform commonUniforms {\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  float u_linearColor;\\n  float u_topsurface;\\n  float u_sidesurface;\\n  float u_heightfixed; // \\u9ED8\\u8BA4\\u4E0D\\u56FA\\u5B9A\\n  float u_raisingHeight;\\n};\\n\\nin vec4 v_Color;\\nin vec3 v_uvs;\\nin vec2 v_texture_data;\\n\\n#pragma include \\\"scene_uniforms\\\"\\n#pragma include \\\"picking\\\"\\n\\nout vec4 outputColor;\\n\\nvoid main() {\\n  float opacity = u_opacity;\\n  float isSide = v_texture_data.x;\\n  float lightWeight = v_texture_data.y;\\n  float topU = v_uvs[0];\\n  float topV = 1.0 - v_uvs[1];\\n  float sidey = v_uvs[2];\\n\\n  outputColor = texture(SAMPLER_2D(u_texture), vec2(topU, topV));\\n  // Tip: \\u90E8\\u5206\\u673A\\u578B GPU \\u8BA1\\u7B97\\u7CBE\\u5EA6\\u517C\\u5BB9\\n  if (isSide < 0.999) {// \\u662F\\u5426\\u662F\\u8FB9\\u7F18\\n    // side face\\n    if (u_sidesurface < 1.0) {\\n      discard;\\n    }\\n\\n    if (u_linearColor == 1.0) {\\n      vec4 linearColor = mix(u_targetColor, u_sourceColor, sidey);\\n      linearColor.rgb *= lightWeight;\\n      outputColor = linearColor;\\n    } else {\\n      outputColor = v_Color;\\n    }\\n  } else {\\n     // top face\\n    if (u_topsurface < 1.0) {\\n      discard;\\n    }\\n  }\\n  \\n  outputColor.a *= opacity;\\n  outputColor = filterColor(outputColor);\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/extrude/polygon_extrudetex_vert.glsl' */\nconst polygonExtrudeTexVert = \"layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec3 a_uvs;\\n\\nlayout(std140) uniform commonUniforms {\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  float u_linearColor;\\n  float u_topsurface;\\n  float u_sidesurface;\\n  float u_heightfixed; // \\u9ED8\\u8BA4\\u4E0D\\u56FA\\u5B9A\\n  float u_raisingHeight;\\n};\\n\\nout vec4 v_Color;\\nout vec3 v_uvs;\\nout vec2 v_texture_data;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"light\\\"\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  vec4 pos = vec4(a_Position.xy, a_Position.z * a_Size, 1.0);\\n  vec4 project_pos = project_position(pos, a_Position64Low);\\n  float lightWeight = calc_lighting(project_pos);\\n  v_uvs = a_uvs;\\n  v_Color = a_Color;\\n  v_Color.a *= opacity;\\n\\n  v_texture_data = vec2(a_Position.z, lightWeight);\\n\\n  if (u_heightfixed > 0.0) {\\n    // \\u5224\\u65AD\\u51E0\\u4F55\\u4F53\\u662F\\u5426\\u56FA\\u5B9A\\u9AD8\\u5EA6\\n    project_pos.z = a_Position.z * a_Size;\\n    project_pos.z += u_raisingHeight;\\n\\n    if (\\n      u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\\n      u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\\n    ) {\\n      float mapboxZoomScale = 4.0 / pow(2.0, 21.0 - u_Zoom);\\n      project_pos.z *= mapboxZoomScale;\\n      project_pos.z += u_raisingHeight * mapboxZoomScale;\\n    }\\n  }\\n\\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\nexport default class ExtrudeModel extends BaseModel {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"texture\", void 0);\n  }\n  get attributeLocation() {\n    return Object.assign(super.attributeLocation, {\n      MAX: super.attributeLocation.MAX,\n      SIZE: 9,\n      NORMAL: 10,\n      UV: 11\n    });\n  }\n  getUninforms() {\n    const commoninfo = this.getCommonUniformsInfo();\n    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());\n    this.updateStyleUnifoms();\n    return _objectSpread(_objectSpread({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);\n  }\n  getCommonUniformsInfo() {\n    const {\n      mapTexture,\n      heightfixed = false,\n      raisingHeight = 0,\n      topsurface = true,\n      sidesurface = true,\n      sourceColor,\n      targetColor\n    } = this.layer.getLayerConfig();\n\n    // 转化渐变色\n    let useLinearColor = 0; // 默认不生效\n    let sourceColorArr = [1, 1, 1, 1];\n    let targetColorArr = [1, 1, 1, 1];\n    if (sourceColor && targetColor) {\n      sourceColorArr = rgb2arr(sourceColor);\n      targetColorArr = rgb2arr(targetColor);\n      useLinearColor = 1;\n    }\n    const commonOptions = {\n      u_sourceColor: sourceColorArr,\n      u_targetColor: targetColorArr,\n      u_linearColor: useLinearColor,\n      // 控制侧面和顶面的显示隐藏\n      u_topsurface: Number(topsurface),\n      u_sidesurface: Number(sidesurface),\n      u_heightfixed: Number(heightfixed),\n      u_raisingHeight: Number(raisingHeight)\n    };\n    if (mapTexture && this.texture) {\n      // @ts-ignore\n      commonOptions.u_texture = this.texture;\n      this.textures = [this.texture];\n    }\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      yield _this.loadTexture();\n      return _this.buildModels();\n    })();\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        frag,\n        vert,\n        type\n      } = _this2.getShaders();\n      _this2.initUniformsBuffer();\n      const model = yield _this2.layer.buildLayerModel({\n        moduleName: type,\n        vertexShader: vert,\n        fragmentShader: frag,\n        depth: {\n          enable: true\n        },\n        defines: _this2.getDefines(),\n        inject: _this2.getInject(),\n        triangulation: PolygonExtrudeTriangulation\n      });\n      return [model];\n    })();\n  }\n  getShaders() {\n    const {\n      pickLight,\n      mapTexture\n    } = this.layer.getLayerConfig();\n    if (mapTexture) {\n      return {\n        frag: polygonExtrudeTexFrag,\n        vert: polygonExtrudeTexVert,\n        type: 'polygonExtrudeTexture'\n      };\n    }\n    if (pickLight) {\n      return {\n        frag: polygonExtrudePickLightFrag,\n        vert: polygonExtrudePickLightVert,\n        type: 'polygonExtrudePickLight'\n      };\n    } else {\n      return {\n        frag: polygonExtrudeFrag,\n        vert: polygonExtrudeVert,\n        type: 'polygonExtrude'\n      };\n    }\n  }\n  clearModels() {\n    var _this$texture;\n    (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();\n    this.textures = [];\n  }\n  registerBuiltinAttributes() {\n    const bounds = this.layer.getSource().extent;\n    const lngLen = bounds[2] - bounds[0];\n    const latLen = bounds[3] - bounds[1];\n\n    // 注册 Position 属性 64 位地位部分，经纬度数据开启双精度，避免大于 22 层级以上出现数据偏移\n    this.registerPosition64LowAttribute();\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'uvs',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_uvs',\n        shaderLocation: this.attributeLocation.UV,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.STATIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        update: (feature, featureIdx, vertex) => {\n          const lng = vertex[0];\n          const lat = vertex[1];\n          // 临时 兼容高德V2\n          return [(lng - bounds[0]) / lngLen, (lat - bounds[1]) / latLen, vertex[4]];\n        }\n      }\n    });\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'normal',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Normal',\n        shaderLocation: this.attributeLocation.NORMAL,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.STATIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        update: (feature, featureIdx, vertex, attributeIdx, normal) => {\n          return normal;\n        }\n      }\n    });\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Size',\n        shaderLocation: this.attributeLocation.SIZE,\n        buffer: {\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 1,\n        update: feature => {\n          const {\n            size = 10\n          } = feature;\n          return Array.isArray(size) ? [size[0]] : [size];\n        }\n      }\n    });\n  }\n  loadTexture() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        mapTexture\n      } = _this3.layer.getLayerConfig();\n      const {\n        createTexture2D\n      } = _this3.rendererService;\n      _this3.texture = createTexture2D({\n        height: 1,\n        width: 1\n      });\n      if (mapTexture) {\n        const image = yield loadImage(mapTexture);\n        _this3.texture = createTexture2D({\n          data: image,\n          width: image.width,\n          height: image.height,\n          wrapS: gl.CLAMP_TO_EDGE,\n          wrapT: gl.CLAMP_TO_EDGE,\n          min: gl.LINEAR,\n          mag: gl.LINEAR\n        });\n      }\n    })();\n  }\n}","map":{"version":3,"names":["_asyncToGenerator","_objectSpread","_defineProperty","AttributeType","gl","rgb2arr","BaseModel","PolygonExtrudeTriangulation","loadImage","polygonExtrudeFrag","polygonExtrudePickLightFrag","polygonExtrudePickLightVert","polygonExtrudeVert","polygonExtrudeTexFrag","polygonExtrudeTexVert","ExtrudeModel","constructor","args","attributeLocation","Object","assign","MAX","SIZE","NORMAL","UV","getUninforms","commoninfo","getCommonUniformsInfo","attributeInfo","getUniformsBufferInfo","getStyleAttribute","updateStyleUnifoms","uniformsOption","mapTexture","heightfixed","raisingHeight","topsurface","sidesurface","sourceColor","targetColor","layer","getLayerConfig","useLinearColor","sourceColorArr","targetColorArr","commonOptions","u_sourceColor","u_targetColor","u_linearColor","u_topsurface","Number","u_sidesurface","u_heightfixed","u_raisingHeight","texture","u_texture","textures","commonBufferInfo","initModels","_this","loadTexture","buildModels","_this2","frag","vert","type","getShaders","initUniformsBuffer","model","buildLayerModel","moduleName","vertexShader","fragmentShader","depth","enable","defines","getDefines","inject","getInject","triangulation","pickLight","clearModels","_this$texture","destroy","registerBuiltinAttributes","bounds","getSource","extent","lngLen","latLen","registerPosition64LowAttribute","styleAttributeService","registerStyleAttribute","name","Attribute","descriptor","shaderLocation","buffer","usage","STATIC_DRAW","data","FLOAT","size","update","feature","featureIdx","vertex","lng","lat","attributeIdx","normal","DYNAMIC_DRAW","Array","isArray","_this3","createTexture2D","rendererService","height","width","image","wrapS","CLAMP_TO_EDGE","wrapT","min","LINEAR","mag"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/l7-layers/es/polygon/models/extrude.js"],"sourcesContent":["import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { rgb2arr } from '@antv/l7-utils';\nimport BaseModel from \"../../core/BaseModel\";\nimport { PolygonExtrudeTriangulation } from \"../../core/triangulation\";\nimport { loadImage } from \"../../utils/load-image\";\n/* babel-plugin-inline-import '../shaders/extrude/polygon_extrude_frag.glsl' */\nconst polygonExtrudeFrag = \"layout(std140) uniform commonUniforms {\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  float u_linearColor;\\n  float u_topsurface;\\n  float u_sidesurface;\\n  float u_heightfixed; // \\u9ED8\\u8BA4\\u4E0D\\u56FA\\u5B9A\\n  float u_raisingHeight;\\n};\\n\\nin vec4 v_Color;\\n#pragma include \\\"scene_uniforms\\\"\\n#pragma include \\\"picking\\\"\\nout vec4 outputColor;\\nvoid main() {\\n\\n     // top face\\n    if(u_topsurface < 1.0) {\\n      discard;\\n    }\\n\\n    outputColor = v_Color;\\n  \\n  outputColor = filterColor(outputColor);\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/extrude/polygon_extrude_picklight_frag.glsl' */\nconst polygonExtrudePickLightFrag = \"\\nlayout(std140) uniform commonUniforms {\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  float u_linearColor;\\n  float u_topsurface;\\n  float u_sidesurface;\\n  float u_heightfixed; // \\u9ED8\\u8BA4\\u4E0D\\u56FA\\u5B9A\\n  float u_raisingHeight;\\n};\\n\\nin vec4 v_Color;\\nin vec3 v_uvs;\\nin vec2 v_texture_data;\\nout vec4 outputColor;\\n\\n#pragma include \\\"scene_uniforms\\\"\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  float isSide =  v_texture_data.x;\\n  float sidey = v_uvs[2];\\n  float lightWeight = v_texture_data.y;\\n\\n  // Tip: \\u90E8\\u5206\\u673A\\u578B GPU \\u8BA1\\u7B97\\u7CBE\\u5EA6\\u517C\\u5BB9\\n  if(isSide < 0.999) {\\n    // side face\\n    if(u_sidesurface < 1.0) {\\n      discard;\\n    }\\n    \\n    if( u_linearColor == 1.0) {\\n      // side use linear\\n      vec4 linearColor = mix(u_targetColor, u_sourceColor, sidey);\\n      linearColor.rgb *= lightWeight;\\n      outputColor = linearColor;\\n    } else {\\n      // side notuse linear\\n       outputColor = v_Color;\\n    }\\n  } else {\\n    // top face\\n    if(u_topsurface < 1.0) {\\n      discard;\\n    }\\n    outputColor = v_Color;\\n  }\\n\\n  outputColor = filterColorAlpha(outputColor, lightWeight);\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/extrude/polygon_extrude_picklight_vert.glsl' */\nconst polygonExtrudePickLightVert = \"layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec3 a_uvs;\\n\\nlayout(std140) uniform commonUniforms {\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  float u_linearColor;\\n  float u_topsurface;\\n  float u_sidesurface;\\n  float u_heightfixed; // \\u9ED8\\u8BA4\\u4E0D\\u56FA\\u5B9A\\n  float u_raisingHeight;\\n};\\n\\nout vec4 v_Color;\\nout vec3 v_uvs;\\nout vec2 v_texture_data;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"light\\\"\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  v_uvs = a_uvs;\\n  // cal style mapping - \\u6570\\u636E\\u7EB9\\u7406\\u6620\\u5C04\\u90E8\\u5206\\u7684\\u8BA1\\u7B97\\n  vec4 pos = vec4(a_Position.xy, a_Position.z * a_Size, 1.0);\\n  vec4 project_pos = project_position(pos, a_Position64Low);\\n\\n  if (u_heightfixed > 0.0) {\\n    // \\u5224\\u65AD\\u51E0\\u4F55\\u4F53\\u662F\\u5426\\u56FA\\u5B9A\\u9AD8\\u5EA6\\n    project_pos.z = a_Position.z * a_Size;\\n    project_pos.z += u_raisingHeight;\\n    if (\\n      u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\\n      u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\\n    ) {\\n      float mapboxZoomScale = 4.0 / pow(2.0, 21.0 - u_Zoom);\\n      project_pos.z *= mapboxZoomScale;\\n      project_pos.z += u_raisingHeight * mapboxZoomScale;\\n    }\\n  }\\n\\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\\n  float lightWeight = calc_lighting(project_pos);\\n  v_texture_data = vec2(a_Position.z, lightWeight);\\n\\n  v_Color = vec4(a_Color.rgb * lightWeight, a_Color.w * opacity);\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/extrude/polygon_extrude_vert.glsl' */\nconst polygonExtrudeVert = \"layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec3 a_uvs;\\n\\nlayout(std140) uniform commonUniforms {\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  float u_linearColor;\\n  float u_topsurface;\\n  float u_sidesurface;\\n  float u_heightfixed; // \\u9ED8\\u8BA4\\u4E0D\\u56FA\\u5B9A\\n  float u_raisingHeight;\\n};\\n\\nout vec4 v_Color;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"light\\\"\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  float isSide = a_Position.z;\\n  float topU = a_uvs[0];\\n  float topV = 1.0 - a_uvs[1];\\n  float sidey = a_uvs[2];\\n\\n  vec4 pos = vec4(a_Position.xy, a_Position.z * a_Size, 1.0);\\n\\n  vec4 project_pos = project_position(pos, a_Position64Low);\\n  float lightWeight = calc_lighting(project_pos);\\n\\n  if (u_heightfixed > 0.0) {\\n    // \\u5224\\u65AD\\u51E0\\u4F55\\u4F53\\u662F\\u5426\\u56FA\\u5B9A\\u9AD8\\u5EA6\\n    project_pos.z = a_Position.z * a_Size;\\n    project_pos.z += u_raisingHeight;\\n\\n    if (\\n      u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\\n      u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\\n    ) {\\n      float mapboxZoomScale = 4.0 / pow(2.0, 21.0 - u_Zoom);\\n      project_pos.z *= mapboxZoomScale;\\n      project_pos.z += u_raisingHeight * mapboxZoomScale;\\n    }\\n  }\\n\\n gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\\n\\n  // Tip: \\u90E8\\u5206\\u673A\\u578B GPU \\u8BA1\\u7B97\\u7CBE\\u5EA6\\u517C\\u5BB9\\n  if (isSide < 0.999) {\\n    // side face\\n    // if(u_sidesurface < 1.0) {\\n    //   discard;\\n    // }\\n\\n    if (u_linearColor == 1.0) {\\n      vec4 linearColor = mix(u_targetColor, u_sourceColor, sidey);\\n      linearColor.rgb *= lightWeight;\\n      v_Color = linearColor;\\n    } else {\\n      v_Color = a_Color;\\n    }\\n\\n  } else {\\n    v_Color = a_Color;\\n  }\\n\\n  v_Color = vec4(v_Color.rgb * lightWeight, v_Color.w * opacity);\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/extrude/polygon_extrudetex_frag.glsl' */\nconst polygonExtrudeTexFrag = \"uniform sampler2D u_texture;\\n\\nlayout(std140) uniform commonUniforms {\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  float u_linearColor;\\n  float u_topsurface;\\n  float u_sidesurface;\\n  float u_heightfixed; // \\u9ED8\\u8BA4\\u4E0D\\u56FA\\u5B9A\\n  float u_raisingHeight;\\n};\\n\\nin vec4 v_Color;\\nin vec3 v_uvs;\\nin vec2 v_texture_data;\\n\\n#pragma include \\\"scene_uniforms\\\"\\n#pragma include \\\"picking\\\"\\n\\nout vec4 outputColor;\\n\\nvoid main() {\\n  float opacity = u_opacity;\\n  float isSide = v_texture_data.x;\\n  float lightWeight = v_texture_data.y;\\n  float topU = v_uvs[0];\\n  float topV = 1.0 - v_uvs[1];\\n  float sidey = v_uvs[2];\\n\\n  outputColor = texture(SAMPLER_2D(u_texture), vec2(topU, topV));\\n  // Tip: \\u90E8\\u5206\\u673A\\u578B GPU \\u8BA1\\u7B97\\u7CBE\\u5EA6\\u517C\\u5BB9\\n  if (isSide < 0.999) {// \\u662F\\u5426\\u662F\\u8FB9\\u7F18\\n    // side face\\n    if (u_sidesurface < 1.0) {\\n      discard;\\n    }\\n\\n    if (u_linearColor == 1.0) {\\n      vec4 linearColor = mix(u_targetColor, u_sourceColor, sidey);\\n      linearColor.rgb *= lightWeight;\\n      outputColor = linearColor;\\n    } else {\\n      outputColor = v_Color;\\n    }\\n  } else {\\n     // top face\\n    if (u_topsurface < 1.0) {\\n      discard;\\n    }\\n  }\\n  \\n  outputColor.a *= opacity;\\n  outputColor = filterColor(outputColor);\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/extrude/polygon_extrudetex_vert.glsl' */\nconst polygonExtrudeTexVert = \"layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec3 a_uvs;\\n\\nlayout(std140) uniform commonUniforms {\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  float u_linearColor;\\n  float u_topsurface;\\n  float u_sidesurface;\\n  float u_heightfixed; // \\u9ED8\\u8BA4\\u4E0D\\u56FA\\u5B9A\\n  float u_raisingHeight;\\n};\\n\\nout vec4 v_Color;\\nout vec3 v_uvs;\\nout vec2 v_texture_data;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"light\\\"\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  vec4 pos = vec4(a_Position.xy, a_Position.z * a_Size, 1.0);\\n  vec4 project_pos = project_position(pos, a_Position64Low);\\n  float lightWeight = calc_lighting(project_pos);\\n  v_uvs = a_uvs;\\n  v_Color = a_Color;\\n  v_Color.a *= opacity;\\n\\n  v_texture_data = vec2(a_Position.z, lightWeight);\\n\\n  if (u_heightfixed > 0.0) {\\n    // \\u5224\\u65AD\\u51E0\\u4F55\\u4F53\\u662F\\u5426\\u56FA\\u5B9A\\u9AD8\\u5EA6\\n    project_pos.z = a_Position.z * a_Size;\\n    project_pos.z += u_raisingHeight;\\n\\n    if (\\n      u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\\n      u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\\n    ) {\\n      float mapboxZoomScale = 4.0 / pow(2.0, 21.0 - u_Zoom);\\n      project_pos.z *= mapboxZoomScale;\\n      project_pos.z += u_raisingHeight * mapboxZoomScale;\\n    }\\n  }\\n\\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\nexport default class ExtrudeModel extends BaseModel {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"texture\", void 0);\n  }\n  get attributeLocation() {\n    return Object.assign(super.attributeLocation, {\n      MAX: super.attributeLocation.MAX,\n      SIZE: 9,\n      NORMAL: 10,\n      UV: 11\n    });\n  }\n  getUninforms() {\n    const commoninfo = this.getCommonUniformsInfo();\n    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());\n    this.updateStyleUnifoms();\n    return _objectSpread(_objectSpread({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);\n  }\n  getCommonUniformsInfo() {\n    const {\n      mapTexture,\n      heightfixed = false,\n      raisingHeight = 0,\n      topsurface = true,\n      sidesurface = true,\n      sourceColor,\n      targetColor\n    } = this.layer.getLayerConfig();\n\n    // 转化渐变色\n    let useLinearColor = 0; // 默认不生效\n    let sourceColorArr = [1, 1, 1, 1];\n    let targetColorArr = [1, 1, 1, 1];\n    if (sourceColor && targetColor) {\n      sourceColorArr = rgb2arr(sourceColor);\n      targetColorArr = rgb2arr(targetColor);\n      useLinearColor = 1;\n    }\n    const commonOptions = {\n      u_sourceColor: sourceColorArr,\n      u_targetColor: targetColorArr,\n      u_linearColor: useLinearColor,\n      // 控制侧面和顶面的显示隐藏\n      u_topsurface: Number(topsurface),\n      u_sidesurface: Number(sidesurface),\n      u_heightfixed: Number(heightfixed),\n      u_raisingHeight: Number(raisingHeight)\n    };\n    if (mapTexture && this.texture) {\n      // @ts-ignore\n      commonOptions.u_texture = this.texture;\n      this.textures = [this.texture];\n    }\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      yield _this.loadTexture();\n      return _this.buildModels();\n    })();\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        frag,\n        vert,\n        type\n      } = _this2.getShaders();\n      _this2.initUniformsBuffer();\n      const model = yield _this2.layer.buildLayerModel({\n        moduleName: type,\n        vertexShader: vert,\n        fragmentShader: frag,\n        depth: {\n          enable: true\n        },\n        defines: _this2.getDefines(),\n        inject: _this2.getInject(),\n        triangulation: PolygonExtrudeTriangulation\n      });\n      return [model];\n    })();\n  }\n  getShaders() {\n    const {\n      pickLight,\n      mapTexture\n    } = this.layer.getLayerConfig();\n    if (mapTexture) {\n      return {\n        frag: polygonExtrudeTexFrag,\n        vert: polygonExtrudeTexVert,\n        type: 'polygonExtrudeTexture'\n      };\n    }\n    if (pickLight) {\n      return {\n        frag: polygonExtrudePickLightFrag,\n        vert: polygonExtrudePickLightVert,\n        type: 'polygonExtrudePickLight'\n      };\n    } else {\n      return {\n        frag: polygonExtrudeFrag,\n        vert: polygonExtrudeVert,\n        type: 'polygonExtrude'\n      };\n    }\n  }\n  clearModels() {\n    var _this$texture;\n    (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();\n    this.textures = [];\n  }\n  registerBuiltinAttributes() {\n    const bounds = this.layer.getSource().extent;\n    const lngLen = bounds[2] - bounds[0];\n    const latLen = bounds[3] - bounds[1];\n\n    // 注册 Position 属性 64 位地位部分，经纬度数据开启双精度，避免大于 22 层级以上出现数据偏移\n    this.registerPosition64LowAttribute();\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'uvs',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_uvs',\n        shaderLocation: this.attributeLocation.UV,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.STATIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        update: (feature, featureIdx, vertex) => {\n          const lng = vertex[0];\n          const lat = vertex[1];\n          // 临时 兼容高德V2\n          return [(lng - bounds[0]) / lngLen, (lat - bounds[1]) / latLen, vertex[4]];\n        }\n      }\n    });\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'normal',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Normal',\n        shaderLocation: this.attributeLocation.NORMAL,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.STATIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        update: (feature, featureIdx, vertex, attributeIdx, normal) => {\n          return normal;\n        }\n      }\n    });\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Size',\n        shaderLocation: this.attributeLocation.SIZE,\n        buffer: {\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 1,\n        update: feature => {\n          const {\n            size = 10\n          } = feature;\n          return Array.isArray(size) ? [size[0]] : [size];\n        }\n      }\n    });\n  }\n  loadTexture() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        mapTexture\n      } = _this3.layer.getLayerConfig();\n      const {\n        createTexture2D\n      } = _this3.rendererService;\n      _this3.texture = createTexture2D({\n        height: 1,\n        width: 1\n      });\n      if (mapTexture) {\n        const image = yield loadImage(mapTexture);\n        _this3.texture = createTexture2D({\n          data: image,\n          width: image.width,\n          height: image.height,\n          wrapS: gl.CLAMP_TO_EDGE,\n          wrapT: gl.CLAMP_TO_EDGE,\n          min: gl.LINEAR,\n          mag: gl.LINEAR\n        });\n      }\n    })();\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}