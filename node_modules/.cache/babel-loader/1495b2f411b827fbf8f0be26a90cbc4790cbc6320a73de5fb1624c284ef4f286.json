{"ast":null,"code":"import _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\nvar _dec, _dec2, _class, _class2, _descriptor, _class3, _temp;\nimport { Frustum, IDENTIFIER } from '@antv/g-webgpu-core';\nimport { mat3, mat4, quat, vec3, vec4 } from 'gl-matrix';\nimport { inject, injectable } from 'inversify';\nimport { createVec3, getAngle } from '../utils/math';\nimport Landmark from './Landmark';\nexport var CAMERA_TYPE;\n(function (CAMERA_TYPE) {\n  CAMERA_TYPE[\"ORBITING\"] = \"ORBITING\";\n  CAMERA_TYPE[\"EXPLORING\"] = \"EXPLORING\";\n  CAMERA_TYPE[\"TRACKING\"] = \"TRACKING\";\n})(CAMERA_TYPE || (CAMERA_TYPE = {}));\nexport var CAMERA_TRACKING_MODE;\n(function (CAMERA_TRACKING_MODE) {\n  CAMERA_TRACKING_MODE[\"DEFAULT\"] = \"DEFAULT\";\n  CAMERA_TRACKING_MODE[\"ROTATIONAL\"] = \"ROTATIONAL\";\n  CAMERA_TRACKING_MODE[\"TRANSLATIONAL\"] = \"TRANSLATIONAL\";\n  CAMERA_TRACKING_MODE[\"CINEMATIC\"] = \"CINEMATIC\";\n})(CAMERA_TRACKING_MODE || (CAMERA_TRACKING_MODE = {}));\nexport var CAMERA_PROJECTION_MODE;\n(function (CAMERA_PROJECTION_MODE) {\n  CAMERA_PROJECTION_MODE[\"ORTHOGRAPHIC\"] = \"ORTHOGRAPHIC\";\n  CAMERA_PROJECTION_MODE[\"PERSPECTIVE\"] = \"PERSPECTIVE\";\n})(CAMERA_PROJECTION_MODE || (CAMERA_PROJECTION_MODE = {}));\nvar DEG_2_RAD = Math.PI / 180;\nvar RAD_2_DEG = 180 / Math.PI;\n/**\n * 参考「WebGL Insights - 23.Designing Cameras for WebGL Applications」，基于 Responsible Camera 思路设计\n * 保存相机参数，定义相机动作：\n * 1. dolly 沿 n 轴移动\n * 2. pan 沿 u v 轴移动\n * 3. rotate 以方位角旋转\n * 4. 移动到 Landmark，具有平滑的动画效果，其间禁止其他用户交互\n */\n\nexport var Camera = (_dec = injectable(), _dec2 = inject(IDENTIFIER.InteractorService), _dec(_class = (_class2 = (_temp = _class3 = /*#__PURE__*/function () {\n  function Camera() {\n    _classCallCheck(this, Camera);\n    this.matrix = mat4.create();\n    this.right = vec3.fromValues(1, 0, 0);\n    this.up = vec3.fromValues(0, 1, 0);\n    this.forward = vec3.fromValues(0, 0, 1);\n    this.position = vec3.fromValues(0, 0, 1);\n    this.focalPoint = vec3.fromValues(0, 0, 0);\n    this.distanceVector = vec3.fromValues(0, 0, 0);\n    this.distance = 1;\n    this.azimuth = 0;\n    this.elevation = 0;\n    this.roll = 0;\n    this.relAzimuth = 0;\n    this.relElevation = 0;\n    this.relRoll = 0;\n    this.dollyingStep = 0;\n    this.maxDistance = Infinity;\n    this.minDistance = -Infinity;\n    this.rotateWorld = false;\n    _initializerDefineProperty(this, \"interactor\", _descriptor, this);\n    this.fov = 30;\n    this.near = 0.1;\n    this.far = 10000;\n    this.aspect = 1;\n    this.left = void 0;\n    this.rright = void 0;\n    this.top = void 0;\n    this.bottom = void 0;\n    this.zoom = 1;\n    this.perspective = mat4.create();\n    this.view = void 0;\n    this.following = undefined;\n    this.type = CAMERA_TYPE.EXPLORING;\n    this.trackingMode = CAMERA_TRACKING_MODE.DEFAULT;\n    this.projectionMode = CAMERA_PROJECTION_MODE.PERSPECTIVE;\n    this.frustum = new Frustum();\n    this.landmarks = [];\n    this.landmarkAnimationID = void 0;\n  }\n  _createClass(Camera, [{\n    key: \"clone\",\n    value: function clone() {\n      var camera = new Camera();\n      camera.setType(this.type, undefined);\n      camera.interactor = this.interactor;\n      return camera;\n    }\n  }, {\n    key: \"getProjectionMode\",\n    value: function getProjectionMode() {\n      return this.projectionMode;\n    }\n  }, {\n    key: \"getPerspective\",\n    value: function getPerspective() {\n      return this.perspective;\n    }\n  }, {\n    key: \"getFrustum\",\n    value: function getFrustum() {\n      return this.frustum;\n    }\n  }, {\n    key: \"getPosition\",\n    value: function getPosition() {\n      return this.position;\n    }\n  }, {\n    key: \"setType\",\n    value: function setType(type, trackingMode) {\n      this.type = type;\n      if (this.type === CAMERA_TYPE.EXPLORING) {\n        this.setWorldRotation(true);\n      } else {\n        this.setWorldRotation(false);\n      }\n      this._getAngles();\n      if (this.type === CAMERA_TYPE.TRACKING && trackingMode !== undefined) {\n        this.setTrackingMode(trackingMode);\n      }\n      return this;\n    }\n  }, {\n    key: \"setProjectionMode\",\n    value: function setProjectionMode(projectionMode) {\n      this.projectionMode = projectionMode;\n      return this;\n    }\n  }, {\n    key: \"setTrackingMode\",\n    value: function setTrackingMode(trackingMode) {\n      if (this.type !== CAMERA_TYPE.TRACKING) {\n        throw new Error('Impossible to set a tracking mode if the camera is not of tracking type');\n      }\n      this.trackingMode = trackingMode;\n      return this;\n    }\n    /**\n     * If flag is true, it reverses the azimuth and elevation angles.\n     * Subsequent calls to rotate, setAzimuth, setElevation,\n     * changeAzimuth or changeElevation will cause the inverted effect.\n     * setRoll or changeRoll is not affected by this method.\n     *\n     * This inversion is useful when one wants to simulate that the world\n     * is moving, instead of the camera.\n     *\n     * By default the camera angles are not reversed.\n     * @param {Boolean} flag the boolean flag to reverse the angles.\n     */\n  }, {\n    key: \"setWorldRotation\",\n    value: function setWorldRotation(flag) {\n      this.rotateWorld = flag;\n      this._getAngles();\n    }\n    /**\n     * 计算 MV 矩阵，为相机矩阵的逆矩阵\n     */\n  }, {\n    key: \"getViewTransform\",\n    value: function getViewTransform() {\n      return mat4.invert(mat4.create(), this.matrix);\n    }\n  }, {\n    key: \"getWorldTransform\",\n    value: function getWorldTransform() {\n      return this.matrix;\n    }\n    /**\n     * 设置相机矩阵\n     */\n  }, {\n    key: \"setMatrix\",\n    value: function setMatrix(matrix) {\n      this.matrix = matrix;\n      this._update();\n      return this;\n    }\n  }, {\n    key: \"setAspect\",\n    value: function setAspect(aspect) {\n      this.setPerspective(this.near, this.far, this.fov, aspect);\n      return this;\n    }\n    /**\n     * Sets an offset in a larger frustum, used in PixelPicking\n     */\n  }, {\n    key: \"setViewOffset\",\n    value: function setViewOffset(fullWidth, fullHeight, x, y, width, height) {\n      this.aspect = fullWidth / fullHeight;\n      if (this.view === undefined) {\n        this.view = {\n          enabled: true,\n          fullWidth: 1,\n          fullHeight: 1,\n          offsetX: 0,\n          offsetY: 0,\n          width: 1,\n          height: 1\n        };\n      }\n      this.view.enabled = true;\n      this.view.fullWidth = fullWidth;\n      this.view.fullHeight = fullHeight;\n      this.view.offsetX = x;\n      this.view.offsetY = y;\n      this.view.width = width;\n      this.view.height = height;\n      if (this.projectionMode === CAMERA_PROJECTION_MODE.PERSPECTIVE) {\n        this.setPerspective(this.near, this.far, this.fov, this.aspect);\n      } else {\n        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);\n      }\n      return this;\n    }\n  }, {\n    key: \"clearViewOffset\",\n    value: function clearViewOffset() {\n      if (this.view !== undefined) {\n        this.view.enabled = false;\n      }\n      if (this.projectionMode === CAMERA_PROJECTION_MODE.PERSPECTIVE) {\n        this.setPerspective(this.near, this.far, this.fov, this.aspect);\n      } else {\n        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);\n      }\n      return this;\n    }\n  }, {\n    key: \"setPerspective\",\n    value: function setPerspective(near, far, fov, aspect) {\n      this.projectionMode = CAMERA_PROJECTION_MODE.PERSPECTIVE;\n      this.fov = fov;\n      this.near = near;\n      this.far = far;\n      this.aspect = aspect;\n      mat4.perspective(this.perspective, this.fov * DEG_2_RAD, this.aspect, this.near, this.far);\n      return this;\n    }\n  }, {\n    key: \"setOrthographic\",\n    value: function setOrthographic(l, r, t, b, near, far) {\n      this.projectionMode = CAMERA_PROJECTION_MODE.ORTHOGRAPHIC;\n      this.rright = r;\n      this.left = l;\n      this.top = t;\n      this.bottom = b;\n      this.near = near;\n      this.far = far;\n      var dx = (this.rright - this.left) / (2 * this.zoom);\n      var dy = (this.top - this.bottom) / (2 * this.zoom);\n      var cx = (this.rright + this.left) / 2;\n      var cy = (this.top + this.bottom) / 2;\n      var left = cx - dx;\n      var right = cx + dx;\n      var top = cy + dy;\n      var bottom = cy - dy;\n      if (this.view !== undefined && this.view.enabled) {\n        var scaleW = (this.rright - this.left) / this.view.fullWidth / this.zoom;\n        var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;\n        left += scaleW * this.view.offsetX;\n        right = left + scaleW * this.view.width;\n        top -= scaleH * this.view.offsetY;\n        bottom = top - scaleH * this.view.height;\n      }\n      mat4.ortho(this.perspective, left, right, top, bottom, near, far);\n      return this;\n    }\n    /**\n     * 设置相机位置\n     */\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(x, y, z) {\n      this._setPosition(x, y, z);\n      this.setFocalPoint(this.focalPoint);\n      return this;\n    }\n    /**\n     * 设置视点位置\n     */\n  }, {\n    key: \"setFocalPoint\",\n    value: function setFocalPoint(x, y, z) {\n      var up = vec3.fromValues(0, 1, 0);\n      this.focalPoint = createVec3(x, y, z);\n      if (this.trackingMode === CAMERA_TRACKING_MODE.CINEMATIC) {\n        var d = vec3.subtract(vec3.create(), this.focalPoint, this.position);\n        x = d[0];\n        y = d[1];\n        z = d[2];\n        var r = vec3.length(d);\n        var el = Math.asin(y / r) * RAD_2_DEG;\n        var az = 90 + Math.atan2(z, x) * RAD_2_DEG;\n        var m = mat4.create();\n        mat4.rotateY(m, m, az * DEG_2_RAD);\n        mat4.rotateX(m, m, el * DEG_2_RAD);\n        up = vec3.transformMat4(vec3.create(), [0, 1, 0], m);\n      }\n      mat4.invert(this.matrix, mat4.lookAt(mat4.create(), this.position, this.focalPoint, up));\n      this._getAxes();\n      this._getDistance();\n      this._getAngles();\n      return this;\n    }\n    /**\n     * 固定当前视点，按指定距离放置相机\n     */\n  }, {\n    key: \"setDistance\",\n    value: function setDistance(d) {\n      if (this.distance === d || d < 0) {\n        return;\n      }\n      this.distance = d;\n      if (this.distance < 0.0002) {\n        this.distance = 0.0002;\n      }\n      this.dollyingStep = this.distance / 100;\n      var pos = vec3.create();\n      d = this.distance;\n      var n = this.forward;\n      var f = this.focalPoint;\n      pos[0] = d * n[0] + f[0];\n      pos[1] = d * n[1] + f[1];\n      pos[2] = d * n[2] + f[2];\n      this._setPosition(pos);\n      return this;\n    }\n  }, {\n    key: \"setMaxDistance\",\n    value: function setMaxDistance(d) {\n      this.maxDistance = d;\n      return this;\n    }\n  }, {\n    key: \"setMinDistance\",\n    value: function setMinDistance(d) {\n      this.minDistance = d;\n      return this;\n    }\n    /**\n     * Changes the initial azimuth of the camera\n     */\n  }, {\n    key: \"changeAzimuth\",\n    value: function changeAzimuth(az) {\n      this.setAzimuth(this.azimuth + az);\n      return this;\n    }\n    /**\n     * Changes the initial elevation of the camera\n     */\n  }, {\n    key: \"changeElevation\",\n    value: function changeElevation(el) {\n      this.setElevation(this.elevation + el);\n      return this;\n    }\n    /**\n     * Changes the initial roll of the camera\n     */\n  }, {\n    key: \"changeRoll\",\n    value: function changeRoll(rl) {\n      this.setRoll(this.roll + rl);\n      return this;\n    }\n    /**\n     * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置\n     * @param {Number} el the azimuth in degrees\n     */\n  }, {\n    key: \"setAzimuth\",\n    value: function setAzimuth(az) {\n      this.azimuth = getAngle(az);\n      this.computeMatrix();\n      this._getAxes();\n      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {\n        this._getPosition();\n      } else if (this.type === CAMERA_TYPE.TRACKING) {\n        this._getFocalPoint();\n      }\n      return this;\n    }\n  }, {\n    key: \"getAzimuth\",\n    value: function getAzimuth() {\n      return this.azimuth;\n    }\n    /**\n     * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置\n     * @param {Number} el the elevation in degrees\n     */\n  }, {\n    key: \"setElevation\",\n    value: function setElevation(el) {\n      this.elevation = getAngle(el);\n      this.computeMatrix();\n      this._getAxes();\n      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {\n        this._getPosition();\n      } else if (this.type === CAMERA_TYPE.TRACKING) {\n        this._getFocalPoint();\n      }\n      return this;\n    }\n    /**\n     * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置\n     * @param {Number} angle the roll angle\n     */\n  }, {\n    key: \"setRoll\",\n    value: function setRoll(angle) {\n      this.roll = getAngle(angle);\n      this.computeMatrix();\n      this._getAxes();\n      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {\n        this._getPosition();\n      } else if (this.type === CAMERA_TYPE.TRACKING) {\n        this._getFocalPoint();\n      }\n      return this;\n    }\n    /**\n     * Changes the azimuth and elevation with respect to the current camera axes\n     * @param {Number} azimuth the relative azimuth\n     * @param {Number} elevation the relative elevation\n     * @param {Number} roll the relative roll\n     */\n  }, {\n    key: \"rotate\",\n    value: function rotate(azimuth, elevation, roll) {\n      if (this.type === CAMERA_TYPE.EXPLORING) {\n        azimuth = getAngle(azimuth);\n        elevation = getAngle(elevation);\n        roll = getAngle(roll);\n        var rotX = quat.setAxisAngle(quat.create(), [1, 0, 0], (this.rotateWorld ? 1 : -1) * elevation * DEG_2_RAD);\n        var rotY = quat.setAxisAngle(quat.create(), [0, 1, 0], (this.rotateWorld ? 1 : -1) * azimuth * DEG_2_RAD);\n        var rotZ = quat.setAxisAngle(quat.create(), [0, 0, 1], roll * DEG_2_RAD);\n        var rotQ = quat.multiply(quat.create(), rotY, rotX);\n        rotQ = quat.multiply(quat.create(), rotQ, rotZ);\n        var rotMatrix = mat4.fromQuat(mat4.create(), rotQ);\n        mat4.translate(this.matrix, this.matrix, [0, 0, -this.distance]);\n        mat4.multiply(this.matrix, this.matrix, rotMatrix);\n        mat4.translate(this.matrix, this.matrix, [0, 0, this.distance]);\n      } else {\n        if (Math.abs(this.elevation + elevation) > 90) {\n          return;\n        }\n        this.relElevation = getAngle(elevation);\n        this.relAzimuth = getAngle(azimuth);\n        this.relRoll = getAngle(roll);\n        this.elevation += this.relElevation;\n        this.azimuth += this.relAzimuth;\n        this.roll += this.relRoll;\n        this.computeMatrix();\n      }\n      this._getAxes();\n      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {\n        this._getPosition();\n      } else if (this.type === CAMERA_TYPE.TRACKING) {\n        this._getFocalPoint();\n      }\n      this._update();\n      return this;\n    }\n    /**\n     * 沿水平(right) & 垂直(up)平移相机\n     */\n  }, {\n    key: \"pan\",\n    value: function pan(tx, ty) {\n      var coords = createVec3(tx, ty, 0);\n      var pos = vec3.clone(this.position);\n      vec3.add(pos, pos, vec3.scale(vec3.create(), this.right, coords[0]));\n      vec3.add(pos, pos, vec3.scale(vec3.create(), this.up, coords[1]));\n      this._setPosition(pos);\n      return this;\n    }\n    /**\n     * 沿 n 轴移动，当距离视点远时移动速度较快，离视点越近速度越慢\n     */\n  }, {\n    key: \"dolly\",\n    value: function dolly(value) {\n      var n = this.forward;\n      var pos = vec3.clone(this.position);\n      var step = value * this.dollyingStep;\n      var updatedDistance = this.distance + value * this.dollyingStep; // 限制视点距离范围\n\n      step = Math.max(Math.min(updatedDistance, this.maxDistance), this.minDistance) - this.distance;\n      pos[0] += step * n[0];\n      pos[1] += step * n[1];\n      pos[2] += step * n[2];\n      this._setPosition(pos);\n      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {\n        // 重新计算视点距离\n        this._getDistance();\n      } else if (this.type === CAMERA_TYPE.TRACKING) {\n        // 保持视距，移动视点位置\n        vec3.add(this.focalPoint, pos, this.distanceVector);\n      }\n      return this;\n    }\n  }, {\n    key: \"createLandmark\",\n    value: function createLandmark(name, params) {\n      var camera = this.clone();\n      camera.setPosition(params.position);\n      camera.setFocalPoint(params.focalPoint);\n      if (params.roll !== undefined) {\n        camera.setRoll(params.roll);\n      }\n      var landmark = new Landmark(name, camera);\n      this.landmarks.push(landmark);\n      return landmark;\n    }\n  }, {\n    key: \"setLandmark\",\n    value: function setLandmark(name) {\n      var landmark = new Landmark(name, this);\n      this.landmarks.push(landmark);\n      return this;\n    }\n  }, {\n    key: \"gotoLandmark\",\n    value: function gotoLandmark(name) {\n      var _this = this;\n      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n      var landmark = this.landmarks.find(function (l) {\n        return l.name === name;\n      });\n      if (landmark) {\n        if (duration === 0) {\n          landmark.retrieve(this);\n          return;\n        }\n        if (this.landmarkAnimationID !== undefined) {\n          window.cancelAnimationFrame(this.landmarkAnimationID);\n        } // TODO: do not process events during animation\n\n        this.interactor.disconnect();\n        var destPosition = landmark.getPosition();\n        var destFocalPoint = landmark.getFocalPoint();\n        var destRoll = landmark.getRoll();\n        var timeStart;\n        var animate = function animate(timestamp) {\n          if (timeStart === undefined) {\n            timeStart = timestamp;\n          }\n          var elapsed = timestamp - timeStart; // TODO: use better ease function\n\n          var t = (1 - Math.cos(elapsed / duration * Math.PI)) / 2;\n          var interFocalPoint = vec3.create();\n          var interPosition = vec3.create();\n          var interRoll = 0;\n          vec3.lerp(interFocalPoint, _this.focalPoint, destFocalPoint, t);\n          vec3.lerp(interPosition, _this.position, destPosition, t);\n          interRoll = _this.roll * (1 - t) + destRoll * t;\n          _this.setFocalPoint(interFocalPoint);\n          _this.setPosition(interPosition);\n          _this.setRoll(interRoll);\n          _this.computeMatrix();\n          var dist = vec3.dist(interFocalPoint, destFocalPoint) + vec3.dist(interPosition, destPosition);\n          if (dist > 0.01) {//\n          } else {\n            _this.setFocalPoint(interFocalPoint);\n            _this.setPosition(interPosition);\n            _this.setRoll(interRoll);\n            _this.computeMatrix();\n            _this.interactor.connect();\n            return;\n          }\n          if (elapsed < duration) {\n            _this.landmarkAnimationID = window.requestAnimationFrame(animate);\n          }\n        };\n        window.requestAnimationFrame(animate);\n      }\n    }\n    /**\n     * 根据相机矩阵重新计算各种相机参数\n     */\n  }, {\n    key: \"_update\",\n    value: function _update() {\n      this._getAxes();\n      this._getPosition();\n      this._getDistance();\n      this._getAngles();\n    }\n    /**\n     * 计算相机矩阵\n     */\n  }, {\n    key: \"computeMatrix\",\n    value: function computeMatrix() {\n      var rotX;\n      var rotY; // 使用四元数描述 3D 旋转\n      // @see https://xiaoiver.github.io/coding/2018/12/28/Camera-%E8%AE%BE%E8%AE%A1-%E4%B8%80.html\n\n      var rotZ = quat.setAxisAngle(quat.create(), [0, 0, 1], this.roll * DEG_2_RAD);\n      mat4.identity(this.matrix); // only consider HCS for EXPLORING and ORBITING cameras\n\n      rotX = quat.setAxisAngle(quat.create(), [1, 0, 0], (this.rotateWorld && this.type !== CAMERA_TYPE.TRACKING || this.type === CAMERA_TYPE.TRACKING ? 1 : -1) * this.elevation * DEG_2_RAD);\n      rotY = quat.setAxisAngle(quat.create(), [0, 1, 0], (this.rotateWorld && this.type !== CAMERA_TYPE.TRACKING || this.type === CAMERA_TYPE.TRACKING ? 1 : -1) * this.azimuth * DEG_2_RAD);\n      var rotQ = quat.multiply(quat.create(), rotY, rotX);\n      rotQ = quat.multiply(quat.create(), rotQ, rotZ);\n      var rotMatrix = mat4.fromQuat(mat4.create(), rotQ);\n      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {\n        mat4.translate(this.matrix, this.matrix, this.focalPoint);\n        mat4.multiply(this.matrix, this.matrix, rotMatrix);\n        mat4.translate(this.matrix, this.matrix, [0, 0, this.distance]);\n      } else if (this.type === CAMERA_TYPE.TRACKING) {\n        mat4.translate(this.matrix, this.matrix, this.position);\n        mat4.multiply(this.matrix, this.matrix, rotMatrix);\n      }\n    }\n    /**\n     * Sets the camera position in the camera matrix\n     */\n  }, {\n    key: \"_setPosition\",\n    value: function _setPosition(x, y, z) {\n      this.position = createVec3(x, y, z);\n      var m = this.matrix;\n      m[12] = this.position[0];\n      m[13] = this.position[1];\n      m[14] = this.position[2];\n      m[15] = 1;\n    }\n    /**\n     * Recalculates axes based on the current matrix\n     */\n  }, {\n    key: \"_getAxes\",\n    value: function _getAxes() {\n      vec3.copy(this.right, createVec3(vec4.transformMat4(vec4.create(), [1, 0, 0, 0], this.matrix)));\n      vec3.copy(this.up, createVec3(vec4.transformMat4(vec4.create(), [0, 1, 0, 0], this.matrix)));\n      vec3.copy(this.forward, createVec3(vec4.transformMat4(vec4.create(), [0, 0, 1, 0], this.matrix)));\n      vec3.normalize(this.right, this.right);\n      vec3.normalize(this.up, this.up);\n      vec3.normalize(this.forward, this.forward);\n    }\n    /**\n     * Recalculates euler angles based on the current state\n     */\n  }, {\n    key: \"_getAngles\",\n    value: function _getAngles() {\n      // Recalculates angles\n      var x = this.distanceVector[0];\n      var y = this.distanceVector[1];\n      var z = this.distanceVector[2];\n      var r = vec3.length(this.distanceVector); // FAST FAIL: If there is no distance we cannot compute angles\n\n      if (r === 0) {\n        this.elevation = 0;\n        this.azimuth = 0;\n        return;\n      }\n      if (this.type === CAMERA_TYPE.TRACKING) {\n        this.elevation = Math.asin(y / r) * RAD_2_DEG;\n        this.azimuth = Math.atan2(-x, -z) * RAD_2_DEG;\n      } else {\n        if (this.rotateWorld) {\n          this.elevation = Math.asin(y / r) * RAD_2_DEG;\n          this.azimuth = Math.atan2(-x, -z) * RAD_2_DEG;\n        } else {\n          this.elevation = -Math.asin(y / r) * RAD_2_DEG;\n          this.azimuth = -Math.atan2(-x, -z) * RAD_2_DEG;\n        }\n      }\n    }\n    /**\n     * 重新计算相机位置，只有 ORBITING 模式相机位置才会发生变化\n     */\n  }, {\n    key: \"_getPosition\",\n    value: function _getPosition() {\n      vec3.copy(this.position, createVec3(vec4.transformMat4(vec4.create(), [0, 0, 0, 1], this.matrix))); // 相机位置变化，需要重新计算视距\n\n      this._getDistance();\n    }\n    /**\n     * 重新计算视点，只有 TRACKING 模式视点才会发生变化\n     */\n  }, {\n    key: \"_getFocalPoint\",\n    value: function _getFocalPoint() {\n      vec3.transformMat3(this.distanceVector, [0, 0, -this.distance], mat3.fromMat4(mat3.create(), this.matrix));\n      vec3.add(this.focalPoint, this.position, this.distanceVector); // 视点变化，需要重新计算视距\n\n      this._getDistance();\n    }\n    /**\n     * 重新计算视距\n     */\n  }, {\n    key: \"_getDistance\",\n    value: function _getDistance() {\n      this.distanceVector = vec3.subtract(vec3.create(), this.focalPoint, this.position);\n      this.distance = vec3.length(this.distanceVector);\n      this.dollyingStep = this.distance / 100;\n    }\n  }]);\n  return Camera;\n}(), _class3.ProjectionMode = {\n  ORTHOGRAPHIC: 'ORTHOGRAPHIC',\n  PERSPECTIVE: 'PERSPECTIVE'\n}, _temp), _descriptor = _applyDecoratedDescriptor(_class2.prototype, \"interactor\", [_dec2], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _class2)) || _class);","map":{"version":3,"names":["Frustum","IDENTIFIER","mat3","mat4","quat","vec3","vec4","inject","injectable","createVec3","getAngle","Landmark","CAMERA_TYPE","CAMERA_TRACKING_MODE","CAMERA_PROJECTION_MODE","DEG_2_RAD","Math","PI","RAD_2_DEG","Camera","_dec","_dec2","InteractorService","_class","_class2","_temp","_class3","_classCallCheck","matrix","create","right","fromValues","up","forward","position","focalPoint","distanceVector","distance","azimuth","elevation","roll","relAzimuth","relElevation","relRoll","dollyingStep","maxDistance","Infinity","minDistance","rotateWorld","_initializerDefineProperty","_descriptor","fov","near","far","aspect","left","rright","top","bottom","zoom","perspective","view","following","undefined","type","EXPLORING","trackingMode","DEFAULT","projectionMode","PERSPECTIVE","frustum","landmarks","landmarkAnimationID","_createClass","key","value","clone","camera","setType","interactor","getProjectionMode","getPerspective","getFrustum","getPosition","setWorldRotation","_getAngles","TRACKING","setTrackingMode","setProjectionMode","Error","flag","getViewTransform","invert","getWorldTransform","setMatrix","_update","setAspect","setPerspective","setViewOffset","fullWidth","fullHeight","x","y","width","height","enabled","offsetX","offsetY","setOrthographic","clearViewOffset","l","r","t","b","ORTHOGRAPHIC","dx","dy","cx","cy","scaleW","scaleH","ortho","setPosition","z","_setPosition","setFocalPoint","CINEMATIC","d","subtract","length","el","asin","az","atan2","m","rotateY","rotateX","transformMat4","lookAt","_getAxes","_getDistance","setDistance","pos","n","f","setMaxDistance","setMinDistance","changeAzimuth","setAzimuth","changeElevation","setElevation","changeRoll","rl","setRoll","computeMatrix","ORBITING","_getPosition","_getFocalPoint","getAzimuth","angle","rotate","rotX","setAxisAngle","rotY","rotZ","rotQ","multiply","rotMatrix","fromQuat","translate","abs","pan","tx","ty","coords","add","scale","dolly","step","updatedDistance","max","min","createLandmark","name","params","landmark","push","setLandmark","gotoLandmark","_this","duration","arguments","find","retrieve","window","cancelAnimationFrame","disconnect","destPosition","destFocalPoint","getFocalPoint","destRoll","getRoll","timeStart","animate","timestamp","elapsed","cos","interFocalPoint","interPosition","interRoll","lerp","dist","connect","requestAnimationFrame","identity","copy","normalize","transformMat3","fromMat4","ProjectionMode","_applyDecoratedDescriptor","prototype","configurable","enumerable","writable","initializer"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/g-webgpu/src/camera/Camera.ts"],"sourcesContent":["import {\n  Frustum,\n  ICamera,\n  IDENTIFIER,\n  IInteractorService,\n} from '@antv/g-webgpu-core';\nimport { mat3, mat4, quat, vec3, vec4 } from 'gl-matrix';\nimport { inject, injectable, postConstruct } from 'inversify';\nimport { createVec3, getAngle } from '../utils/math';\nimport Landmark from './Landmark';\n\nexport enum CAMERA_TYPE {\n  ORBITING = 'ORBITING',\n  EXPLORING = 'EXPLORING',\n  TRACKING = 'TRACKING',\n}\n\nexport enum CAMERA_TRACKING_MODE {\n  DEFAULT = 'DEFAULT',\n  ROTATIONAL = 'ROTATIONAL',\n  TRANSLATIONAL = 'TRANSLATIONAL',\n  CINEMATIC = 'CINEMATIC',\n}\n\nexport enum CAMERA_PROJECTION_MODE {\n  ORTHOGRAPHIC = 'ORTHOGRAPHIC',\n  PERSPECTIVE = 'PERSPECTIVE',\n}\n\nconst DEG_2_RAD = Math.PI / 180;\nconst RAD_2_DEG = 180 / Math.PI;\n\n/**\n * 参考「WebGL Insights - 23.Designing Cameras for WebGL Applications」，基于 Responsible Camera 思路设计\n * 保存相机参数，定义相机动作：\n * 1. dolly 沿 n 轴移动\n * 2. pan 沿 u v 轴移动\n * 3. rotate 以方位角旋转\n * 4. 移动到 Landmark，具有平滑的动画效果，其间禁止其他用户交互\n */\n@injectable()\nexport class Camera implements ICamera {\n  public static ProjectionMode = {\n    ORTHOGRAPHIC: 'ORTHOGRAPHIC',\n    PERSPECTIVE: 'PERSPECTIVE',\n  };\n  /**\n   * 相机矩阵\n   */\n  public matrix = mat4.create();\n\n  /**\n   * u 轴\n   * @see http://learnwebgl.brown37.net/07_cameras/camera_introduction.html#a-camera-definition\n   */\n  public right = vec3.fromValues(1, 0, 0);\n\n  /**\n   * v 轴\n   */\n  public up = vec3.fromValues(0, 1, 0);\n\n  /**\n   * n 轴\n   */\n  public forward = vec3.fromValues(0, 0, 1);\n\n  /**\n   * 相机位置\n   */\n  public position = vec3.fromValues(0, 0, 1);\n\n  /**\n   * 视点位置\n   */\n  public focalPoint = vec3.fromValues(0, 0, 0);\n\n  /**\n   * 相机位置到视点向量\n   * focalPoint - position\n   */\n  public distanceVector = vec3.fromValues(0, 0, 0);\n\n  /**\n   * 相机位置到视点距离\n   * length(focalPoint - position)\n   */\n  public distance = 1;\n\n  /**\n   * @see https://en.wikipedia.org/wiki/Azimuth\n   */\n  public azimuth = 0;\n  public elevation = 0;\n  public roll = 0;\n  public relAzimuth = 0;\n  public relElevation = 0;\n  public relRoll = 0;\n\n  /**\n   * 沿 n 轴移动时，保证移动速度从快到慢\n   */\n  public dollyingStep = 0;\n  public maxDistance = Infinity;\n  public minDistance = -Infinity;\n\n  /**\n   * invert the horizontal coordinate system HCS\n   */\n  public rotateWorld = false;\n\n  @inject(IDENTIFIER.InteractorService)\n  public interactor: IInteractorService;\n\n  /**\n   * 投影矩阵参数\n   */\n\n  /**\n   * field of view [0-360]\n   * @see http://en.wikipedia.org/wiki/Angle_of_view\n   */\n  private fov = 30;\n  private near = 0.1;\n  private far = 10000;\n  private aspect = 1;\n  private left: number;\n  private rright: number;\n  private top: number;\n  private bottom: number;\n  private zoom = 1;\n  private perspective = mat4.create();\n\n  private view:\n    | {\n        enabled: boolean;\n        fullWidth: number;\n        fullHeight: number;\n        offsetX: number;\n        offsetY: number;\n        width: number;\n        height: number;\n      }\n    | undefined;\n\n  private following = undefined;\n\n  private type = CAMERA_TYPE.EXPLORING;\n  private trackingMode = CAMERA_TRACKING_MODE.DEFAULT;\n  private projectionMode = CAMERA_PROJECTION_MODE.PERSPECTIVE;\n\n  /**\n   * for culling use\n   */\n  private frustum: Frustum = new Frustum();\n\n  /**\n   * switch between multiple landmarks\n   */\n  private landmarks: Landmark[] = [];\n  private landmarkAnimationID: number | undefined;\n\n  public clone(): Camera {\n    const camera = new Camera();\n    camera.setType(this.type, undefined);\n    camera.interactor = this.interactor;\n    return camera;\n  }\n\n  public getProjectionMode() {\n    return this.projectionMode;\n  }\n\n  public getPerspective() {\n    return this.perspective;\n  }\n\n  public getFrustum() {\n    return this.frustum;\n  }\n\n  public getPosition() {\n    return this.position;\n  }\n\n  public setType(\n    type: CAMERA_TYPE,\n    trackingMode: CAMERA_TRACKING_MODE | undefined,\n  ) {\n    this.type = type;\n    if (this.type === CAMERA_TYPE.EXPLORING) {\n      this.setWorldRotation(true);\n    } else {\n      this.setWorldRotation(false);\n    }\n    this._getAngles();\n\n    if (this.type === CAMERA_TYPE.TRACKING && trackingMode !== undefined) {\n      this.setTrackingMode(trackingMode);\n    }\n    return this;\n  }\n\n  public setProjectionMode(projectionMode: CAMERA_PROJECTION_MODE) {\n    this.projectionMode = projectionMode;\n    return this;\n  }\n\n  public setTrackingMode(trackingMode: CAMERA_TRACKING_MODE) {\n    if (this.type !== CAMERA_TYPE.TRACKING) {\n      throw new Error(\n        'Impossible to set a tracking mode if the camera is not of tracking type',\n      );\n    }\n    this.trackingMode = trackingMode;\n    return this;\n  }\n\n  /**\n   * If flag is true, it reverses the azimuth and elevation angles.\n   * Subsequent calls to rotate, setAzimuth, setElevation,\n   * changeAzimuth or changeElevation will cause the inverted effect.\n   * setRoll or changeRoll is not affected by this method.\n   *\n   * This inversion is useful when one wants to simulate that the world\n   * is moving, instead of the camera.\n   *\n   * By default the camera angles are not reversed.\n   * @param {Boolean} flag the boolean flag to reverse the angles.\n   */\n  public setWorldRotation(flag: boolean) {\n    this.rotateWorld = flag;\n    this._getAngles();\n  }\n\n  /**\n   * 计算 MV 矩阵，为相机矩阵的逆矩阵\n   */\n  public getViewTransform(): mat4 {\n    return mat4.invert(mat4.create(), this.matrix)!;\n  }\n\n  public getWorldTransform(): mat4 {\n    return this.matrix;\n  }\n\n  /**\n   * 设置相机矩阵\n   */\n  public setMatrix(matrix: mat4) {\n    this.matrix = matrix;\n    this._update();\n    return this;\n  }\n\n  public setAspect(aspect: number) {\n    this.setPerspective(this.near, this.far, this.fov, aspect);\n    return this;\n  }\n\n  /**\n   * Sets an offset in a larger frustum, used in PixelPicking\n   */\n  public setViewOffset(\n    fullWidth: number,\n    fullHeight: number,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n  ) {\n    this.aspect = fullWidth / fullHeight;\n    if (this.view === undefined) {\n      this.view = {\n        enabled: true,\n        fullWidth: 1,\n        fullHeight: 1,\n        offsetX: 0,\n        offsetY: 0,\n        width: 1,\n        height: 1,\n      };\n    }\n\n    this.view.enabled = true;\n    this.view.fullWidth = fullWidth;\n    this.view.fullHeight = fullHeight;\n    this.view.offsetX = x;\n    this.view.offsetY = y;\n    this.view.width = width;\n    this.view.height = height;\n\n    if (this.projectionMode === CAMERA_PROJECTION_MODE.PERSPECTIVE) {\n      this.setPerspective(this.near, this.far, this.fov, this.aspect);\n    } else {\n      this.setOrthographic(\n        this.left,\n        this.rright,\n        this.top,\n        this.bottom,\n        this.near,\n        this.far,\n      );\n    }\n    return this;\n  }\n\n  public clearViewOffset() {\n    if (this.view !== undefined) {\n      this.view.enabled = false;\n    }\n\n    if (this.projectionMode === CAMERA_PROJECTION_MODE.PERSPECTIVE) {\n      this.setPerspective(this.near, this.far, this.fov, this.aspect);\n    } else {\n      this.setOrthographic(\n        this.left,\n        this.rright,\n        this.top,\n        this.bottom,\n        this.near,\n        this.far,\n      );\n    }\n    return this;\n  }\n\n  public setPerspective(\n    near: number,\n    far: number,\n    fov: number,\n    aspect: number,\n  ) {\n    this.projectionMode = CAMERA_PROJECTION_MODE.PERSPECTIVE;\n    this.fov = fov;\n    this.near = near;\n    this.far = far;\n    this.aspect = aspect;\n    mat4.perspective(\n      this.perspective,\n      this.fov * DEG_2_RAD,\n      this.aspect,\n      this.near,\n      this.far,\n    );\n    return this;\n  }\n\n  public setOrthographic(\n    l: number,\n    r: number,\n    t: number,\n    b: number,\n    near: number,\n    far: number,\n  ) {\n    this.projectionMode = CAMERA_PROJECTION_MODE.ORTHOGRAPHIC;\n    this.rright = r;\n    this.left = l;\n    this.top = t;\n    this.bottom = b;\n    this.near = near;\n    this.far = far;\n\n    const dx = (this.rright - this.left) / (2 * this.zoom);\n    const dy = (this.top - this.bottom) / (2 * this.zoom);\n    const cx = (this.rright + this.left) / 2;\n    const cy = (this.top + this.bottom) / 2;\n\n    let left = cx - dx;\n    let right = cx + dx;\n    let top = cy + dy;\n    let bottom = cy - dy;\n\n    if (this.view !== undefined && this.view.enabled) {\n      const scaleW =\n        (this.rright - this.left) / this.view.fullWidth / this.zoom;\n      const scaleH =\n        (this.top - this.bottom) / this.view.fullHeight / this.zoom;\n\n      left += scaleW * this.view.offsetX;\n      right = left + scaleW * this.view.width;\n      top -= scaleH * this.view.offsetY;\n      bottom = top - scaleH * this.view.height;\n    }\n\n    mat4.ortho(this.perspective, left, right, top, bottom, near, far);\n    return this;\n  }\n\n  /**\n   * 设置相机位置\n   */\n  public setPosition(x: number | vec3, y?: number, z?: number) {\n    this._setPosition(x, y, z);\n    this.setFocalPoint(this.focalPoint);\n    return this;\n  }\n\n  /**\n   * 设置视点位置\n   */\n  public setFocalPoint(x: number | vec3, y?: number, z?: number) {\n    let up = vec3.fromValues(0, 1, 0);\n    this.focalPoint = createVec3(x, y, z);\n\n    if (this.trackingMode === CAMERA_TRACKING_MODE.CINEMATIC) {\n      const d = vec3.subtract(vec3.create(), this.focalPoint, this.position);\n      x = d[0];\n      y = d[1] as number;\n      z = d[2] as number;\n      const r = vec3.length(d);\n      const el = Math.asin(y / r) * RAD_2_DEG;\n      const az = 90 + Math.atan2(z, x) * RAD_2_DEG;\n      const m = mat4.create();\n      mat4.rotateY(m, m, az * DEG_2_RAD);\n      mat4.rotateX(m, m, el * DEG_2_RAD);\n      up = vec3.transformMat4(vec3.create(), [0, 1, 0], m);\n    }\n\n    mat4.invert(\n      this.matrix,\n      mat4.lookAt(mat4.create(), this.position, this.focalPoint, up),\n    );\n\n    this._getAxes();\n    this._getDistance();\n    this._getAngles();\n    return this;\n  }\n\n  /**\n   * 固定当前视点，按指定距离放置相机\n   */\n  public setDistance(d: number) {\n    if (this.distance === d || d < 0) {\n      return;\n    }\n\n    this.distance = d;\n\n    if (this.distance < 0.0002) {\n      this.distance = 0.0002;\n    }\n    this.dollyingStep = this.distance / 100;\n\n    const pos = vec3.create();\n    d = this.distance;\n    const n = this.forward;\n    const f = this.focalPoint;\n\n    pos[0] = d * n[0] + f[0];\n    pos[1] = d * n[1] + f[1];\n    pos[2] = d * n[2] + f[2];\n\n    this._setPosition(pos);\n    return this;\n  }\n\n  public setMaxDistance(d: number) {\n    this.maxDistance = d;\n    return this;\n  }\n\n  public setMinDistance(d: number) {\n    this.minDistance = d;\n    return this;\n  }\n\n  /**\n   * Changes the initial azimuth of the camera\n   */\n  public changeAzimuth(az: number) {\n    this.setAzimuth(this.azimuth + az);\n    return this;\n  }\n\n  /**\n   * Changes the initial elevation of the camera\n   */\n  public changeElevation(el: number) {\n    this.setElevation(this.elevation + el);\n    return this;\n  }\n\n  /**\n   * Changes the initial roll of the camera\n   */\n  public changeRoll(rl: number) {\n    this.setRoll(this.roll + rl);\n    return this;\n  }\n\n  /**\n   * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置\n   * @param {Number} el the azimuth in degrees\n   */\n  public setAzimuth(az: number) {\n    this.azimuth = getAngle(az);\n    this.computeMatrix();\n\n    this._getAxes();\n    if (\n      this.type === CAMERA_TYPE.ORBITING ||\n      this.type === CAMERA_TYPE.EXPLORING\n    ) {\n      this._getPosition();\n    } else if (this.type === CAMERA_TYPE.TRACKING) {\n      this._getFocalPoint();\n    }\n    return this;\n  }\n\n  public getAzimuth() {\n    return this.azimuth;\n  }\n\n  /**\n   * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置\n   * @param {Number} el the elevation in degrees\n   */\n  public setElevation(el: number) {\n    this.elevation = getAngle(el);\n    this.computeMatrix();\n\n    this._getAxes();\n    if (\n      this.type === CAMERA_TYPE.ORBITING ||\n      this.type === CAMERA_TYPE.EXPLORING\n    ) {\n      this._getPosition();\n    } else if (this.type === CAMERA_TYPE.TRACKING) {\n      this._getFocalPoint();\n    }\n    return this;\n  }\n\n  /**\n   * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置\n   * @param {Number} angle the roll angle\n   */\n  public setRoll(angle: number) {\n    this.roll = getAngle(angle);\n    this.computeMatrix();\n\n    this._getAxes();\n    if (\n      this.type === CAMERA_TYPE.ORBITING ||\n      this.type === CAMERA_TYPE.EXPLORING\n    ) {\n      this._getPosition();\n    } else if (this.type === CAMERA_TYPE.TRACKING) {\n      this._getFocalPoint();\n    }\n    return this;\n  }\n\n  /**\n   * Changes the azimuth and elevation with respect to the current camera axes\n   * @param {Number} azimuth the relative azimuth\n   * @param {Number} elevation the relative elevation\n   * @param {Number} roll the relative roll\n   */\n  public rotate(azimuth: number, elevation: number, roll: number) {\n    if (this.type === CAMERA_TYPE.EXPLORING) {\n      azimuth = getAngle(azimuth);\n      elevation = getAngle(elevation);\n      roll = getAngle(roll);\n\n      const rotX = quat.setAxisAngle(\n        quat.create(),\n        [1, 0, 0],\n        (this.rotateWorld ? 1 : -1) * elevation * DEG_2_RAD,\n      );\n      const rotY = quat.setAxisAngle(\n        quat.create(),\n        [0, 1, 0],\n        (this.rotateWorld ? 1 : -1) * azimuth * DEG_2_RAD,\n      );\n\n      const rotZ = quat.setAxisAngle(\n        quat.create(),\n        [0, 0, 1],\n        roll * DEG_2_RAD,\n      );\n      let rotQ = quat.multiply(quat.create(), rotY, rotX);\n      rotQ = quat.multiply(quat.create(), rotQ, rotZ);\n      const rotMatrix = mat4.fromQuat(mat4.create(), rotQ);\n      mat4.translate(this.matrix, this.matrix, [0, 0, -this.distance]);\n      mat4.multiply(this.matrix, this.matrix, rotMatrix);\n      mat4.translate(this.matrix, this.matrix, [0, 0, this.distance]);\n    } else {\n      if (Math.abs(this.elevation + elevation) > 90) {\n        return;\n      }\n      this.relElevation = getAngle(elevation);\n      this.relAzimuth = getAngle(azimuth);\n      this.relRoll = getAngle(roll);\n      this.elevation += this.relElevation;\n      this.azimuth += this.relAzimuth;\n      this.roll += this.relRoll;\n\n      this.computeMatrix();\n    }\n\n    this._getAxes();\n    if (\n      this.type === CAMERA_TYPE.ORBITING ||\n      this.type === CAMERA_TYPE.EXPLORING\n    ) {\n      this._getPosition();\n    } else if (this.type === CAMERA_TYPE.TRACKING) {\n      this._getFocalPoint();\n    }\n\n    this._update();\n    return this;\n  }\n\n  /**\n   * 沿水平(right) & 垂直(up)平移相机\n   */\n  public pan(tx: number, ty: number) {\n    const coords = createVec3(tx, ty, 0);\n    const pos = vec3.clone(this.position);\n\n    vec3.add(pos, pos, vec3.scale(vec3.create(), this.right, coords[0]));\n    vec3.add(pos, pos, vec3.scale(vec3.create(), this.up, coords[1]));\n\n    this._setPosition(pos);\n\n    return this;\n  }\n\n  /**\n   * 沿 n 轴移动，当距离视点远时移动速度较快，离视点越近速度越慢\n   */\n  public dolly(value: number) {\n    const n = this.forward;\n    const pos = vec3.clone(this.position);\n    let step = value * this.dollyingStep;\n    const updatedDistance = this.distance + value * this.dollyingStep;\n\n    // 限制视点距离范围\n    step =\n      Math.max(Math.min(updatedDistance, this.maxDistance), this.minDistance) -\n      this.distance;\n    pos[0] += step * n[0];\n    pos[1] += step * n[1];\n    pos[2] += step * n[2];\n\n    this._setPosition(pos);\n    if (\n      this.type === CAMERA_TYPE.ORBITING ||\n      this.type === CAMERA_TYPE.EXPLORING\n    ) {\n      // 重新计算视点距离\n      this._getDistance();\n    } else if (this.type === CAMERA_TYPE.TRACKING) {\n      // 保持视距，移动视点位置\n      vec3.add(this.focalPoint, pos, this.distanceVector);\n    }\n    return this;\n  }\n\n  public createLandmark(\n    name: string,\n    params: {\n      position: vec3;\n      focalPoint: vec3;\n      roll?: number;\n    },\n  ): Landmark {\n    const camera = this.clone();\n    camera.setPosition(params.position);\n    camera.setFocalPoint(params.focalPoint);\n    if (params.roll !== undefined) {\n      camera.setRoll(params.roll);\n    }\n    const landmark = new Landmark(name, camera);\n    this.landmarks.push(landmark);\n    return landmark;\n  }\n\n  public setLandmark(name: string) {\n    const landmark = new Landmark(name, this);\n    this.landmarks.push(landmark);\n    return this;\n  }\n\n  public gotoLandmark(name: string, duration: number = 1000) {\n    const landmark = this.landmarks.find((l) => l.name === name);\n    if (landmark) {\n      if (duration === 0) {\n        landmark.retrieve(this);\n        return;\n      }\n\n      if (this.landmarkAnimationID !== undefined) {\n        window.cancelAnimationFrame(this.landmarkAnimationID);\n      }\n\n      // TODO: do not process events during animation\n      this.interactor.disconnect();\n\n      const destPosition = landmark.getPosition();\n      const destFocalPoint = landmark.getFocalPoint();\n      const destRoll = landmark.getRoll();\n\n      let timeStart: number | undefined;\n      const animate = (timestamp: number) => {\n        if (timeStart === undefined) {\n          timeStart = timestamp;\n        }\n        const elapsed = timestamp - timeStart;\n        // TODO: use better ease function\n        const t = (1 - Math.cos((elapsed / duration) * Math.PI)) / 2;\n\n        const interFocalPoint = vec3.create();\n        const interPosition = vec3.create();\n        let interRoll = 0;\n\n        vec3.lerp(interFocalPoint, this.focalPoint, destFocalPoint, t);\n        vec3.lerp(interPosition, this.position, destPosition, t);\n        interRoll = this.roll * (1 - t) + destRoll * t;\n\n        this.setFocalPoint(interFocalPoint);\n        this.setPosition(interPosition);\n        this.setRoll(interRoll);\n        this.computeMatrix();\n\n        const dist =\n          vec3.dist(interFocalPoint, destFocalPoint) +\n          vec3.dist(interPosition, destPosition);\n        if (dist > 0.01) {\n          //\n        } else {\n          this.setFocalPoint(interFocalPoint);\n          this.setPosition(interPosition);\n          this.setRoll(interRoll);\n          this.computeMatrix();\n          this.interactor.connect();\n          return;\n        }\n\n        if (elapsed < duration) {\n          this.landmarkAnimationID = window.requestAnimationFrame(animate);\n        }\n      };\n\n      window.requestAnimationFrame(animate);\n    }\n  }\n\n  /**\n   * 根据相机矩阵重新计算各种相机参数\n   */\n  private _update() {\n    this._getAxes();\n    this._getPosition();\n    this._getDistance();\n    this._getAngles();\n  }\n\n  /**\n   * 计算相机矩阵\n   */\n  private computeMatrix() {\n    let rotX;\n    let rotY;\n    // 使用四元数描述 3D 旋转\n    // @see https://xiaoiver.github.io/coding/2018/12/28/Camera-%E8%AE%BE%E8%AE%A1-%E4%B8%80.html\n    const rotZ = quat.setAxisAngle(\n      quat.create(),\n      [0, 0, 1],\n      this.roll * DEG_2_RAD,\n    );\n\n    mat4.identity(this.matrix);\n\n    // only consider HCS for EXPLORING and ORBITING cameras\n    rotX = quat.setAxisAngle(\n      quat.create(),\n      [1, 0, 0],\n      ((this.rotateWorld && this.type !== CAMERA_TYPE.TRACKING) ||\n      this.type === CAMERA_TYPE.TRACKING\n        ? 1\n        : -1) *\n        this.elevation *\n        DEG_2_RAD,\n    );\n    rotY = quat.setAxisAngle(\n      quat.create(),\n      [0, 1, 0],\n      ((this.rotateWorld && this.type !== CAMERA_TYPE.TRACKING) ||\n      this.type === CAMERA_TYPE.TRACKING\n        ? 1\n        : -1) *\n        this.azimuth *\n        DEG_2_RAD,\n    );\n\n    let rotQ = quat.multiply(quat.create(), rotY, rotX);\n    rotQ = quat.multiply(quat.create(), rotQ, rotZ);\n    const rotMatrix = mat4.fromQuat(mat4.create(), rotQ);\n\n    if (\n      this.type === CAMERA_TYPE.ORBITING ||\n      this.type === CAMERA_TYPE.EXPLORING\n    ) {\n      mat4.translate(this.matrix, this.matrix, this.focalPoint);\n      mat4.multiply(this.matrix, this.matrix, rotMatrix);\n      mat4.translate(this.matrix, this.matrix, [0, 0, this.distance]);\n    } else if (this.type === CAMERA_TYPE.TRACKING) {\n      mat4.translate(this.matrix, this.matrix, this.position);\n      mat4.multiply(this.matrix, this.matrix, rotMatrix);\n    }\n  }\n\n  /**\n   * Sets the camera position in the camera matrix\n   */\n  private _setPosition(x: number | vec3, y?: number, z?: number) {\n    this.position = createVec3(x, y, z);\n    const m = this.matrix;\n    m[12] = this.position[0];\n    m[13] = this.position[1];\n    m[14] = this.position[2];\n    m[15] = 1;\n  }\n\n  /**\n   * Recalculates axes based on the current matrix\n   */\n  private _getAxes() {\n    vec3.copy(\n      this.right,\n      createVec3(vec4.transformMat4(vec4.create(), [1, 0, 0, 0], this.matrix)),\n    );\n    vec3.copy(\n      this.up,\n      createVec3(vec4.transformMat4(vec4.create(), [0, 1, 0, 0], this.matrix)),\n    );\n    vec3.copy(\n      this.forward,\n      createVec3(vec4.transformMat4(vec4.create(), [0, 0, 1, 0], this.matrix)),\n    );\n    vec3.normalize(this.right, this.right);\n    vec3.normalize(this.up, this.up);\n    vec3.normalize(this.forward, this.forward);\n  }\n\n  /**\n   * Recalculates euler angles based on the current state\n   */\n  private _getAngles() {\n    // Recalculates angles\n    const x = this.distanceVector[0];\n    const y = this.distanceVector[1];\n    const z = this.distanceVector[2];\n    const r = vec3.length(this.distanceVector);\n\n    // FAST FAIL: If there is no distance we cannot compute angles\n    if (r === 0) {\n      this.elevation = 0;\n      this.azimuth = 0;\n      return;\n    }\n\n    if (this.type === CAMERA_TYPE.TRACKING) {\n      this.elevation = Math.asin(y / r) * RAD_2_DEG;\n      this.azimuth = Math.atan2(-x, -z) * RAD_2_DEG;\n    } else {\n      if (this.rotateWorld) {\n        this.elevation = Math.asin(y / r) * RAD_2_DEG;\n        this.azimuth = Math.atan2(-x, -z) * RAD_2_DEG;\n      } else {\n        this.elevation = -Math.asin(y / r) * RAD_2_DEG;\n        this.azimuth = -Math.atan2(-x, -z) * RAD_2_DEG;\n      }\n    }\n  }\n\n  /**\n   * 重新计算相机位置，只有 ORBITING 模式相机位置才会发生变化\n   */\n  private _getPosition() {\n    vec3.copy(\n      this.position,\n      createVec3(vec4.transformMat4(vec4.create(), [0, 0, 0, 1], this.matrix)),\n    );\n\n    // 相机位置变化，需要重新计算视距\n    this._getDistance();\n  }\n\n  /**\n   * 重新计算视点，只有 TRACKING 模式视点才会发生变化\n   */\n  private _getFocalPoint() {\n    vec3.transformMat3(\n      this.distanceVector,\n      [0, 0, -this.distance],\n      mat3.fromMat4(mat3.create(), this.matrix),\n    );\n    vec3.add(this.focalPoint, this.position, this.distanceVector);\n\n    // 视点变化，需要重新计算视距\n    this._getDistance();\n  }\n\n  /**\n   * 重新计算视距\n   */\n  private _getDistance() {\n    this.distanceVector = vec3.subtract(\n      vec3.create(),\n      this.focalPoint,\n      this.position,\n    );\n    this.distance = vec3.length(this.distanceVector);\n    this.dollyingStep = this.distance / 100;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}