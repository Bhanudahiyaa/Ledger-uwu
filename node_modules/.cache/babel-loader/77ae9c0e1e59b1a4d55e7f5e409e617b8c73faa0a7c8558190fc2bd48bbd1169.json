{"ast":null,"code":"\"use strict\";\n\nvar _ = require(\"./lodash\");\nmodule.exports = Graph;\nvar DEFAULT_EDGE_NAME = \"\\x00\",\n  GRAPH_NODE = \"\\x00\",\n  EDGE_KEY_DELIM = \"\\x01\";\n\n// Implementation notes:\n//\n//  * Node id query functions should return string ids for the nodes\n//  * Edge id query functions should return an \"edgeObj\", edge object, that is\n//    composed of enough information to uniquely identify an edge: {v, w, name}.\n//  * Internally we use an \"edgeId\", a stringified form of the edgeObj, to\n//    reference edges. This is because we need a performant way to look these\n//    edges up and, object properties, which have string keys, are the closest\n//    we're going to get to a performant hashtable in JavaScript.\n\nfunction Graph(opts) {\n  this._isDirected = _.has(opts, \"directed\") ? opts.directed : true;\n  this._isMultigraph = _.has(opts, \"multigraph\") ? opts.multigraph : false;\n  this._isCompound = _.has(opts, \"compound\") ? opts.compound : false;\n\n  // Label for the graph itself\n  this._label = undefined;\n\n  // Defaults to be set when creating a new node\n  this._defaultNodeLabelFn = _.constant(undefined);\n\n  // Defaults to be set when creating a new edge\n  this._defaultEdgeLabelFn = _.constant(undefined);\n\n  // v -> label\n  this._nodes = {};\n  if (this._isCompound) {\n    // v -> parent\n    this._parent = {};\n\n    // v -> children\n    this._children = {};\n    this._children[GRAPH_NODE] = {};\n  }\n\n  // v -> edgeObj\n  this._in = {};\n\n  // u -> v -> Number\n  this._preds = {};\n\n  // v -> edgeObj\n  this._out = {};\n\n  // v -> w -> Number\n  this._sucs = {};\n\n  // e -> edgeObj\n  this._edgeObjs = {};\n\n  // e -> label\n  this._edgeLabels = {};\n}\n\n/* Number of nodes in the graph. Should only be changed by the implementation. */\nGraph.prototype._nodeCount = 0;\n\n/* Number of edges in the graph. Should only be changed by the implementation. */\nGraph.prototype._edgeCount = 0;\n\n/* === Graph functions ========= */\n\nGraph.prototype.isDirected = function () {\n  return this._isDirected;\n};\nGraph.prototype.isMultigraph = function () {\n  return this._isMultigraph;\n};\nGraph.prototype.isCompound = function () {\n  return this._isCompound;\n};\nGraph.prototype.setGraph = function (label) {\n  this._label = label;\n  return this;\n};\nGraph.prototype.graph = function () {\n  return this._label;\n};\n\n/* === Node functions ========== */\n\nGraph.prototype.setDefaultNodeLabel = function (newDefault) {\n  if (!_.isFunction(newDefault)) {\n    newDefault = _.constant(newDefault);\n  }\n  this._defaultNodeLabelFn = newDefault;\n  return this;\n};\nGraph.prototype.nodeCount = function () {\n  return this._nodeCount;\n};\nGraph.prototype.nodes = function () {\n  return _.keys(this._nodes);\n};\nGraph.prototype.sources = function () {\n  return _.filter(this.nodes(), _.bind(function (v) {\n    return _.isEmpty(this._in[v]);\n  }, this));\n};\nGraph.prototype.sinks = function () {\n  return _.filter(this.nodes(), _.bind(function (v) {\n    return _.isEmpty(this._out[v]);\n  }, this));\n};\nGraph.prototype.setNodes = function (vs, value) {\n  var args = arguments;\n  _.each(vs, _.bind(function (v) {\n    if (args.length > 1) {\n      this.setNode(v, value);\n    } else {\n      this.setNode(v);\n    }\n  }, this));\n  return this;\n};\nGraph.prototype.setNode = function (v, value) {\n  if (_.has(this._nodes, v)) {\n    if (arguments.length > 1) {\n      this._nodes[v] = value;\n    }\n    return this;\n  }\n  this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);\n  if (this._isCompound) {\n    this._parent[v] = GRAPH_NODE;\n    this._children[v] = {};\n    this._children[GRAPH_NODE][v] = true;\n  }\n  this._in[v] = {};\n  this._preds[v] = {};\n  this._out[v] = {};\n  this._sucs[v] = {};\n  ++this._nodeCount;\n  return this;\n};\nGraph.prototype.node = function (v) {\n  return this._nodes[v];\n};\nGraph.prototype.hasNode = function (v) {\n  return _.has(this._nodes, v);\n};\nGraph.prototype.removeNode = function (v) {\n  var self = this;\n  if (_.has(this._nodes, v)) {\n    var removeEdge = function (e) {\n      self.removeEdge(self._edgeObjs[e]);\n    };\n    delete this._nodes[v];\n    if (this._isCompound) {\n      this._removeFromParentsChildList(v);\n      delete this._parent[v];\n      _.each(this.children(v), _.bind(function (child) {\n        this.setParent(child);\n      }, this));\n      delete this._children[v];\n    }\n    _.each(_.keys(this._in[v]), removeEdge);\n    delete this._in[v];\n    delete this._preds[v];\n    _.each(_.keys(this._out[v]), removeEdge);\n    delete this._out[v];\n    delete this._sucs[v];\n    --this._nodeCount;\n  }\n  return this;\n};\nGraph.prototype.setParent = function (v, parent) {\n  if (!this._isCompound) {\n    throw new Error(\"Cannot set parent in a non-compound graph\");\n  }\n  if (_.isUndefined(parent)) {\n    parent = GRAPH_NODE;\n  } else {\n    // Coerce parent to string\n    parent += \"\";\n    for (var ancestor = parent; !_.isUndefined(ancestor); ancestor = this.parent(ancestor)) {\n      if (ancestor === v) {\n        throw new Error(\"Setting \" + parent + \" as parent of \" + v + \" would create create a cycle\");\n      }\n    }\n    this.setNode(parent);\n  }\n  this.setNode(v);\n  this._removeFromParentsChildList(v);\n  this._parent[v] = parent;\n  this._children[parent][v] = true;\n  return this;\n};\nGraph.prototype._removeFromParentsChildList = function (v) {\n  delete this._children[this._parent[v]][v];\n};\nGraph.prototype.parent = function (v) {\n  if (this._isCompound) {\n    var parent = this._parent[v];\n    if (parent !== GRAPH_NODE) {\n      return parent;\n    }\n  }\n};\nGraph.prototype.children = function (v) {\n  if (_.isUndefined(v)) {\n    v = GRAPH_NODE;\n  }\n  if (this._isCompound) {\n    var children = this._children[v];\n    if (children) {\n      return _.keys(children);\n    }\n  } else if (v === GRAPH_NODE) {\n    return this.nodes();\n  } else if (this.hasNode(v)) {\n    return [];\n  }\n};\nGraph.prototype.predecessors = function (v) {\n  var predsV = this._preds[v];\n  if (predsV) {\n    return _.keys(predsV);\n  }\n};\nGraph.prototype.successors = function (v) {\n  var sucsV = this._sucs[v];\n  if (sucsV) {\n    return _.keys(sucsV);\n  }\n};\nGraph.prototype.neighbors = function (v) {\n  var preds = this.predecessors(v);\n  if (preds) {\n    return _.union(preds, this.successors(v));\n  }\n};\nGraph.prototype.isLeaf = function (v) {\n  var neighbors;\n  if (this.isDirected()) {\n    neighbors = this.successors(v);\n  } else {\n    neighbors = this.neighbors(v);\n  }\n  return neighbors.length === 0;\n};\nGraph.prototype.filterNodes = function (filter) {\n  var copy = new this.constructor({\n    directed: this._isDirected,\n    multigraph: this._isMultigraph,\n    compound: this._isCompound\n  });\n  copy.setGraph(this.graph());\n  _.each(this._nodes, _.bind(function (value, v) {\n    if (filter(v)) {\n      copy.setNode(v, value);\n    }\n  }, this));\n  _.each(this._edgeObjs, _.bind(function (e) {\n    if (copy.hasNode(e.v) && copy.hasNode(e.w)) {\n      copy.setEdge(e, this.edge(e));\n    }\n  }, this));\n  var self = this;\n  var parents = {};\n  function findParent(v) {\n    var parent = self.parent(v);\n    if (parent === undefined || copy.hasNode(parent)) {\n      parents[v] = parent;\n      return parent;\n    } else if (parent in parents) {\n      return parents[parent];\n    } else {\n      return findParent(parent);\n    }\n  }\n  if (this._isCompound) {\n    _.each(copy.nodes(), function (v) {\n      copy.setParent(v, findParent(v));\n    });\n  }\n  return copy;\n};\n\n/* === Edge functions ========== */\n\nGraph.prototype.setDefaultEdgeLabel = function (newDefault) {\n  if (!_.isFunction(newDefault)) {\n    newDefault = _.constant(newDefault);\n  }\n  this._defaultEdgeLabelFn = newDefault;\n  return this;\n};\nGraph.prototype.edgeCount = function () {\n  return this._edgeCount;\n};\nGraph.prototype.edges = function () {\n  return _.values(this._edgeObjs);\n};\nGraph.prototype.setPath = function (vs, value) {\n  var self = this,\n    args = arguments;\n  _.reduce(vs, function (v, w) {\n    if (args.length > 1) {\n      self.setEdge(v, w, value);\n    } else {\n      self.setEdge(v, w);\n    }\n    return w;\n  });\n  return this;\n};\n\n/*\n * setEdge(v, w, [value, [name]])\n * setEdge({ v, w, [name] }, [value])\n */\nGraph.prototype.setEdge = function () {\n  var v,\n    w,\n    name,\n    value,\n    valueSpecified = false,\n    arg0 = arguments[0];\n  if (typeof arg0 === \"object\" && arg0 !== null && \"v\" in arg0) {\n    v = arg0.v;\n    w = arg0.w;\n    name = arg0.name;\n    if (arguments.length === 2) {\n      value = arguments[1];\n      valueSpecified = true;\n    }\n  } else {\n    v = arg0;\n    w = arguments[1];\n    name = arguments[3];\n    if (arguments.length > 2) {\n      value = arguments[2];\n      valueSpecified = true;\n    }\n  }\n  v = \"\" + v;\n  w = \"\" + w;\n  if (!_.isUndefined(name)) {\n    name = \"\" + name;\n  }\n  var e = edgeArgsToId(this._isDirected, v, w, name);\n  if (_.has(this._edgeLabels, e)) {\n    if (valueSpecified) {\n      this._edgeLabels[e] = value;\n    }\n    return this;\n  }\n  if (!_.isUndefined(name) && !this._isMultigraph) {\n    throw new Error(\"Cannot set a named edge when isMultigraph = false\");\n  }\n\n  // It didn't exist, so we need to create it.\n  // First ensure the nodes exist.\n  this.setNode(v);\n  this.setNode(w);\n  this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);\n  var edgeObj = edgeArgsToObj(this._isDirected, v, w, name);\n  // Ensure we add undirected edges in a consistent way.\n  v = edgeObj.v;\n  w = edgeObj.w;\n  Object.freeze(edgeObj);\n  this._edgeObjs[e] = edgeObj;\n  incrementOrInitEntry(this._preds[w], v);\n  incrementOrInitEntry(this._sucs[v], w);\n  this._in[w][e] = edgeObj;\n  this._out[v][e] = edgeObj;\n  this._edgeCount++;\n  return this;\n};\nGraph.prototype.edge = function (v, w, name) {\n  var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);\n  return this._edgeLabels[e];\n};\nGraph.prototype.hasEdge = function (v, w, name) {\n  var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);\n  return _.has(this._edgeLabels, e);\n};\nGraph.prototype.removeEdge = function (v, w, name) {\n  var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name),\n    edge = this._edgeObjs[e];\n  if (edge) {\n    v = edge.v;\n    w = edge.w;\n    delete this._edgeLabels[e];\n    delete this._edgeObjs[e];\n    decrementOrRemoveEntry(this._preds[w], v);\n    decrementOrRemoveEntry(this._sucs[v], w);\n    delete this._in[w][e];\n    delete this._out[v][e];\n    this._edgeCount--;\n  }\n  return this;\n};\nGraph.prototype.inEdges = function (v, u) {\n  var inV = this._in[v];\n  if (inV) {\n    var edges = _.values(inV);\n    if (!u) {\n      return edges;\n    }\n    return _.filter(edges, function (edge) {\n      return edge.v === u;\n    });\n  }\n};\nGraph.prototype.outEdges = function (v, w) {\n  var outV = this._out[v];\n  if (outV) {\n    var edges = _.values(outV);\n    if (!w) {\n      return edges;\n    }\n    return _.filter(edges, function (edge) {\n      return edge.w === w;\n    });\n  }\n};\nGraph.prototype.nodeEdges = function (v, w) {\n  var inEdges = this.inEdges(v, w);\n  if (inEdges) {\n    return inEdges.concat(this.outEdges(v, w));\n  }\n};\nfunction incrementOrInitEntry(map, k) {\n  if (map[k]) {\n    map[k]++;\n  } else {\n    map[k] = 1;\n  }\n}\nfunction decrementOrRemoveEntry(map, k) {\n  if (! --map[k]) {\n    delete map[k];\n  }\n}\nfunction edgeArgsToId(isDirected, v_, w_, name) {\n  var v = \"\" + v_;\n  var w = \"\" + w_;\n  if (!isDirected && v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n  return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM + (_.isUndefined(name) ? DEFAULT_EDGE_NAME : name);\n}\nfunction edgeArgsToObj(isDirected, v_, w_, name) {\n  var v = \"\" + v_;\n  var w = \"\" + w_;\n  if (!isDirected && v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n  var edgeObj = {\n    v: v,\n    w: w\n  };\n  if (name) {\n    edgeObj.name = name;\n  }\n  return edgeObj;\n}\nfunction edgeObjToId(isDirected, edgeObj) {\n  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);\n}","map":{"version":3,"names":["_","require","module","exports","Graph","DEFAULT_EDGE_NAME","GRAPH_NODE","EDGE_KEY_DELIM","opts","_isDirected","has","directed","_isMultigraph","multigraph","_isCompound","compound","_label","undefined","_defaultNodeLabelFn","constant","_defaultEdgeLabelFn","_nodes","_parent","_children","_in","_preds","_out","_sucs","_edgeObjs","_edgeLabels","prototype","_nodeCount","_edgeCount","isDirected","isMultigraph","isCompound","setGraph","label","graph","setDefaultNodeLabel","newDefault","isFunction","nodeCount","nodes","keys","sources","filter","bind","v","isEmpty","sinks","setNodes","vs","value","args","arguments","each","length","setNode","node","hasNode","removeNode","self","removeEdge","e","_removeFromParentsChildList","children","child","setParent","parent","Error","isUndefined","ancestor","predecessors","predsV","successors","sucsV","neighbors","preds","union","isLeaf","filterNodes","copy","constructor","w","setEdge","edge","parents","findParent","setDefaultEdgeLabel","edgeCount","edges","values","setPath","reduce","name","valueSpecified","arg0","edgeArgsToId","edgeObj","edgeArgsToObj","Object","freeze","incrementOrInitEntry","edgeObjToId","hasEdge","decrementOrRemoveEntry","inEdges","u","inV","outEdges","outV","nodeEdges","concat","map","k","v_","w_","tmp"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@dagrejs/graphlib/lib/graph.js"],"sourcesContent":["\"use strict\";\n\nvar _ = require(\"./lodash\");\n\nmodule.exports = Graph;\n\nvar DEFAULT_EDGE_NAME = \"\\x00\",\n    GRAPH_NODE = \"\\x00\",\n    EDGE_KEY_DELIM = \"\\x01\";\n\n// Implementation notes:\n//\n//  * Node id query functions should return string ids for the nodes\n//  * Edge id query functions should return an \"edgeObj\", edge object, that is\n//    composed of enough information to uniquely identify an edge: {v, w, name}.\n//  * Internally we use an \"edgeId\", a stringified form of the edgeObj, to\n//    reference edges. This is because we need a performant way to look these\n//    edges up and, object properties, which have string keys, are the closest\n//    we're going to get to a performant hashtable in JavaScript.\n\nfunction Graph(opts) {\n  this._isDirected = _.has(opts, \"directed\") ? opts.directed : true;\n  this._isMultigraph = _.has(opts, \"multigraph\") ? opts.multigraph : false;\n  this._isCompound = _.has(opts, \"compound\") ? opts.compound : false;\n\n  // Label for the graph itself\n  this._label = undefined;\n\n  // Defaults to be set when creating a new node\n  this._defaultNodeLabelFn = _.constant(undefined);\n\n  // Defaults to be set when creating a new edge\n  this._defaultEdgeLabelFn = _.constant(undefined);\n\n  // v -> label\n  this._nodes = {};\n\n  if (this._isCompound) {\n    // v -> parent\n    this._parent = {};\n\n    // v -> children\n    this._children = {};\n    this._children[GRAPH_NODE] = {};\n  }\n\n  // v -> edgeObj\n  this._in = {};\n\n  // u -> v -> Number\n  this._preds = {};\n\n  // v -> edgeObj\n  this._out = {};\n\n  // v -> w -> Number\n  this._sucs = {};\n\n  // e -> edgeObj\n  this._edgeObjs = {};\n\n  // e -> label\n  this._edgeLabels = {};\n}\n\n/* Number of nodes in the graph. Should only be changed by the implementation. */\nGraph.prototype._nodeCount = 0;\n\n/* Number of edges in the graph. Should only be changed by the implementation. */\nGraph.prototype._edgeCount = 0;\n\n\n/* === Graph functions ========= */\n\nGraph.prototype.isDirected = function() {\n  return this._isDirected;\n};\n\nGraph.prototype.isMultigraph = function() {\n  return this._isMultigraph;\n};\n\nGraph.prototype.isCompound = function() {\n  return this._isCompound;\n};\n\nGraph.prototype.setGraph = function(label) {\n  this._label = label;\n  return this;\n};\n\nGraph.prototype.graph = function() {\n  return this._label;\n};\n\n\n/* === Node functions ========== */\n\nGraph.prototype.setDefaultNodeLabel = function(newDefault) {\n  if (!_.isFunction(newDefault)) {\n    newDefault = _.constant(newDefault);\n  }\n  this._defaultNodeLabelFn = newDefault;\n  return this;\n};\n\nGraph.prototype.nodeCount = function() {\n  return this._nodeCount;\n};\n\nGraph.prototype.nodes = function() {\n  return _.keys(this._nodes);\n};\n\nGraph.prototype.sources = function() {\n  return _.filter(this.nodes(), _.bind(function(v) {\n    return _.isEmpty(this._in[v]);\n  }, this));\n};\n\nGraph.prototype.sinks = function() {\n  return _.filter(this.nodes(), _.bind(function(v) {\n    return _.isEmpty(this._out[v]);\n  }, this));\n};\n\nGraph.prototype.setNodes = function(vs, value) {\n  var args = arguments;\n  _.each(vs, _.bind(function(v) {\n    if (args.length > 1) {\n      this.setNode(v, value);\n    } else {\n      this.setNode(v);\n    }\n  }, this));\n  return this;\n};\n\nGraph.prototype.setNode = function(v, value) {\n  if (_.has(this._nodes, v)) {\n    if (arguments.length > 1) {\n      this._nodes[v] = value;\n    }\n    return this;\n  }\n\n  this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);\n  if (this._isCompound) {\n    this._parent[v] = GRAPH_NODE;\n    this._children[v] = {};\n    this._children[GRAPH_NODE][v] = true;\n  }\n  this._in[v] = {};\n  this._preds[v] = {};\n  this._out[v] = {};\n  this._sucs[v] = {};\n  ++this._nodeCount;\n  return this;\n};\n\nGraph.prototype.node = function(v) {\n  return this._nodes[v];\n};\n\nGraph.prototype.hasNode = function(v) {\n  return _.has(this._nodes, v);\n};\n\nGraph.prototype.removeNode =  function(v) {\n  var self = this;\n  if (_.has(this._nodes, v)) {\n    var removeEdge = function(e) { self.removeEdge(self._edgeObjs[e]); };\n    delete this._nodes[v];\n    if (this._isCompound) {\n      this._removeFromParentsChildList(v);\n      delete this._parent[v];\n      _.each(this.children(v), _.bind(function(child) {\n        this.setParent(child);\n      }, this));\n      delete this._children[v];\n    }\n    _.each(_.keys(this._in[v]), removeEdge);\n    delete this._in[v];\n    delete this._preds[v];\n    _.each(_.keys(this._out[v]), removeEdge);\n    delete this._out[v];\n    delete this._sucs[v];\n    --this._nodeCount;\n  }\n  return this;\n};\n\nGraph.prototype.setParent = function(v, parent) {\n  if (!this._isCompound) {\n    throw new Error(\"Cannot set parent in a non-compound graph\");\n  }\n\n  if (_.isUndefined(parent)) {\n    parent = GRAPH_NODE;\n  } else {\n    // Coerce parent to string\n    parent += \"\";\n    for (var ancestor = parent;\n         !_.isUndefined(ancestor);\n         ancestor = this.parent(ancestor)) {\n      if (ancestor === v) {\n        throw new Error(\"Setting \" + parent+ \" as parent of \" + v +\n                        \" would create create a cycle\");\n      }\n    }\n\n    this.setNode(parent);\n  }\n\n  this.setNode(v);\n  this._removeFromParentsChildList(v);\n  this._parent[v] = parent;\n  this._children[parent][v] = true;\n  return this;\n};\n\nGraph.prototype._removeFromParentsChildList = function(v) {\n  delete this._children[this._parent[v]][v];\n};\n\nGraph.prototype.parent = function(v) {\n  if (this._isCompound) {\n    var parent = this._parent[v];\n    if (parent !== GRAPH_NODE) {\n      return parent;\n    }\n  }\n};\n\nGraph.prototype.children = function(v) {\n  if (_.isUndefined(v)) {\n    v = GRAPH_NODE;\n  }\n\n  if (this._isCompound) {\n    var children = this._children[v];\n    if (children) {\n      return _.keys(children);\n    }\n  } else if (v === GRAPH_NODE) {\n    return this.nodes();\n  } else if (this.hasNode(v)) {\n    return [];\n  }\n};\n\nGraph.prototype.predecessors = function(v) {\n  var predsV = this._preds[v];\n  if (predsV) {\n    return _.keys(predsV);\n  }\n};\n\nGraph.prototype.successors = function(v) {\n  var sucsV = this._sucs[v];\n  if (sucsV) {\n    return _.keys(sucsV);\n  }\n};\n\nGraph.prototype.neighbors = function(v) {\n  var preds = this.predecessors(v);\n  if (preds) {\n    return _.union(preds, this.successors(v));\n  }\n};\n\nGraph.prototype.isLeaf = function (v) {\n  var neighbors;\n  if (this.isDirected()) {\n    neighbors = this.successors(v);\n  } else {\n    neighbors = this.neighbors(v);\n  }\n  return neighbors.length === 0;\n};\n\nGraph.prototype.filterNodes = function(filter) {\n  var copy = new this.constructor({\n    directed: this._isDirected,\n    multigraph: this._isMultigraph,\n    compound: this._isCompound\n  });\n\n  copy.setGraph(this.graph());\n\n  _.each(this._nodes, _.bind(function(value, v) {\n    if (filter(v)) {\n      copy.setNode(v, value);\n    }\n  }, this));\n\n  _.each(this._edgeObjs, _.bind(function(e) {\n    if (copy.hasNode(e.v) && copy.hasNode(e.w)) {\n      copy.setEdge(e, this.edge(e));\n    }\n  }, this));\n\n  var self = this;\n  var parents = {};\n  function findParent(v) {\n    var parent = self.parent(v);\n    if (parent === undefined || copy.hasNode(parent)) {\n      parents[v] = parent;\n      return parent;\n    } else if (parent in parents) {\n      return parents[parent];\n    } else {\n      return findParent(parent);\n    }\n  }\n\n  if (this._isCompound) {\n    _.each(copy.nodes(), function(v) {\n      copy.setParent(v, findParent(v));\n    });\n  }\n\n  return copy;\n};\n\n/* === Edge functions ========== */\n\nGraph.prototype.setDefaultEdgeLabel = function(newDefault) {\n  if (!_.isFunction(newDefault)) {\n    newDefault = _.constant(newDefault);\n  }\n  this._defaultEdgeLabelFn = newDefault;\n  return this;\n};\n\nGraph.prototype.edgeCount = function() {\n  return this._edgeCount;\n};\n\nGraph.prototype.edges = function() {\n  return _.values(this._edgeObjs);\n};\n\nGraph.prototype.setPath = function(vs, value) {\n  var self = this,\n      args = arguments;\n  _.reduce(vs, function(v, w) {\n    if (args.length > 1) {\n      self.setEdge(v, w, value);\n    } else {\n      self.setEdge(v, w);\n    }\n    return w;\n  });\n  return this;\n};\n\n/*\n * setEdge(v, w, [value, [name]])\n * setEdge({ v, w, [name] }, [value])\n */\nGraph.prototype.setEdge = function() {\n  var v, w, name, value,\n      valueSpecified = false,\n      arg0 = arguments[0];\n\n  if (typeof arg0 === \"object\" && arg0 !== null && \"v\" in arg0) {\n    v = arg0.v;\n    w = arg0.w;\n    name = arg0.name;\n    if (arguments.length === 2) {\n      value = arguments[1];\n      valueSpecified = true;\n    }\n  } else {\n    v = arg0;\n    w = arguments[1];\n    name = arguments[3];\n    if (arguments.length > 2) {\n      value = arguments[2];\n      valueSpecified = true;\n    }\n  }\n\n  v = \"\" + v;\n  w = \"\" + w;\n  if (!_.isUndefined(name)) {\n    name = \"\" + name;\n  }\n\n  var e = edgeArgsToId(this._isDirected, v, w, name);\n  if (_.has(this._edgeLabels, e)) {\n    if (valueSpecified) {\n      this._edgeLabels[e] = value;\n    }\n    return this;\n  }\n\n  if (!_.isUndefined(name) && !this._isMultigraph) {\n    throw new Error(\"Cannot set a named edge when isMultigraph = false\");\n  }\n\n  // It didn't exist, so we need to create it.\n  // First ensure the nodes exist.\n  this.setNode(v);\n  this.setNode(w);\n\n  this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);\n\n  var edgeObj = edgeArgsToObj(this._isDirected, v, w, name);\n  // Ensure we add undirected edges in a consistent way.\n  v = edgeObj.v;\n  w = edgeObj.w;\n\n  Object.freeze(edgeObj);\n  this._edgeObjs[e] = edgeObj;\n  incrementOrInitEntry(this._preds[w], v);\n  incrementOrInitEntry(this._sucs[v], w);\n  this._in[w][e] = edgeObj;\n  this._out[v][e] = edgeObj;\n  this._edgeCount++;\n  return this;\n};\n\nGraph.prototype.edge = function(v, w, name) {\n  var e = (arguments.length === 1\n            ? edgeObjToId(this._isDirected, arguments[0])\n            : edgeArgsToId(this._isDirected, v, w, name));\n  return this._edgeLabels[e];\n};\n\nGraph.prototype.hasEdge = function(v, w, name) {\n  var e = (arguments.length === 1\n            ? edgeObjToId(this._isDirected, arguments[0])\n            : edgeArgsToId(this._isDirected, v, w, name));\n  return _.has(this._edgeLabels, e);\n};\n\nGraph.prototype.removeEdge = function(v, w, name) {\n  var e = (arguments.length === 1\n            ? edgeObjToId(this._isDirected, arguments[0])\n            : edgeArgsToId(this._isDirected, v, w, name)),\n      edge = this._edgeObjs[e];\n  if (edge) {\n    v = edge.v;\n    w = edge.w;\n    delete this._edgeLabels[e];\n    delete this._edgeObjs[e];\n    decrementOrRemoveEntry(this._preds[w], v);\n    decrementOrRemoveEntry(this._sucs[v], w);\n    delete this._in[w][e];\n    delete this._out[v][e];\n    this._edgeCount--;\n  }\n  return this;\n};\n\nGraph.prototype.inEdges = function(v, u) {\n  var inV = this._in[v];\n  if (inV) {\n    var edges = _.values(inV);\n    if (!u) {\n      return edges;\n    }\n    return _.filter(edges, function(edge) { return edge.v === u; });\n  }\n};\n\nGraph.prototype.outEdges = function(v, w) {\n  var outV = this._out[v];\n  if (outV) {\n    var edges = _.values(outV);\n    if (!w) {\n      return edges;\n    }\n    return _.filter(edges, function(edge) { return edge.w === w; });\n  }\n};\n\nGraph.prototype.nodeEdges = function(v, w) {\n  var inEdges = this.inEdges(v, w);\n  if (inEdges) {\n    return inEdges.concat(this.outEdges(v, w));\n  }\n};\n\nfunction incrementOrInitEntry(map, k) {\n  if (map[k]) {\n    map[k]++;\n  } else {\n    map[k] = 1;\n  }\n}\n\nfunction decrementOrRemoveEntry(map, k) {\n  if (!--map[k]) { delete map[k]; }\n}\n\nfunction edgeArgsToId(isDirected, v_, w_, name) {\n  var v = \"\" + v_;\n  var w = \"\" + w_;\n  if (!isDirected && v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n  return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM +\n             (_.isUndefined(name) ? DEFAULT_EDGE_NAME : name);\n}\n\nfunction edgeArgsToObj(isDirected, v_, w_, name) {\n  var v = \"\" + v_;\n  var w = \"\" + w_;\n  if (!isDirected && v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n  var edgeObj =  { v: v, w: w };\n  if (name) {\n    edgeObj.name = name;\n  }\n  return edgeObj;\n}\n\nfunction edgeObjToId(isDirected, edgeObj) {\n  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}