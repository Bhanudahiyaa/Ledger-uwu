{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport BaseModel from \"../../core/BaseModel\";\nimport { PointFillTriangulation } from \"../../core/triangulation\";\n/* babel-plugin-inline-import '../shaders/fill/fill_frag.glsl' */\nconst pointFillFrag = \"\\nlayout(std140) uniform commonUniforms {\\n  vec3 u_blur_height_fixed;\\n  float u_stroke_width;\\n  float u_additive;\\n  float u_stroke_opacity;\\n  float u_size_unit;\\n  float u_time;\\n  vec4 u_animate;\\n};\\n\\nin vec4 v_color;\\nin vec4 v_stroke;\\nin vec4 v_data;\\nin float v_radius;\\n\\n#pragma include \\\"scene_uniforms\\\"\\n#pragma include \\\"sdf_2d\\\"\\n#pragma include \\\"picking\\\"\\n\\nout vec4 outputColor;\\n\\nvoid main() {\\n  int shape = int(floor(v_data.w + 0.5));\\n  lowp float antialiasblur = v_data.z;\\n  float r = v_radius / (v_radius + u_stroke_width);\\n\\n  float outer_df;\\n  float inner_df;\\n  // 'circle', 'triangle', 'square', 'pentagon', 'hexagon', 'octogon', 'hexagram', 'rhombus', 'vesica'\\n  if (shape == 0) {\\n    outer_df = sdCircle(v_data.xy, 1.0);\\n    inner_df = sdCircle(v_data.xy, r);\\n  } else if (shape == 1) {\\n    outer_df = sdEquilateralTriangle(1.1 * v_data.xy);\\n    inner_df = sdEquilateralTriangle(1.1 / r * v_data.xy);\\n  } else if (shape == 2) {\\n    outer_df = sdBox(v_data.xy, vec2(1.));\\n    inner_df = sdBox(v_data.xy, vec2(r));\\n  } else if (shape == 3) {\\n    outer_df = sdPentagon(v_data.xy, 0.8);\\n    inner_df = sdPentagon(v_data.xy, r * 0.8);\\n  } else if (shape == 4) {\\n    outer_df = sdHexagon(v_data.xy, 0.8);\\n    inner_df = sdHexagon(v_data.xy, r * 0.8);\\n  } else if (shape == 5) {\\n    outer_df = sdOctogon(v_data.xy, 1.0);\\n    inner_df = sdOctogon(v_data.xy, r);\\n  } else if (shape == 6) {\\n    outer_df = sdHexagram(v_data.xy, 0.52);\\n    inner_df = sdHexagram(v_data.xy, r * 0.52);\\n  } else if (shape == 7) {\\n    outer_df = sdRhombus(v_data.xy, vec2(1.0));\\n    inner_df = sdRhombus(v_data.xy, vec2(r));\\n  } else if (shape == 8) {\\n    outer_df = sdVesica(v_data.xy, 1.1, 0.8);\\n    inner_df = sdVesica(v_data.xy, r * 1.1, r * 0.8);\\n  }\\n\\n  float opacity_t = smoothstep(0.0, antialiasblur, outer_df);\\n\\n  float color_t = u_stroke_width < 0.01 ? 0.0 : smoothstep(\\n    antialiasblur,\\n    0.0,\\n    inner_df\\n  );\\n\\n  float PI = 3.14159;\\n  float N_RINGS = 3.0;\\n  float FREQ = 1.0;\\n\\n  if(u_stroke_width < 0.01) {\\n    outputColor = v_color;\\n  } else {\\n    outputColor = mix(v_color, v_stroke * u_stroke_opacity, color_t);\\n  }\\n  float intensity = 1.0;\\n  if(u_time!=-1.0){\\n    //wave\\u76F8\\u5173\\u903B\\u8F91\\n    float d = length(v_data.xy);\\n    if(d > 0.5) {\\n      discard;\\n    }\\n    intensity = clamp(cos(d * PI), 0.0, 1.0) * clamp(cos(2.0 * PI * (d * 2.0 * u_animate.z - u_animate.y * u_time)), 0.0, 1.0);\\n  }\\n\\n  if(u_additive > 0.0) {\\n    outputColor *= opacity_t;\\n    outputColor *= intensity;//wave\\n    outputColor = filterColorAlpha(outputColor, outputColor.a);\\n  } else {\\n    outputColor.a *= opacity_t;\\n    outputColor.a *= intensity;//wave \\n    outputColor = filterColor(outputColor);\\n  }\\n   // \\u4F5C\\u4E3A mask \\u6A21\\u677F\\u65F6\\u9700\\u8981\\u4E22\\u5F03\\u900F\\u660E\\u7684\\u50CF\\u7D20\\n  if(outputColor.a < 0.01) {\\n    discard;\\n  } \\n}\\n\";\n/* babel-plugin-inline-import '../shaders/fill/fill_vert.glsl' */\nconst pointFillVert = \"layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\\nlayout(location = ATTRIBUTE_LOCATION_SHAPE) in float a_Shape;\\nlayout(location = ATTRIBUTE_LOCATION_EXTRUDE) in vec3 a_Extrude;\\n\\nlayout(std140) uniform commonUniforms {\\n  vec3 u_blur_height_fixed;\\n  float u_stroke_width;\\n  float u_additive;\\n  float u_stroke_opacity;\\n  float u_size_unit;\\n  float u_time;\\n  vec4 u_animate;\\n};\\n\\nout vec4 v_color;\\nout vec4 v_stroke;\\nout vec4 v_data;\\nout float v_radius;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"picking\\\"\\n#pragma include \\\"rotation_2d\\\"\\n\\nvoid main() {\\n  // \\u900F\\u660E\\u5EA6\\u8BA1\\u7B97\\n   v_stroke = stroke;\\n  vec3 extrude = a_Extrude;\\n  float shape_type = a_Shape;\\n  /*\\n  *  setPickingSize \\u8BBE\\u7F6E\\u62FE\\u53D6\\u5927\\u5C0F\\n  *  u_meter2coord \\u5728\\u7B49\\u9762\\u79EF\\u5927\\u5C0F\\u7684\\u65F6\\u5019\\u8BBE\\u7F6E\\u5355\\u4F4D\\n  */\\n  float newSize = setPickingSize(a_Size);\\n  // float newSize = setPickingSize(a_Size) * 0.00001038445708445579;\\n\\n\\n\\n  // unpack color(vec2)\\n  v_color = vec4(a_Color.xyz, a_Color.w * opacity);\\n\\n  if(u_size_unit == 1.0) {\\n    newSize = newSize  * u_PixelsPerMeter.z;\\n  }\\n\\n   v_radius = newSize;\\n\\n  // anti-alias\\n  //  float antialiased_blur = -max(u_blur, antialiasblur);\\n  float antialiasblur = -max(2.0 / u_DevicePixelRatio / newSize, u_blur_height_fixed.x);\\n\\n  vec2 offset = (extrude.xy * (newSize + u_stroke_width) + u_offsets);\\n\\n  offset = project_pixel(offset);\\n  offset = rotate_matrix(offset,rotation);\\n\\n  // TODP: /abs(extrude.x) \\u662F\\u4E3A\\u4E86\\u517C\\u5BB9\\u5730\\u7403\\u6A21\\u5F0F\\n  v_data = vec4(extrude.x/abs(extrude.x), extrude.y/abs(extrude.y), antialiasblur,shape_type);\\n\\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0.0, 1.0), a_Position64Low);\\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, project_pixel(setPickingOrder(0.0)), 1.0));\\n\\n  float raisingHeight = u_blur_height_fixed.y;\\n\\n  if(u_blur_height_fixed.z < 1.0) { // false\\n    raisingHeight = project_pixel(u_blur_height_fixed.y);\\n  } else {\\n     if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\\n      float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\\n      raisingHeight = u_blur_height_fixed.y * mapboxZoomScale;\\n    }\\n  }\\n\\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, raisingHeight, 1.0));\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\nimport { SizeUnitType } from \"../../core/interface\";\nexport default class FillModel extends BaseModel {\n  get attributeLocation() {\n    return Object.assign(super.attributeLocation, {\n      MAX: super.attributeLocation.MAX,\n      SIZE: 9,\n      SHAPE: 10,\n      EXTRUDE: 11\n    });\n  }\n  getCommonUniformsInfo() {\n    const {\n      strokeOpacity = 1,\n      strokeWidth = 0,\n      blend,\n      blur = 0,\n      raisingHeight = 0,\n      heightfixed = false,\n      unit = 'pixel'\n    } = this.layer.getLayerConfig();\n    let u_time = this.getAnimateUniforms().u_time;\n    if (isNaN(u_time)) {\n      u_time = -1.0;\n    }\n    const commonOptions = {\n      u_blur_height_fixed: [blur, Number(raisingHeight), Number(heightfixed)],\n      u_stroke_width: strokeWidth,\n      u_additive: blend === 'additive' ? 1.0 : 0.0,\n      u_stroke_opacity: strokeOpacity,\n      u_size_unit: SizeUnitType[unit],\n      u_time,\n      u_animate: this.getAnimateUniforms().u_animate\n    };\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  getAnimateUniforms() {\n    const {\n      animateOption = {\n        enable: false\n      }\n    } = this.layer.getLayerConfig();\n    return {\n      u_animate: this.animateOption2Array(animateOption),\n      u_time: this.layer.getLayerAnimateTime()\n    };\n  }\n  getAttribute() {\n    return this.styleAttributeService.createAttributesAndIndices(this.layer.getEncodedData(), PointFillTriangulation);\n  }\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return _this.buildModels();\n    })();\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        frag,\n        vert,\n        type\n      } = _this2.getShaders();\n      _this2.layer.triangulation = PointFillTriangulation;\n      _this2.initUniformsBuffer();\n      const model = yield _this2.layer.buildLayerModel({\n        moduleName: type,\n        vertexShader: vert,\n        fragmentShader: frag,\n        defines: _this2.getDefines(),\n        inject: _this2.getInject(),\n        triangulation: PointFillTriangulation,\n        depth: {\n          enable: false\n        }\n      });\n      return [model];\n    })();\n  }\n\n  /**\n   * 根据 animateOption 的值返回对应的 shader 代码\n   * @returns\n   */\n  getShaders() {\n    return {\n      frag: pointFillFrag,\n      vert: pointFillVert,\n      type: 'pointFill'\n    };\n  }\n\n  // overwrite baseModel func\n  animateOption2Array(option) {\n    return [option.enable ? 0 : 1.0, option.speed || 1, option.rings || 3, 0];\n  }\n  registerBuiltinAttributes() {\n    // 注册 Style 参与数据映射的内置属性\n    const shape2d = this.layer.getLayerConfig().shape2d;\n\n    // 注册 Position 属性 64 位地位部分，经纬度数据开启双精度，避免大于 20层级以上出现数据偏移\n    this.registerPosition64LowAttribute();\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'extrude',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Extrude',\n        shaderLocation: this.attributeLocation.EXTRUDE,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        update: (feature, featureIdx, vertex, attributeIdx) => {\n          const extrude = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0];\n          const extrudeIndex = attributeIdx % 4 * 3;\n          return [extrude[extrudeIndex], extrude[extrudeIndex + 1], extrude[extrudeIndex + 2]];\n        }\n      }\n    });\n\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Size',\n        shaderLocation: this.attributeLocation.SIZE,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 1,\n        update: feature => {\n          const {\n            size = 5\n          } = feature;\n          return Array.isArray(size) ? [size[0]] : [size];\n        }\n      }\n    });\n\n    // point layer shape;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'shape',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Shape',\n        shaderLocation: this.attributeLocation.SHAPE,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 1,\n        update: feature => {\n          const {\n            shape = 2\n          } = feature;\n          const shapeIndex = shape2d.indexOf(shape);\n          return [shapeIndex];\n        }\n      }\n    });\n  }\n}","map":{"version":3,"names":["_asyncToGenerator","AttributeType","gl","BaseModel","PointFillTriangulation","pointFillFrag","pointFillVert","SizeUnitType","FillModel","attributeLocation","Object","assign","MAX","SIZE","SHAPE","EXTRUDE","getCommonUniformsInfo","strokeOpacity","strokeWidth","blend","blur","raisingHeight","heightfixed","unit","layer","getLayerConfig","u_time","getAnimateUniforms","isNaN","commonOptions","u_blur_height_fixed","Number","u_stroke_width","u_additive","u_stroke_opacity","u_size_unit","u_animate","commonBufferInfo","getUniformsBufferInfo","animateOption","enable","animateOption2Array","getLayerAnimateTime","getAttribute","styleAttributeService","createAttributesAndIndices","getEncodedData","initModels","_this","buildModels","_this2","frag","vert","type","getShaders","triangulation","initUniformsBuffer","model","buildLayerModel","moduleName","vertexShader","fragmentShader","defines","getDefines","inject","getInject","depth","option","speed","rings","registerBuiltinAttributes","shape2d","registerPosition64LowAttribute","registerStyleAttribute","name","Attribute","descriptor","shaderLocation","buffer","usage","DYNAMIC_DRAW","data","FLOAT","size","update","feature","featureIdx","vertex","attributeIdx","extrude","extrudeIndex","Array","isArray","shape","shapeIndex","indexOf"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/l7-layers/es/point/models/fill.js"],"sourcesContent":["import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport BaseModel from \"../../core/BaseModel\";\nimport { PointFillTriangulation } from \"../../core/triangulation\";\n/* babel-plugin-inline-import '../shaders/fill/fill_frag.glsl' */\nconst pointFillFrag = \"\\nlayout(std140) uniform commonUniforms {\\n  vec3 u_blur_height_fixed;\\n  float u_stroke_width;\\n  float u_additive;\\n  float u_stroke_opacity;\\n  float u_size_unit;\\n  float u_time;\\n  vec4 u_animate;\\n};\\n\\nin vec4 v_color;\\nin vec4 v_stroke;\\nin vec4 v_data;\\nin float v_radius;\\n\\n#pragma include \\\"scene_uniforms\\\"\\n#pragma include \\\"sdf_2d\\\"\\n#pragma include \\\"picking\\\"\\n\\nout vec4 outputColor;\\n\\nvoid main() {\\n  int shape = int(floor(v_data.w + 0.5));\\n  lowp float antialiasblur = v_data.z;\\n  float r = v_radius / (v_radius + u_stroke_width);\\n\\n  float outer_df;\\n  float inner_df;\\n  // 'circle', 'triangle', 'square', 'pentagon', 'hexagon', 'octogon', 'hexagram', 'rhombus', 'vesica'\\n  if (shape == 0) {\\n    outer_df = sdCircle(v_data.xy, 1.0);\\n    inner_df = sdCircle(v_data.xy, r);\\n  } else if (shape == 1) {\\n    outer_df = sdEquilateralTriangle(1.1 * v_data.xy);\\n    inner_df = sdEquilateralTriangle(1.1 / r * v_data.xy);\\n  } else if (shape == 2) {\\n    outer_df = sdBox(v_data.xy, vec2(1.));\\n    inner_df = sdBox(v_data.xy, vec2(r));\\n  } else if (shape == 3) {\\n    outer_df = sdPentagon(v_data.xy, 0.8);\\n    inner_df = sdPentagon(v_data.xy, r * 0.8);\\n  } else if (shape == 4) {\\n    outer_df = sdHexagon(v_data.xy, 0.8);\\n    inner_df = sdHexagon(v_data.xy, r * 0.8);\\n  } else if (shape == 5) {\\n    outer_df = sdOctogon(v_data.xy, 1.0);\\n    inner_df = sdOctogon(v_data.xy, r);\\n  } else if (shape == 6) {\\n    outer_df = sdHexagram(v_data.xy, 0.52);\\n    inner_df = sdHexagram(v_data.xy, r * 0.52);\\n  } else if (shape == 7) {\\n    outer_df = sdRhombus(v_data.xy, vec2(1.0));\\n    inner_df = sdRhombus(v_data.xy, vec2(r));\\n  } else if (shape == 8) {\\n    outer_df = sdVesica(v_data.xy, 1.1, 0.8);\\n    inner_df = sdVesica(v_data.xy, r * 1.1, r * 0.8);\\n  }\\n\\n  float opacity_t = smoothstep(0.0, antialiasblur, outer_df);\\n\\n  float color_t = u_stroke_width < 0.01 ? 0.0 : smoothstep(\\n    antialiasblur,\\n    0.0,\\n    inner_df\\n  );\\n\\n  float PI = 3.14159;\\n  float N_RINGS = 3.0;\\n  float FREQ = 1.0;\\n\\n  if(u_stroke_width < 0.01) {\\n    outputColor = v_color;\\n  } else {\\n    outputColor = mix(v_color, v_stroke * u_stroke_opacity, color_t);\\n  }\\n  float intensity = 1.0;\\n  if(u_time!=-1.0){\\n    //wave\\u76F8\\u5173\\u903B\\u8F91\\n    float d = length(v_data.xy);\\n    if(d > 0.5) {\\n      discard;\\n    }\\n    intensity = clamp(cos(d * PI), 0.0, 1.0) * clamp(cos(2.0 * PI * (d * 2.0 * u_animate.z - u_animate.y * u_time)), 0.0, 1.0);\\n  }\\n\\n  if(u_additive > 0.0) {\\n    outputColor *= opacity_t;\\n    outputColor *= intensity;//wave\\n    outputColor = filterColorAlpha(outputColor, outputColor.a);\\n  } else {\\n    outputColor.a *= opacity_t;\\n    outputColor.a *= intensity;//wave \\n    outputColor = filterColor(outputColor);\\n  }\\n   // \\u4F5C\\u4E3A mask \\u6A21\\u677F\\u65F6\\u9700\\u8981\\u4E22\\u5F03\\u900F\\u660E\\u7684\\u50CF\\u7D20\\n  if(outputColor.a < 0.01) {\\n    discard;\\n  } \\n}\\n\";\n/* babel-plugin-inline-import '../shaders/fill/fill_vert.glsl' */\nconst pointFillVert = \"layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\\nlayout(location = ATTRIBUTE_LOCATION_SHAPE) in float a_Shape;\\nlayout(location = ATTRIBUTE_LOCATION_EXTRUDE) in vec3 a_Extrude;\\n\\nlayout(std140) uniform commonUniforms {\\n  vec3 u_blur_height_fixed;\\n  float u_stroke_width;\\n  float u_additive;\\n  float u_stroke_opacity;\\n  float u_size_unit;\\n  float u_time;\\n  vec4 u_animate;\\n};\\n\\nout vec4 v_color;\\nout vec4 v_stroke;\\nout vec4 v_data;\\nout float v_radius;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"picking\\\"\\n#pragma include \\\"rotation_2d\\\"\\n\\nvoid main() {\\n  // \\u900F\\u660E\\u5EA6\\u8BA1\\u7B97\\n   v_stroke = stroke;\\n  vec3 extrude = a_Extrude;\\n  float shape_type = a_Shape;\\n  /*\\n  *  setPickingSize \\u8BBE\\u7F6E\\u62FE\\u53D6\\u5927\\u5C0F\\n  *  u_meter2coord \\u5728\\u7B49\\u9762\\u79EF\\u5927\\u5C0F\\u7684\\u65F6\\u5019\\u8BBE\\u7F6E\\u5355\\u4F4D\\n  */\\n  float newSize = setPickingSize(a_Size);\\n  // float newSize = setPickingSize(a_Size) * 0.00001038445708445579;\\n\\n\\n\\n  // unpack color(vec2)\\n  v_color = vec4(a_Color.xyz, a_Color.w * opacity);\\n\\n  if(u_size_unit == 1.0) {\\n    newSize = newSize  * u_PixelsPerMeter.z;\\n  }\\n\\n   v_radius = newSize;\\n\\n  // anti-alias\\n  //  float antialiased_blur = -max(u_blur, antialiasblur);\\n  float antialiasblur = -max(2.0 / u_DevicePixelRatio / newSize, u_blur_height_fixed.x);\\n\\n  vec2 offset = (extrude.xy * (newSize + u_stroke_width) + u_offsets);\\n\\n  offset = project_pixel(offset);\\n  offset = rotate_matrix(offset,rotation);\\n\\n  // TODP: /abs(extrude.x) \\u662F\\u4E3A\\u4E86\\u517C\\u5BB9\\u5730\\u7403\\u6A21\\u5F0F\\n  v_data = vec4(extrude.x/abs(extrude.x), extrude.y/abs(extrude.y), antialiasblur,shape_type);\\n\\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0.0, 1.0), a_Position64Low);\\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, project_pixel(setPickingOrder(0.0)), 1.0));\\n\\n  float raisingHeight = u_blur_height_fixed.y;\\n\\n  if(u_blur_height_fixed.z < 1.0) { // false\\n    raisingHeight = project_pixel(u_blur_height_fixed.y);\\n  } else {\\n     if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\\n      float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\\n      raisingHeight = u_blur_height_fixed.y * mapboxZoomScale;\\n    }\\n  }\\n\\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, raisingHeight, 1.0));\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\nimport { SizeUnitType } from \"../../core/interface\";\nexport default class FillModel extends BaseModel {\n  get attributeLocation() {\n    return Object.assign(super.attributeLocation, {\n      MAX: super.attributeLocation.MAX,\n      SIZE: 9,\n      SHAPE: 10,\n      EXTRUDE: 11\n    });\n  }\n  getCommonUniformsInfo() {\n    const {\n      strokeOpacity = 1,\n      strokeWidth = 0,\n      blend,\n      blur = 0,\n      raisingHeight = 0,\n      heightfixed = false,\n      unit = 'pixel'\n    } = this.layer.getLayerConfig();\n    let u_time = this.getAnimateUniforms().u_time;\n    if (isNaN(u_time)) {\n      u_time = -1.0;\n    }\n    const commonOptions = {\n      u_blur_height_fixed: [blur, Number(raisingHeight), Number(heightfixed)],\n      u_stroke_width: strokeWidth,\n      u_additive: blend === 'additive' ? 1.0 : 0.0,\n      u_stroke_opacity: strokeOpacity,\n      u_size_unit: SizeUnitType[unit],\n      u_time,\n      u_animate: this.getAnimateUniforms().u_animate\n    };\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  getAnimateUniforms() {\n    const {\n      animateOption = {\n        enable: false\n      }\n    } = this.layer.getLayerConfig();\n    return {\n      u_animate: this.animateOption2Array(animateOption),\n      u_time: this.layer.getLayerAnimateTime()\n    };\n  }\n  getAttribute() {\n    return this.styleAttributeService.createAttributesAndIndices(this.layer.getEncodedData(), PointFillTriangulation);\n  }\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return _this.buildModels();\n    })();\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        frag,\n        vert,\n        type\n      } = _this2.getShaders();\n      _this2.layer.triangulation = PointFillTriangulation;\n      _this2.initUniformsBuffer();\n      const model = yield _this2.layer.buildLayerModel({\n        moduleName: type,\n        vertexShader: vert,\n        fragmentShader: frag,\n        defines: _this2.getDefines(),\n        inject: _this2.getInject(),\n        triangulation: PointFillTriangulation,\n        depth: {\n          enable: false\n        }\n      });\n      return [model];\n    })();\n  }\n\n  /**\n   * 根据 animateOption 的值返回对应的 shader 代码\n   * @returns\n   */\n  getShaders() {\n    return {\n      frag: pointFillFrag,\n      vert: pointFillVert,\n      type: 'pointFill'\n    };\n  }\n\n  // overwrite baseModel func\n  animateOption2Array(option) {\n    return [option.enable ? 0 : 1.0, option.speed || 1, option.rings || 3, 0];\n  }\n  registerBuiltinAttributes() {\n    // 注册 Style 参与数据映射的内置属性\n    const shape2d = this.layer.getLayerConfig().shape2d;\n\n    // 注册 Position 属性 64 位地位部分，经纬度数据开启双精度，避免大于 20层级以上出现数据偏移\n    this.registerPosition64LowAttribute();\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'extrude',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Extrude',\n        shaderLocation: this.attributeLocation.EXTRUDE,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        update: (feature, featureIdx, vertex, attributeIdx) => {\n          const extrude = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0];\n          const extrudeIndex = attributeIdx % 4 * 3;\n          return [extrude[extrudeIndex], extrude[extrudeIndex + 1], extrude[extrudeIndex + 2]];\n        }\n      }\n    });\n\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Size',\n        shaderLocation: this.attributeLocation.SIZE,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 1,\n        update: feature => {\n          const {\n            size = 5\n          } = feature;\n          return Array.isArray(size) ? [size[0]] : [size];\n        }\n      }\n    });\n\n    // point layer shape;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'shape',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Shape',\n        shaderLocation: this.attributeLocation.SHAPE,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 1,\n        update: feature => {\n          const {\n            shape = 2\n          } = feature;\n          const shapeIndex = shape2d.indexOf(shape);\n          return [shapeIndex];\n        }\n      }\n    });\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}