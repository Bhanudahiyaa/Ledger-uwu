{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Angle, Point, Rectangle } from '../../geometry';\nimport { ArrayExt, FunctionExt } from '../../util';\nimport { Vector } from '../../util/vector';\nimport { View } from '../../view/view';\nexport class Snapline extends View {\n  constructor(options) {\n    super();\n    const {\n        graph\n      } = options,\n      others = __rest(options, [\"graph\"]);\n    this.graph = graph;\n    this.options = Object.assign({\n      tolerance: 10\n    }, others);\n    this.offset = {\n      x: 0,\n      y: 0\n    };\n    this.render();\n    this.parseFilter();\n    if (!this.disabled) {\n      this.startListening();\n    }\n  }\n  get model() {\n    return this.graph.model;\n  }\n  get containerClassName() {\n    return this.prefixClassName('widget-snapline');\n  }\n  get verticalClassName() {\n    return `${this.containerClassName}-vertical`;\n  }\n  get horizontalClassName() {\n    return `${this.containerClassName}-horizontal`;\n  }\n  get disabled() {\n    return this.options.enabled !== true || this.graph.options.snapline.enabled !== true;\n  }\n  enable() {\n    if (this.disabled) {\n      this.options.enabled = true;\n      this.graph.options.snapline.enabled = true;\n      this.startListening();\n    }\n  }\n  disable() {\n    if (!this.disabled) {\n      this.options.enabled = false;\n      this.graph.options.snapline.enabled = false;\n      this.stopListening();\n    }\n  }\n  setFilter(filter) {\n    this.options.filter = filter;\n    this.parseFilter();\n  }\n  render() {\n    const container = this.containerWrapper = new Vector('svg');\n    const horizontal = this.horizontal = new Vector('line');\n    const vertical = this.vertical = new Vector('line');\n    container.addClass(this.containerClassName);\n    horizontal.addClass(this.horizontalClassName);\n    vertical.addClass(this.verticalClassName);\n    container.setAttribute('width', '100%');\n    container.setAttribute('height', '100%');\n    horizontal.setAttribute('display', 'none');\n    vertical.setAttribute('display', 'none');\n    container.append([horizontal, vertical]);\n    if (this.options.className) {\n      container.addClass(this.options.className);\n    }\n    this.container = this.containerWrapper.node;\n  }\n  startListening() {\n    this.stopListening();\n    this.graph.on('node:mousedown', this.captureCursorOffset, this);\n    this.graph.on('node:mousemove', this.snapOnMoving, this);\n    this.model.on('batch:stop', this.onBatchStop, this);\n    this.delegateDocumentEvents({\n      mouseup: 'hide',\n      touchend: 'hide'\n    });\n  }\n  stopListening() {\n    this.graph.off('node:mousedown', this.captureCursorOffset, this);\n    this.graph.off('node:mousemove', this.snapOnMoving, this);\n    this.model.off('batch:stop', this.onBatchStop, this);\n    this.undelegateDocumentEvents();\n  }\n  parseFilter() {\n    this.filterShapes = {};\n    this.filterCells = {};\n    this.filterFunction = null;\n    const filter = this.options.filter;\n    if (Array.isArray(filter)) {\n      filter.forEach(item => {\n        if (typeof item === 'string') {\n          this.filterShapes[item] = true;\n        } else {\n          this.filterCells[item.id] = true;\n        }\n      });\n    } else if (typeof filter === 'function') {\n      this.filterFunction = filter;\n    }\n  }\n  onBatchStop({\n    name,\n    data\n  }) {\n    if (name === 'resize') {\n      this.snapOnResizing(data.cell, data);\n    }\n  }\n  captureCursorOffset({\n    view,\n    x,\n    y\n  }) {\n    const targetView = view.getDelegatedView();\n    if (targetView && this.isNodeMovable(targetView)) {\n      const pos = view.cell.getPosition();\n      this.offset = {\n        x: x - pos.x,\n        y: y - pos.y\n      };\n    }\n  }\n  isNodeMovable(view) {\n    return view && view.cell.isNode() && view.can('nodeMovable');\n  }\n  snapOnResizing(node, options) {\n    if (this.options.resizing && !options.snapped && options.ui && options.direction && options.trueDirection) {\n      const view = this.graph.renderer.findViewByCell(node);\n      if (view && view.cell.isNode()) {\n        const nodeBbox = node.getBBox();\n        const nodeBBoxRotated = nodeBbox.bbox(node.getAngle());\n        const nodeTopLeft = nodeBBoxRotated.getTopLeft();\n        const nodeBottomRight = nodeBBoxRotated.getBottomRight();\n        const angle = Angle.normalize(node.getAngle());\n        const tolerance = this.options.tolerance || 0;\n        let verticalLeft;\n        let verticalTop;\n        let verticalHeight;\n        let horizontalTop;\n        let horizontalLeft;\n        let horizontalWidth;\n        const snapOrigin = {\n          vertical: 0,\n          horizontal: 0\n        };\n        const direction = options.direction;\n        const trueDirection = options.trueDirection;\n        const relativeDirection = options.relativeDirection;\n        if (trueDirection.indexOf('right') !== -1) {\n          snapOrigin.vertical = nodeBottomRight.x;\n        } else {\n          snapOrigin.vertical = nodeTopLeft.x;\n        }\n        if (trueDirection.indexOf('bottom') !== -1) {\n          snapOrigin.horizontal = nodeBottomRight.y;\n        } else {\n          snapOrigin.horizontal = nodeTopLeft.y;\n        }\n        this.model.getNodes().some(cell => {\n          if (this.isIgnored(node, cell)) {\n            return false;\n          }\n          const snapBBox = cell.getBBox().bbox(cell.getAngle());\n          const snapTopLeft = snapBBox.getTopLeft();\n          const snapBottomRight = snapBBox.getBottomRight();\n          const groups = {\n            vertical: [snapTopLeft.x, snapBottomRight.x],\n            horizontal: [snapTopLeft.y, snapBottomRight.y]\n          };\n          const distances = {};\n          Object.keys(groups).forEach(k => {\n            const key = k;\n            const list = groups[key].map(value => ({\n              position: value,\n              distance: Math.abs(value - snapOrigin[key])\n            })).filter(item => item.distance <= tolerance);\n            distances[key] = ArrayExt.sortBy(list, item => item.distance);\n          });\n          if (verticalLeft == null && distances.vertical.length > 0) {\n            verticalLeft = distances.vertical[0].position;\n            verticalTop = Math.min(nodeBBoxRotated.y, snapBBox.y);\n            verticalHeight = Math.max(nodeBottomRight.y, snapBottomRight.y) - verticalTop;\n          }\n          if (horizontalTop == null && distances.horizontal.length > 0) {\n            horizontalTop = distances.horizontal[0].position;\n            horizontalLeft = Math.min(nodeBBoxRotated.x, snapBBox.x);\n            horizontalWidth = Math.max(nodeBottomRight.x, snapBottomRight.x) - horizontalLeft;\n          }\n          return verticalLeft != null && horizontalTop != null;\n        });\n        this.hide();\n        let dx = 0;\n        let dy = 0;\n        if (horizontalTop != null || verticalLeft != null) {\n          if (verticalLeft != null) {\n            dx = trueDirection.indexOf('right') !== -1 ? verticalLeft - nodeBottomRight.x : nodeTopLeft.x - verticalLeft;\n          }\n          if (horizontalTop != null) {\n            dy = trueDirection.indexOf('bottom') !== -1 ? horizontalTop - nodeBottomRight.y : nodeTopLeft.y - horizontalTop;\n          }\n        }\n        let dWidth = 0;\n        let dHeight = 0;\n        if (angle % 90 === 0) {\n          if (angle === 90 || angle === 270) {\n            dWidth = dy;\n            dHeight = dx;\n          } else {\n            dWidth = dx;\n            dHeight = dy;\n          }\n        } else {\n          const quadrant = angle >= 0 && angle < 90 ? 1 : angle >= 90 && angle < 180 ? 4 : angle >= 180 && angle < 270 ? 3 : 2;\n          if (horizontalTop != null && verticalLeft != null) {\n            if (dx < dy) {\n              dy = 0;\n              horizontalTop = undefined;\n            } else {\n              dx = 0;\n              verticalLeft = undefined;\n            }\n          }\n          const rad = Angle.toRad(angle % 90);\n          if (dx) {\n            dWidth = quadrant === 3 ? dx / Math.cos(rad) : dx / Math.sin(rad);\n          }\n          if (dy) {\n            dHeight = quadrant === 3 ? dy / Math.cos(rad) : dy / Math.sin(rad);\n          }\n          const quadrant13 = quadrant === 1 || quadrant === 3;\n          switch (relativeDirection) {\n            case 'top':\n            case 'bottom':\n              dHeight = dy ? dy / (quadrant13 ? Math.cos(rad) : Math.sin(rad)) : dx / (quadrant13 ? Math.sin(rad) : Math.cos(rad));\n              break;\n            case 'left':\n            case 'right':\n              dWidth = dx ? dx / (quadrant13 ? Math.cos(rad) : Math.sin(rad)) : dy / (quadrant13 ? Math.sin(rad) : Math.cos(rad));\n              break;\n            default:\n              break;\n          }\n        }\n        switch (relativeDirection) {\n          case 'top':\n          case 'bottom':\n            dWidth = 0;\n            break;\n          case 'left':\n          case 'right':\n            dHeight = 0;\n            break;\n          default:\n            break;\n        }\n        const gridSize = this.graph.getGridSize();\n        let newWidth = Math.max(nodeBbox.width + dWidth, gridSize);\n        let newHeight = Math.max(nodeBbox.height + dHeight, gridSize);\n        if (options.minWidth && options.minWidth > gridSize) {\n          newWidth = Math.max(newWidth, options.minWidth);\n        }\n        if (options.minHeight && options.minHeight > gridSize) {\n          newHeight = Math.max(newHeight, options.minHeight);\n        }\n        if (options.maxWidth) {\n          newWidth = Math.min(newWidth, options.maxWidth);\n        }\n        if (options.maxHeight) {\n          newHeight = Math.min(newHeight, options.maxHeight);\n        }\n        if (options.preserveAspectRatio) {\n          if (dHeight < dWidth) {\n            newHeight = newWidth * (nodeBbox.height / nodeBbox.width);\n          } else {\n            newWidth = newHeight * (nodeBbox.width / nodeBbox.height);\n          }\n        }\n        if (newWidth !== nodeBbox.width || newHeight !== nodeBbox.height) {\n          node.resize(newWidth, newHeight, {\n            direction,\n            relativeDirection,\n            trueDirection,\n            snapped: true,\n            snaplines: this.cid,\n            restrict: this.graph.hook.getRestrictArea(view)\n          });\n          if (verticalHeight) {\n            verticalHeight += newHeight - nodeBbox.height;\n          }\n          if (horizontalWidth) {\n            horizontalWidth += newWidth - nodeBbox.width;\n          }\n        }\n        const newRotatedBBox = node.getBBox().bbox(angle);\n        if (verticalLeft && Math.abs(newRotatedBBox.x - verticalLeft) > 1 && Math.abs(newRotatedBBox.width + newRotatedBBox.x - verticalLeft) > 1) {\n          verticalLeft = undefined;\n        }\n        if (horizontalTop && Math.abs(newRotatedBBox.y - horizontalTop) > 1 && Math.abs(newRotatedBBox.height + newRotatedBBox.y - horizontalTop) > 1) {\n          horizontalTop = undefined;\n        }\n        this.update({\n          verticalLeft,\n          verticalTop,\n          verticalHeight,\n          horizontalTop,\n          horizontalLeft,\n          horizontalWidth\n        });\n      }\n    }\n  }\n  snapOnMoving({\n    view,\n    e,\n    x,\n    y\n  }) {\n    const targetView = view.getEventData(e).delegatedView || view;\n    if (!this.isNodeMovable(targetView)) {\n      return;\n    }\n    const node = targetView.cell;\n    const size = node.getSize();\n    const position = node.getPosition();\n    const cellBBox = new Rectangle(x - this.offset.x, y - this.offset.y, size.width, size.height);\n    const angle = node.getAngle();\n    const nodeCenter = cellBBox.getCenter();\n    const nodeBBoxRotated = cellBBox.bbox(angle);\n    const nodeTopLeft = nodeBBoxRotated.getTopLeft();\n    const nodeBottomRight = nodeBBoxRotated.getBottomRight();\n    const distance = this.options.tolerance || 0;\n    let verticalLeft;\n    let verticalTop;\n    let verticalHeight;\n    let horizontalTop;\n    let horizontalLeft;\n    let horizontalWidth;\n    let verticalFix = 0;\n    let horizontalFix = 0;\n    this.model.getNodes().some(targetNode => {\n      if (this.isIgnored(node, targetNode)) {\n        return false;\n      }\n      const snapBBox = targetNode.getBBox().bbox(targetNode.getAngle());\n      const snapCenter = snapBBox.getCenter();\n      const snapTopLeft = snapBBox.getTopLeft();\n      const snapBottomRight = snapBBox.getBottomRight();\n      if (verticalLeft == null) {\n        if (Math.abs(snapCenter.x - nodeCenter.x) < distance) {\n          verticalLeft = snapCenter.x;\n          verticalFix = 0.5;\n        } else if (Math.abs(snapTopLeft.x - nodeTopLeft.x) < distance) {\n          verticalLeft = snapTopLeft.x;\n          verticalFix = 0;\n        } else if (Math.abs(snapTopLeft.x - nodeBottomRight.x) < distance) {\n          verticalLeft = snapTopLeft.x;\n          verticalFix = 1;\n        } else if (Math.abs(snapBottomRight.x - nodeBottomRight.x) < distance) {\n          verticalLeft = snapBottomRight.x;\n          verticalFix = 1;\n        } else if (Math.abs(snapBottomRight.x - nodeTopLeft.x) < distance) {\n          verticalLeft = snapBottomRight.x;\n        }\n        if (verticalLeft != null) {\n          verticalTop = Math.min(nodeBBoxRotated.y, snapBBox.y);\n          verticalHeight = Math.max(nodeBottomRight.y, snapBottomRight.y) - verticalTop;\n        }\n      }\n      if (horizontalTop == null) {\n        if (Math.abs(snapCenter.y - nodeCenter.y) < distance) {\n          horizontalTop = snapCenter.y;\n          horizontalFix = 0.5;\n        } else if (Math.abs(snapTopLeft.y - nodeTopLeft.y) < distance) {\n          horizontalTop = snapTopLeft.y;\n        } else if (Math.abs(snapTopLeft.y - nodeBottomRight.y) < distance) {\n          horizontalTop = snapTopLeft.y;\n          horizontalFix = 1;\n        } else if (Math.abs(snapBottomRight.y - nodeBottomRight.y) < distance) {\n          horizontalTop = snapBottomRight.y;\n          horizontalFix = 1;\n        } else if (Math.abs(snapBottomRight.y - nodeTopLeft.y) < distance) {\n          horizontalTop = snapBottomRight.y;\n        }\n        if (horizontalTop != null) {\n          horizontalLeft = Math.min(nodeBBoxRotated.x, snapBBox.x);\n          horizontalWidth = Math.max(nodeBottomRight.x, snapBottomRight.x) - horizontalLeft;\n        }\n      }\n      return verticalLeft != null && horizontalTop != null;\n    });\n    this.hide();\n    if (horizontalTop != null || verticalLeft != null) {\n      if (horizontalTop != null) {\n        nodeBBoxRotated.y = horizontalTop - horizontalFix * nodeBBoxRotated.height;\n      }\n      if (verticalLeft != null) {\n        nodeBBoxRotated.x = verticalLeft - verticalFix * nodeBBoxRotated.width;\n      }\n      const newCenter = nodeBBoxRotated.getCenter();\n      const newX = newCenter.x - cellBBox.width / 2;\n      const newY = newCenter.y - cellBBox.height / 2;\n      const dx = newX - position.x;\n      const dy = newY - position.y;\n      if (dx !== 0 || dy !== 0) {\n        node.translate(dx, dy, {\n          snapped: true,\n          restrict: this.graph.hook.getRestrictArea(targetView)\n        });\n        if (horizontalWidth) {\n          horizontalWidth += dx;\n        }\n        if (verticalHeight) {\n          verticalHeight += dy;\n        }\n      }\n      this.update({\n        verticalLeft,\n        verticalTop,\n        verticalHeight,\n        horizontalTop,\n        horizontalLeft,\n        horizontalWidth\n      });\n    }\n  }\n  isIgnored(snapNode, targetNode) {\n    return targetNode.id === snapNode.id || targetNode.isDescendantOf(snapNode) || this.filterShapes[targetNode.shape] || this.filterCells[targetNode.id] || this.filterFunction && FunctionExt.call(this.filterFunction, this.graph, targetNode);\n  }\n  update(metadata) {\n    // https://en.wikipedia.org/wiki/Transformation_matrix#Affine_transformations\n    if (metadata.horizontalTop) {\n      const start = this.graph.localToGraph(new Point(metadata.horizontalLeft, metadata.horizontalTop));\n      const end = this.graph.localToGraph(new Point(metadata.horizontalLeft + metadata.horizontalWidth, metadata.horizontalTop));\n      this.horizontal.setAttributes({\n        x1: this.options.sharp ? `${start.x}` : '0',\n        y1: `${start.y}`,\n        x2: this.options.sharp ? `${end.x}` : '100%',\n        y2: `${end.y}`,\n        display: 'inherit'\n      });\n    } else {\n      this.horizontal.setAttribute('display', 'none');\n    }\n    if (metadata.verticalLeft) {\n      const start = this.graph.localToGraph(new Point(metadata.verticalLeft, metadata.verticalTop));\n      const end = this.graph.localToGraph(new Point(metadata.verticalLeft, metadata.verticalTop + metadata.verticalHeight));\n      this.vertical.setAttributes({\n        x1: `${start.x}`,\n        y1: this.options.sharp ? `${start.y}` : '0',\n        x2: `${end.x}`,\n        y2: this.options.sharp ? `${end.y}` : '100%',\n        display: 'inherit'\n      });\n    } else {\n      this.vertical.setAttribute('display', 'none');\n    }\n    this.show();\n  }\n  resetTimer() {\n    if (this.timer) {\n      clearTimeout(this.timer);\n      this.timer = null;\n    }\n  }\n  show() {\n    this.resetTimer();\n    if (this.container.parentNode == null) {\n      this.graph.container.appendChild(this.container);\n    }\n    return this;\n  }\n  hide() {\n    this.resetTimer();\n    this.vertical.setAttribute('display', 'none');\n    this.horizontal.setAttribute('display', 'none');\n    const clean = this.options.clean;\n    const delay = typeof clean === 'number' ? clean : clean !== false ? 3000 : 0;\n    if (delay > 0) {\n      this.timer = window.setTimeout(() => {\n        if (this.container.parentNode !== null) {\n          this.unmount();\n        }\n      }, delay);\n    }\n    return this;\n  }\n  onRemove() {\n    this.stopListening();\n    this.hide();\n  }\n  dispose() {\n    this.remove();\n  }\n}\n__decorate([View.dispose()], Snapline.prototype, \"dispose\", null);","map":{"version":3,"names":["Angle","Point","Rectangle","ArrayExt","FunctionExt","Vector","View","Snapline","constructor","options","graph","others","__rest","Object","assign","tolerance","offset","x","y","render","parseFilter","disabled","startListening","model","containerClassName","prefixClassName","verticalClassName","horizontalClassName","enabled","snapline","enable","disable","stopListening","setFilter","filter","container","containerWrapper","horizontal","vertical","addClass","setAttribute","append","className","node","on","captureCursorOffset","snapOnMoving","onBatchStop","delegateDocumentEvents","mouseup","touchend","off","undelegateDocumentEvents","filterShapes","filterCells","filterFunction","Array","isArray","forEach","item","id","name","data","snapOnResizing","cell","view","targetView","getDelegatedView","isNodeMovable","pos","getPosition","isNode","can","resizing","snapped","ui","direction","trueDirection","renderer","findViewByCell","nodeBbox","getBBox","nodeBBoxRotated","bbox","getAngle","nodeTopLeft","getTopLeft","nodeBottomRight","getBottomRight","angle","normalize","verticalLeft","verticalTop","verticalHeight","horizontalTop","horizontalLeft","horizontalWidth","snapOrigin","relativeDirection","indexOf","getNodes","some","isIgnored","snapBBox","snapTopLeft","snapBottomRight","groups","distances","keys","k","key","list","map","value","position","distance","Math","abs","sortBy","length","min","max","hide","dx","dy","dWidth","dHeight","quadrant","undefined","rad","toRad","cos","sin","quadrant13","gridSize","getGridSize","newWidth","width","newHeight","height","minWidth","minHeight","maxWidth","maxHeight","preserveAspectRatio","resize","snaplines","cid","restrict","hook","getRestrictArea","newRotatedBBox","update","e","getEventData","delegatedView","size","getSize","cellBBox","nodeCenter","getCenter","verticalFix","horizontalFix","targetNode","snapCenter","newCenter","newX","newY","translate","snapNode","isDescendantOf","shape","call","metadata","start","localToGraph","end","setAttributes","x1","sharp","y1","x2","y2","display","show","resetTimer","timer","clearTimeout","parentNode","appendChild","clean","delay","window","setTimeout","unmount","onRemove","dispose","remove","__decorate"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/addon/snapline/index.ts"],"sourcesContent":["import { IDisablable } from '../../common'\nimport { Angle, Point, Rectangle } from '../../geometry'\nimport { Graph } from '../../graph'\nimport { EventArgs } from '../../graph/events'\nimport { Model } from '../../model/model'\nimport { Node } from '../../model/node'\nimport { ArrayExt, FunctionExt } from '../../util'\nimport { Vector } from '../../util/vector'\nimport { CellView } from '../../view/cell'\nimport { NodeView } from '../../view/node'\nimport { View } from '../../view/view'\n\nexport class Snapline extends View implements IDisablable {\n  public readonly options: Snapline.Options\n  protected readonly graph: Graph\n  protected filterShapes: { [type: string]: boolean }\n  protected filterCells: { [id: string]: boolean }\n  protected filterFunction: Snapline.FilterFunction | null\n  protected offset: Point.PointLike\n  protected timer: number | null\n\n  public container: SVGElement\n  protected containerWrapper: Vector\n  protected horizontal: Vector\n  protected vertical: Vector\n\n  protected get model() {\n    return this.graph.model\n  }\n\n  protected get containerClassName() {\n    return this.prefixClassName('widget-snapline')\n  }\n\n  protected get verticalClassName() {\n    return `${this.containerClassName}-vertical`\n  }\n\n  protected get horizontalClassName() {\n    return `${this.containerClassName}-horizontal`\n  }\n\n  constructor(options: Snapline.Options & { graph: Graph }) {\n    super()\n\n    const { graph, ...others } = options\n    this.graph = graph\n    this.options = { tolerance: 10, ...others }\n    this.offset = { x: 0, y: 0 }\n    this.render()\n    this.parseFilter()\n    if (!this.disabled) {\n      this.startListening()\n    }\n  }\n\n  public get disabled() {\n    return (\n      this.options.enabled !== true ||\n      this.graph.options.snapline.enabled !== true\n    )\n  }\n\n  enable() {\n    if (this.disabled) {\n      this.options.enabled = true\n      this.graph.options.snapline.enabled = true\n      this.startListening()\n    }\n  }\n\n  disable() {\n    if (!this.disabled) {\n      this.options.enabled = false\n      this.graph.options.snapline.enabled = false\n      this.stopListening()\n    }\n  }\n\n  setFilter(filter?: Snapline.Filter) {\n    this.options.filter = filter\n    this.parseFilter()\n  }\n\n  protected render() {\n    const container = (this.containerWrapper = new Vector('svg'))\n    const horizontal = (this.horizontal = new Vector('line'))\n    const vertical = (this.vertical = new Vector('line'))\n\n    container.addClass(this.containerClassName)\n    horizontal.addClass(this.horizontalClassName)\n    vertical.addClass(this.verticalClassName)\n\n    container.setAttribute('width', '100%')\n    container.setAttribute('height', '100%')\n\n    horizontal.setAttribute('display', 'none')\n    vertical.setAttribute('display', 'none')\n\n    container.append([horizontal, vertical])\n\n    if (this.options.className) {\n      container.addClass(this.options.className)\n    }\n\n    this.container = this.containerWrapper.node\n  }\n\n  protected startListening() {\n    this.stopListening()\n    this.graph.on('node:mousedown', this.captureCursorOffset, this)\n    this.graph.on('node:mousemove', this.snapOnMoving, this)\n    this.model.on('batch:stop', this.onBatchStop, this)\n    this.delegateDocumentEvents({\n      mouseup: 'hide',\n      touchend: 'hide',\n    })\n  }\n\n  protected stopListening() {\n    this.graph.off('node:mousedown', this.captureCursorOffset, this)\n    this.graph.off('node:mousemove', this.snapOnMoving, this)\n    this.model.off('batch:stop', this.onBatchStop, this)\n    this.undelegateDocumentEvents()\n  }\n\n  protected parseFilter() {\n    this.filterShapes = {}\n    this.filterCells = {}\n    this.filterFunction = null\n    const filter = this.options.filter\n    if (Array.isArray(filter)) {\n      filter.forEach((item) => {\n        if (typeof item === 'string') {\n          this.filterShapes[item] = true\n        } else {\n          this.filterCells[item.id] = true\n        }\n      })\n    } else if (typeof filter === 'function') {\n      this.filterFunction = filter\n    }\n  }\n\n  protected onBatchStop({ name, data }: Model.EventArgs['batch:stop']) {\n    if (name === 'resize') {\n      this.snapOnResizing(data.cell, data as Node.ResizeOptions)\n    }\n  }\n\n  captureCursorOffset({ view, x, y }: EventArgs['node:mousedown']) {\n    const targetView = view.getDelegatedView()\n    if (targetView && this.isNodeMovable(targetView)) {\n      const pos = view.cell.getPosition()\n      this.offset = {\n        x: x - pos.x,\n        y: y - pos.y,\n      }\n    }\n  }\n\n  protected isNodeMovable(view: CellView) {\n    return view && view.cell.isNode() && view.can('nodeMovable')\n  }\n\n  protected snapOnResizing(node: Node, options: Node.ResizeOptions) {\n    if (\n      this.options.resizing &&\n      !options.snapped &&\n      options.ui &&\n      options.direction &&\n      options.trueDirection\n    ) {\n      const view = this.graph.renderer.findViewByCell(node) as NodeView\n      if (view && view.cell.isNode()) {\n        const nodeBbox = node.getBBox()\n        const nodeBBoxRotated = nodeBbox.bbox(node.getAngle())\n        const nodeTopLeft = nodeBBoxRotated.getTopLeft()\n        const nodeBottomRight = nodeBBoxRotated.getBottomRight()\n        const angle = Angle.normalize(node.getAngle())\n        const tolerance = this.options.tolerance || 0\n        let verticalLeft: number | undefined\n        let verticalTop: number | undefined\n        let verticalHeight: number | undefined\n        let horizontalTop: number | undefined\n        let horizontalLeft: number | undefined\n        let horizontalWidth: number | undefined\n\n        const snapOrigin = {\n          vertical: 0,\n          horizontal: 0,\n        }\n\n        const direction = options.direction\n        const trueDirection = options.trueDirection\n        const relativeDirection = options.relativeDirection\n\n        if (trueDirection.indexOf('right') !== -1) {\n          snapOrigin.vertical = nodeBottomRight.x\n        } else {\n          snapOrigin.vertical = nodeTopLeft.x\n        }\n\n        if (trueDirection.indexOf('bottom') !== -1) {\n          snapOrigin.horizontal = nodeBottomRight.y\n        } else {\n          snapOrigin.horizontal = nodeTopLeft.y\n        }\n\n        this.model.getNodes().some((cell) => {\n          if (this.isIgnored(node, cell)) {\n            return false\n          }\n\n          const snapBBox = cell.getBBox().bbox(cell.getAngle())\n          const snapTopLeft = snapBBox.getTopLeft()\n          const snapBottomRight = snapBBox.getBottomRight()\n          const groups = {\n            vertical: [snapTopLeft.x, snapBottomRight.x],\n            horizontal: [snapTopLeft.y, snapBottomRight.y],\n          }\n\n          const distances = {} as {\n            vertical: { position: number; distance: number }[]\n            horizontal: { position: number; distance: number }[]\n          }\n\n          Object.keys(groups).forEach((k) => {\n            const key = k as 'vertical' | 'horizontal'\n            const list = groups[key]\n              .map((value) => ({\n                position: value,\n                distance: Math.abs(value - snapOrigin[key]),\n              }))\n              .filter((item) => item.distance <= tolerance)\n\n            distances[key] = ArrayExt.sortBy(list, (item) => item.distance)\n          })\n\n          if (verticalLeft == null && distances.vertical.length > 0) {\n            verticalLeft = distances.vertical[0].position\n            verticalTop = Math.min(nodeBBoxRotated.y, snapBBox.y)\n            verticalHeight =\n              Math.max(nodeBottomRight.y, snapBottomRight.y) - verticalTop\n          }\n\n          if (horizontalTop == null && distances.horizontal.length > 0) {\n            horizontalTop = distances.horizontal[0].position\n            horizontalLeft = Math.min(nodeBBoxRotated.x, snapBBox.x)\n            horizontalWidth =\n              Math.max(nodeBottomRight.x, snapBottomRight.x) - horizontalLeft\n          }\n\n          return verticalLeft != null && horizontalTop != null\n        })\n\n        this.hide()\n\n        let dx = 0\n        let dy = 0\n        if (horizontalTop != null || verticalLeft != null) {\n          if (verticalLeft != null) {\n            dx =\n              trueDirection.indexOf('right') !== -1\n                ? verticalLeft - nodeBottomRight.x\n                : nodeTopLeft.x - verticalLeft\n          }\n\n          if (horizontalTop != null) {\n            dy =\n              trueDirection.indexOf('bottom') !== -1\n                ? horizontalTop - nodeBottomRight.y\n                : nodeTopLeft.y - horizontalTop\n          }\n        }\n\n        let dWidth = 0\n        let dHeight = 0\n        if (angle % 90 === 0) {\n          if (angle === 90 || angle === 270) {\n            dWidth = dy\n            dHeight = dx\n          } else {\n            dWidth = dx\n            dHeight = dy\n          }\n        } else {\n          const quadrant =\n            angle >= 0 && angle < 90\n              ? 1\n              : angle >= 90 && angle < 180\n              ? 4\n              : angle >= 180 && angle < 270\n              ? 3\n              : 2\n\n          if (horizontalTop != null && verticalLeft != null) {\n            if (dx < dy) {\n              dy = 0\n              horizontalTop = undefined\n            } else {\n              dx = 0\n              verticalLeft = undefined\n            }\n          }\n\n          const rad = Angle.toRad(angle % 90)\n          if (dx) {\n            dWidth = quadrant === 3 ? dx / Math.cos(rad) : dx / Math.sin(rad)\n          }\n          if (dy) {\n            dHeight = quadrant === 3 ? dy / Math.cos(rad) : dy / Math.sin(rad)\n          }\n\n          const quadrant13 = quadrant === 1 || quadrant === 3\n          switch (relativeDirection) {\n            case 'top':\n            case 'bottom':\n              dHeight = dy\n                ? dy / (quadrant13 ? Math.cos(rad) : Math.sin(rad))\n                : dx / (quadrant13 ? Math.sin(rad) : Math.cos(rad))\n              break\n            case 'left':\n            case 'right':\n              dWidth = dx\n                ? dx / (quadrant13 ? Math.cos(rad) : Math.sin(rad))\n                : dy / (quadrant13 ? Math.sin(rad) : Math.cos(rad))\n              break\n            default:\n              break\n          }\n        }\n\n        switch (relativeDirection) {\n          case 'top':\n          case 'bottom':\n            dWidth = 0\n            break\n          case 'left':\n          case 'right':\n            dHeight = 0\n            break\n          default:\n            break\n        }\n\n        const gridSize = this.graph.getGridSize()\n        let newWidth = Math.max(nodeBbox.width + dWidth, gridSize)\n        let newHeight = Math.max(nodeBbox.height + dHeight, gridSize)\n\n        if (options.minWidth && options.minWidth > gridSize) {\n          newWidth = Math.max(newWidth, options.minWidth)\n        }\n\n        if (options.minHeight && options.minHeight > gridSize) {\n          newHeight = Math.max(newHeight, options.minHeight)\n        }\n\n        if (options.maxWidth) {\n          newWidth = Math.min(newWidth, options.maxWidth)\n        }\n\n        if (options.maxHeight) {\n          newHeight = Math.min(newHeight, options.maxHeight)\n        }\n\n        if (options.preserveAspectRatio) {\n          if (dHeight < dWidth) {\n            newHeight = newWidth * (nodeBbox.height / nodeBbox.width)\n          } else {\n            newWidth = newHeight * (nodeBbox.width / nodeBbox.height)\n          }\n        }\n\n        if (newWidth !== nodeBbox.width || newHeight !== nodeBbox.height) {\n          node.resize(newWidth, newHeight, {\n            direction,\n            relativeDirection,\n            trueDirection,\n            snapped: true,\n            snaplines: this.cid,\n            restrict: this.graph.hook.getRestrictArea(view),\n          })\n\n          if (verticalHeight) {\n            verticalHeight += newHeight - nodeBbox.height\n          }\n\n          if (horizontalWidth) {\n            horizontalWidth += newWidth - nodeBbox.width\n          }\n        }\n\n        const newRotatedBBox = node.getBBox().bbox(angle)\n        if (\n          verticalLeft &&\n          Math.abs(newRotatedBBox.x - verticalLeft) > 1 &&\n          Math.abs(newRotatedBBox.width + newRotatedBBox.x - verticalLeft) > 1\n        ) {\n          verticalLeft = undefined\n        }\n\n        if (\n          horizontalTop &&\n          Math.abs(newRotatedBBox.y - horizontalTop) > 1 &&\n          Math.abs(newRotatedBBox.height + newRotatedBBox.y - horizontalTop) > 1\n        ) {\n          horizontalTop = undefined\n        }\n\n        this.update({\n          verticalLeft,\n          verticalTop,\n          verticalHeight,\n          horizontalTop,\n          horizontalLeft,\n          horizontalWidth,\n        })\n      }\n    }\n  }\n\n  snapOnMoving({ view, e, x, y }: EventArgs['node:mousemove']) {\n    const targetView: NodeView = view.getEventData(e).delegatedView || view\n    if (!this.isNodeMovable(targetView)) {\n      return\n    }\n\n    const node = targetView.cell\n    const size = node.getSize()\n    const position = node.getPosition()\n    const cellBBox = new Rectangle(\n      x - this.offset.x,\n      y - this.offset.y,\n      size.width,\n      size.height,\n    )\n    const angle = node.getAngle()\n    const nodeCenter = cellBBox.getCenter()\n    const nodeBBoxRotated = cellBBox.bbox(angle)\n    const nodeTopLeft = nodeBBoxRotated.getTopLeft()\n    const nodeBottomRight = nodeBBoxRotated.getBottomRight()\n\n    const distance = this.options.tolerance || 0\n    let verticalLeft: number | undefined\n    let verticalTop: number | undefined\n    let verticalHeight: number | undefined\n    let horizontalTop: number | undefined\n    let horizontalLeft: number | undefined\n    let horizontalWidth: number | undefined\n    let verticalFix = 0\n    let horizontalFix = 0\n\n    this.model.getNodes().some((targetNode) => {\n      if (this.isIgnored(node, targetNode)) {\n        return false\n      }\n\n      const snapBBox = targetNode.getBBox().bbox(targetNode.getAngle())\n      const snapCenter = snapBBox.getCenter()\n      const snapTopLeft = snapBBox.getTopLeft()\n      const snapBottomRight = snapBBox.getBottomRight()\n\n      if (verticalLeft == null) {\n        if (Math.abs(snapCenter.x - nodeCenter.x) < distance) {\n          verticalLeft = snapCenter.x\n          verticalFix = 0.5\n        } else if (Math.abs(snapTopLeft.x - nodeTopLeft.x) < distance) {\n          verticalLeft = snapTopLeft.x\n          verticalFix = 0\n        } else if (Math.abs(snapTopLeft.x - nodeBottomRight.x) < distance) {\n          verticalLeft = snapTopLeft.x\n          verticalFix = 1\n        } else if (Math.abs(snapBottomRight.x - nodeBottomRight.x) < distance) {\n          verticalLeft = snapBottomRight.x\n          verticalFix = 1\n        } else if (Math.abs(snapBottomRight.x - nodeTopLeft.x) < distance) {\n          verticalLeft = snapBottomRight.x\n        }\n\n        if (verticalLeft != null) {\n          verticalTop = Math.min(nodeBBoxRotated.y, snapBBox.y)\n          verticalHeight =\n            Math.max(nodeBottomRight.y, snapBottomRight.y) - verticalTop\n        }\n      }\n\n      if (horizontalTop == null) {\n        if (Math.abs(snapCenter.y - nodeCenter.y) < distance) {\n          horizontalTop = snapCenter.y\n          horizontalFix = 0.5\n        } else if (Math.abs(snapTopLeft.y - nodeTopLeft.y) < distance) {\n          horizontalTop = snapTopLeft.y\n        } else if (Math.abs(snapTopLeft.y - nodeBottomRight.y) < distance) {\n          horizontalTop = snapTopLeft.y\n          horizontalFix = 1\n        } else if (Math.abs(snapBottomRight.y - nodeBottomRight.y) < distance) {\n          horizontalTop = snapBottomRight.y\n          horizontalFix = 1\n        } else if (Math.abs(snapBottomRight.y - nodeTopLeft.y) < distance) {\n          horizontalTop = snapBottomRight.y\n        }\n\n        if (horizontalTop != null) {\n          horizontalLeft = Math.min(nodeBBoxRotated.x, snapBBox.x)\n          horizontalWidth =\n            Math.max(nodeBottomRight.x, snapBottomRight.x) - horizontalLeft\n        }\n      }\n\n      return verticalLeft != null && horizontalTop != null\n    })\n\n    this.hide()\n\n    if (horizontalTop != null || verticalLeft != null) {\n      if (horizontalTop != null) {\n        nodeBBoxRotated.y =\n          horizontalTop - horizontalFix * nodeBBoxRotated.height\n      }\n\n      if (verticalLeft != null) {\n        nodeBBoxRotated.x = verticalLeft - verticalFix * nodeBBoxRotated.width\n      }\n\n      const newCenter = nodeBBoxRotated.getCenter()\n      const newX = newCenter.x - cellBBox.width / 2\n      const newY = newCenter.y - cellBBox.height / 2\n      const dx = newX - position.x\n      const dy = newY - position.y\n\n      if (dx !== 0 || dy !== 0) {\n        node.translate(dx, dy, {\n          snapped: true,\n          restrict: this.graph.hook.getRestrictArea(targetView),\n        })\n\n        if (horizontalWidth) {\n          horizontalWidth += dx\n        }\n\n        if (verticalHeight) {\n          verticalHeight += dy\n        }\n      }\n\n      this.update({\n        verticalLeft,\n        verticalTop,\n        verticalHeight,\n        horizontalTop,\n        horizontalLeft,\n        horizontalWidth,\n      })\n    }\n  }\n\n  protected isIgnored(snapNode: Node, targetNode: Node) {\n    return (\n      targetNode.id === snapNode.id ||\n      targetNode.isDescendantOf(snapNode) ||\n      this.filterShapes[targetNode.shape] ||\n      this.filterCells[targetNode.id] ||\n      (this.filterFunction &&\n        FunctionExt.call(this.filterFunction, this.graph, targetNode))\n    )\n  }\n\n  protected update(metadata: {\n    verticalLeft?: number\n    verticalTop?: number\n    verticalHeight?: number\n    horizontalTop?: number\n    horizontalLeft?: number\n    horizontalWidth?: number\n  }) {\n    // https://en.wikipedia.org/wiki/Transformation_matrix#Affine_transformations\n    if (metadata.horizontalTop) {\n      const start = this.graph.localToGraph(\n        new Point(metadata.horizontalLeft, metadata.horizontalTop),\n      )\n      const end = this.graph.localToGraph(\n        new Point(\n          metadata.horizontalLeft! + metadata.horizontalWidth!,\n          metadata.horizontalTop,\n        ),\n      )\n      this.horizontal.setAttributes({\n        x1: this.options.sharp ? `${start.x}` : '0',\n        y1: `${start.y}`,\n        x2: this.options.sharp ? `${end.x}` : '100%',\n        y2: `${end.y}`,\n        display: 'inherit',\n      })\n    } else {\n      this.horizontal.setAttribute('display', 'none')\n    }\n\n    if (metadata.verticalLeft) {\n      const start = this.graph.localToGraph(\n        new Point(metadata.verticalLeft, metadata.verticalTop),\n      )\n      const end = this.graph.localToGraph(\n        new Point(\n          metadata.verticalLeft,\n          metadata.verticalTop! + metadata.verticalHeight!,\n        ),\n      )\n      this.vertical.setAttributes({\n        x1: `${start.x}`,\n        y1: this.options.sharp ? `${start.y}` : '0',\n        x2: `${end.x}`,\n        y2: this.options.sharp ? `${end.y}` : '100%',\n        display: 'inherit',\n      })\n    } else {\n      this.vertical.setAttribute('display', 'none')\n    }\n\n    this.show()\n  }\n\n  protected resetTimer() {\n    if (this.timer) {\n      clearTimeout(this.timer)\n      this.timer = null\n    }\n  }\n\n  show() {\n    this.resetTimer()\n    if (this.container.parentNode == null) {\n      this.graph.container.appendChild(this.container)\n    }\n    return this\n  }\n\n  hide() {\n    this.resetTimer()\n    this.vertical.setAttribute('display', 'none')\n    this.horizontal.setAttribute('display', 'none')\n    const clean = this.options.clean\n    const delay = typeof clean === 'number' ? clean : clean !== false ? 3000 : 0\n    if (delay > 0) {\n      this.timer = window.setTimeout(() => {\n        if (this.container.parentNode !== null) {\n          this.unmount()\n        }\n      }, delay)\n    }\n    return this\n  }\n\n  protected onRemove() {\n    this.stopListening()\n    this.hide()\n  }\n\n  @View.dispose()\n  dispose() {\n    this.remove()\n  }\n}\n\nexport namespace Snapline {\n  export interface Options {\n    enabled?: boolean\n    className?: string\n    tolerance?: number\n    sharp?: boolean\n    /**\n     * Specify if snap on node resizing or not.\n     */\n    resizing?: boolean\n    clean?: boolean | number\n    filter?: Filter\n  }\n\n  export type Filter = null | (string | { id: string })[] | FilterFunction\n\n  export type FilterFunction = (this: Graph, node: Node) => boolean\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}