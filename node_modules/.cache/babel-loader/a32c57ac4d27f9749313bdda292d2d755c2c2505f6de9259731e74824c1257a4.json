{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { AST_TOKEN_TYPES, createEntity, isSafari, STORAGE_CLASS } from '@antv/g-webgpu-core';\nimport * as WebGPUConstants from '@webgpu/types/dist/constants';\nimport { isNumber } from '../utils/is-number';\nimport WebGPUBuffer from './WebGPUBuffer';\nvar WebGPUComputeModel = /*#__PURE__*/function () {\n  /**\n   * 用于后续渲染时动态更新\n   */\n  function WebGPUComputeModel(engine, context) {\n    _classCallCheck(this, WebGPUComputeModel);\n    this.engine = engine;\n    this.context = context;\n    this.entity = createEntity();\n    this.uniformGPUBufferLayout = [];\n    this.uniformBuffer = void 0;\n    this.vertexBuffers = {};\n    this.outputBuffer = void 0;\n    this.bindGroupEntries = void 0;\n    this.bindGroup = void 0;\n    this.computePipeline = void 0;\n  }\n  _createClass(WebGPUComputeModel, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n        var _yield$this$compileCo, computeStage, buffers, uniforms, bufferBindingIndex, offset, mergedUniformData;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.compileComputePipelineStageDescriptor(this.context.shader);\n              case 2:\n                _yield$this$compileCo = _context.sent;\n                computeStage = _yield$this$compileCo.computeStage;\n                buffers = this.context.uniforms.filter(function (uniform) {\n                  return uniform.storageClass === STORAGE_CLASS.StorageBuffer;\n                });\n                uniforms = this.context.uniforms.filter(function (uniform) {\n                  return uniform.storageClass === STORAGE_CLASS.Uniform;\n                });\n                bufferBindingIndex = uniforms.length ? 1 : 0;\n                this.bindGroupEntries = [];\n                if (bufferBindingIndex) {\n                  offset = 0; // FIXME: 所有 uniform 合并成一个 buffer，固定使用 Float32Array 存储，确实会造成一些内存的浪费\n                  // we use std140 layout @see https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)\n\n                  mergedUniformData = [];\n                  uniforms.forEach(function (uniform) {\n                    if (isNumber(uniform.data)) {\n                      _this.uniformGPUBufferLayout.push({\n                        name: uniform.name,\n                        offset: offset\n                      });\n                      offset += 4; // @ts-ignore\n\n                      mergedUniformData.push(uniform.data);\n                    } else {\n                      var _uniform$data;\n\n                      // @ts-ignore\n                      var originDataLength = ((_uniform$data = uniform.data) === null || _uniform$data === void 0 ? void 0 : _uniform$data.length) || 1;\n                      if (originDataLength === 3) {\n                        // vec3 -> vec4\n                        // @see http://ptgmedia.pearsoncmg.com/images/9780321552624/downloads/0321552628_AppL.pdf\n                        originDataLength = 4; // @ts-ignore\n\n                        uniform.data.push(0);\n                      } // 4 elements per block/line\n\n                      var padding = offset / 4 % 4;\n                      if (padding > 0) {\n                        var space = 4 - padding;\n                        if (originDataLength > 1 && originDataLength <= space) {\n                          if (originDataLength === 2) {\n                            if (space === 3) {\n                              offset += 4;\n                              mergedUniformData.push(0);\n                            } // @ts-ignore\n\n                            mergedUniformData.push.apply(mergedUniformData, _toConsumableArray(uniform.data));\n                            _this.uniformGPUBufferLayout.push({\n                              name: uniform.name,\n                              offset: offset\n                            });\n                          }\n                        } else {\n                          for (var i = 0; i < space; i++) {\n                            offset += 4;\n                            mergedUniformData.push(0);\n                          } // @ts-ignore\n\n                          mergedUniformData.push.apply(mergedUniformData, _toConsumableArray(uniform.data));\n                          _this.uniformGPUBufferLayout.push({\n                            name: uniform.name,\n                            offset: offset\n                          });\n                        }\n                      }\n                      offset += 4 * originDataLength;\n                    }\n                  });\n                  this.uniformBuffer = new WebGPUBuffer(this.engine, {\n                    // TODO: 处理 Struct 和 boolean\n                    // @ts-ignore\n                    data: mergedUniformData instanceof Array ?\n                    // @ts-ignore\n                    new Float32Array(mergedUniformData) : mergedUniformData,\n                    usage: WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst\n                  });\n                  this.bindGroupEntries.push({\n                    binding: 0,\n                    resource: {\n                      buffer: this.uniformBuffer.get()\n                    }\n                  });\n                } // create GPUBuffers for storeage buffers\n\n                buffers.forEach(function (buffer) {\n                  if (buffer.data !== null) {\n                    if (buffer.type === AST_TOKEN_TYPES.Vector4FloatArray || buffer.type === AST_TOKEN_TYPES.FloatArray) {\n                      var gpuBuffer;\n                      if (buffer.name === _this.context.output.name) {\n                        gpuBuffer = new WebGPUBuffer(_this.engine, {\n                          // @ts-ignore\n                          data: isFinite(Number(buffer.data)) ? [buffer.data] : buffer.data,\n                          usage: WebGPUConstants.BufferUsage.Storage | WebGPUConstants.BufferUsage.CopyDst | WebGPUConstants.BufferUsage.CopySrc\n                        });\n                        _this.outputBuffer = gpuBuffer;\n                        _this.context.output = {\n                          name: buffer.name,\n                          // @ts-ignore\n                          length: isFinite(Number(buffer.data)) ? 1 : buffer.data.length,\n                          typedArrayConstructor: Float32Array,\n                          gpuBuffer: gpuBuffer.get()\n                        };\n                      } else {\n                        if (buffer.isReferer) {\n                          // @ts-ignore\n                          if (buffer.data.model && buffer.data.model.outputBuffer) {\n                            // @ts-ignore\n                            gpuBuffer = buffer.data.model.outputBuffer;\n                          } else {// referred kernel haven't been executed\n                          }\n                        } else {\n                          gpuBuffer = new WebGPUBuffer(_this.engine, {\n                            // @ts-ignore\n                            data: isFinite(Number(buffer.data)) ? [buffer.data] : buffer.data,\n                            usage: WebGPUConstants.BufferUsage.Storage | WebGPUConstants.BufferUsage.CopyDst | WebGPUConstants.BufferUsage.CopySrc\n                          });\n                        }\n                      } // @ts-ignore\n\n                      _this.vertexBuffers[buffer.name] = gpuBuffer;\n                      _this.bindGroupEntries.push({\n                        binding: bufferBindingIndex,\n                        resource: {\n                          name: buffer.name,\n                          refer: gpuBuffer ? undefined : buffer.data,\n                          // @ts-ignore\n                          buffer: gpuBuffer ? gpuBuffer.get() : undefined\n                        }\n                      });\n                      bufferBindingIndex++;\n                    }\n                  }\n                }); // create compute pipeline layout\n\n                this.computePipeline = this.engine.device.createComputePipeline({\n                  computeStage: computeStage\n                });\n                console.log(this.bindGroupEntries);\n                this.bindGroup = this.engine.device.createBindGroup({\n                  layout: this.computePipeline.getBindGroupLayout(0),\n                  entries: this.bindGroupEntries\n                });\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function init() {\n        return _init.apply(this, arguments);\n      }\n      return init;\n    }()\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this2 = this;\n      if (this.uniformBuffer) {\n        this.uniformBuffer.destroy();\n      }\n      Object.keys(this.vertexBuffers).forEach(function (bufferName) {\n        return _this2.vertexBuffers[bufferName].destroy();\n      });\n    }\n  }, {\n    key: \"readData\",\n    value: function () {\n      var _readData = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var output, length, typedArrayConstructor, gpuBuffer, byteCount, gpuReadBuffer, encoder, queue, arraybuffer, typedArray;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                output = this.context.output;\n                if (!output) {\n                  _context2.next = 16;\n                  break;\n                }\n                length = output.length, typedArrayConstructor = output.typedArrayConstructor, gpuBuffer = output.gpuBuffer;\n                if (!gpuBuffer) {\n                  _context2.next = 16;\n                  break;\n                }\n\n                // await gpuBuffer.mapAsync(WebGPUConstants.MapMode.Read);\n                // const arraybuffer = gpuBuffer.getMappedRange();\n                // let arraybuffer;\n                // if (isSafari) {\n                //   arraybuffer = await gpuBuffer.mapReadAsync();\n                // } else {\n                byteCount = length * typedArrayConstructor.BYTES_PER_ELEMENT; // @see https://developers.google.com/web/updates/2019/08/get-started-with-gpu-compute-on-the-web\n\n                gpuReadBuffer = this.engine.device.createBuffer({\n                  size: byteCount,\n                  usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n                });\n                encoder = this.engine.device.createCommandEncoder();\n                encoder.copyBufferToBuffer(gpuBuffer, 0, gpuReadBuffer, 0, byteCount);\n                queue = isSafari ?\n                // @ts-ignore\n                this.engine.device.getQueue() : this.engine.device.defaultQueue;\n                queue.submit([encoder.finish()]);\n                _context2.next = 12;\n                return gpuReadBuffer.mapAsync(WebGPUConstants.MapMode.Read);\n              case 12:\n                arraybuffer = gpuReadBuffer.getMappedRange();\n                typedArray = new typedArrayConstructor(arraybuffer.slice(0));\n                gpuReadBuffer.unmap();\n                return _context2.abrupt(\"return\", typedArray);\n              case 16:\n                return _context2.abrupt(\"return\", new Float32Array());\n              case 17:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function readData() {\n        return _readData.apply(this, arguments);\n      }\n      return readData;\n    }()\n  }, {\n    key: \"run\",\n    value: function run() {\n      if (this.engine.currentComputePass) {\n        var _this$engine$currentC;\n        this.engine.currentComputePass.setPipeline(this.computePipeline); // this.bindGroupEntries.forEach((entry) => {\n        //   if (!entry.resource.buffer) {\n        //     // get referred kernel's output\n        //     const gpuBuffer = (entry.resource.refer.model as WebGPUComputeModel)\n        //       .outputBuffer;\n        //     this.vertexBuffers[entry.resource.name] = gpuBuffer;\n        //     entry.resource.buffer = gpuBuffer.get();\n        //   }\n        // });\n        // const bindGroup = this.engine.device.createBindGroup({\n        //   layout: this.computePipeline.getBindGroupLayout(0),\n        //   entries: this.bindGroupEntries,\n        // });\n\n        this.engine.currentComputePass.setBindGroup(0, this.bindGroup);\n        (_this$engine$currentC = this.engine.currentComputePass).dispatch.apply(_this$engine$currentC, _toConsumableArray(this.context.dispatch));\n      }\n    }\n  }, {\n    key: \"updateBuffer\",\n    value: function updateBuffer(bufferName, data) {\n      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var buffer = this.vertexBuffers[bufferName];\n      if (buffer) {\n        buffer.subData({\n          data: data,\n          offset: offset\n        });\n      }\n    }\n  }, {\n    key: \"updateUniform\",\n    value: function updateUniform(uniformName, data) {\n      var layout = this.uniformGPUBufferLayout.find(function (l) {\n        return l.name === uniformName;\n      });\n      if (layout) {\n        this.uniformBuffer.subData({\n          data: Number.isFinite(data) ? new Float32Array([data]) : new Float32Array(data),\n          offset: layout.offset\n        });\n      }\n    }\n  }, {\n    key: \"confirmInput\",\n    value: function confirmInput(model, inputName) {\n      // copy output GPUBuffer of kernel\n      var inputBuffer = this.vertexBuffers[inputName];\n      var outputBuffer = model.outputBuffer;\n      if (inputBuffer && outputBuffer && inputBuffer !== outputBuffer) {\n        var encoder = this.engine.device.createCommandEncoder();\n        var _context$output = model.context.output,\n          length = _context$output.length,\n          typedArrayConstructor = _context$output.typedArrayConstructor;\n        var byteCount = length * typedArrayConstructor.BYTES_PER_ELEMENT;\n        encoder.copyBufferToBuffer(outputBuffer.get(), 0, inputBuffer.get(), 0, byteCount);\n        var queue = isSafari ?\n        // @ts-ignore\n        this.engine.device.getQueue() : this.engine.device.defaultQueue;\n        queue.submit([encoder.finish()]);\n      }\n    }\n  }, {\n    key: \"compileShaderToSpirV\",\n    value: function compileShaderToSpirV(source, type, shaderVersion) {\n      return this.compileRawShaderToSpirV(shaderVersion + source, type);\n    }\n  }, {\n    key: \"compileRawShaderToSpirV\",\n    value: function compileRawShaderToSpirV(source, type) {\n      return this.engine.glslang.compileGLSL(source, type);\n    }\n  }, {\n    key: \"compileComputePipelineStageDescriptor\",\n    value: function () {\n      var _compileComputePipelineStageDescriptor = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(computeCode) {\n        var computeShader, shaderVersion;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                computeShader = computeCode;\n                shaderVersion = '#version 450\\n';\n                if (this.engine.options.useWGSL) {\n                  _context3.next = 6;\n                  break;\n                }\n                _context3.next = 5;\n                return this.compileShaderToSpirV(computeCode, 'compute', shaderVersion);\n              case 5:\n                computeShader = _context3.sent;\n              case 6:\n                return _context3.abrupt(\"return\", {\n                  computeStage: {\n                    module: this.engine.device.createShaderModule({\n                      code: computeShader,\n                      // @ts-ignore\n                      isWHLSL: isSafari\n                    }),\n                    entryPoint: 'main'\n                  }\n                });\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function compileComputePipelineStageDescriptor(_x) {\n        return _compileComputePipelineStageDescriptor.apply(this, arguments);\n      }\n      return compileComputePipelineStageDescriptor;\n    }()\n  }]);\n  return WebGPUComputeModel;\n}();\nexport { WebGPUComputeModel as default };","map":{"version":3,"names":["AST_TOKEN_TYPES","createEntity","isSafari","STORAGE_CLASS","WebGPUConstants","isNumber","WebGPUBuffer","WebGPUComputeModel","engine","context","_classCallCheck","entity","uniformGPUBufferLayout","uniformBuffer","vertexBuffers","outputBuffer","bindGroupEntries","bindGroup","computePipeline","compileComputePipelineStageDescriptor","shader","computeStage","buffers","uniforms","filter","uniform","storageClass","StorageBuffer","Uniform","bufferBindingIndex","length","offset","mergedUniformData","forEach","data","_this","push","name","_uniform$data","originDataLength","padding","space","apply","_toConsumableArray","i","Array","Float32Array","usage","BufferUsage","CopyDst","binding","resource","buffer","get","type","Vector4FloatArray","FloatArray","gpuBuffer","output","isFinite","Number","Storage","CopySrc","typedArrayConstructor","isReferer","model","refer","undefined","device","createComputePipeline","console","log","createBindGroup","layout","getBindGroupLayout","entries","_this2","destroy","Object","keys","bufferName","byteCount","BYTES_PER_ELEMENT","gpuReadBuffer","createBuffer","size","GPUBufferUsage","COPY_DST","MAP_READ","encoder","createCommandEncoder","copyBufferToBuffer","queue","getQueue","defaultQueue","submit","finish","mapAsync","MapMode","Read","arraybuffer","getMappedRange","typedArray","slice","unmap","currentComputePass","_this$engine$currentC","setPipeline","setBindGroup","dispatch","arguments","subData","uniformName","find","l","inputName","inputBuffer","_context$output","source","shaderVersion","compileRawShaderToSpirV","glslang","compileGLSL","computeCode","computeShader","options","useWGSL","compileShaderToSpirV","module","createShaderModule","code","isWHLSL","entryPoint"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/g-webgpu-engine/src/webgpu/WebGPUComputeModel.ts"],"sourcesContent":["import {\n  AST_TOKEN_TYPES,\n  createEntity,\n  GLSLContext,\n  IComputeModel,\n  isSafari,\n  STORAGE_CLASS,\n} from '@antv/g-webgpu-core';\nimport * as WebGPUConstants from '@webgpu/types/dist/constants';\nimport { WebGPUEngine } from '.';\nimport { isNumber } from '../utils/is-number';\nimport WebGPUBuffer from './WebGPUBuffer';\n\nexport default class WebGPUComputeModel implements IComputeModel {\n  private entity = createEntity();\n  /**\n   * 用于后续渲染时动态更新\n   */\n  private uniformGPUBufferLayout: Array<{\n    name: string;\n    offset: number;\n  }> = [];\n\n  private uniformBuffer: WebGPUBuffer;\n  private vertexBuffers: Record<string, WebGPUBuffer> = {};\n  private outputBuffer: WebGPUBuffer;\n  private bindGroupEntries: GPUBindGroupEntry[];\n  private bindGroup: GPUBindGroup;\n\n  private computePipeline: GPUComputePipeline;\n\n  constructor(private engine: WebGPUEngine, private context: GLSLContext) {}\n\n  public async init() {\n    const { computeStage } = await this.compileComputePipelineStageDescriptor(\n      this.context.shader!,\n    );\n\n    const buffers = this.context.uniforms.filter(\n      (uniform) => uniform.storageClass === STORAGE_CLASS.StorageBuffer,\n    );\n    const uniforms = this.context.uniforms.filter(\n      (uniform) => uniform.storageClass === STORAGE_CLASS.Uniform,\n    );\n\n    let bufferBindingIndex = uniforms.length ? 1 : 0;\n    this.bindGroupEntries = [];\n    if (bufferBindingIndex) {\n      let offset = 0;\n      // FIXME: 所有 uniform 合并成一个 buffer，固定使用 Float32Array 存储，确实会造成一些内存的浪费\n      // we use std140 layout @see https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)\n      const mergedUniformData: number[] = [];\n      uniforms.forEach((uniform) => {\n        if (isNumber(uniform.data)) {\n          this.uniformGPUBufferLayout.push({\n            name: uniform.name,\n            offset,\n          });\n          offset += 4;\n          // @ts-ignore\n          mergedUniformData.push(uniform.data);\n        } else {\n          // @ts-ignore\n          let originDataLength = uniform.data?.length || 1;\n          if (originDataLength === 3) {\n            // vec3 -> vec4\n            // @see http://ptgmedia.pearsoncmg.com/images/9780321552624/downloads/0321552628_AppL.pdf\n            originDataLength = 4;\n            // @ts-ignore\n            uniform.data.push(0);\n          }\n          // 4 elements per block/line\n          const padding = (offset / 4) % 4;\n          if (padding > 0) {\n            const space = 4 - padding;\n            if (originDataLength > 1 && originDataLength <= space) {\n              if (originDataLength === 2) {\n                if (space === 3) {\n                  offset += 4;\n                  mergedUniformData.push(0);\n                }\n                // @ts-ignore\n                mergedUniformData.push(...uniform.data);\n                this.uniformGPUBufferLayout.push({\n                  name: uniform.name,\n                  offset,\n                });\n              }\n            } else {\n              for (let i = 0; i < space; i++) {\n                offset += 4;\n                mergedUniformData.push(0);\n              }\n              // @ts-ignore\n              mergedUniformData.push(...uniform.data);\n              this.uniformGPUBufferLayout.push({\n                name: uniform.name,\n                offset,\n              });\n            }\n          }\n\n          offset += 4 * originDataLength;\n        }\n      });\n\n      this.uniformBuffer = new WebGPUBuffer(this.engine, {\n        // TODO: 处理 Struct 和 boolean\n        // @ts-ignore\n        data:\n          mergedUniformData instanceof Array\n            ? // @ts-ignore\n              new Float32Array(mergedUniformData)\n            : mergedUniformData,\n        usage:\n          WebGPUConstants.BufferUsage.Uniform |\n          WebGPUConstants.BufferUsage.CopyDst,\n      });\n\n      this.bindGroupEntries.push({\n        binding: 0,\n        resource: {\n          buffer: this.uniformBuffer.get(),\n        },\n      });\n    }\n\n    // create GPUBuffers for storeage buffers\n    buffers.forEach((buffer) => {\n      if (buffer.data !== null) {\n        if (\n          buffer.type === AST_TOKEN_TYPES.Vector4FloatArray ||\n          buffer.type === AST_TOKEN_TYPES.FloatArray\n        ) {\n          let gpuBuffer;\n          if (buffer.name === this.context.output.name) {\n            gpuBuffer = new WebGPUBuffer(this.engine, {\n              // @ts-ignore\n              data: isFinite(Number(buffer.data)) ? [buffer.data] : buffer.data,\n              usage:\n                WebGPUConstants.BufferUsage.Storage |\n                WebGPUConstants.BufferUsage.CopyDst |\n                WebGPUConstants.BufferUsage.CopySrc,\n            });\n            this.outputBuffer = gpuBuffer;\n            this.context.output = {\n              name: buffer.name,\n              // @ts-ignore\n              length: isFinite(Number(buffer.data)) ? 1 : buffer.data.length,\n              typedArrayConstructor: Float32Array,\n              gpuBuffer: gpuBuffer.get(),\n            };\n          } else {\n            if (buffer.isReferer) {\n              // @ts-ignore\n              if (buffer.data.model && buffer.data.model.outputBuffer) {\n                // @ts-ignore\n                gpuBuffer = (buffer.data.model as WebGPUComputeModel)\n                  .outputBuffer;\n              } else {\n                // referred kernel haven't been executed\n              }\n            } else {\n              gpuBuffer = new WebGPUBuffer(this.engine, {\n                // @ts-ignore\n                data: isFinite(Number(buffer.data))\n                  ? [buffer.data]\n                  : buffer.data,\n                usage:\n                  WebGPUConstants.BufferUsage.Storage |\n                  WebGPUConstants.BufferUsage.CopyDst |\n                  WebGPUConstants.BufferUsage.CopySrc,\n              });\n            }\n          }\n\n          // @ts-ignore\n          this.vertexBuffers[buffer.name] = gpuBuffer;\n          this.bindGroupEntries.push({\n            binding: bufferBindingIndex,\n            resource: {\n              name: buffer.name,\n              refer: gpuBuffer ? undefined : buffer.data,\n              // @ts-ignore\n              buffer: gpuBuffer ? gpuBuffer.get() : undefined,\n            },\n          });\n          bufferBindingIndex++;\n        }\n      }\n    });\n\n    // create compute pipeline layout\n    this.computePipeline = this.engine.device.createComputePipeline({\n      computeStage,\n    });\n\n    console.log(this.bindGroupEntries);\n\n    this.bindGroup = this.engine.device.createBindGroup({\n      layout: this.computePipeline.getBindGroupLayout(0),\n      entries: this.bindGroupEntries,\n    });\n  }\n\n  public destroy(): void {\n    if (this.uniformBuffer) {\n      this.uniformBuffer.destroy();\n    }\n\n    Object.keys(this.vertexBuffers).forEach((bufferName) =>\n      this.vertexBuffers[bufferName].destroy(),\n    );\n  }\n\n  public async readData() {\n    const { output } = this.context;\n    if (output) {\n      const { length, typedArrayConstructor, gpuBuffer } = output;\n      if (gpuBuffer) {\n        // await gpuBuffer.mapAsync(WebGPUConstants.MapMode.Read);\n        // const arraybuffer = gpuBuffer.getMappedRange();\n        // let arraybuffer;\n\n        // if (isSafari) {\n        //   arraybuffer = await gpuBuffer.mapReadAsync();\n        // } else {\n        const byteCount = length! * typedArrayConstructor!.BYTES_PER_ELEMENT;\n\n        // @see https://developers.google.com/web/updates/2019/08/get-started-with-gpu-compute-on-the-web\n        const gpuReadBuffer = this.engine.device.createBuffer({\n          size: byteCount,\n          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n        });\n        const encoder = this.engine.device.createCommandEncoder();\n        encoder.copyBufferToBuffer(gpuBuffer, 0, gpuReadBuffer, 0, byteCount);\n        const queue: GPUQueue = isSafari\n          ? // @ts-ignore\n            this.engine.device.getQueue()\n          : this.engine.device.defaultQueue;\n        queue.submit([encoder.finish()]);\n\n        await gpuReadBuffer.mapAsync(WebGPUConstants.MapMode.Read);\n        const arraybuffer = gpuReadBuffer.getMappedRange();\n        const typedArray = new typedArrayConstructor!(arraybuffer.slice(0));\n        gpuReadBuffer.unmap();\n\n        return typedArray;\n      }\n    }\n    return new Float32Array();\n  }\n\n  public run() {\n    if (this.engine.currentComputePass) {\n      this.engine.currentComputePass.setPipeline(this.computePipeline);\n\n      // this.bindGroupEntries.forEach((entry) => {\n      //   if (!entry.resource.buffer) {\n      //     // get referred kernel's output\n      //     const gpuBuffer = (entry.resource.refer.model as WebGPUComputeModel)\n      //       .outputBuffer;\n      //     this.vertexBuffers[entry.resource.name] = gpuBuffer;\n      //     entry.resource.buffer = gpuBuffer.get();\n      //   }\n      // });\n\n      // const bindGroup = this.engine.device.createBindGroup({\n      //   layout: this.computePipeline.getBindGroupLayout(0),\n      //   entries: this.bindGroupEntries,\n      // });\n      this.engine.currentComputePass.setBindGroup(0, this.bindGroup);\n      this.engine.currentComputePass.dispatch(...this.context.dispatch);\n    }\n  }\n\n  public updateBuffer(\n    bufferName: string,\n    data:\n      | number[]\n      | Float32Array\n      | Uint8Array\n      | Uint16Array\n      | Uint32Array\n      | Int8Array\n      | Int16Array\n      | Int32Array,\n    offset: number = 0,\n  ) {\n    const buffer = this.vertexBuffers[bufferName];\n    if (buffer) {\n      buffer.subData({ data, offset });\n    }\n  }\n\n  public updateUniform(\n    uniformName: string,\n    data:\n      | number\n      | number[]\n      | Float32Array\n      | Uint8Array\n      | Uint16Array\n      | Uint32Array\n      | Int8Array\n      | Int16Array\n      | Int32Array,\n  ) {\n    const layout = this.uniformGPUBufferLayout.find(\n      (l) => l.name === uniformName,\n    );\n\n    if (layout) {\n      this.uniformBuffer.subData({\n        data: Number.isFinite(data)\n          ? new Float32Array([data as number])\n          : new Float32Array(\n              data as\n                | number[]\n                | Float32Array\n                | Uint8Array\n                | Uint16Array\n                | Uint32Array\n                | Int8Array\n                | Int16Array\n                | Int32Array,\n            ),\n        offset: layout.offset,\n      });\n    }\n  }\n\n  public confirmInput(model: IComputeModel, inputName: string): void {\n    // copy output GPUBuffer of kernel\n    const inputBuffer = this.vertexBuffers[inputName];\n    const outputBuffer = (model as WebGPUComputeModel).outputBuffer;\n\n    if (inputBuffer && outputBuffer && inputBuffer !== outputBuffer) {\n      const encoder = this.engine.device.createCommandEncoder();\n      const {\n        length,\n        typedArrayConstructor,\n      } = (model as WebGPUComputeModel).context.output;\n      const byteCount = length! * typedArrayConstructor!.BYTES_PER_ELEMENT;\n      encoder.copyBufferToBuffer(\n        outputBuffer.get(),\n        0,\n        inputBuffer.get(),\n        0,\n        byteCount,\n      );\n      const queue: GPUQueue = isSafari\n        ? // @ts-ignore\n          this.engine.device.getQueue()\n        : this.engine.device.defaultQueue;\n      queue.submit([encoder.finish()]);\n    }\n  }\n\n  private compileShaderToSpirV(\n    source: string,\n    type: string,\n    shaderVersion: string,\n  ): Promise<Uint32Array> {\n    return this.compileRawShaderToSpirV(shaderVersion + source, type);\n  }\n\n  private compileRawShaderToSpirV(\n    source: string,\n    type: string,\n  ): Promise<Uint32Array> {\n    return this.engine.glslang.compileGLSL(source, type);\n  }\n\n  private async compileComputePipelineStageDescriptor(\n    computeCode: string,\n  ): Promise<Pick<GPUComputePipelineDescriptor, 'computeStage'>> {\n    let computeShader: Uint32Array | string = computeCode;\n    const shaderVersion = '#version 450\\n';\n    if (!this.engine.options.useWGSL) {\n      computeShader = await this.compileShaderToSpirV(\n        computeCode,\n        'compute',\n        shaderVersion,\n      );\n    }\n\n    return {\n      computeStage: {\n        module: this.engine.device.createShaderModule({\n          code: computeShader,\n          // @ts-ignore\n          isWHLSL: isSafari,\n        }),\n        entryPoint: 'main',\n      },\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}