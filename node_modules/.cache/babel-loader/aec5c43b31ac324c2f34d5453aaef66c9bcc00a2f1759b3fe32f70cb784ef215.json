{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Rectangle, Polyline, Point, Angle, Path, Line } from '../geometry';\nimport { StringExt, ObjectExt, NumberExt, FunctionExt, Dom, Vector } from '../util';\nimport { Router, Connector, NodeAnchor, EdgeAnchor, ConnectionPoint } from '../registry';\nimport { Edge } from '../model/edge';\nimport { Markup } from './markup';\nimport { CellView } from './cell';\nexport class EdgeView extends CellView {\n  constructor() {\n    super(...arguments);\n    this.POINT_ROUNDING = 2;\n    this.markerCache = {};\n    // #endregion\n    // #endregion\n  }\n  get [Symbol.toStringTag]() {\n    return EdgeView.toStringTag;\n  }\n  getContainerClassName() {\n    return [super.getContainerClassName(), this.prefixClassName('edge')].join(' ');\n  }\n  get sourceBBox() {\n    const sourceView = this.sourceView;\n    if (!sourceView) {\n      const sourceDef = this.cell.getSource();\n      return new Rectangle(sourceDef.x, sourceDef.y);\n    }\n    const sourceMagnet = this.sourceMagnet;\n    if (sourceView.isEdgeElement(sourceMagnet)) {\n      return new Rectangle(this.sourceAnchor.x, this.sourceAnchor.y);\n    }\n    return sourceView.getBBoxOfElement(sourceMagnet || sourceView.container);\n  }\n  get targetBBox() {\n    const targetView = this.targetView;\n    if (!targetView) {\n      const targetDef = this.cell.getTarget();\n      return new Rectangle(targetDef.x, targetDef.y);\n    }\n    const targetMagnet = this.targetMagnet;\n    if (targetView.isEdgeElement(targetMagnet)) {\n      return new Rectangle(this.targetAnchor.x, this.targetAnchor.y);\n    }\n    return targetView.getBBoxOfElement(targetMagnet || targetView.container);\n  }\n  isEdgeView() {\n    return true;\n  }\n  confirmUpdate(flag, options = {}) {\n    let ref = flag;\n    if (this.hasAction(ref, 'source')) {\n      if (!this.updateTerminalProperties('source')) {\n        return ref;\n      }\n      ref = this.removeAction(ref, 'source');\n    }\n    if (this.hasAction(ref, 'target')) {\n      if (!this.updateTerminalProperties('target')) {\n        return ref;\n      }\n      ref = this.removeAction(ref, 'target');\n    }\n    const graph = this.graph;\n    const sourceView = this.sourceView;\n    const targetView = this.targetView;\n    if (graph && (sourceView && !graph.renderer.isViewMounted(sourceView) || targetView && !graph.renderer.isViewMounted(targetView))) {\n      // Wait for the sourceView and targetView to be rendered.\n      return ref;\n    }\n    if (this.hasAction(ref, 'render')) {\n      this.render();\n      ref = this.removeAction(ref, ['render', 'update', 'vertices', 'labels', 'tools', 'widget']);\n      return ref;\n    }\n    ref = this.handleAction(ref, 'vertices', () => this.renderVertexMarkers());\n    ref = this.handleAction(ref, 'update', () => this.update(null, options));\n    ref = this.handleAction(ref, 'labels', () => this.onLabelsChange(options));\n    ref = this.handleAction(ref, 'tools', () => {\n      this.renderTools();\n      this.updateToolsPosition();\n    });\n    ref = this.handleAction(ref, 'widget', () => this.renderExternalTools());\n    return ref;\n  }\n  onLabelsChange(options = {}) {\n    // Note: this optimization works in async=false mode only\n    if (this.shouldRerenderLabels(options)) {\n      this.renderLabels();\n    } else {\n      this.updateLabels();\n    }\n    this.updateLabelPositions();\n  }\n  shouldRerenderLabels(options = {}) {\n    const previousLabels = this.cell.previous('labels');\n    if (previousLabels == null) {\n      return true;\n    }\n    // Here is an optimization for cases when we know, that change does\n    // not require re-rendering of all labels.\n    if ('propertyPathArray' in options && 'propertyValue' in options) {\n      // The label is setting by `prop()` method\n      const pathArray = options.propertyPathArray || [];\n      const pathLength = pathArray.length;\n      if (pathLength > 1) {\n        // We are changing a single label here e.g. 'labels/0/position'\n        const index = pathArray[1];\n        if (previousLabels[index]) {\n          if (pathLength === 2) {\n            // We are changing the entire label. Need to check if the\n            // markup is also being changed.\n            return typeof options.propertyValue === 'object' && ObjectExt.has(options.propertyValue, 'markup');\n          }\n          // We are changing a label property but not the markup\n          if (pathArray[2] !== 'markup') {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n  render() {\n    this.empty();\n    this.containers = {};\n    this.renderMarkup();\n    this.renderLabels();\n    this.update();\n    this.renderExternalTools();\n    return this;\n  }\n  renderMarkup() {\n    const markup = this.cell.markup;\n    if (markup) {\n      if (typeof markup === 'string') {\n        return this.renderStringMarkup(markup);\n      }\n      return this.renderJSONMarkup(markup);\n    }\n    throw new TypeError('Invalid edge markup.');\n  }\n  renderJSONMarkup(markup) {\n    const ret = this.parseJSONMarkup(markup, this.container);\n    this.selectors = ret.selectors;\n    this.container.append(ret.fragment);\n  }\n  renderStringMarkup(markup) {\n    const cache = this.containers;\n    const children = Vector.createVectors(markup);\n    // Cache children elements for quicker access.\n    children.forEach(child => {\n      const className = child.attr('class');\n      if (className) {\n        cache[StringExt.camelCase(className)] = child.node;\n      }\n    });\n    this.renderTools();\n    this.renderVertexMarkers();\n    this.renderArrowheadMarkers();\n    Dom.append(this.container, children.map(child => child.node));\n  }\n  renderLabels() {\n    const edge = this.cell;\n    const labels = edge.getLabels();\n    const count = labels.length;\n    let container = this.containers.labels;\n    this.labelCache = {};\n    this.labelSelectors = {};\n    if (count <= 0) {\n      if (container && container.parentNode) {\n        container.parentNode.removeChild(container);\n      }\n      return this;\n    }\n    if (container) {\n      this.empty(container);\n    } else {\n      container = Dom.createSvgElement('g');\n      this.addClass(this.prefixClassName('edge-labels'), container);\n      this.containers.labels = container;\n    }\n    for (let i = 0, ii = labels.length; i < ii; i += 1) {\n      const label = labels[i];\n      const normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(label.markup));\n      let labelNode;\n      let selectors;\n      if (normalized) {\n        labelNode = normalized.node;\n        selectors = normalized.selectors;\n      } else {\n        const defaultLabel = edge.getDefaultLabel();\n        const normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(defaultLabel.markup));\n        labelNode = normalized.node;\n        selectors = normalized.selectors;\n      }\n      labelNode.setAttribute('data-index', `${i}`);\n      container.appendChild(labelNode);\n      const rootSelector = this.rootSelector;\n      if (selectors[rootSelector]) {\n        throw new Error('Ambiguous label root selector.');\n      }\n      selectors[rootSelector] = labelNode;\n      this.labelCache[i] = labelNode;\n      this.labelSelectors[i] = selectors;\n    }\n    if (container.parentNode == null) {\n      this.container.appendChild(container);\n    }\n    this.updateLabels();\n    this.customizeLabels();\n    return this;\n  }\n  parseLabelMarkup(markup) {\n    if (markup) {\n      if (typeof markup === 'string') {\n        return this.parseLabelStringMarkup(markup);\n      }\n      return this.parseJSONMarkup(markup);\n    }\n    return null;\n  }\n  parseLabelStringMarkup(labelMarkup) {\n    const children = Vector.createVectors(labelMarkup);\n    const fragment = document.createDocumentFragment();\n    for (let i = 0, n = children.length; i < n; i += 1) {\n      const currentChild = children[i].node;\n      fragment.appendChild(currentChild);\n    }\n    return {\n      fragment,\n      selectors: {}\n    };\n  }\n  normalizeLabelMarkup(markup) {\n    if (markup == null) {\n      return;\n    }\n    const fragment = markup.fragment;\n    if (!(fragment instanceof DocumentFragment) || !fragment.hasChildNodes()) {\n      throw new Error('Invalid label markup.');\n    }\n    let vel;\n    const childNodes = fragment.childNodes;\n    if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== 'G') {\n      // default markup fragment is not wrapped in `<g/>`\n      // add a `<g/>` container\n      vel = Vector.create('g').append(fragment);\n    } else {\n      vel = Vector.create(childNodes[0]);\n    }\n    vel.addClass(this.prefixClassName('edge-label'));\n    return {\n      node: vel.node,\n      selectors: markup.selectors\n    };\n  }\n  updateLabels() {\n    if (this.containers.labels) {\n      const edge = this.cell;\n      const labels = edge.labels;\n      const canLabelMove = this.can('edgeLabelMovable');\n      const defaultLabel = edge.getDefaultLabel();\n      for (let i = 0, n = labels.length; i < n; i += 1) {\n        const elem = this.labelCache[i];\n        const selectors = this.labelSelectors[i];\n        elem.setAttribute('cursor', canLabelMove ? 'move' : 'default');\n        const label = labels[i];\n        const attrs = ObjectExt.merge({}, defaultLabel.attrs, label.attrs);\n        this.updateAttrs(elem, attrs, {\n          selectors,\n          rootBBox: label.size ? Rectangle.fromSize(label.size) : undefined\n        });\n      }\n    }\n  }\n  mergeLabelAttrs(hasCustomMarkup, labelAttrs, defaultLabelAttrs) {\n    if (labelAttrs === null) {\n      return null;\n    }\n    if (labelAttrs === undefined) {\n      if (defaultLabelAttrs === null) {\n        return null;\n      }\n      if (defaultLabelAttrs === undefined) {\n        return undefined;\n      }\n      if (hasCustomMarkup) {\n        return defaultLabelAttrs;\n      }\n      return ObjectExt.merge({}, defaultLabelAttrs);\n    }\n    if (hasCustomMarkup) {\n      return ObjectExt.merge({}, defaultLabelAttrs, labelAttrs);\n    }\n  }\n  customizeLabels() {\n    if (this.containers.labels) {\n      const edge = this.cell;\n      const labels = edge.labels;\n      for (let i = 0, n = labels.length; i < n; i += 1) {\n        const label = labels[i];\n        const container = this.labelCache[i];\n        const selectors = this.labelSelectors[i];\n        this.graph.hook.onEdgeLabelRendered({\n          edge,\n          label,\n          container,\n          selectors\n        });\n      }\n    }\n  }\n  renderTools() {\n    const container = this.containers.tools;\n    if (container == null) {\n      return this;\n    }\n    const markup = this.cell.toolMarkup;\n    const $container = this.$(container).empty();\n    if (Markup.isStringMarkup(markup)) {\n      let template = StringExt.template(markup);\n      const tool = Vector.create(template());\n      $container.append(tool.node);\n      this.toolCache = tool.node;\n      // If `doubleTools` is enabled, we render copy of the tools on the\n      // other side of the edge as well but only if the edge is longer\n      // than `longLength`.\n      if (this.options.doubleTools) {\n        let tool2;\n        const doubleToolMarkup = this.cell.doubleToolMarkup;\n        if (Markup.isStringMarkup(doubleToolMarkup)) {\n          template = StringExt.template(doubleToolMarkup);\n          tool2 = Vector.create(template());\n        } else {\n          tool2 = tool.clone();\n        }\n        $container.append(tool2.node);\n        this.tool2Cache = tool2.node;\n      }\n    }\n    return this;\n  }\n  renderExternalTools() {\n    const tools = this.cell.getTools();\n    this.addTools(tools);\n    return this;\n  }\n  renderVertexMarkers() {\n    const container = this.containers.vertices;\n    if (container == null) {\n      return this;\n    }\n    const markup = this.cell.vertexMarkup;\n    const $container = this.$(container).empty();\n    if (Markup.isStringMarkup(markup)) {\n      const template = StringExt.template(markup);\n      this.cell.getVertices().forEach((vertex, index) => {\n        $container.append(Vector.create(template(Object.assign({\n          index\n        }, vertex))).node);\n      });\n    }\n    return this;\n  }\n  renderArrowheadMarkers() {\n    const container = this.containers.arrowheads;\n    if (container == null) {\n      return this;\n    }\n    const markup = this.cell.arrowheadMarkup;\n    const $container = this.$(container).empty();\n    if (Markup.isStringMarkup(markup)) {\n      const template = StringExt.template(markup);\n      const sourceArrowhead = Vector.create(template({\n        end: 'source'\n      })).node;\n      const targetArrowhead = Vector.create(template({\n        end: 'target'\n      })).node;\n      this.containers.sourceArrowhead = sourceArrowhead;\n      this.containers.targetArrowhead = targetArrowhead;\n      $container.append(sourceArrowhead, targetArrowhead);\n    }\n    return this;\n  }\n  // #endregion\n  // #region updating\n  update(partialAttrs, options = {}) {\n    this.cleanCache();\n    this.updateConnection(options);\n    const attrs = this.cell.getAttrs();\n    if (attrs != null) {\n      this.updateAttrs(this.container, attrs, {\n        attrs: partialAttrs === attrs ? null : partialAttrs,\n        selectors: this.selectors\n      });\n    }\n    this.updateConnectionPath();\n    this.updateLabelPositions();\n    this.updateToolsPosition();\n    this.updateArrowheadMarkers();\n    this.updateTools(options);\n    return this;\n  }\n  removeRedundantLinearVertices(options = {}) {\n    const edge = this.cell;\n    const vertices = edge.getVertices();\n    const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor];\n    const rawCount = routePoints.length;\n    // Puts the route points into a polyline and try to simplify.\n    const polyline = new Polyline(routePoints);\n    polyline.simplify({\n      threshold: 0.01\n    });\n    const simplifiedPoints = polyline.points.map(point => point.toJSON());\n    const simplifiedCount = simplifiedPoints.length;\n    // If simplification did not remove any redundant vertices.\n    if (rawCount === simplifiedCount) {\n      return 0;\n    }\n    // Sets simplified polyline points as edge vertices.\n    // Removes first and last polyline points again (source/target anchors).\n    edge.setVertices(simplifiedPoints.slice(1, simplifiedCount - 1), options);\n    return rawCount - simplifiedCount;\n  }\n  updateConnectionPath() {\n    const containers = this.containers;\n    if (containers.connection) {\n      const pathData = this.getConnectionPathData();\n      containers.connection.setAttribute('d', pathData);\n    }\n    if (containers.connectionWrap) {\n      const pathData = this.getConnectionPathData();\n      containers.connectionWrap.setAttribute('d', pathData);\n    }\n    if (containers.sourceMarker && containers.targetMarker) {\n      this.translateAndAutoOrientArrows(containers.sourceMarker, containers.targetMarker);\n    }\n  }\n  getTerminalView(type) {\n    switch (type) {\n      case 'source':\n        return this.sourceView || null;\n      case 'target':\n        return this.targetView || null;\n      default:\n        throw new Error(`Unknown terminal type '${type}'`);\n    }\n  }\n  getTerminalAnchor(type) {\n    switch (type) {\n      case 'source':\n        return Point.create(this.sourceAnchor);\n      case 'target':\n        return Point.create(this.targetAnchor);\n      default:\n        throw new Error(`Unknown terminal type '${type}'`);\n    }\n  }\n  getTerminalConnectionPoint(type) {\n    switch (type) {\n      case 'source':\n        return Point.create(this.sourcePoint);\n      case 'target':\n        return Point.create(this.targetPoint);\n      default:\n        throw new Error(`Unknown terminal type '${type}'`);\n    }\n  }\n  getTerminalMagnet(type, options = {}) {\n    switch (type) {\n      case 'source':\n        {\n          if (options.raw) {\n            return this.sourceMagnet;\n          }\n          const sourceView = this.sourceView;\n          if (!sourceView) {\n            return null;\n          }\n          return this.sourceMagnet || sourceView.container;\n        }\n      case 'target':\n        {\n          if (options.raw) {\n            return this.targetMagnet;\n          }\n          const targetView = this.targetView;\n          if (!targetView) {\n            return null;\n          }\n          return this.targetMagnet || targetView.container;\n        }\n      default:\n        {\n          throw new Error(`Unknown terminal type '${type}'`);\n        }\n    }\n  }\n  updateConnection(options = {}) {\n    const edge = this.cell;\n    // The edge is being translated by an ancestor that will shift\n    // source, target and vertices by an equal distance.\n    if (options.translateBy && edge.isFragmentDescendantOf(options.translateBy)) {\n      const tx = options.tx || 0;\n      const ty = options.ty || 0;\n      this.routePoints = new Polyline(this.routePoints).translate(tx, ty).points;\n      this.translateConnectionPoints(tx, ty);\n      this.path.translate(tx, ty);\n    } else {\n      const vertices = edge.getVertices();\n      // 1. Find anchor points\n      const anchors = this.findAnchors(vertices);\n      this.sourceAnchor = anchors.source;\n      this.targetAnchor = anchors.target;\n      // 2. Find route points\n      this.routePoints = this.findRoutePoints(vertices);\n      // 3. Find connection points\n      const connectionPoints = this.findConnectionPoints(this.routePoints, this.sourceAnchor, this.targetAnchor);\n      this.sourcePoint = connectionPoints.source;\n      this.targetPoint = connectionPoints.target;\n      // 4. Find Marker Connection Point\n      const markerPoints = this.findMarkerPoints(this.routePoints, this.sourcePoint, this.targetPoint);\n      // 5. Make path\n      this.path = this.findPath(this.routePoints, markerPoints.source || this.sourcePoint, markerPoints.target || this.targetPoint);\n    }\n    this.cleanCache();\n  }\n  findAnchors(vertices) {\n    const edge = this.cell;\n    const source = edge.source;\n    const target = edge.target;\n    const firstVertex = vertices[0];\n    const lastVertex = vertices[vertices.length - 1];\n    if (target.priority && !source.priority) {\n      // Reversed order\n      return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);\n    }\n    // Usual order\n    return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);\n  }\n  findAnchorsOrdered(firstType, firstPoint, secondType, secondPoint) {\n    let firstAnchor;\n    let secondAnchor;\n    const edge = this.cell;\n    const firstTerminal = edge[firstType];\n    const secondTerminal = edge[secondType];\n    const firstView = this.getTerminalView(firstType);\n    const secondView = this.getTerminalView(secondType);\n    const firstMagnet = this.getTerminalMagnet(firstType);\n    const secondMagnet = this.getTerminalMagnet(secondType);\n    if (firstView) {\n      let firstRef;\n      if (firstPoint) {\n        firstRef = Point.create(firstPoint);\n      } else if (secondView) {\n        firstRef = secondMagnet;\n      } else {\n        firstRef = Point.create(secondTerminal);\n      }\n      firstAnchor = this.getAnchor(firstTerminal.anchor, firstView, firstMagnet, firstRef, firstType);\n    } else {\n      firstAnchor = Point.create(firstTerminal);\n    }\n    if (secondView) {\n      const secondRef = Point.create(secondPoint || firstAnchor);\n      secondAnchor = this.getAnchor(secondTerminal.anchor, secondView, secondMagnet, secondRef, secondType);\n    } else {\n      secondAnchor = Point.isPointLike(secondTerminal) ? Point.create(secondTerminal) : new Point();\n    }\n    return {\n      [firstType]: firstAnchor,\n      [secondType]: secondAnchor\n    };\n  }\n  getAnchor(def, cellView, magnet, ref, terminalType) {\n    const isEdge = cellView.isEdgeElement(magnet);\n    const connecting = this.graph.options.connecting;\n    let config = typeof def === 'string' ? {\n      name: def\n    } : def;\n    if (!config) {\n      const defaults = isEdge ? (terminalType === 'source' ? connecting.sourceEdgeAnchor : connecting.targetEdgeAnchor) || connecting.edgeAnchor : (terminalType === 'source' ? connecting.sourceAnchor : connecting.targetAnchor) || connecting.anchor;\n      config = typeof defaults === 'string' ? {\n        name: defaults\n      } : defaults;\n    }\n    if (!config) {\n      throw new Error(`Anchor should be specified.`);\n    }\n    let anchor;\n    const name = config.name;\n    if (isEdge) {\n      const fn = EdgeAnchor.registry.get(name);\n      if (typeof fn !== 'function') {\n        return EdgeAnchor.registry.onNotFound(name);\n      }\n      anchor = FunctionExt.call(fn, this, cellView, magnet, ref, config.args || {}, terminalType);\n    } else {\n      const fn = NodeAnchor.registry.get(name);\n      if (typeof fn !== 'function') {\n        return NodeAnchor.registry.onNotFound(name);\n      }\n      anchor = FunctionExt.call(fn, this, cellView, magnet, ref, config.args || {}, terminalType);\n    }\n    return anchor ? anchor.round(this.POINT_ROUNDING) : new Point();\n  }\n  findRoutePoints(vertices = []) {\n    const defaultRouter = this.graph.options.connecting.router || Router.presets.normal;\n    const router = this.cell.getRouter() || defaultRouter;\n    let routePoints;\n    if (typeof router === 'function') {\n      routePoints = FunctionExt.call(router, this, vertices, {}, this);\n    } else {\n      const name = typeof router === 'string' ? router : router.name;\n      const args = typeof router === 'string' ? {} : router.args || {};\n      const fn = name ? Router.registry.get(name) : Router.presets.normal;\n      if (typeof fn !== 'function') {\n        return Router.registry.onNotFound(name);\n      }\n      routePoints = FunctionExt.call(fn, this, vertices, args, this);\n    }\n    return routePoints == null ? vertices.map(p => Point.create(p)) : routePoints.map(p => Point.create(p));\n  }\n  findConnectionPoints(routePoints, sourceAnchor, targetAnchor) {\n    const edge = this.cell;\n    const connecting = this.graph.options.connecting;\n    const sourceTerminal = edge.getSource();\n    const targetTerminal = edge.getTarget();\n    const sourceView = this.sourceView;\n    const targetView = this.targetView;\n    const firstRoutePoint = routePoints[0];\n    const lastRoutePoint = routePoints[routePoints.length - 1];\n    // source\n    let sourcePoint;\n    if (sourceView && !sourceView.isEdgeElement(this.sourceMagnet)) {\n      const sourceMagnet = this.sourceMagnet || sourceView.container;\n      const sourcePointRef = firstRoutePoint || targetAnchor;\n      const sourceLine = new Line(sourcePointRef, sourceAnchor);\n      const connectionPointDef = sourceTerminal.connectionPoint || connecting.sourceConnectionPoint || connecting.connectionPoint;\n      sourcePoint = this.getConnectionPoint(connectionPointDef, sourceView, sourceMagnet, sourceLine, 'source');\n    } else {\n      sourcePoint = sourceAnchor;\n    }\n    // target\n    let targetPoint;\n    if (targetView && !targetView.isEdgeElement(this.targetMagnet)) {\n      const targetMagnet = this.targetMagnet || targetView.container;\n      const targetConnectionPointDef = targetTerminal.connectionPoint || connecting.targetConnectionPoint || connecting.connectionPoint;\n      const targetPointRef = lastRoutePoint || sourceAnchor;\n      const targetLine = new Line(targetPointRef, targetAnchor);\n      targetPoint = this.getConnectionPoint(targetConnectionPointDef, targetView, targetMagnet, targetLine, 'target');\n    } else {\n      targetPoint = targetAnchor;\n    }\n    return {\n      source: sourcePoint,\n      target: targetPoint\n    };\n  }\n  getConnectionPoint(def, view, magnet, line, endType) {\n    const anchor = line.end;\n    if (def == null) {\n      return anchor;\n    }\n    const name = typeof def === 'string' ? def : def.name;\n    const args = typeof def === 'string' ? {} : def.args;\n    const fn = ConnectionPoint.registry.get(name);\n    if (typeof fn !== 'function') {\n      return ConnectionPoint.registry.onNotFound(name);\n    }\n    const connectionPoint = FunctionExt.call(fn, this, line, view, magnet, args || {}, endType);\n    return connectionPoint ? connectionPoint.round(this.POINT_ROUNDING) : anchor;\n  }\n  updateMarkerAttr(type) {\n    const attrs = this.cell.getAttrs();\n    const key = `.${type}-marker`;\n    const partial = attrs && attrs[key];\n    if (partial) {\n      this.updateAttrs(this.container, {}, {\n        attrs: {\n          [key]: partial\n        },\n        selectors: this.selectors\n      });\n    }\n  }\n  findMarkerPoints(routePoints, sourcePoint, targetPoint) {\n    const getLineWidth = type => {\n      const attrs = this.cell.getAttrs();\n      const keys = Object.keys(attrs);\n      for (let i = 0, l = keys.length; i < l; i += 1) {\n        const attr = attrs[keys[i]];\n        if (attr[`${type}Marker`] || attr[`${type}-marker`]) {\n          const strokeWidth = attr.strokeWidth || attr['stroke-width'];\n          if (strokeWidth) {\n            return parseFloat(strokeWidth);\n          }\n          break;\n        }\n      }\n      return null;\n    };\n    const firstRoutePoint = routePoints[0];\n    const lastRoutePoint = routePoints[routePoints.length - 1];\n    const sourceMarkerElem = this.containers.sourceMarker;\n    const targetMarkerElem = this.containers.targetMarker;\n    const cache = this.markerCache;\n    let sourceMarkerPoint;\n    let targetMarkerPoint;\n    // Move the source point by the width of the marker taking into\n    // account its scale around x-axis. Note that scale is the only\n    // transform that makes sense to be set in `.marker-source`\n    // attributes object as all other transforms (translate/rotate)\n    // will be replaced by the `translateAndAutoOrient()` function.\n    if (sourceMarkerElem) {\n      this.updateMarkerAttr('source');\n      // support marker connection point registry???\n      cache.sourceBBox = cache.sourceBBox || Dom.getBBox(sourceMarkerElem);\n      if (cache.sourceBBox.width > 0) {\n        const scale = Dom.scale(sourceMarkerElem);\n        sourceMarkerPoint = sourcePoint.clone().move(firstRoutePoint || targetPoint, cache.sourceBBox.width * scale.sx * -1);\n      }\n    } else {\n      const strokeWidth = getLineWidth('source');\n      if (strokeWidth) {\n        sourceMarkerPoint = sourcePoint.clone().move(firstRoutePoint || targetPoint, -strokeWidth);\n      }\n    }\n    if (targetMarkerElem) {\n      this.updateMarkerAttr('target');\n      cache.targetBBox = cache.targetBBox || Dom.getBBox(targetMarkerElem);\n      if (cache.targetBBox.width > 0) {\n        const scale = Dom.scale(targetMarkerElem);\n        targetMarkerPoint = targetPoint.clone().move(lastRoutePoint || sourcePoint, cache.targetBBox.width * scale.sx * -1);\n      }\n    } else {\n      const strokeWidth = getLineWidth('target');\n      if (strokeWidth) {\n        targetMarkerPoint = targetPoint.clone().move(lastRoutePoint || sourcePoint, -strokeWidth);\n      }\n    }\n    // If there was no markup for the marker, use the connection point.\n    cache.sourcePoint = sourceMarkerPoint || sourcePoint.clone();\n    cache.targetPoint = targetMarkerPoint || targetPoint.clone();\n    return {\n      source: sourceMarkerPoint,\n      target: targetMarkerPoint\n    };\n  }\n  findPath(routePoints, sourcePoint, targetPoint) {\n    const def = this.cell.getConnector() || this.graph.options.connecting.connector;\n    let name;\n    let args;\n    let fn;\n    if (typeof def === 'string') {\n      name = def;\n    } else {\n      name = def.name;\n      args = def.args;\n    }\n    if (name) {\n      const method = Connector.registry.get(name);\n      if (typeof method !== 'function') {\n        return Connector.registry.onNotFound(name);\n      }\n      fn = method;\n    } else {\n      fn = Connector.presets.normal;\n    }\n    const path = FunctionExt.call(fn, this, sourcePoint, targetPoint, routePoints, Object.assign(Object.assign({}, args), {\n      raw: true\n    }), this);\n    return typeof path === 'string' ? Path.parse(path) : path;\n  }\n  translateConnectionPoints(tx, ty) {\n    const cache = this.markerCache;\n    if (cache.sourcePoint) {\n      cache.sourcePoint.translate(tx, ty);\n    }\n    if (cache.targetPoint) {\n      cache.targetPoint.translate(tx, ty);\n    }\n    this.sourcePoint.translate(tx, ty);\n    this.targetPoint.translate(tx, ty);\n    this.sourceAnchor.translate(tx, ty);\n    this.targetAnchor.translate(tx, ty);\n  }\n  updateLabelPositions() {\n    if (this.containers.labels == null) {\n      return this;\n    }\n    const path = this.path;\n    if (!path) {\n      return this;\n    }\n    const edge = this.cell;\n    const labels = edge.getLabels();\n    if (labels.length === 0) {\n      return this;\n    }\n    const defaultLabel = edge.getDefaultLabel();\n    const defaultPosition = this.normalizeLabelPosition(defaultLabel.position);\n    for (let i = 0, ii = labels.length; i < ii; i += 1) {\n      const label = labels[i];\n      const labelNode = this.labelCache[i];\n      if (!labelNode) {\n        continue;\n      }\n      const labelPosition = this.normalizeLabelPosition(label.position);\n      const pos = ObjectExt.merge({}, defaultPosition, labelPosition);\n      const matrix = this.getLabelTransformationMatrix(pos);\n      labelNode.setAttribute('transform', Dom.matrixToTransformString(matrix));\n    }\n    return this;\n  }\n  updateToolsPosition() {\n    if (this.containers.tools == null) {\n      return this;\n    }\n    // Move the tools a bit to the target position but don't cover the\n    // `sourceArrowhead` marker. Note that the offset is hardcoded here.\n    // The offset should be always more than the\n    // `this.$('.marker-arrowhead[end=\"source\"]')[0].bbox().width` but looking\n    // this up all the time would be slow.\n    let scale = '';\n    let offset = this.options.toolsOffset;\n    const connectionLength = this.getConnectionLength();\n    // Firefox returns `connectionLength=NaN` in odd cases (for bezier curves).\n    // In that case we won't update tools position at all.\n    if (connectionLength != null) {\n      // If the edge is too short, make the tools half the\n      // size and the offset twice as low.\n      if (connectionLength < this.options.shortLength) {\n        scale = 'scale(.5)';\n        offset /= 2;\n      }\n      let pos = this.getPointAtLength(offset);\n      if (pos != null) {\n        Dom.attr(this.toolCache, 'transform', `translate(${pos.x},${pos.y}) ${scale}`);\n      }\n      if (this.options.doubleTools && connectionLength >= this.options.longLength) {\n        const doubleToolsOffset = this.options.doubleToolsOffset || offset;\n        pos = this.getPointAtLength(connectionLength - doubleToolsOffset);\n        if (pos != null) {\n          Dom.attr(this.tool2Cache, 'transform', `translate(${pos.x},${pos.y}) ${scale}`);\n        }\n        Dom.attr(this.tool2Cache, 'visibility', 'visible');\n      } else if (this.options.doubleTools) {\n        Dom.attr(this.tool2Cache, 'visibility', 'hidden');\n      }\n    }\n    return this;\n  }\n  updateArrowheadMarkers() {\n    const container = this.containers.arrowheads;\n    if (container == null) {\n      return this;\n    }\n    if (container.style.display === 'none') {\n      return this;\n    }\n    const sourceArrowhead = this.containers.sourceArrowhead;\n    const targetArrowhead = this.containers.targetArrowhead;\n    if (sourceArrowhead && targetArrowhead) {\n      const len = this.getConnectionLength() || 0;\n      const sx = len < this.options.shortLength ? 0.5 : 1;\n      Dom.scale(sourceArrowhead, sx);\n      Dom.scale(targetArrowhead, sx);\n      this.translateAndAutoOrientArrows(sourceArrowhead, targetArrowhead);\n    }\n    return this;\n  }\n  updateTerminalProperties(type) {\n    const edge = this.cell;\n    const graph = this.graph;\n    const terminal = edge[type];\n    const nodeId = terminal && terminal.cell;\n    const viewKey = `${type}View`;\n    // terminal is a point\n    if (!nodeId) {\n      this[viewKey] = null;\n      this.updateTerminalMagnet(type);\n      return true;\n    }\n    const terminalCell = graph.getCellById(nodeId);\n    if (!terminalCell) {\n      throw new Error(`Edge's ${type} node with id \"${nodeId}\" not exists`);\n    }\n    const endView = terminalCell.findView(graph);\n    if (!endView) {\n      return false;\n    }\n    this[viewKey] = endView;\n    this.updateTerminalMagnet(type);\n    return true;\n  }\n  updateTerminalMagnet(type) {\n    const propName = `${type}Magnet`;\n    const terminalView = this.getTerminalView(type);\n    if (terminalView) {\n      let magnet = terminalView.getMagnetFromEdgeTerminal(this.cell[type]);\n      if (magnet === terminalView.container) {\n        magnet = null;\n      }\n      this[propName] = magnet;\n    } else {\n      this[propName] = null;\n    }\n  }\n  translateAndAutoOrientArrows(sourceArrow, targetArrow) {\n    const route = this.routePoints;\n    if (sourceArrow) {\n      Dom.translateAndAutoOrient(sourceArrow, this.sourcePoint, route[0] || this.targetPoint, this.graph.view.stage);\n    }\n    if (targetArrow) {\n      Dom.translateAndAutoOrient(targetArrow, this.targetPoint, route[route.length - 1] || this.sourcePoint, this.graph.view.stage);\n    }\n  }\n  getLabelPositionAngle(idx) {\n    const label = this.cell.getLabelAt(idx);\n    if (label && label.position && typeof label.position === 'object') {\n      return label.position.angle || 0;\n    }\n    return 0;\n  }\n  getLabelPositionArgs(idx) {\n    const label = this.cell.getLabelAt(idx);\n    if (label && label.position && typeof label.position === 'object') {\n      return label.position.options;\n    }\n  }\n  getDefaultLabelPositionArgs() {\n    const defaultLabel = this.cell.getDefaultLabel();\n    if (defaultLabel && defaultLabel.position && typeof defaultLabel.position === 'object') {\n      return defaultLabel.position.options;\n    }\n  }\n  // merge default label position args into label position args\n  // keep `undefined` or `null` because `{}` means something else\n  mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs) {\n    if (labelPositionArgs === null) {\n      return null;\n    }\n    if (labelPositionArgs === undefined) {\n      if (defaultLabelPositionArgs === null) {\n        return null;\n      }\n      return defaultLabelPositionArgs;\n    }\n    return ObjectExt.merge({}, defaultLabelPositionArgs, labelPositionArgs);\n  }\n  addLabel(p1, p2, p3, options) {\n    let localX;\n    let localY;\n    let localAngle = 0;\n    let localOptions;\n    if (typeof p1 !== 'number') {\n      localX = p1.x;\n      localY = p1.y;\n      if (typeof p2 === 'number') {\n        localAngle = p2;\n        localOptions = p3;\n      } else {\n        localOptions = p2;\n      }\n    } else {\n      localX = p1;\n      localY = p2;\n      if (typeof p3 === 'number') {\n        localAngle = p3;\n        localOptions = options;\n      } else {\n        localOptions = p3;\n      }\n    }\n    // merge label position arguments\n    const defaultLabelPositionArgs = this.getDefaultLabelPositionArgs();\n    const labelPositionArgs = localOptions;\n    const positionArgs = this.mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n    // append label to labels array\n    const label = {\n      position: this.getLabelPosition(localX, localY, localAngle, positionArgs)\n    };\n    const index = -1;\n    this.cell.insertLabel(label, index, localOptions);\n    return index;\n  }\n  addVertex(x, y, options) {\n    const isPoint = typeof x !== 'number';\n    const localX = isPoint ? x.x : x;\n    const localY = isPoint ? x.y : y;\n    const localOptions = isPoint ? y : options;\n    const vertex = {\n      x: localX,\n      y: localY\n    };\n    const index = this.getVertexIndex(localX, localY);\n    this.cell.insertVertex(vertex, index, localOptions);\n    return index;\n  }\n  sendToken(token, options, callback) {\n    let duration;\n    let reversed;\n    let selector;\n    let rorate;\n    let timing = 'linear';\n    if (typeof options === 'object') {\n      duration = options.duration;\n      reversed = options.reversed === true;\n      selector = options.selector;\n      if (options.rotate === false) {\n        rorate = '';\n      } else if (options.rotate === true) {\n        rorate = 'auto';\n      } else if (options.rotate != null) {\n        rorate = `${options.rotate}`;\n      }\n      if (options.timing) {\n        timing = options.timing;\n      }\n    } else {\n      duration = options;\n      reversed = false;\n      selector = null;\n    }\n    duration = duration || 1000;\n    const attrs = {\n      dur: `${duration}ms`,\n      repeatCount: '1',\n      calcMode: timing,\n      fill: 'freeze'\n    };\n    if (rorate) {\n      attrs.rotate = rorate;\n    }\n    if (reversed) {\n      attrs.keyPoints = '1;0';\n      attrs.keyTimes = '0;1';\n    }\n    if (typeof options === 'object') {\n      const {\n          duration,\n          reversed,\n          selector,\n          rotate,\n          timing\n        } = options,\n        others = __rest(options, [\"duration\", \"reversed\", \"selector\", \"rotate\", \"timing\"]);\n      Object.keys(others).forEach(key => {\n        attrs[key] = others[key];\n      });\n    }\n    let path;\n    if (typeof selector === 'string') {\n      path = this.findOne(selector, this.container, this.selectors);\n    } else {\n      // Select connection path automatically.\n      path = this.containers.connection ? this.containers.connection : this.container.querySelector('path');\n    }\n    if (!(path instanceof SVGPathElement)) {\n      throw new Error('Token animation requires a valid connection path.');\n    }\n    const target = typeof token === 'string' ? this.findOne(token) : token;\n    if (target == null) {\n      throw new Error('Token animation requires a valid token element.');\n    }\n    const parent = target.parentNode;\n    const revert = () => {\n      if (!parent) {\n        Dom.remove(target);\n      }\n    };\n    const vToken = Vector.create(target);\n    if (!parent) {\n      vToken.appendTo(this.graph.view.stage);\n    }\n    const onComplete = attrs.complete;\n    attrs.complete = e => {\n      revert();\n      if (callback) {\n        callback();\n      }\n      if (onComplete) {\n        onComplete(e);\n      }\n    };\n    const stop = vToken.animateAlongPath(attrs, path);\n    return () => {\n      revert();\n      stop();\n    };\n  }\n  // #endregion\n  getConnection() {\n    return this.path != null ? this.path.clone() : null;\n  }\n  getConnectionPathData() {\n    if (this.path == null) {\n      return '';\n    }\n    const cache = this.cache.pathCache;\n    if (!ObjectExt.has(cache, 'data')) {\n      cache.data = this.path.serialize();\n    }\n    return cache.data || '';\n  }\n  getConnectionSubdivisions() {\n    if (this.path == null) {\n      return null;\n    }\n    const cache = this.cache.pathCache;\n    if (!ObjectExt.has(cache, 'segmentSubdivisions')) {\n      cache.segmentSubdivisions = this.path.getSegmentSubdivisions();\n    }\n    return cache.segmentSubdivisions;\n  }\n  getConnectionLength() {\n    if (this.path == null) {\n      return 0;\n    }\n    const cache = this.cache.pathCache;\n    if (!ObjectExt.has(cache, 'length')) {\n      cache.length = this.path.length({\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      });\n    }\n    return cache.length;\n  }\n  getPointAtLength(length) {\n    if (this.path == null) {\n      return null;\n    }\n    return this.path.pointAtLength(length, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n  getPointAtRatio(ratio) {\n    if (this.path == null) {\n      return null;\n    }\n    if (NumberExt.isPercentage(ratio)) {\n      // eslint-disable-next-line\n      ratio = parseFloat(ratio) / 100;\n    }\n    return this.path.pointAt(ratio, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n  getTangentAtLength(length) {\n    if (this.path == null) {\n      return null;\n    }\n    return this.path.tangentAtLength(length, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n  getTangentAtRatio(ratio) {\n    if (this.path == null) {\n      return null;\n    }\n    return this.path.tangentAt(ratio, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n  getClosestPoint(point) {\n    if (this.path == null) {\n      return null;\n    }\n    return this.path.closestPoint(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n  getClosestPointLength(point) {\n    if (this.path == null) {\n      return null;\n    }\n    return this.path.closestPointLength(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n  getClosestPointRatio(point) {\n    if (this.path == null) {\n      return null;\n    }\n    return this.path.closestPointNormalizedLength(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n  getLabelPosition(x, y, p3, p4) {\n    const pos = {\n      distance: 0\n    };\n    // normalize data from the two possible signatures\n    let angle = 0;\n    let options;\n    if (typeof p3 === 'number') {\n      angle = p3;\n      options = p4;\n    } else {\n      options = p3;\n    }\n    if (options != null) {\n      pos.options = options;\n    }\n    // identify distance/offset settings\n    const isOffsetAbsolute = options && options.absoluteOffset;\n    const isDistanceRelative = !(options && options.absoluteDistance);\n    const isDistanceAbsoluteReverse = options && options.absoluteDistance && options.reverseDistance;\n    // find closest point t\n    const path = this.path;\n    const pathOptions = {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    };\n    const labelPoint = new Point(x, y);\n    const t = path.closestPointT(labelPoint, pathOptions);\n    // distance\n    const totalLength = this.getConnectionLength() || 0;\n    let labelDistance = path.lengthAtT(t, pathOptions);\n    if (isDistanceRelative) {\n      labelDistance = totalLength > 0 ? labelDistance / totalLength : 0;\n    }\n    if (isDistanceAbsoluteReverse) {\n      // fix for end point (-0 => 1)\n      labelDistance = -1 * (totalLength - labelDistance) || 1;\n    }\n    pos.distance = labelDistance;\n    // offset\n    // use absolute offset if:\n    // - options.absoluteOffset is true,\n    // - options.absoluteOffset is not true but there is no tangent\n    let tangent;\n    if (!isOffsetAbsolute) tangent = path.tangentAtT(t);\n    let labelOffset;\n    if (tangent) {\n      labelOffset = tangent.pointOffset(labelPoint);\n    } else {\n      const closestPoint = path.pointAtT(t);\n      const labelOffsetDiff = labelPoint.diff(closestPoint);\n      labelOffset = {\n        x: labelOffsetDiff.x,\n        y: labelOffsetDiff.y\n      };\n    }\n    pos.offset = labelOffset;\n    pos.angle = angle;\n    return pos;\n  }\n  normalizeLabelPosition(pos) {\n    if (typeof pos === 'number') {\n      return {\n        distance: pos\n      };\n    }\n    return pos;\n  }\n  getLabelTransformationMatrix(labelPosition) {\n    const pos = this.normalizeLabelPosition(labelPosition);\n    const options = pos.options || {};\n    const labelAngle = pos.angle || 0;\n    const labelDistance = pos.distance;\n    const isDistanceRelative = labelDistance > 0 && labelDistance <= 1;\n    let labelOffset = 0;\n    const offsetCoord = {\n      x: 0,\n      y: 0\n    };\n    const offset = pos.offset;\n    if (offset) {\n      if (typeof offset === 'number') {\n        labelOffset = offset;\n      } else {\n        if (offset.x != null) {\n          offsetCoord.x = offset.x;\n        }\n        if (offset.y != null) {\n          offsetCoord.y = offset.y;\n        }\n      }\n    }\n    const isOffsetAbsolute = offsetCoord.x !== 0 || offsetCoord.y !== 0 || labelOffset === 0;\n    const isKeepGradient = options.keepGradient;\n    const isEnsureLegibility = options.ensureLegibility;\n    const path = this.path;\n    const pathOpt = {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    };\n    const distance = isDistanceRelative ? labelDistance * this.getConnectionLength() : labelDistance;\n    const tangent = path.tangentAtLength(distance, pathOpt);\n    let translation;\n    let angle = labelAngle;\n    if (tangent) {\n      if (isOffsetAbsolute) {\n        translation = tangent.start;\n        translation.translate(offsetCoord);\n      } else {\n        const normal = tangent.clone();\n        normal.rotate(-90, tangent.start);\n        normal.setLength(labelOffset);\n        translation = normal.end;\n      }\n      if (isKeepGradient) {\n        angle = tangent.angle() + labelAngle;\n        if (isEnsureLegibility) {\n          angle = Angle.normalize((angle + 90) % 180 - 90);\n        }\n      }\n    } else {\n      // fallback - the connection has zero length\n      translation = path.start;\n      if (isOffsetAbsolute) {\n        translation.translate(offsetCoord);\n      }\n    }\n    return Dom.createSVGMatrix().translate(translation.x, translation.y).rotate(angle);\n  }\n  getLabelCoordinates(pos) {\n    const matrix = this.getLabelTransformationMatrix(pos);\n    return new Point(matrix.e, matrix.f);\n  }\n  getVertexIndex(x, y) {\n    const edge = this.cell;\n    const vertices = edge.getVertices();\n    const vertexLength = this.getClosestPointLength(new Point(x, y));\n    let index = 0;\n    if (vertexLength != null) {\n      for (const ii = vertices.length; index < ii; index += 1) {\n        const currentVertex = vertices[index];\n        const currentLength = this.getClosestPointLength(currentVertex);\n        if (currentLength != null && vertexLength < currentLength) {\n          break;\n        }\n      }\n    }\n    return index;\n  }\n  getEventArgs(e, x, y) {\n    const view = this; // eslint-disable-line\n    const edge = view.cell;\n    const cell = edge;\n    if (x == null || y == null) {\n      return {\n        e,\n        view,\n        edge,\n        cell\n      };\n    }\n    return {\n      e,\n      x,\n      y,\n      view,\n      edge,\n      cell\n    };\n  }\n  notifyUnhandledMouseDown(e, x, y) {\n    this.notify('edge:unhandled:mousedown', {\n      e,\n      x,\n      y,\n      view: this,\n      cell: this.cell,\n      edge: this.cell\n    });\n  }\n  notifyMouseDown(e, x, y) {\n    super.onMouseDown(e, x, y);\n    this.notify('edge:mousedown', this.getEventArgs(e, x, y));\n  }\n  notifyMouseMove(e, x, y) {\n    super.onMouseMove(e, x, y);\n    this.notify('edge:mousemove', this.getEventArgs(e, x, y));\n  }\n  notifyMouseUp(e, x, y) {\n    super.onMouseUp(e, x, y);\n    this.notify('edge:mouseup', this.getEventArgs(e, x, y));\n  }\n  onClick(e, x, y) {\n    super.onClick(e, x, y);\n    this.notify('edge:click', this.getEventArgs(e, x, y));\n  }\n  onDblClick(e, x, y) {\n    super.onDblClick(e, x, y);\n    this.notify('edge:dblclick', this.getEventArgs(e, x, y));\n  }\n  onContextMenu(e, x, y) {\n    super.onContextMenu(e, x, y);\n    this.notify('edge:contextmenu', this.getEventArgs(e, x, y));\n  }\n  onMouseDown(e, x, y) {\n    this.notifyMouseDown(e, x, y);\n    const className = e.target.getAttribute('class');\n    switch (className) {\n      case 'vertex':\n        {\n          this.startVertexDragging(e, x, y);\n          return;\n        }\n      case 'vertex-remove':\n      case 'vertex-remove-area':\n        {\n          this.handleVertexRemoving(e, x, y);\n          return;\n        }\n      case 'connection':\n      case 'connection-wrap':\n        {\n          this.handleVertexAdding(e, x, y);\n          return;\n        }\n      case 'arrowhead':\n        {\n          this.startArrowheadDragging(e, x, y);\n          return;\n        }\n      case 'source-marker':\n      case 'target-marker':\n        {\n          this.notifyUnhandledMouseDown(e, x, y);\n          return;\n        }\n      default:\n        break;\n    }\n    this.startEdgeDragging(e, x, y);\n  }\n  onMouseMove(e, x, y) {\n    const data = this.getEventData(e);\n    switch (data.action) {\n      case 'drag-vertex':\n        {\n          this.dragVertex(e, x, y);\n          break;\n        }\n      case 'drag-label':\n        {\n          this.dragLabel(e, x, y);\n          break;\n        }\n      case 'drag-arrowhead':\n        {\n          this.dragArrowhead(e, x, y);\n          break;\n        }\n      case 'drag-edge':\n        {\n          this.dragEdge(e, x, y);\n          break;\n        }\n      default:\n        break;\n    }\n    this.notifyMouseMove(e, x, y);\n    return data;\n  }\n  onMouseUp(e, x, y) {\n    const data = this.getEventData(e);\n    switch (data.action) {\n      case 'drag-vertex':\n        {\n          this.stopVertexDragging(e, x, y);\n          break;\n        }\n      case 'drag-label':\n        {\n          this.stopLabelDragging(e, x, y);\n          break;\n        }\n      case 'drag-arrowhead':\n        {\n          this.stopArrowheadDragging(e, x, y);\n          break;\n        }\n      case 'drag-edge':\n        {\n          this.stopEdgeDragging(e, x, y);\n          break;\n        }\n      default:\n        break;\n    }\n    this.notifyMouseUp(e, x, y);\n    this.checkMouseleave(e);\n    return data;\n  }\n  onMouseOver(e) {\n    super.onMouseOver(e);\n    this.notify('edge:mouseover', this.getEventArgs(e));\n  }\n  onMouseOut(e) {\n    super.onMouseOut(e);\n    this.notify('edge:mouseout', this.getEventArgs(e));\n  }\n  onMouseEnter(e) {\n    super.onMouseEnter(e);\n    this.notify('edge:mouseenter', this.getEventArgs(e));\n  }\n  onMouseLeave(e) {\n    super.onMouseLeave(e);\n    this.notify('edge:mouseleave', this.getEventArgs(e));\n  }\n  onMouseWheel(e, x, y, delta) {\n    super.onMouseWheel(e, x, y, delta);\n    this.notify('edge:mousewheel', Object.assign({\n      delta\n    }, this.getEventArgs(e, x, y)));\n  }\n  onCustomEvent(e, name, x, y) {\n    // For default edge tool\n    const tool = Dom.findParentByClass(e.target, 'edge-tool', this.container);\n    if (tool) {\n      e.stopPropagation(); // no further action to be executed\n      if (this.can('useEdgeTools')) {\n        if (name === 'edge:remove') {\n          this.cell.remove({\n            ui: true\n          });\n          return;\n        }\n        this.notify('edge:customevent', Object.assign({\n          name\n        }, this.getEventArgs(e, x, y)));\n      }\n      this.notifyMouseDown(e, x, y);\n    } else {\n      this.notify('edge:customevent', Object.assign({\n        name\n      }, this.getEventArgs(e, x, y)));\n      super.onCustomEvent(e, name, x, y);\n    }\n  }\n  onLabelMouseDown(e, x, y) {\n    this.notifyMouseDown(e, x, y);\n    this.startLabelDragging(e, x, y);\n    const stopPropagation = this.getEventData(e).stopPropagation;\n    if (stopPropagation) {\n      e.stopPropagation();\n    }\n  }\n  // #region drag edge\n  startEdgeDragging(e, x, y) {\n    if (!this.can('edgeMovable')) {\n      this.notifyUnhandledMouseDown(e, x, y);\n      return;\n    }\n    this.setEventData(e, {\n      x,\n      y,\n      moving: false,\n      action: 'drag-edge'\n    });\n  }\n  dragEdge(e, x, y) {\n    const data = this.getEventData(e);\n    if (!data.moving) {\n      data.moving = true;\n      this.addClass('edge-moving');\n      this.notify('edge:move', {\n        e,\n        x,\n        y,\n        view: this,\n        cell: this.cell,\n        edge: this.cell\n      });\n    }\n    this.cell.translate(x - data.x, y - data.y, {\n      ui: true\n    });\n    this.setEventData(e, {\n      x,\n      y\n    });\n    this.notify('edge:moving', {\n      e,\n      x,\n      y,\n      view: this,\n      cell: this.cell,\n      edge: this.cell\n    });\n  }\n  stopEdgeDragging(e, x, y) {\n    const data = this.getEventData(e);\n    if (data.moving) {\n      this.removeClass('edge-moving');\n      this.notify('edge:moved', {\n        e,\n        x,\n        y,\n        view: this,\n        cell: this.cell,\n        edge: this.cell\n      });\n    }\n    data.moving = false;\n  }\n  // #endregion\n  // #region drag arrowhead\n  prepareArrowheadDragging(type, options) {\n    const magnet = this.getTerminalMagnet(type);\n    const data = {\n      action: 'drag-arrowhead',\n      x: options.x,\n      y: options.y,\n      isNewEdge: options.isNewEdge === true,\n      terminalType: type,\n      initialMagnet: magnet,\n      initialTerminal: ObjectExt.clone(this.cell[type]),\n      fallbackAction: options.fallbackAction || 'revert',\n      getValidateConnectionArgs: this.createValidateConnectionArgs(type),\n      options: options.options\n    };\n    this.beforeArrowheadDragging(data);\n    return data;\n  }\n  createValidateConnectionArgs(type) {\n    const args = [];\n    args[4] = type;\n    args[5] = this;\n    let opposite;\n    let i = 0;\n    let j = 0;\n    if (type === 'source') {\n      i = 2;\n      opposite = 'target';\n    } else {\n      j = 2;\n      opposite = 'source';\n    }\n    const terminal = this.cell[opposite];\n    const cellId = terminal.cell;\n    if (cellId) {\n      let magnet;\n      const view = args[i] = this.graph.renderer.findViewByCell(cellId);\n      if (view) {\n        magnet = view.getMagnetFromEdgeTerminal(terminal);\n        if (magnet === view.container) {\n          magnet = undefined;\n        }\n      }\n      args[i + 1] = magnet;\n    }\n    return (cellView, magnet) => {\n      args[j] = cellView;\n      args[j + 1] = cellView.container === magnet ? undefined : magnet;\n      return args;\n    };\n  }\n  beforeArrowheadDragging(data) {\n    data.zIndex = this.cell.zIndex;\n    this.cell.toFront();\n    const style = this.container.style;\n    data.pointerEvents = style.pointerEvents;\n    style.pointerEvents = 'none';\n    if (this.graph.options.connecting.highlight) {\n      this.highlightAvailableMagnets(data);\n    }\n  }\n  afterArrowheadDragging(data) {\n    if (data.zIndex != null) {\n      this.cell.setZIndex(data.zIndex, {\n        ui: true\n      });\n      data.zIndex = null;\n    }\n    const container = this.container;\n    container.style.pointerEvents = data.pointerEvents || '';\n    if (this.graph.options.connecting.highlight) {\n      this.unhighlightAvailableMagnets(data);\n    }\n  }\n  arrowheadDragging(target, x, y, data) {\n    data.x = x;\n    data.y = y;\n    // Checking views right under the pointer\n    if (data.currentTarget !== target) {\n      // Unhighlight the previous view under pointer if there was one.\n      if (data.currentMagnet && data.currentView) {\n        data.currentView.unhighlight(data.currentMagnet, {\n          type: 'magnetAdsorbed'\n        });\n      }\n      data.currentView = this.graph.renderer.findViewByElem(target);\n      if (data.currentView) {\n        // If we found a view that is under the pointer, we need to find\n        // the closest magnet based on the real target element of the event.\n        data.currentMagnet = data.currentView.findMagnet(target);\n        if (data.currentMagnet && this.graph.hook.validateConnection(...data.getValidateConnectionArgs(data.currentView, data.currentMagnet), data.currentView.getEdgeTerminal(data.currentMagnet, x, y, this.cell, data.terminalType))) {\n          data.currentView.highlight(data.currentMagnet, {\n            type: 'magnetAdsorbed'\n          });\n        } else {\n          // This type of connection is not valid. Disregard this magnet.\n          data.currentMagnet = null;\n        }\n      } else {\n        // Make sure we'll unset previous magnet.\n        data.currentMagnet = null;\n      }\n    }\n    data.currentTarget = target;\n    this.cell.prop(data.terminalType, {\n      x,\n      y\n    }, Object.assign(Object.assign({}, data.options), {\n      ui: true\n    }));\n  }\n  arrowheadDragged(data, x, y) {\n    const view = data.currentView;\n    const magnet = data.currentMagnet;\n    if (!magnet || !view) {\n      return;\n    }\n    view.unhighlight(magnet, {\n      type: 'magnetAdsorbed'\n    });\n    const type = data.terminalType;\n    const terminal = view.getEdgeTerminal(magnet, x, y, this.cell, type);\n    this.cell.setTerminal(type, terminal, {\n      ui: true\n    });\n  }\n  snapArrowhead(x, y, data) {\n    const graph = this.graph;\n    const {\n      snap,\n      allowEdge\n    } = graph.options.connecting;\n    const radius = typeof snap === 'object' && snap.radius || 50;\n    const findViewsOption = {\n      x: x - radius,\n      y: y - radius,\n      width: 2 * radius,\n      height: 2 * radius\n    };\n    const views = graph.renderer.findViewsInArea(findViewsOption);\n    if (allowEdge) {\n      const edgeViews = graph.renderer.findEdgeViewsInArea(findViewsOption).filter(view => {\n        return view !== this;\n      });\n      views.push(...edgeViews);\n    }\n    const prevView = data.closestView || null;\n    const prevMagnet = data.closestMagnet || null;\n    data.closestView = null;\n    data.closestMagnet = null;\n    let distance;\n    let minDistance = Number.MAX_SAFE_INTEGER;\n    const pos = new Point(x, y);\n    views.forEach(view => {\n      if (view.container.getAttribute('magnet') !== 'false') {\n        // Find distance from the center of the cell to pointer coordinates\n        distance = view.cell.getBBox().getCenter().distance(pos);\n        // the connection is looked up in a circle area by `distance < r`\n        if (distance < radius && distance < minDistance) {\n          if (prevMagnet === view.container || graph.hook.validateConnection(...data.getValidateConnectionArgs(view, null), view.getEdgeTerminal(view.container, x, y, this.cell, data.terminalType))) {\n            minDistance = distance;\n            data.closestView = view;\n            data.closestMagnet = view.container;\n          }\n        }\n      }\n      view.container.querySelectorAll('[magnet]').forEach(magnet => {\n        if (magnet.getAttribute('magnet') !== 'false') {\n          const bbox = view.getBBoxOfElement(magnet);\n          distance = pos.distance(bbox.getCenter());\n          if (distance < radius && distance < minDistance) {\n            if (prevMagnet === magnet || graph.hook.validateConnection(...data.getValidateConnectionArgs(view, magnet), view.getEdgeTerminal(magnet, x, y, this.cell, data.terminalType))) {\n              minDistance = distance;\n              data.closestView = view;\n              data.closestMagnet = magnet;\n            }\n          }\n        }\n      });\n    });\n    let terminal;\n    const type = data.terminalType;\n    const closestView = data.closestView;\n    const closestMagnet = data.closestMagnet;\n    const changed = prevMagnet !== closestMagnet;\n    if (prevView && changed) {\n      prevView.unhighlight(prevMagnet, {\n        type: 'magnetAdsorbed'\n      });\n    }\n    if (closestView) {\n      if (!changed) {\n        return;\n      }\n      closestView.highlight(closestMagnet, {\n        type: 'magnetAdsorbed'\n      });\n      terminal = closestView.getEdgeTerminal(closestMagnet, x, y, this.cell, type);\n    } else {\n      terminal = {\n        x,\n        y\n      };\n    }\n    this.cell.setTerminal(type, terminal, {}, Object.assign(Object.assign({}, data.options), {\n      ui: true\n    }));\n  }\n  snapArrowheadEnd(data) {\n    // Finish off link snapping.\n    // Everything except view unhighlighting was already done on pointermove.\n    const closestView = data.closestView;\n    const closestMagnet = data.closestMagnet;\n    if (closestView && closestMagnet) {\n      closestView.unhighlight(closestMagnet, {\n        type: 'magnetAdsorbed'\n      });\n      data.currentMagnet = closestView.findMagnet(closestMagnet);\n    }\n    data.closestView = null;\n    data.closestMagnet = null;\n  }\n  finishEmbedding(data) {\n    // Resets parent of the edge if embedding is enabled\n    if (this.graph.options.embedding.enabled && this.cell.updateParent()) {\n      // Make sure we don't reverse to the original 'z' index\n      data.zIndex = null;\n    }\n  }\n  fallbackConnection(data) {\n    switch (data.fallbackAction) {\n      case 'remove':\n        this.cell.remove({\n          ui: true\n        });\n        break;\n      case 'revert':\n      default:\n        this.cell.prop(data.terminalType, data.initialTerminal, {\n          ui: true\n        });\n        break;\n    }\n  }\n  notifyConnectionEvent(data, e) {\n    const terminalType = data.terminalType;\n    const initialTerminal = data.initialTerminal;\n    const currentTerminal = this.cell[terminalType];\n    const changed = currentTerminal && !Edge.equalTerminals(initialTerminal, currentTerminal);\n    if (changed) {\n      const graph = this.graph;\n      const previous = initialTerminal;\n      const previousCell = previous.cell ? graph.getCellById(previous.cell) : null;\n      const previousPort = previous.port;\n      const previousView = previousCell ? graph.findViewByCell(previousCell) : null;\n      const previousPoint = previousCell || data.isNewEdge ? null : Point.create(initialTerminal).toJSON();\n      const current = currentTerminal;\n      const currentCell = current.cell ? graph.getCellById(current.cell) : null;\n      const currentPort = current.port;\n      const currentView = currentCell ? graph.findViewByCell(currentCell) : null;\n      const currentPoint = currentCell ? null : Point.create(currentTerminal).toJSON();\n      this.notify('edge:connected', {\n        e,\n        previousCell,\n        previousPort,\n        previousView,\n        previousPoint,\n        currentCell,\n        currentView,\n        currentPort,\n        currentPoint,\n        previousMagnet: data.initialMagnet,\n        currentMagnet: data.currentMagnet,\n        edge: this.cell,\n        view: this,\n        type: terminalType,\n        isNew: data.isNewEdge\n      });\n    }\n  }\n  highlightAvailableMagnets(data) {\n    const graph = this.graph;\n    const cells = graph.model.getCells();\n    data.marked = {};\n    for (let i = 0, ii = cells.length; i < ii; i += 1) {\n      const view = graph.renderer.findViewByCell(cells[i]);\n      if (!view) {\n        continue;\n      }\n      const magnets = Array.prototype.slice.call(view.container.querySelectorAll('[magnet]'));\n      if (view.container.getAttribute('magnet') !== 'false') {\n        magnets.push(view.container);\n      }\n      const availableMagnets = magnets.filter(magnet => graph.hook.validateConnection(...data.getValidateConnectionArgs(view, magnet), view.getEdgeTerminal(magnet, data.x, data.y, this.cell, data.terminalType)));\n      if (availableMagnets.length > 0) {\n        // highlight all available magnets\n        for (let j = 0, jj = availableMagnets.length; j < jj; j += 1) {\n          view.highlight(availableMagnets[j], {\n            type: 'magnetAvailable'\n          });\n        }\n        // highlight the entire view\n        view.highlight(null, {\n          type: 'nodeAvailable'\n        });\n        data.marked[view.cell.id] = availableMagnets;\n      }\n    }\n  }\n  unhighlightAvailableMagnets(data) {\n    const marked = data.marked || {};\n    Object.keys(marked).forEach(id => {\n      const view = this.graph.renderer.findViewByCell(id);\n      if (view) {\n        const magnets = marked[id];\n        magnets.forEach(magnet => {\n          view.unhighlight(magnet, {\n            type: 'magnetAvailable'\n          });\n        });\n        view.unhighlight(null, {\n          type: 'nodeAvailable'\n        });\n      }\n    });\n    data.marked = null;\n  }\n  startArrowheadDragging(e, x, y) {\n    if (!this.can('arrowheadMovable')) {\n      this.notifyUnhandledMouseDown(e, x, y);\n      return;\n    }\n    const elem = e.target;\n    const type = elem.getAttribute('data-terminal');\n    const data = this.prepareArrowheadDragging(type, {\n      x,\n      y\n    });\n    this.setEventData(e, data);\n  }\n  dragArrowhead(e, x, y) {\n    const data = this.getEventData(e);\n    if (this.graph.options.connecting.snap) {\n      this.snapArrowhead(x, y, data);\n    } else {\n      this.arrowheadDragging(this.getEventTarget(e), x, y, data);\n    }\n  }\n  stopArrowheadDragging(e, x, y) {\n    const graph = this.graph;\n    const data = this.getEventData(e);\n    if (graph.options.connecting.snap) {\n      this.snapArrowheadEnd(data);\n    } else {\n      this.arrowheadDragged(data, x, y);\n    }\n    const valid = graph.hook.validateEdge(this.cell, data.terminalType, data.initialTerminal);\n    if (valid) {\n      this.finishEmbedding(data);\n      this.notifyConnectionEvent(data, e);\n    } else {\n      // If the changed edge is not allowed, revert to its previous state.\n      this.fallbackConnection(data);\n    }\n    this.afterArrowheadDragging(data);\n  }\n  // #endregion\n  // #region drag lable\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  startLabelDragging(e, x, y) {\n    if (this.can('edgeLabelMovable')) {\n      const target = e.currentTarget;\n      const index = parseInt(target.getAttribute('data-index'), 10);\n      const positionAngle = this.getLabelPositionAngle(index);\n      const labelPositionArgs = this.getLabelPositionArgs(index);\n      const defaultLabelPositionArgs = this.getDefaultLabelPositionArgs();\n      const positionArgs = this.mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n      this.setEventData(e, {\n        index,\n        positionAngle,\n        positionArgs,\n        stopPropagation: true,\n        action: 'drag-label'\n      });\n    } else {\n      // If labels can't be dragged no default action is triggered.\n      this.setEventData(e, {\n        stopPropagation: true\n      });\n    }\n    this.graph.view.delegateDragEvents(e, this);\n  }\n  dragLabel(e, x, y) {\n    const data = this.getEventData(e);\n    const originLabel = this.cell.getLabelAt(data.index);\n    const label = ObjectExt.merge({}, originLabel, {\n      position: this.getLabelPosition(x, y, data.positionAngle, data.positionArgs)\n    });\n    this.cell.setLabelAt(data.index, label);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  stopLabelDragging(e, x, y) {}\n  // #endregion\n  // #region drag vertex\n  handleVertexAdding(e, x, y) {\n    if (!this.can('vertexAddable')) {\n      this.notifyUnhandledMouseDown(e, x, y);\n      return;\n    }\n    // Store the index at which the new vertex has just been placed.\n    // We'll be update the very same vertex position in `pointermove()`.\n    const index = this.addVertex({\n      x,\n      y\n    }, {\n      ui: true\n    });\n    this.setEventData(e, {\n      index,\n      action: 'drag-vertex'\n    });\n  }\n  handleVertexRemoving(e, x, y) {\n    if (!this.can('vertexDeletable')) {\n      this.notifyUnhandledMouseDown(e, x, y);\n      return;\n    }\n    const target = e.target;\n    const index = parseInt(target.getAttribute('idx'), 10);\n    this.cell.removeVertexAt(index);\n  }\n  startVertexDragging(e, x, y) {\n    if (!this.can('vertexMovable')) {\n      this.notifyUnhandledMouseDown(e, x, y);\n      return;\n    }\n    const target = e.target;\n    const index = parseInt(target.getAttribute('idx'), 10);\n    this.setEventData(e, {\n      index,\n      action: 'drag-vertex'\n    });\n  }\n  dragVertex(e, x, y) {\n    const data = this.getEventData(e);\n    this.cell.setVertexAt(data.index, {\n      x,\n      y\n    }, {\n      ui: true\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  stopVertexDragging(e, x, y) {}\n}\n(function (EdgeView) {\n  EdgeView.toStringTag = `X6.${EdgeView.name}`;\n  function isEdgeView(instance) {\n    if (instance == null) {\n      return false;\n    }\n    if (instance instanceof EdgeView) {\n      return true;\n    }\n    const tag = instance[Symbol.toStringTag];\n    const view = instance;\n    if ((tag == null || tag === EdgeView.toStringTag) && typeof view.isNodeView === 'function' && typeof view.isEdgeView === 'function' && typeof view.confirmUpdate === 'function' && typeof view.update === 'function' && typeof view.getConnection === 'function') {\n      return true;\n    }\n    return false;\n  }\n  EdgeView.isEdgeView = isEdgeView;\n})(EdgeView || (EdgeView = {}));\nEdgeView.config({\n  isSvgElement: true,\n  priority: 1,\n  bootstrap: ['render', 'source', 'target'],\n  actions: {\n    view: ['render'],\n    markup: ['render'],\n    attrs: ['update'],\n    source: ['source', 'update'],\n    target: ['target', 'update'],\n    router: ['update'],\n    connector: ['update'],\n    labels: ['labels'],\n    defaultLabel: ['labels'],\n    vertices: ['vertices', 'update'],\n    vertexMarkup: ['vertices'],\n    toolMarkup: ['tools'],\n    tools: ['widget']\n  },\n  shortLength: 105,\n  longLength: 155,\n  toolsOffset: 40,\n  doubleTools: false,\n  doubleToolsOffset: 65,\n  sampleInterval: 50\n});\nEdgeView.registry.register('edge', EdgeView, true);","map":{"version":3,"names":["Rectangle","Polyline","Point","Angle","Path","Line","StringExt","ObjectExt","NumberExt","FunctionExt","Dom","Vector","Router","Connector","NodeAnchor","EdgeAnchor","ConnectionPoint","Edge","Markup","CellView","EdgeView","constructor","POINT_ROUNDING","markerCache","Symbol","toStringTag","getContainerClassName","prefixClassName","join","sourceBBox","sourceView","sourceDef","cell","getSource","x","y","sourceMagnet","isEdgeElement","sourceAnchor","getBBoxOfElement","container","targetBBox","targetView","targetDef","getTarget","targetMagnet","targetAnchor","isEdgeView","confirmUpdate","flag","options","ref","hasAction","updateTerminalProperties","removeAction","graph","renderer","isViewMounted","render","handleAction","renderVertexMarkers","update","onLabelsChange","renderTools","updateToolsPosition","renderExternalTools","shouldRerenderLabels","renderLabels","updateLabels","updateLabelPositions","previousLabels","previous","pathArray","propertyPathArray","pathLength","length","index","propertyValue","has","empty","containers","renderMarkup","markup","renderStringMarkup","renderJSONMarkup","TypeError","ret","parseJSONMarkup","selectors","append","fragment","cache","children","createVectors","forEach","child","className","attr","camelCase","node","renderArrowheadMarkers","map","edge","labels","getLabels","count","labelCache","labelSelectors","parentNode","removeChild","createSvgElement","addClass","i","ii","label","normalized","normalizeLabelMarkup","parseLabelMarkup","labelNode","defaultLabel","getDefaultLabel","setAttribute","appendChild","rootSelector","Error","customizeLabels","parseLabelStringMarkup","labelMarkup","document","createDocumentFragment","n","currentChild","DocumentFragment","hasChildNodes","vel","childNodes","nodeName","toUpperCase","create","canLabelMove","can","elem","attrs","merge","updateAttrs","rootBBox","size","fromSize","undefined","mergeLabelAttrs","hasCustomMarkup","labelAttrs","defaultLabelAttrs","hook","onEdgeLabelRendered","tools","toolMarkup","$container","$","isStringMarkup","template","tool","toolCache","doubleTools","tool2","doubleToolMarkup","clone","tool2Cache","getTools","addTools","vertices","vertexMarkup","getVertices","vertex","Object","assign","arrowheads","arrowheadMarkup","sourceArrowhead","end","targetArrowhead","partialAttrs","cleanCache","updateConnection","getAttrs","updateConnectionPath","updateArrowheadMarkers","updateTools","removeRedundantLinearVertices","routePoints","rawCount","polyline","simplify","threshold","simplifiedPoints","points","point","toJSON","simplifiedCount","setVertices","slice","connection","pathData","getConnectionPathData","connectionWrap","sourceMarker","targetMarker","translateAndAutoOrientArrows","getTerminalView","type","getTerminalAnchor","getTerminalConnectionPoint","sourcePoint","targetPoint","getTerminalMagnet","raw","translateBy","isFragmentDescendantOf","tx","ty","translate","translateConnectionPoints","path","anchors","findAnchors","source","target","findRoutePoints","connectionPoints","findConnectionPoints","markerPoints","findMarkerPoints","findPath","firstVertex","lastVertex","priority","findAnchorsOrdered","firstType","firstPoint","secondType","secondPoint","firstAnchor","secondAnchor","firstTerminal","secondTerminal","firstView","secondView","firstMagnet","secondMagnet","firstRef","getAnchor","anchor","secondRef","isPointLike","def","cellView","magnet","terminalType","isEdge","connecting","config","name","defaults","sourceEdgeAnchor","targetEdgeAnchor","edgeAnchor","fn","registry","get","onNotFound","call","args","round","defaultRouter","router","presets","normal","getRouter","p","sourceTerminal","targetTerminal","firstRoutePoint","lastRoutePoint","sourcePointRef","sourceLine","connectionPointDef","connectionPoint","sourceConnectionPoint","getConnectionPoint","targetConnectionPointDef","targetConnectionPoint","targetPointRef","targetLine","view","line","endType","updateMarkerAttr","key","partial","getLineWidth","keys","l","strokeWidth","parseFloat","sourceMarkerElem","targetMarkerElem","sourceMarkerPoint","targetMarkerPoint","getBBox","width","scale","move","sx","getConnector","connector","method","parse","defaultPosition","normalizeLabelPosition","position","labelPosition","pos","matrix","getLabelTransformationMatrix","matrixToTransformString","offset","toolsOffset","connectionLength","getConnectionLength","shortLength","getPointAtLength","longLength","doubleToolsOffset","style","display","len","terminal","nodeId","viewKey","updateTerminalMagnet","terminalCell","getCellById","endView","findView","propName","terminalView","getMagnetFromEdgeTerminal","sourceArrow","targetArrow","route","translateAndAutoOrient","stage","getLabelPositionAngle","idx","getLabelAt","angle","getLabelPositionArgs","getDefaultLabelPositionArgs","mergeLabelPositionArgs","labelPositionArgs","defaultLabelPositionArgs","addLabel","p1","p2","p3","localX","localY","localAngle","localOptions","positionArgs","getLabelPosition","insertLabel","addVertex","isPoint","getVertexIndex","insertVertex","sendToken","token","callback","duration","reversed","selector","rorate","timing","rotate","dur","repeatCount","calcMode","fill","keyPoints","keyTimes","others","__rest","findOne","querySelector","SVGPathElement","parent","revert","remove","vToken","appendTo","onComplete","complete","e","stop","animateAlongPath","getConnection","pathCache","data","serialize","getConnectionSubdivisions","segmentSubdivisions","getSegmentSubdivisions","pointAtLength","getPointAtRatio","ratio","isPercentage","pointAt","getTangentAtLength","tangentAtLength","getTangentAtRatio","tangentAt","getClosestPoint","closestPoint","getClosestPointLength","closestPointLength","getClosestPointRatio","closestPointNormalizedLength","p4","distance","isOffsetAbsolute","absoluteOffset","isDistanceRelative","absoluteDistance","isDistanceAbsoluteReverse","reverseDistance","pathOptions","labelPoint","t","closestPointT","totalLength","labelDistance","lengthAtT","tangent","tangentAtT","labelOffset","pointOffset","pointAtT","labelOffsetDiff","diff","labelAngle","offsetCoord","isKeepGradient","keepGradient","isEnsureLegibility","ensureLegibility","pathOpt","translation","start","setLength","normalize","createSVGMatrix","getLabelCoordinates","f","vertexLength","currentVertex","currentLength","getEventArgs","notifyUnhandledMouseDown","notify","notifyMouseDown","onMouseDown","notifyMouseMove","onMouseMove","notifyMouseUp","onMouseUp","onClick","onDblClick","onContextMenu","getAttribute","startVertexDragging","handleVertexRemoving","handleVertexAdding","startArrowheadDragging","startEdgeDragging","getEventData","action","dragVertex","dragLabel","dragArrowhead","dragEdge","stopVertexDragging","stopLabelDragging","stopArrowheadDragging","stopEdgeDragging","checkMouseleave","onMouseOver","onMouseOut","onMouseEnter","onMouseLeave","onMouseWheel","delta","onCustomEvent","findParentByClass","stopPropagation","ui","onLabelMouseDown","startLabelDragging","setEventData","moving","removeClass","prepareArrowheadDragging","isNewEdge","initialMagnet","initialTerminal","fallbackAction","getValidateConnectionArgs","createValidateConnectionArgs","beforeArrowheadDragging","opposite","j","cellId","findViewByCell","zIndex","toFront","pointerEvents","highlight","highlightAvailableMagnets","afterArrowheadDragging","setZIndex","unhighlightAvailableMagnets","arrowheadDragging","currentTarget","currentMagnet","currentView","unhighlight","findViewByElem","findMagnet","validateConnection","getEdgeTerminal","prop","arrowheadDragged","setTerminal","snapArrowhead","snap","allowEdge","radius","findViewsOption","height","views","findViewsInArea","edgeViews","findEdgeViewsInArea","filter","push","prevView","closestView","prevMagnet","closestMagnet","minDistance","Number","MAX_SAFE_INTEGER","getCenter","querySelectorAll","bbox","changed","snapArrowheadEnd","finishEmbedding","embedding","enabled","updateParent","fallbackConnection","notifyConnectionEvent","currentTerminal","equalTerminals","previousCell","previousPort","port","previousView","previousPoint","current","currentCell","currentPort","currentPoint","previousMagnet","isNew","cells","model","getCells","marked","magnets","Array","prototype","availableMagnets","jj","id","getEventTarget","valid","validateEdge","parseInt","positionAngle","delegateDragEvents","originLabel","setLabelAt","removeVertexAt","setVertexAt","instance","tag","isNodeView","isSvgElement","bootstrap","actions","sampleInterval","register"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/view/edge.ts"],"sourcesContent":["import { KeyValue } from '../types'\nimport { Rectangle, Polyline, Point, Angle, Path, Line } from '../geometry'\nimport {\n  StringExt,\n  ObjectExt,\n  NumberExt,\n  FunctionExt,\n  Dom,\n  Vector,\n} from '../util'\nimport {\n  Attr,\n  Router,\n  Connector,\n  NodeAnchor,\n  EdgeAnchor,\n  ConnectionPoint,\n} from '../registry'\nimport { Cell } from '../model/cell'\nimport { Edge } from '../model/edge'\nimport { Markup } from './markup'\nimport { CellView } from './cell'\nimport { NodeView } from './node'\nimport { ToolsView } from './tool'\n\nexport class EdgeView<\n  Entity extends Edge = Edge,\n  Options extends EdgeView.Options = EdgeView.Options,\n> extends CellView<Entity, Options> {\n  protected readonly POINT_ROUNDING = 2\n  public path: Path\n  public routePoints: Point[]\n  public sourceAnchor: Point\n  public targetAnchor: Point\n  public sourcePoint: Point\n  public targetPoint: Point\n  public sourceView: CellView | null\n  public targetView: CellView | null\n  public sourceMagnet: Element | null\n  public targetMagnet: Element | null\n  protected toolCache: Element\n  protected tool2Cache: Element\n  protected readonly markerCache: {\n    sourcePoint?: Point\n    targetPoint?: Point\n    sourceBBox?: Rectangle\n    targetBBox?: Rectangle\n  } = {}\n\n  protected get [Symbol.toStringTag]() {\n    return EdgeView.toStringTag\n  }\n\n  protected getContainerClassName() {\n    return [super.getContainerClassName(), this.prefixClassName('edge')].join(\n      ' ',\n    )\n  }\n\n  get sourceBBox() {\n    const sourceView = this.sourceView\n    if (!sourceView) {\n      const sourceDef = this.cell.getSource() as Edge.TerminalPointData\n      return new Rectangle(sourceDef.x, sourceDef.y)\n    }\n    const sourceMagnet = this.sourceMagnet\n    if (sourceView.isEdgeElement(sourceMagnet)) {\n      return new Rectangle(this.sourceAnchor.x, this.sourceAnchor.y)\n    }\n    return sourceView.getBBoxOfElement(sourceMagnet || sourceView.container)\n  }\n\n  get targetBBox() {\n    const targetView = this.targetView\n    if (!targetView) {\n      const targetDef = this.cell.getTarget() as Edge.TerminalPointData\n      return new Rectangle(targetDef.x, targetDef.y)\n    }\n    const targetMagnet = this.targetMagnet\n    if (targetView.isEdgeElement(targetMagnet)) {\n      return new Rectangle(this.targetAnchor.x, this.targetAnchor.y)\n    }\n    return targetView.getBBoxOfElement(targetMagnet || targetView.container)\n  }\n\n  isEdgeView(): this is EdgeView {\n    return true\n  }\n\n  confirmUpdate(flag: number, options: any = {}) {\n    let ref = flag\n    if (this.hasAction(ref, 'source')) {\n      if (!this.updateTerminalProperties('source')) {\n        return ref\n      }\n      ref = this.removeAction(ref, 'source')\n    }\n\n    if (this.hasAction(ref, 'target')) {\n      if (!this.updateTerminalProperties('target')) {\n        return ref\n      }\n      ref = this.removeAction(ref, 'target')\n    }\n\n    const graph = this.graph\n    const sourceView = this.sourceView\n    const targetView = this.targetView\n\n    if (\n      graph &&\n      ((sourceView && !graph.renderer.isViewMounted(sourceView)) ||\n        (targetView && !graph.renderer.isViewMounted(targetView)))\n    ) {\n      // Wait for the sourceView and targetView to be rendered.\n      return ref\n    }\n\n    if (this.hasAction(ref, 'render')) {\n      this.render()\n      ref = this.removeAction(ref, [\n        'render',\n        'update',\n        'vertices',\n        'labels',\n        'tools',\n        'widget',\n      ])\n      return ref\n    }\n\n    ref = this.handleAction(ref, 'vertices', () => this.renderVertexMarkers())\n    ref = this.handleAction(ref, 'update', () => this.update(null, options))\n    ref = this.handleAction(ref, 'labels', () => this.onLabelsChange(options))\n    ref = this.handleAction(ref, 'tools', () => {\n      this.renderTools()\n      this.updateToolsPosition()\n    })\n    ref = this.handleAction(ref, 'widget', () => this.renderExternalTools())\n\n    return ref\n  }\n\n  onLabelsChange(options: any = {}) {\n    // Note: this optimization works in async=false mode only\n    if (this.shouldRerenderLabels(options)) {\n      this.renderLabels()\n    } else {\n      this.updateLabels()\n    }\n\n    this.updateLabelPositions()\n  }\n\n  protected shouldRerenderLabels(options: any = {}) {\n    const previousLabels = this.cell.previous('labels')\n    if (previousLabels == null) {\n      return true\n    }\n\n    // Here is an optimization for cases when we know, that change does\n    // not require re-rendering of all labels.\n    if ('propertyPathArray' in options && 'propertyValue' in options) {\n      // The label is setting by `prop()` method\n      const pathArray = options.propertyPathArray || []\n      const pathLength = pathArray.length\n      if (pathLength > 1) {\n        // We are changing a single label here e.g. 'labels/0/position'\n        const index = pathArray[1]\n        if (previousLabels[index]) {\n          if (pathLength === 2) {\n            // We are changing the entire label. Need to check if the\n            // markup is also being changed.\n            return (\n              typeof options.propertyValue === 'object' &&\n              ObjectExt.has(options.propertyValue, 'markup')\n            )\n          }\n\n          // We are changing a label property but not the markup\n          if (pathArray[2] !== 'markup') {\n            return false\n          }\n        }\n      }\n    }\n\n    return true\n  }\n\n  // #region render\n\n  protected containers: EdgeView.ContainerCache\n\n  protected labelCache: { [index: number]: Element }\n\n  protected labelSelectors: { [index: number]: Markup.Selectors }\n\n  render() {\n    this.empty()\n    this.containers = {}\n    this.renderMarkup()\n    this.renderLabels()\n    this.update()\n    this.renderExternalTools()\n\n    return this\n  }\n\n  protected renderMarkup() {\n    const markup = this.cell.markup\n    if (markup) {\n      if (typeof markup === 'string') {\n        return this.renderStringMarkup(markup)\n      }\n      return this.renderJSONMarkup(markup)\n    }\n    throw new TypeError('Invalid edge markup.')\n  }\n\n  protected renderJSONMarkup(markup: Markup.JSONMarkup | Markup.JSONMarkup[]) {\n    const ret = this.parseJSONMarkup(markup, this.container)\n    this.selectors = ret.selectors\n    this.container.append(ret.fragment)\n  }\n\n  protected renderStringMarkup(markup: string) {\n    const cache = this.containers\n    const children = Vector.createVectors(markup)\n    // Cache children elements for quicker access.\n    children.forEach((child) => {\n      const className = child.attr('class')\n      if (className) {\n        cache[StringExt.camelCase(className) as keyof EdgeView.ContainerCache] =\n          child.node\n      }\n    })\n\n    this.renderTools()\n    this.renderVertexMarkers()\n    this.renderArrowheadMarkers()\n\n    Dom.append(\n      this.container,\n      children.map((child) => child.node),\n    )\n  }\n\n  protected renderLabels() {\n    const edge = this.cell\n    const labels = edge.getLabels()\n    const count = labels.length\n    let container = this.containers.labels\n\n    this.labelCache = {}\n    this.labelSelectors = {}\n\n    if (count <= 0) {\n      if (container && container.parentNode) {\n        container.parentNode.removeChild(container)\n      }\n      return this\n    }\n\n    if (container) {\n      this.empty(container)\n    } else {\n      container = Dom.createSvgElement('g')\n      this.addClass(this.prefixClassName('edge-labels'), container)\n      this.containers.labels = container\n    }\n\n    for (let i = 0, ii = labels.length; i < ii; i += 1) {\n      const label = labels[i]\n      const normalized = this.normalizeLabelMarkup(\n        this.parseLabelMarkup(label.markup),\n      )\n      let labelNode\n      let selectors\n      if (normalized) {\n        labelNode = normalized.node\n        selectors = normalized.selectors\n      } else {\n        const defaultLabel = edge.getDefaultLabel()\n        const normalized = this.normalizeLabelMarkup(\n          this.parseLabelMarkup(defaultLabel.markup),\n        )!\n\n        labelNode = normalized.node\n        selectors = normalized.selectors\n      }\n\n      labelNode.setAttribute('data-index', `${i}`)\n      container.appendChild(labelNode)\n\n      const rootSelector = this.rootSelector\n      if (selectors[rootSelector]) {\n        throw new Error('Ambiguous label root selector.')\n      }\n      selectors[rootSelector] = labelNode\n\n      this.labelCache[i] = labelNode\n      this.labelSelectors[i] = selectors\n    }\n\n    if (container.parentNode == null) {\n      this.container.appendChild(container)\n    }\n\n    this.updateLabels()\n    this.customizeLabels()\n\n    return this\n  }\n\n  protected parseLabelMarkup(markup?: Markup) {\n    if (markup) {\n      if (typeof markup === 'string') {\n        return this.parseLabelStringMarkup(markup)\n      }\n      return this.parseJSONMarkup(markup)\n    }\n\n    return null\n  }\n\n  protected parseLabelStringMarkup(labelMarkup: string) {\n    const children = Vector.createVectors(labelMarkup)\n    const fragment = document.createDocumentFragment()\n    for (let i = 0, n = children.length; i < n; i += 1) {\n      const currentChild = children[i].node\n      fragment.appendChild(currentChild)\n    }\n\n    return { fragment, selectors: {} }\n  }\n\n  protected normalizeLabelMarkup(\n    markup?: {\n      fragment: DocumentFragment\n      selectors: Markup.Selectors\n    } | null,\n  ) {\n    if (markup == null) {\n      return\n    }\n\n    const fragment = markup.fragment\n    if (!(fragment instanceof DocumentFragment) || !fragment.hasChildNodes()) {\n      throw new Error('Invalid label markup.')\n    }\n\n    let vel\n    const childNodes = fragment.childNodes\n    if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== 'G') {\n      // default markup fragment is not wrapped in `<g/>`\n      // add a `<g/>` container\n      vel = Vector.create('g').append(fragment)\n    } else {\n      vel = Vector.create(childNodes[0] as SVGElement)\n    }\n\n    vel.addClass(this.prefixClassName('edge-label'))\n\n    return {\n      node: vel.node,\n      selectors: markup.selectors,\n    }\n  }\n\n  protected updateLabels() {\n    if (this.containers.labels) {\n      const edge = this.cell\n      const labels = edge.labels\n      const canLabelMove = this.can('edgeLabelMovable')\n      const defaultLabel = edge.getDefaultLabel()\n\n      for (let i = 0, n = labels.length; i < n; i += 1) {\n        const elem = this.labelCache[i]\n        const selectors = this.labelSelectors[i]\n\n        elem.setAttribute('cursor', canLabelMove ? 'move' : 'default')\n\n        const label = labels[i]\n        const attrs = ObjectExt.merge({}, defaultLabel.attrs, label.attrs)\n        this.updateAttrs(elem, attrs, {\n          selectors,\n          rootBBox: label.size ? Rectangle.fromSize(label.size) : undefined,\n        })\n      }\n    }\n  }\n\n  protected mergeLabelAttrs(\n    hasCustomMarkup: boolean,\n    labelAttrs?: Attr.CellAttrs | null,\n    defaultLabelAttrs?: Attr.CellAttrs | null,\n  ) {\n    if (labelAttrs === null) {\n      return null\n    }\n\n    if (labelAttrs === undefined) {\n      if (defaultLabelAttrs === null) {\n        return null\n      }\n      if (defaultLabelAttrs === undefined) {\n        return undefined\n      }\n\n      if (hasCustomMarkup) {\n        return defaultLabelAttrs\n      }\n\n      return ObjectExt.merge({}, defaultLabelAttrs)\n    }\n\n    if (hasCustomMarkup) {\n      return ObjectExt.merge({}, defaultLabelAttrs, labelAttrs)\n    }\n  }\n\n  protected customizeLabels() {\n    if (this.containers.labels) {\n      const edge = this.cell\n      const labels = edge.labels\n      for (let i = 0, n = labels.length; i < n; i += 1) {\n        const label = labels[i]\n        const container = this.labelCache[i]\n        const selectors = this.labelSelectors[i]\n        this.graph.hook.onEdgeLabelRendered({\n          edge,\n          label,\n          container,\n          selectors,\n        })\n      }\n    }\n  }\n\n  protected renderTools() {\n    const container = this.containers.tools\n    if (container == null) {\n      return this\n    }\n\n    const markup = this.cell.toolMarkup\n    const $container = this.$(container).empty()\n\n    if (Markup.isStringMarkup(markup)) {\n      let template = StringExt.template(markup)\n      const tool = Vector.create(template())\n\n      $container.append(tool.node)\n      this.toolCache = tool.node\n\n      // If `doubleTools` is enabled, we render copy of the tools on the\n      // other side of the edge as well but only if the edge is longer\n      // than `longLength`.\n      if (this.options.doubleTools) {\n        let tool2\n        const doubleToolMarkup = this.cell.doubleToolMarkup\n        if (Markup.isStringMarkup(doubleToolMarkup)) {\n          template = StringExt.template(doubleToolMarkup)\n          tool2 = Vector.create(template())\n        } else {\n          tool2 = tool.clone()\n        }\n\n        $container.append(tool2.node)\n        this.tool2Cache = tool2.node\n      }\n    }\n\n    return this\n  }\n\n  protected renderExternalTools() {\n    const tools = this.cell.getTools()\n    this.addTools(tools as ToolsView.Options)\n    return this\n  }\n\n  renderVertexMarkers() {\n    const container = this.containers.vertices\n    if (container == null) {\n      return this\n    }\n\n    const markup = this.cell.vertexMarkup\n    const $container = this.$(container).empty()\n    if (Markup.isStringMarkup(markup)) {\n      const template = StringExt.template(markup)\n      this.cell.getVertices().forEach((vertex, index) => {\n        $container.append(Vector.create(template({ index, ...vertex })).node)\n      })\n    }\n\n    return this\n  }\n\n  renderArrowheadMarkers() {\n    const container = this.containers.arrowheads\n    if (container == null) {\n      return this\n    }\n\n    const markup = this.cell.arrowheadMarkup\n    const $container = this.$(container).empty()\n\n    if (Markup.isStringMarkup(markup)) {\n      const template = StringExt.template(markup)\n      const sourceArrowhead = Vector.create(template({ end: 'source' })).node\n      const targetArrowhead = Vector.create(template({ end: 'target' })).node\n\n      this.containers.sourceArrowhead = sourceArrowhead\n      this.containers.targetArrowhead = targetArrowhead\n\n      $container.append(sourceArrowhead, targetArrowhead)\n    }\n\n    return this\n  }\n\n  // #endregion\n\n  // #region updating\n\n  update(partialAttrs?: Attr.CellAttrs | null, options: any = {}) {\n    this.cleanCache()\n    this.updateConnection(options)\n\n    const attrs = this.cell.getAttrs()\n    if (attrs != null) {\n      this.updateAttrs(this.container, attrs, {\n        attrs: partialAttrs === attrs ? null : partialAttrs,\n        selectors: this.selectors,\n      })\n    }\n\n    this.updateConnectionPath()\n    this.updateLabelPositions()\n    this.updateToolsPosition()\n    this.updateArrowheadMarkers()\n    this.updateTools(options)\n\n    return this\n  }\n\n  removeRedundantLinearVertices(options: Edge.SetOptions = {}) {\n    const edge = this.cell\n    const vertices = edge.getVertices()\n    const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor]\n    const rawCount = routePoints.length\n\n    // Puts the route points into a polyline and try to simplify.\n    const polyline = new Polyline(routePoints)\n    polyline.simplify({ threshold: 0.01 })\n    const simplifiedPoints = polyline.points.map((point) => point.toJSON())\n    const simplifiedCount = simplifiedPoints.length\n\n    // If simplification did not remove any redundant vertices.\n    if (rawCount === simplifiedCount) {\n      return 0\n    }\n\n    // Sets simplified polyline points as edge vertices.\n    // Removes first and last polyline points again (source/target anchors).\n    edge.setVertices(simplifiedPoints.slice(1, simplifiedCount - 1), options)\n    return rawCount - simplifiedCount\n  }\n\n  updateConnectionPath() {\n    const containers = this.containers\n    if (containers.connection) {\n      const pathData = this.getConnectionPathData()\n      containers.connection.setAttribute('d', pathData)\n    }\n\n    if (containers.connectionWrap) {\n      const pathData = this.getConnectionPathData()\n      containers.connectionWrap.setAttribute('d', pathData)\n    }\n\n    if (containers.sourceMarker && containers.targetMarker) {\n      this.translateAndAutoOrientArrows(\n        containers.sourceMarker,\n        containers.targetMarker,\n      )\n    }\n  }\n\n  getTerminalView(type: Edge.TerminalType) {\n    switch (type) {\n      case 'source':\n        return this.sourceView || null\n      case 'target':\n        return this.targetView || null\n      default:\n        throw new Error(`Unknown terminal type '${type}'`)\n    }\n  }\n\n  getTerminalAnchor(type: Edge.TerminalType) {\n    switch (type) {\n      case 'source':\n        return Point.create(this.sourceAnchor)\n      case 'target':\n        return Point.create(this.targetAnchor)\n      default:\n        throw new Error(`Unknown terminal type '${type}'`)\n    }\n  }\n\n  getTerminalConnectionPoint(type: Edge.TerminalType) {\n    switch (type) {\n      case 'source':\n        return Point.create(this.sourcePoint)\n      case 'target':\n        return Point.create(this.targetPoint)\n      default:\n        throw new Error(`Unknown terminal type '${type}'`)\n    }\n  }\n\n  getTerminalMagnet(type: Edge.TerminalType, options: { raw?: boolean } = {}) {\n    switch (type) {\n      case 'source': {\n        if (options.raw) {\n          return this.sourceMagnet\n        }\n        const sourceView = this.sourceView\n        if (!sourceView) {\n          return null\n        }\n        return this.sourceMagnet || sourceView.container\n      }\n      case 'target': {\n        if (options.raw) {\n          return this.targetMagnet\n        }\n        const targetView = this.targetView\n        if (!targetView) {\n          return null\n        }\n        return this.targetMagnet || targetView.container\n      }\n      default: {\n        throw new Error(`Unknown terminal type '${type}'`)\n      }\n    }\n  }\n\n  updateConnection(options: any = {}) {\n    const edge = this.cell\n\n    // The edge is being translated by an ancestor that will shift\n    // source, target and vertices by an equal distance.\n    if (\n      options.translateBy &&\n      edge.isFragmentDescendantOf(options.translateBy)\n    ) {\n      const tx = options.tx || 0\n      const ty = options.ty || 0\n      this.routePoints = new Polyline(this.routePoints).translate(tx, ty).points\n      this.translateConnectionPoints(tx, ty)\n      this.path.translate(tx, ty)\n    } else {\n      const vertices = edge.getVertices()\n\n      // 1. Find anchor points\n      const anchors = this.findAnchors(vertices)\n      this.sourceAnchor = anchors.source\n      this.targetAnchor = anchors.target\n\n      // 2. Find route points\n      this.routePoints = this.findRoutePoints(vertices)\n\n      // 3. Find connection points\n      const connectionPoints = this.findConnectionPoints(\n        this.routePoints,\n        this.sourceAnchor,\n        this.targetAnchor,\n      )\n      this.sourcePoint = connectionPoints.source\n      this.targetPoint = connectionPoints.target\n\n      // 4. Find Marker Connection Point\n      const markerPoints = this.findMarkerPoints(\n        this.routePoints,\n        this.sourcePoint,\n        this.targetPoint,\n      )\n\n      // 5. Make path\n      this.path = this.findPath(\n        this.routePoints,\n        markerPoints.source || this.sourcePoint,\n        markerPoints.target || this.targetPoint,\n      )\n    }\n\n    this.cleanCache()\n  }\n\n  protected findAnchors(vertices: Point.PointLike[]) {\n    const edge = this.cell\n    const source = edge.source as Edge.TerminalCellData\n    const target = edge.target as Edge.TerminalCellData\n    const firstVertex = vertices[0]\n    const lastVertex = vertices[vertices.length - 1]\n\n    if (target.priority && !source.priority) {\n      // Reversed order\n      return this.findAnchorsOrdered(\n        'target',\n        lastVertex,\n        'source',\n        firstVertex,\n      )\n    }\n\n    // Usual order\n    return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex)\n  }\n\n  protected findAnchorsOrdered(\n    firstType: Edge.TerminalType,\n    firstPoint: Point.PointLike,\n    secondType: Edge.TerminalType,\n    secondPoint: Point.PointLike,\n  ) {\n    let firstAnchor: Point\n    let secondAnchor: Point\n\n    const edge = this.cell\n    const firstTerminal = edge[firstType]\n    const secondTerminal = edge[secondType]\n    const firstView = this.getTerminalView(firstType)\n    const secondView = this.getTerminalView(secondType)\n    const firstMagnet = this.getTerminalMagnet(firstType)\n    const secondMagnet = this.getTerminalMagnet(secondType)\n\n    if (firstView) {\n      let firstRef\n      if (firstPoint) {\n        firstRef = Point.create(firstPoint)\n      } else if (secondView) {\n        firstRef = secondMagnet\n      } else {\n        firstRef = Point.create(secondTerminal as Edge.TerminalPointData)\n      }\n\n      firstAnchor = this.getAnchor(\n        (firstTerminal as Edge.SetCellTerminalArgs).anchor,\n        firstView,\n        firstMagnet,\n        firstRef,\n        firstType,\n      )\n    } else {\n      firstAnchor = Point.create(firstTerminal as Edge.TerminalPointData)\n    }\n\n    if (secondView) {\n      const secondRef = Point.create(secondPoint || firstAnchor)\n      secondAnchor = this.getAnchor(\n        (secondTerminal as Edge.SetCellTerminalArgs).anchor,\n        secondView,\n        secondMagnet,\n        secondRef,\n        secondType,\n      )\n    } else {\n      secondAnchor = Point.isPointLike(secondTerminal)\n        ? Point.create(secondTerminal)\n        : new Point()\n    }\n\n    return {\n      [firstType]: firstAnchor,\n      [secondType]: secondAnchor,\n    }\n  }\n\n  protected getAnchor(\n    def: NodeAnchor.ManaualItem | string | undefined,\n    cellView: CellView,\n    magnet: Element | null,\n    ref: Point | Element | null,\n    terminalType: Edge.TerminalType,\n  ): Point {\n    const isEdge = cellView.isEdgeElement(magnet)\n    const connecting = this.graph.options.connecting\n    let config = typeof def === 'string' ? { name: def } : def\n    if (!config) {\n      const defaults = isEdge\n        ? (terminalType === 'source'\n            ? connecting.sourceEdgeAnchor\n            : connecting.targetEdgeAnchor) || connecting.edgeAnchor\n        : (terminalType === 'source'\n            ? connecting.sourceAnchor\n            : connecting.targetAnchor) || connecting.anchor\n\n      config = typeof defaults === 'string' ? { name: defaults } : defaults\n    }\n\n    if (!config) {\n      throw new Error(`Anchor should be specified.`)\n    }\n\n    let anchor\n\n    const name = config.name\n    if (isEdge) {\n      const fn = EdgeAnchor.registry.get(name)\n      if (typeof fn !== 'function') {\n        return EdgeAnchor.registry.onNotFound(name)\n      }\n      anchor = FunctionExt.call(\n        fn,\n        this,\n        cellView as EdgeView,\n        magnet as SVGElement,\n        ref as Point.PointLike,\n        config.args || {},\n        terminalType,\n      )\n    } else {\n      const fn = NodeAnchor.registry.get(name)\n      if (typeof fn !== 'function') {\n        return NodeAnchor.registry.onNotFound(name)\n      }\n\n      anchor = FunctionExt.call(\n        fn,\n        this,\n        cellView as NodeView,\n        magnet as SVGElement,\n        ref as Point.PointLike,\n        config.args || {},\n        terminalType,\n      )\n    }\n\n    return anchor ? anchor.round(this.POINT_ROUNDING) : new Point()\n  }\n\n  protected findRoutePoints(vertices: Point.PointLike[] = []): Point[] {\n    const defaultRouter =\n      this.graph.options.connecting.router || Router.presets.normal\n    const router = this.cell.getRouter() || defaultRouter\n    let routePoints\n\n    if (typeof router === 'function') {\n      routePoints = FunctionExt.call(\n        router as Router.Definition<any>,\n        this,\n        vertices,\n        {},\n        this,\n      )\n    } else {\n      const name = typeof router === 'string' ? router : router.name\n      const args = typeof router === 'string' ? {} : router.args || {}\n      const fn = name ? Router.registry.get(name) : Router.presets.normal\n      if (typeof fn !== 'function') {\n        return Router.registry.onNotFound(name!)\n      }\n\n      routePoints = FunctionExt.call(fn, this, vertices, args, this)\n    }\n\n    return routePoints == null\n      ? vertices.map((p) => Point.create(p))\n      : routePoints.map((p) => Point.create(p))\n  }\n\n  protected findConnectionPoints(\n    routePoints: Point[],\n    sourceAnchor: Point,\n    targetAnchor: Point,\n  ) {\n    const edge = this.cell\n    const connecting = this.graph.options.connecting\n    const sourceTerminal = edge.getSource()\n    const targetTerminal = edge.getTarget()\n    const sourceView = this.sourceView\n    const targetView = this.targetView\n    const firstRoutePoint = routePoints[0]\n    const lastRoutePoint = routePoints[routePoints.length - 1]\n\n    // source\n    let sourcePoint\n    if (sourceView && !sourceView.isEdgeElement(this.sourceMagnet)) {\n      const sourceMagnet = this.sourceMagnet || sourceView.container\n      const sourcePointRef = firstRoutePoint || targetAnchor\n      const sourceLine = new Line(sourcePointRef, sourceAnchor)\n      const connectionPointDef =\n        sourceTerminal.connectionPoint ||\n        connecting.sourceConnectionPoint ||\n        connecting.connectionPoint\n      sourcePoint = this.getConnectionPoint(\n        connectionPointDef,\n        sourceView,\n        sourceMagnet,\n        sourceLine,\n        'source',\n      )\n    } else {\n      sourcePoint = sourceAnchor\n    }\n\n    // target\n    let targetPoint\n    if (targetView && !targetView.isEdgeElement(this.targetMagnet)) {\n      const targetMagnet = this.targetMagnet || targetView.container\n      const targetConnectionPointDef =\n        targetTerminal.connectionPoint ||\n        connecting.targetConnectionPoint ||\n        connecting.connectionPoint\n      const targetPointRef = lastRoutePoint || sourceAnchor\n      const targetLine = new Line(targetPointRef, targetAnchor)\n      targetPoint = this.getConnectionPoint(\n        targetConnectionPointDef,\n        targetView,\n        targetMagnet,\n        targetLine,\n        'target',\n      )\n    } else {\n      targetPoint = targetAnchor\n    }\n\n    return {\n      source: sourcePoint,\n      target: targetPoint,\n    }\n  }\n\n  protected getConnectionPoint(\n    def: string | ConnectionPoint.ManaualItem | undefined,\n    view: CellView,\n    magnet: Element,\n    line: Line,\n    endType: Edge.TerminalType,\n  ) {\n    const anchor = line.end\n    if (def == null) {\n      return anchor\n    }\n\n    const name = typeof def === 'string' ? def : def.name\n    const args = typeof def === 'string' ? {} : def.args\n    const fn = ConnectionPoint.registry.get(name)\n    if (typeof fn !== 'function') {\n      return ConnectionPoint.registry.onNotFound(name)\n    }\n\n    const connectionPoint = FunctionExt.call(\n      fn,\n      this,\n      line,\n      view,\n      magnet as SVGElement,\n      args || {},\n      endType,\n    )\n\n    return connectionPoint ? connectionPoint.round(this.POINT_ROUNDING) : anchor\n  }\n\n  protected updateMarkerAttr(type: Edge.TerminalType) {\n    const attrs = this.cell.getAttrs()\n    const key = `.${type}-marker`\n    const partial = attrs && attrs[key]\n    if (partial) {\n      this.updateAttrs(\n        this.container,\n        {},\n        {\n          attrs: { [key]: partial },\n          selectors: this.selectors,\n        },\n      )\n    }\n  }\n\n  protected findMarkerPoints(\n    routePoints: Point[],\n    sourcePoint: Point,\n    targetPoint: Point,\n  ) {\n    const getLineWidth = (type: Edge.TerminalType) => {\n      const attrs = this.cell.getAttrs()\n      const keys = Object.keys(attrs)\n      for (let i = 0, l = keys.length; i < l; i += 1) {\n        const attr = attrs[keys[i]]\n        if (attr[`${type}Marker`] || attr[`${type}-marker`]) {\n          const strokeWidth =\n            (attr.strokeWidth as string) || (attr['stroke-width'] as string)\n          if (strokeWidth) {\n            return parseFloat(strokeWidth)\n          }\n          break\n        }\n      }\n      return null\n    }\n\n    const firstRoutePoint = routePoints[0]\n    const lastRoutePoint = routePoints[routePoints.length - 1]\n    const sourceMarkerElem = this.containers.sourceMarker as SVGElement\n    const targetMarkerElem = this.containers.targetMarker as SVGElement\n    const cache = this.markerCache\n    let sourceMarkerPoint\n    let targetMarkerPoint\n\n    // Move the source point by the width of the marker taking into\n    // account its scale around x-axis. Note that scale is the only\n    // transform that makes sense to be set in `.marker-source`\n    // attributes object as all other transforms (translate/rotate)\n    // will be replaced by the `translateAndAutoOrient()` function.\n    if (sourceMarkerElem) {\n      this.updateMarkerAttr('source')\n      // support marker connection point registry???\n      cache.sourceBBox = cache.sourceBBox || Dom.getBBox(sourceMarkerElem)\n      if (cache.sourceBBox.width > 0) {\n        const scale = Dom.scale(sourceMarkerElem)\n        sourceMarkerPoint = sourcePoint\n          .clone()\n          .move(\n            firstRoutePoint || targetPoint,\n            cache.sourceBBox.width * scale.sx * -1,\n          )\n      }\n    } else {\n      const strokeWidth = getLineWidth('source')\n      if (strokeWidth) {\n        sourceMarkerPoint = sourcePoint\n          .clone()\n          .move(firstRoutePoint || targetPoint, -strokeWidth)\n      }\n    }\n\n    if (targetMarkerElem) {\n      this.updateMarkerAttr('target')\n      cache.targetBBox = cache.targetBBox || Dom.getBBox(targetMarkerElem)\n      if (cache.targetBBox.width > 0) {\n        const scale = Dom.scale(targetMarkerElem)\n        targetMarkerPoint = targetPoint\n          .clone()\n          .move(\n            lastRoutePoint || sourcePoint,\n            cache.targetBBox.width * scale.sx * -1,\n          )\n      }\n    } else {\n      const strokeWidth = getLineWidth('target')\n      if (strokeWidth) {\n        targetMarkerPoint = targetPoint\n          .clone()\n          .move(lastRoutePoint || sourcePoint, -strokeWidth)\n      }\n    }\n\n    // If there was no markup for the marker, use the connection point.\n    cache.sourcePoint = sourceMarkerPoint || sourcePoint.clone()\n    cache.targetPoint = targetMarkerPoint || targetPoint.clone()\n\n    return {\n      source: sourceMarkerPoint,\n      target: targetMarkerPoint,\n    }\n  }\n\n  protected findPath(\n    routePoints: Point[],\n    sourcePoint: Point,\n    targetPoint: Point,\n  ): Path {\n    const def =\n      this.cell.getConnector() || this.graph.options.connecting.connector\n\n    let name: string | undefined\n    let args: Connector.BaseOptions | undefined\n    let fn: Connector.Definition\n\n    if (typeof def === 'string') {\n      name = def\n    } else {\n      name = def.name\n      args = def.args\n    }\n\n    if (name) {\n      const method = Connector.registry.get(name)\n      if (typeof method !== 'function') {\n        return Connector.registry.onNotFound(name)\n      }\n      fn = method\n    } else {\n      fn = Connector.presets.normal\n    }\n\n    const path = FunctionExt.call(\n      fn,\n      this,\n      sourcePoint,\n      targetPoint,\n      routePoints,\n      { ...args, raw: true },\n      this,\n    )\n\n    return typeof path === 'string' ? Path.parse(path) : path\n  }\n\n  protected translateConnectionPoints(tx: number, ty: number) {\n    const cache = this.markerCache\n    if (cache.sourcePoint) {\n      cache.sourcePoint.translate(tx, ty)\n    }\n    if (cache.targetPoint) {\n      cache.targetPoint.translate(tx, ty)\n    }\n    this.sourcePoint.translate(tx, ty)\n    this.targetPoint.translate(tx, ty)\n    this.sourceAnchor.translate(tx, ty)\n    this.targetAnchor.translate(tx, ty)\n  }\n\n  updateLabelPositions() {\n    if (this.containers.labels == null) {\n      return this\n    }\n\n    const path = this.path\n    if (!path) {\n      return this\n    }\n\n    const edge = this.cell\n    const labels = edge.getLabels()\n    if (labels.length === 0) {\n      return this\n    }\n\n    const defaultLabel = edge.getDefaultLabel()\n    const defaultPosition = this.normalizeLabelPosition(\n      defaultLabel.position as Edge.LabelPosition,\n    )\n\n    for (let i = 0, ii = labels.length; i < ii; i += 1) {\n      const label = labels[i]\n      const labelNode = this.labelCache[i]\n\n      if (!labelNode) {\n        continue\n      }\n\n      const labelPosition = this.normalizeLabelPosition(\n        label.position as Edge.LabelPosition,\n      )\n      const pos = ObjectExt.merge({}, defaultPosition, labelPosition)\n      const matrix = this.getLabelTransformationMatrix(pos)\n      labelNode.setAttribute('transform', Dom.matrixToTransformString(matrix))\n    }\n\n    return this\n  }\n\n  updateToolsPosition() {\n    if (this.containers.tools == null) {\n      return this\n    }\n\n    // Move the tools a bit to the target position but don't cover the\n    // `sourceArrowhead` marker. Note that the offset is hardcoded here.\n    // The offset should be always more than the\n    // `this.$('.marker-arrowhead[end=\"source\"]')[0].bbox().width` but looking\n    // this up all the time would be slow.\n\n    let scale = ''\n    let offset = this.options.toolsOffset\n    const connectionLength = this.getConnectionLength()\n\n    // Firefox returns `connectionLength=NaN` in odd cases (for bezier curves).\n    // In that case we won't update tools position at all.\n    if (connectionLength != null) {\n      // If the edge is too short, make the tools half the\n      // size and the offset twice as low.\n      if (connectionLength < this.options.shortLength) {\n        scale = 'scale(.5)'\n        offset /= 2\n      }\n\n      let pos = this.getPointAtLength(offset)\n      if (pos != null) {\n        Dom.attr(\n          this.toolCache,\n          'transform',\n          `translate(${pos.x},${pos.y}) ${scale}`,\n        )\n      }\n\n      if (\n        this.options.doubleTools &&\n        connectionLength >= this.options.longLength\n      ) {\n        const doubleToolsOffset = this.options.doubleToolsOffset || offset\n\n        pos = this.getPointAtLength(connectionLength - doubleToolsOffset)\n        if (pos != null) {\n          Dom.attr(\n            this.tool2Cache,\n            'transform',\n            `translate(${pos.x},${pos.y}) ${scale}`,\n          )\n        }\n        Dom.attr(this.tool2Cache, 'visibility', 'visible')\n      } else if (this.options.doubleTools) {\n        Dom.attr(this.tool2Cache, 'visibility', 'hidden')\n      }\n    }\n\n    return this\n  }\n\n  updateArrowheadMarkers() {\n    const container = this.containers.arrowheads\n    if (container == null) {\n      return this\n    }\n\n    if ((container as HTMLElement).style.display === 'none') {\n      return this\n    }\n\n    const sourceArrowhead = this.containers.sourceArrowhead\n    const targetArrowhead = this.containers.targetArrowhead\n    if (sourceArrowhead && targetArrowhead) {\n      const len = this.getConnectionLength() || 0\n      const sx = len < this.options.shortLength ? 0.5 : 1\n      Dom.scale(sourceArrowhead as SVGElement, sx)\n      Dom.scale(targetArrowhead as SVGElement, sx)\n      this.translateAndAutoOrientArrows(sourceArrowhead, targetArrowhead)\n    }\n\n    return this\n  }\n\n  updateTerminalProperties(type: Edge.TerminalType) {\n    const edge = this.cell\n    const graph = this.graph\n    const terminal = edge[type]\n    const nodeId = terminal && (terminal as Edge.TerminalCellData).cell\n    const viewKey = `${type}View` as 'sourceView' | 'targetView'\n\n    // terminal is a point\n    if (!nodeId) {\n      this[viewKey] = null\n      this.updateTerminalMagnet(type)\n      return true\n    }\n\n    const terminalCell = graph.getCellById(nodeId)\n    if (!terminalCell) {\n      throw new Error(`Edge's ${type} node with id \"${nodeId}\" not exists`)\n    }\n\n    const endView = terminalCell.findView(graph)\n    if (!endView) {\n      return false\n    }\n\n    this[viewKey] = endView\n    this.updateTerminalMagnet(type)\n    return true\n  }\n\n  updateTerminalMagnet(type: Edge.TerminalType) {\n    const propName = `${type}Magnet` as 'sourceMagnet' | 'targetMagnet'\n    const terminalView = this.getTerminalView(type)\n    if (terminalView) {\n      let magnet = terminalView.getMagnetFromEdgeTerminal(this.cell[type])\n      if (magnet === terminalView.container) {\n        magnet = null\n      }\n\n      this[propName] = magnet\n    } else {\n      this[propName] = null\n    }\n  }\n\n  protected translateAndAutoOrientArrows(\n    sourceArrow?: Element,\n    targetArrow?: Element,\n  ) {\n    const route = this.routePoints\n    if (sourceArrow) {\n      Dom.translateAndAutoOrient(\n        sourceArrow as SVGElement,\n        this.sourcePoint,\n        route[0] || this.targetPoint,\n        this.graph.view.stage,\n      )\n    }\n\n    if (targetArrow) {\n      Dom.translateAndAutoOrient(\n        targetArrow as SVGElement,\n        this.targetPoint,\n        route[route.length - 1] || this.sourcePoint,\n        this.graph.view.stage,\n      )\n    }\n  }\n\n  protected getLabelPositionAngle(idx: number) {\n    const label = this.cell.getLabelAt(idx)\n    if (label && label.position && typeof label.position === 'object') {\n      return label.position.angle || 0\n    }\n    return 0\n  }\n\n  protected getLabelPositionArgs(idx: number) {\n    const label = this.cell.getLabelAt(idx)\n    if (label && label.position && typeof label.position === 'object') {\n      return label.position.options\n    }\n  }\n\n  protected getDefaultLabelPositionArgs() {\n    const defaultLabel = this.cell.getDefaultLabel()\n    if (\n      defaultLabel &&\n      defaultLabel.position &&\n      typeof defaultLabel.position === 'object'\n    ) {\n      return defaultLabel.position.options\n    }\n  }\n\n  // merge default label position args into label position args\n  // keep `undefined` or `null` because `{}` means something else\n  protected mergeLabelPositionArgs(\n    labelPositionArgs?: Edge.LabelPositionOptions,\n    defaultLabelPositionArgs?: Edge.LabelPositionOptions,\n  ) {\n    if (labelPositionArgs === null) {\n      return null\n    }\n    if (labelPositionArgs === undefined) {\n      if (defaultLabelPositionArgs === null) {\n        return null\n      }\n      return defaultLabelPositionArgs\n    }\n\n    return ObjectExt.merge({}, defaultLabelPositionArgs, labelPositionArgs)\n  }\n\n  // Add default label at given position at end of `labels` array.\n  addLabel(\n    x: number,\n    y: number,\n    options?: Edge.LabelPositionOptions & Edge.SetOptions,\n  ): number\n  addLabel(\n    x: number,\n    y: number,\n    angle: number,\n    options?: Edge.LabelPositionOptions & Edge.SetOptions,\n  ): number\n  addLabel(\n    p: Point | Point.PointLike,\n    options?: Edge.LabelPositionOptions & Edge.SetOptions,\n  ): number\n  addLabel(\n    p: Point | Point.PointLike,\n    angle: number,\n    options?: Edge.LabelPositionOptions & Edge.SetOptions,\n  ): number\n  addLabel(\n    p1: number | Point | Point.PointLike,\n    p2?: number | (Edge.LabelPositionOptions & Edge.SetOptions),\n    p3?: number | (Edge.LabelPositionOptions & Edge.SetOptions),\n    options?: Edge.LabelPositionOptions & Edge.SetOptions,\n  ) {\n    let localX: number\n    let localY: number\n    let localAngle = 0\n    let localOptions\n\n    if (typeof p1 !== 'number') {\n      localX = p1.x\n      localY = p1.y\n      if (typeof p2 === 'number') {\n        localAngle = p2\n        localOptions = p3\n      } else {\n        localOptions = p2\n      }\n    } else {\n      localX = p1\n      localY = p2 as number\n      if (typeof p3 === 'number') {\n        localAngle = p3\n        localOptions = options\n      } else {\n        localOptions = p3\n      }\n    }\n\n    // merge label position arguments\n    const defaultLabelPositionArgs = this.getDefaultLabelPositionArgs()\n    const labelPositionArgs = localOptions as Edge.LabelPositionOptions\n    const positionArgs = this.mergeLabelPositionArgs(\n      labelPositionArgs,\n      defaultLabelPositionArgs,\n    )\n\n    // append label to labels array\n    const label = {\n      position: this.getLabelPosition(localX, localY, localAngle, positionArgs),\n    }\n    const index = -1\n    this.cell.insertLabel(label, index, localOptions as Edge.SetOptions)\n    return index\n  }\n\n  addVertex(p: Point | Point.PointLike, options?: Edge.SetOptions): number\n  addVertex(x: number, y: number, options?: Edge.SetOptions): number\n  addVertex(\n    x: number | Point | Point.PointLike,\n    y?: number | Edge.SetOptions,\n    options?: Edge.SetOptions,\n  ) {\n    const isPoint = typeof x !== 'number'\n    const localX = isPoint ? (x as Point).x : (x as number)\n    const localY = isPoint ? (x as Point).y : (y as number)\n    const localOptions = isPoint ? (y as Edge.SetOptions) : options\n    const vertex = { x: localX, y: localY }\n    const index = this.getVertexIndex(localX, localY)\n    this.cell.insertVertex(vertex, index, localOptions)\n    return index\n  }\n\n  sendToken(\n    token: string | SVGElement,\n    options?:\n      | number\n      | ({\n          duration?: number\n          reversed?: boolean\n          selector?: string\n          // https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/rotate\n          rotate?: boolean | number | 'auto' | 'auto-reverse'\n          // https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/calcMode\n          timing?: 'linear' | 'discrete' | 'paced' | 'spline'\n        } & Dom.AnimateCallbacks &\n          KeyValue<string | number | undefined>),\n    callback?: () => void,\n  ) {\n    let duration\n    let reversed\n    let selector\n    let rorate\n    let timing = 'linear'\n\n    if (typeof options === 'object') {\n      duration = options.duration\n      reversed = options.reversed === true\n      selector = options.selector\n      if (options.rotate === false) {\n        rorate = ''\n      } else if (options.rotate === true) {\n        rorate = 'auto'\n      } else if (options.rotate != null) {\n        rorate = `${options.rotate}`\n      }\n\n      if (options.timing) {\n        timing = options.timing\n      }\n    } else {\n      duration = options\n      reversed = false\n      selector = null\n    }\n\n    duration = duration || 1000\n\n    const attrs: Dom.AnimationOptions = {\n      dur: `${duration}ms`,\n      repeatCount: '1',\n      calcMode: timing,\n      fill: 'freeze',\n    }\n\n    if (rorate) {\n      attrs.rotate = rorate\n    }\n\n    if (reversed) {\n      attrs.keyPoints = '1;0'\n      attrs.keyTimes = '0;1'\n    }\n\n    if (typeof options === 'object') {\n      const { duration, reversed, selector, rotate, timing, ...others } =\n        options\n      Object.keys(others).forEach((key) => {\n        attrs[key] = others[key]\n      })\n    }\n\n    let path\n    if (typeof selector === 'string') {\n      path = this.findOne(selector, this.container, this.selectors)\n    } else {\n      // Select connection path automatically.\n      path = this.containers.connection\n        ? this.containers.connection\n        : this.container.querySelector('path')\n    }\n\n    if (!(path instanceof SVGPathElement)) {\n      throw new Error('Token animation requires a valid connection path.')\n    }\n\n    const target = typeof token === 'string' ? this.findOne(token) : token\n    if (target == null) {\n      throw new Error('Token animation requires a valid token element.')\n    }\n\n    const parent = target.parentNode\n    const revert = () => {\n      if (!parent) {\n        Dom.remove(target)\n      }\n    }\n\n    const vToken = Vector.create(target as SVGElement)\n    if (!parent) {\n      vToken.appendTo(this.graph.view.stage)\n    }\n\n    const onComplete = attrs.complete\n    attrs.complete = (e: Event) => {\n      revert()\n\n      if (callback) {\n        callback()\n      }\n\n      if (onComplete) {\n        onComplete(e)\n      }\n    }\n\n    const stop = vToken.animateAlongPath(attrs, path)\n    return () => {\n      revert()\n      stop()\n    }\n  }\n\n  // #endregion\n\n  getConnection() {\n    return this.path != null ? this.path.clone() : null\n  }\n\n  getConnectionPathData() {\n    if (this.path == null) {\n      return ''\n    }\n\n    const cache = this.cache.pathCache\n    if (!ObjectExt.has(cache, 'data')) {\n      cache.data = this.path.serialize()\n    }\n    return cache.data || ''\n  }\n\n  getConnectionSubdivisions() {\n    if (this.path == null) {\n      return null\n    }\n\n    const cache = this.cache.pathCache\n    if (!ObjectExt.has(cache, 'segmentSubdivisions')) {\n      cache.segmentSubdivisions = this.path.getSegmentSubdivisions()\n    }\n    return cache.segmentSubdivisions\n  }\n\n  getConnectionLength() {\n    if (this.path == null) {\n      return 0\n    }\n\n    const cache = this.cache.pathCache\n    if (!ObjectExt.has(cache, 'length')) {\n      cache.length = this.path.length({\n        segmentSubdivisions: this.getConnectionSubdivisions(),\n      })\n    }\n    return cache.length\n  }\n\n  getPointAtLength(length: number) {\n    if (this.path == null) {\n      return null\n    }\n\n    return this.path.pointAtLength(length, {\n      segmentSubdivisions: this.getConnectionSubdivisions(),\n    })\n  }\n\n  getPointAtRatio(ratio: number) {\n    if (this.path == null) {\n      return null\n    }\n\n    if (NumberExt.isPercentage(ratio)) {\n      // eslint-disable-next-line\n      ratio = parseFloat(ratio) / 100\n    }\n\n    return this.path.pointAt(ratio, {\n      segmentSubdivisions: this.getConnectionSubdivisions(),\n    })\n  }\n\n  getTangentAtLength(length: number) {\n    if (this.path == null) {\n      return null\n    }\n\n    return this.path.tangentAtLength(length, {\n      segmentSubdivisions: this.getConnectionSubdivisions(),\n    })\n  }\n\n  getTangentAtRatio(ratio: number) {\n    if (this.path == null) {\n      return null\n    }\n\n    return this.path.tangentAt(ratio, {\n      segmentSubdivisions: this.getConnectionSubdivisions(),\n    })\n  }\n\n  getClosestPoint(point: Point.PointLike) {\n    if (this.path == null) {\n      return null\n    }\n\n    return this.path.closestPoint(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions(),\n    })\n  }\n\n  getClosestPointLength(point: Point.PointLike) {\n    if (this.path == null) {\n      return null\n    }\n\n    return this.path.closestPointLength(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions(),\n    })\n  }\n\n  getClosestPointRatio(point: Point.PointLike) {\n    if (this.path == null) {\n      return null\n    }\n\n    return this.path.closestPointNormalizedLength(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions(),\n    })\n  }\n\n  // Get label position object based on two provided coordinates, x and y.\n  getLabelPosition(\n    x: number,\n    y: number,\n    options?: Edge.LabelPositionOptions | null,\n  ): Edge.LabelPositionObject\n  getLabelPosition(\n    x: number,\n    y: number,\n    angle: number,\n    options?: Edge.LabelPositionOptions | null,\n  ): Edge.LabelPositionObject\n  getLabelPosition(\n    x: number,\n    y: number,\n    p3?: number | Edge.LabelPositionOptions | null,\n    p4?: Edge.LabelPositionOptions | null,\n  ): Edge.LabelPositionObject {\n    const pos: Edge.LabelPositionObject = { distance: 0 }\n\n    // normalize data from the two possible signatures\n    let angle = 0\n    let options\n    if (typeof p3 === 'number') {\n      angle = p3\n      options = p4\n    } else {\n      options = p3\n    }\n\n    if (options != null) {\n      pos.options = options\n    }\n\n    // identify distance/offset settings\n    const isOffsetAbsolute = options && options.absoluteOffset\n    const isDistanceRelative = !(options && options.absoluteDistance)\n    const isDistanceAbsoluteReverse =\n      options && options.absoluteDistance && options.reverseDistance\n\n    // find closest point t\n    const path = this.path\n    const pathOptions = {\n      segmentSubdivisions: this.getConnectionSubdivisions(),\n    }\n\n    const labelPoint = new Point(x, y)\n    const t = path.closestPointT(labelPoint, pathOptions)!\n\n    // distance\n    const totalLength = this.getConnectionLength() || 0\n    let labelDistance = path.lengthAtT(t, pathOptions)\n    if (isDistanceRelative) {\n      labelDistance = totalLength > 0 ? labelDistance / totalLength : 0\n    }\n\n    if (isDistanceAbsoluteReverse) {\n      // fix for end point (-0 => 1)\n      labelDistance = -1 * (totalLength - labelDistance) || 1\n    }\n    pos.distance = labelDistance\n\n    // offset\n    // use absolute offset if:\n    // - options.absoluteOffset is true,\n    // - options.absoluteOffset is not true but there is no tangent\n    let tangent\n    if (!isOffsetAbsolute) tangent = path.tangentAtT(t)\n    let labelOffset\n    if (tangent) {\n      labelOffset = tangent.pointOffset(labelPoint)\n    } else {\n      const closestPoint = path.pointAtT(t)!\n      const labelOffsetDiff = labelPoint.diff(closestPoint)\n      labelOffset = { x: labelOffsetDiff.x, y: labelOffsetDiff.y }\n    }\n\n    pos.offset = labelOffset\n    pos.angle = angle\n\n    return pos\n  }\n\n  protected normalizeLabelPosition(): undefined\n  protected normalizeLabelPosition(\n    pos: Edge.LabelPosition,\n  ): Edge.LabelPositionObject\n  protected normalizeLabelPosition(\n    pos?: Edge.LabelPosition,\n  ): Edge.LabelPositionObject | undefined {\n    if (typeof pos === 'number') {\n      return { distance: pos }\n    }\n\n    return pos\n  }\n\n  protected getLabelTransformationMatrix(labelPosition: Edge.LabelPosition) {\n    const pos = this.normalizeLabelPosition(labelPosition)\n    const options = pos.options || {}\n    const labelAngle = pos.angle || 0\n    const labelDistance = pos.distance\n    const isDistanceRelative = labelDistance > 0 && labelDistance <= 1\n\n    let labelOffset = 0\n    const offsetCoord = { x: 0, y: 0 }\n    const offset = pos.offset\n    if (offset) {\n      if (typeof offset === 'number') {\n        labelOffset = offset\n      } else {\n        if (offset.x != null) {\n          offsetCoord.x = offset.x\n        }\n        if (offset.y != null) {\n          offsetCoord.y = offset.y\n        }\n      }\n    }\n\n    const isOffsetAbsolute =\n      offsetCoord.x !== 0 || offsetCoord.y !== 0 || labelOffset === 0\n\n    const isKeepGradient = options.keepGradient\n    const isEnsureLegibility = options.ensureLegibility\n\n    const path = this.path\n    const pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() }\n\n    const distance = isDistanceRelative\n      ? labelDistance * this.getConnectionLength()!\n      : labelDistance\n    const tangent = path.tangentAtLength(distance, pathOpt)\n\n    let translation\n    let angle = labelAngle\n    if (tangent) {\n      if (isOffsetAbsolute) {\n        translation = tangent.start\n        translation.translate(offsetCoord)\n      } else {\n        const normal = tangent.clone()\n        normal.rotate(-90, tangent.start)\n        normal.setLength(labelOffset)\n        translation = normal.end\n      }\n      if (isKeepGradient) {\n        angle = tangent.angle() + labelAngle\n        if (isEnsureLegibility) {\n          angle = Angle.normalize(((angle + 90) % 180) - 90)\n        }\n      }\n    } else {\n      // fallback - the connection has zero length\n      translation = path.start!\n      if (isOffsetAbsolute) {\n        translation.translate(offsetCoord)\n      }\n    }\n\n    return Dom.createSVGMatrix()\n      .translate(translation.x, translation.y)\n      .rotate(angle)\n  }\n\n  getLabelCoordinates(pos: Edge.LabelPosition) {\n    const matrix = this.getLabelTransformationMatrix(pos)\n    return new Point(matrix.e, matrix.f)\n  }\n\n  getVertexIndex(x: number, y: number) {\n    const edge = this.cell\n    const vertices = edge.getVertices()\n    const vertexLength = this.getClosestPointLength(new Point(x, y))\n\n    let index = 0\n\n    if (vertexLength != null) {\n      for (const ii = vertices.length; index < ii; index += 1) {\n        const currentVertex = vertices[index]\n        const currentLength = this.getClosestPointLength(currentVertex)\n        if (currentLength != null && vertexLength < currentLength) {\n          break\n        }\n      }\n    }\n\n    return index\n  }\n\n  // #region events\n\n  protected getEventArgs<E>(e: E): EdgeView.MouseEventArgs<E>\n  protected getEventArgs<E>(\n    e: E,\n    x: number,\n    y: number,\n  ): EdgeView.PositionEventArgs<E>\n  protected getEventArgs<E>(e: E, x?: number, y?: number) {\n    const view = this // eslint-disable-line\n    const edge = view.cell\n    const cell = edge\n    if (x == null || y == null) {\n      return { e, view, edge, cell } as EdgeView.MouseEventArgs<E>\n    }\n    return { e, x, y, view, edge, cell } as EdgeView.PositionEventArgs<E>\n  }\n\n  protected notifyUnhandledMouseDown(\n    e: JQuery.MouseDownEvent,\n    x: number,\n    y: number,\n  ) {\n    this.notify('edge:unhandled:mousedown', {\n      e,\n      x,\n      y,\n      view: this,\n      cell: this.cell,\n      edge: this.cell,\n    })\n  }\n\n  notifyMouseDown(e: JQuery.MouseDownEvent, x: number, y: number) {\n    super.onMouseDown(e, x, y)\n    this.notify('edge:mousedown', this.getEventArgs(e, x, y))\n  }\n\n  notifyMouseMove(e: JQuery.MouseMoveEvent, x: number, y: number) {\n    super.onMouseMove(e, x, y)\n    this.notify('edge:mousemove', this.getEventArgs(e, x, y))\n  }\n\n  notifyMouseUp(e: JQuery.MouseUpEvent, x: number, y: number) {\n    super.onMouseUp(e, x, y)\n    this.notify('edge:mouseup', this.getEventArgs(e, x, y))\n  }\n\n  onClick(e: JQuery.ClickEvent, x: number, y: number) {\n    super.onClick(e, x, y)\n    this.notify('edge:click', this.getEventArgs(e, x, y))\n  }\n\n  onDblClick(e: JQuery.DoubleClickEvent, x: number, y: number) {\n    super.onDblClick(e, x, y)\n    this.notify('edge:dblclick', this.getEventArgs(e, x, y))\n  }\n\n  onContextMenu(e: JQuery.ContextMenuEvent, x: number, y: number) {\n    super.onContextMenu(e, x, y)\n    this.notify('edge:contextmenu', this.getEventArgs(e, x, y))\n  }\n\n  onMouseDown(e: JQuery.MouseDownEvent, x: number, y: number) {\n    this.notifyMouseDown(e, x, y)\n    const className = e.target.getAttribute('class')\n    switch (className) {\n      case 'vertex': {\n        this.startVertexDragging(e, x, y)\n        return\n      }\n\n      case 'vertex-remove':\n      case 'vertex-remove-area': {\n        this.handleVertexRemoving(e, x, y)\n        return\n      }\n\n      case 'connection':\n      case 'connection-wrap': {\n        this.handleVertexAdding(e, x, y)\n        return\n      }\n\n      case 'arrowhead': {\n        this.startArrowheadDragging(e, x, y)\n        return\n      }\n\n      case 'source-marker':\n      case 'target-marker': {\n        this.notifyUnhandledMouseDown(e, x, y)\n        return\n      }\n\n      default:\n        break\n    }\n\n    this.startEdgeDragging(e, x, y)\n  }\n\n  onMouseMove(e: JQuery.MouseMoveEvent, x: number, y: number) {\n    const data = this.getEventData(e)\n    switch (data.action) {\n      case 'drag-vertex': {\n        this.dragVertex(e, x, y)\n        break\n      }\n\n      case 'drag-label': {\n        this.dragLabel(e, x, y)\n        break\n      }\n\n      case 'drag-arrowhead': {\n        this.dragArrowhead(e, x, y)\n        break\n      }\n\n      case 'drag-edge': {\n        this.dragEdge(e, x, y)\n        break\n      }\n\n      default:\n        break\n    }\n\n    this.notifyMouseMove(e, x, y)\n    return data\n  }\n\n  onMouseUp(e: JQuery.MouseUpEvent, x: number, y: number) {\n    const data = this.getEventData(e)\n    switch (data.action) {\n      case 'drag-vertex': {\n        this.stopVertexDragging(e, x, y)\n        break\n      }\n\n      case 'drag-label': {\n        this.stopLabelDragging(e, x, y)\n        break\n      }\n\n      case 'drag-arrowhead': {\n        this.stopArrowheadDragging(e, x, y)\n        break\n      }\n\n      case 'drag-edge': {\n        this.stopEdgeDragging(e, x, y)\n        break\n      }\n\n      default:\n        break\n    }\n\n    this.notifyMouseUp(e, x, y)\n    this.checkMouseleave(e)\n    return data\n  }\n\n  onMouseOver(e: JQuery.MouseOverEvent) {\n    super.onMouseOver(e)\n    this.notify('edge:mouseover', this.getEventArgs(e))\n  }\n\n  onMouseOut(e: JQuery.MouseOutEvent) {\n    super.onMouseOut(e)\n    this.notify('edge:mouseout', this.getEventArgs(e))\n  }\n\n  onMouseEnter(e: JQuery.MouseEnterEvent) {\n    super.onMouseEnter(e)\n    this.notify('edge:mouseenter', this.getEventArgs(e))\n  }\n\n  onMouseLeave(e: JQuery.MouseLeaveEvent) {\n    super.onMouseLeave(e)\n    this.notify('edge:mouseleave', this.getEventArgs(e))\n  }\n\n  onMouseWheel(e: JQuery.TriggeredEvent, x: number, y: number, delta: number) {\n    super.onMouseWheel(e, x, y, delta)\n    this.notify('edge:mousewheel', {\n      delta,\n      ...this.getEventArgs(e, x, y),\n    })\n  }\n\n  onCustomEvent(e: JQuery.MouseDownEvent, name: string, x: number, y: number) {\n    // For default edge tool\n    const tool = Dom.findParentByClass(e.target, 'edge-tool', this.container)\n    if (tool) {\n      e.stopPropagation() // no further action to be executed\n      if (this.can('useEdgeTools')) {\n        if (name === 'edge:remove') {\n          this.cell.remove({ ui: true })\n          return\n        }\n        this.notify('edge:customevent', { name, ...this.getEventArgs(e, x, y) })\n      }\n\n      this.notifyMouseDown(e as JQuery.MouseDownEvent, x, y)\n    } else {\n      this.notify('edge:customevent', { name, ...this.getEventArgs(e, x, y) })\n      super.onCustomEvent(e, name, x, y)\n    }\n  }\n\n  onLabelMouseDown(e: JQuery.MouseDownEvent, x: number, y: number) {\n    this.notifyMouseDown(e, x, y)\n    this.startLabelDragging(e, x, y)\n\n    const stopPropagation = this.getEventData(e).stopPropagation\n    if (stopPropagation) {\n      e.stopPropagation()\n    }\n  }\n\n  // #region drag edge\n\n  protected startEdgeDragging(e: JQuery.MouseDownEvent, x: number, y: number) {\n    if (!this.can('edgeMovable')) {\n      this.notifyUnhandledMouseDown(e, x, y)\n      return\n    }\n\n    this.setEventData<EventData.EdgeDragging>(e, {\n      x,\n      y,\n      moving: false,\n      action: 'drag-edge',\n    })\n  }\n\n  protected dragEdge(e: JQuery.MouseMoveEvent, x: number, y: number) {\n    const data = this.getEventData<EventData.EdgeDragging>(e)\n    if (!data.moving) {\n      data.moving = true\n      this.addClass('edge-moving')\n      this.notify('edge:move', {\n        e,\n        x,\n        y,\n        view: this,\n        cell: this.cell,\n        edge: this.cell,\n      })\n    }\n\n    this.cell.translate(x - data.x, y - data.y, { ui: true })\n    this.setEventData<Partial<EventData.EdgeDragging>>(e, { x, y })\n    this.notify('edge:moving', {\n      e,\n      x,\n      y,\n      view: this,\n      cell: this.cell,\n      edge: this.cell,\n    })\n  }\n\n  protected stopEdgeDragging(e: JQuery.MouseUpEvent, x: number, y: number) {\n    const data = this.getEventData<EventData.EdgeDragging>(e)\n    if (data.moving) {\n      this.removeClass('edge-moving')\n      this.notify('edge:moved', {\n        e,\n        x,\n        y,\n        view: this,\n        cell: this.cell,\n        edge: this.cell,\n      })\n    }\n    data.moving = false\n  }\n\n  // #endregion\n\n  // #region drag arrowhead\n\n  prepareArrowheadDragging(\n    type: Edge.TerminalType,\n    options: {\n      x: number\n      y: number\n      options?: KeyValue\n      isNewEdge?: boolean\n      fallbackAction?: EventData.ArrowheadDragging['fallbackAction']\n    },\n  ) {\n    const magnet = this.getTerminalMagnet(type)\n    const data: EventData.ArrowheadDragging = {\n      action: 'drag-arrowhead',\n      x: options.x,\n      y: options.y,\n      isNewEdge: options.isNewEdge === true,\n      terminalType: type,\n      initialMagnet: magnet,\n      initialTerminal: ObjectExt.clone(this.cell[type]) as Edge.TerminalData,\n      fallbackAction: options.fallbackAction || 'revert',\n      getValidateConnectionArgs: this.createValidateConnectionArgs(type),\n      options: options.options,\n    }\n\n    this.beforeArrowheadDragging(data)\n\n    return data\n  }\n\n  protected createValidateConnectionArgs(type: Edge.TerminalType) {\n    const args: EventData.ValidateConnectionArgs = [] as any\n\n    args[4] = type\n    args[5] = this\n\n    let opposite: Edge.TerminalType\n    let i = 0\n    let j = 0\n\n    if (type === 'source') {\n      i = 2\n      opposite = 'target'\n    } else {\n      j = 2\n      opposite = 'source'\n    }\n\n    const terminal = this.cell[opposite]\n    const cellId = (terminal as Edge.TerminalCellData).cell\n    if (cellId) {\n      let magnet\n      const view = (args[i] = this.graph.renderer.findViewByCell(cellId))\n      if (view) {\n        magnet = view.getMagnetFromEdgeTerminal(terminal)\n        if (magnet === view.container) {\n          magnet = undefined\n        }\n      }\n      args[i + 1] = magnet\n    }\n\n    return (cellView: CellView, magnet: Element) => {\n      args[j] = cellView\n      args[j + 1] = cellView.container === magnet ? undefined : magnet\n      return args\n    }\n  }\n\n  protected beforeArrowheadDragging(data: EventData.ArrowheadDragging) {\n    data.zIndex = this.cell.zIndex\n    this.cell.toFront()\n\n    const style = (this.container as HTMLElement).style\n    data.pointerEvents = style.pointerEvents\n    style.pointerEvents = 'none'\n\n    if (this.graph.options.connecting.highlight) {\n      this.highlightAvailableMagnets(data)\n    }\n  }\n\n  protected afterArrowheadDragging(data: EventData.ArrowheadDragging) {\n    if (data.zIndex != null) {\n      this.cell.setZIndex(data.zIndex, { ui: true })\n      data.zIndex = null\n    }\n\n    const container = this.container as HTMLElement\n    container.style.pointerEvents = data.pointerEvents || ''\n\n    if (this.graph.options.connecting.highlight) {\n      this.unhighlightAvailableMagnets(data)\n    }\n  }\n\n  protected arrowheadDragging(\n    target: Element,\n    x: number,\n    y: number,\n    data: EventData.ArrowheadDragging,\n  ) {\n    data.x = x\n    data.y = y\n\n    // Checking views right under the pointer\n    if (data.currentTarget !== target) {\n      // Unhighlight the previous view under pointer if there was one.\n      if (data.currentMagnet && data.currentView) {\n        data.currentView.unhighlight(data.currentMagnet, {\n          type: 'magnetAdsorbed',\n        })\n      }\n\n      data.currentView = this.graph.renderer.findViewByElem(target)\n      if (data.currentView) {\n        // If we found a view that is under the pointer, we need to find\n        // the closest magnet based on the real target element of the event.\n        data.currentMagnet = data.currentView.findMagnet(target)\n\n        if (\n          data.currentMagnet &&\n          this.graph.hook.validateConnection(\n            ...data.getValidateConnectionArgs(\n              data.currentView,\n              data.currentMagnet,\n            ),\n            data.currentView.getEdgeTerminal(\n              data.currentMagnet,\n              x,\n              y,\n              this.cell,\n              data.terminalType,\n            ),\n          )\n        ) {\n          data.currentView.highlight(data.currentMagnet, {\n            type: 'magnetAdsorbed',\n          })\n        } else {\n          // This type of connection is not valid. Disregard this magnet.\n          data.currentMagnet = null\n        }\n      } else {\n        // Make sure we'll unset previous magnet.\n        data.currentMagnet = null\n      }\n    }\n\n    data.currentTarget = target\n    this.cell.prop(data.terminalType, { x, y }, { ...data.options, ui: true })\n  }\n\n  protected arrowheadDragged(\n    data: EventData.ArrowheadDragging,\n    x: number,\n    y: number,\n  ) {\n    const view = data.currentView\n    const magnet = data.currentMagnet\n    if (!magnet || !view) {\n      return\n    }\n\n    view.unhighlight(magnet, { type: 'magnetAdsorbed' })\n\n    const type = data.terminalType\n    const terminal = view.getEdgeTerminal(magnet, x, y, this.cell, type)\n    this.cell.setTerminal(type, terminal, { ui: true })\n  }\n\n  protected snapArrowhead(\n    x: number,\n    y: number,\n    data: EventData.ArrowheadDragging,\n  ) {\n    const graph = this.graph\n    const { snap, allowEdge } = graph.options.connecting\n    const radius = (typeof snap === 'object' && snap.radius) || 50\n\n    const findViewsOption = {\n      x: x - radius,\n      y: y - radius,\n      width: 2 * radius,\n      height: 2 * radius,\n    }\n\n    const views = graph.renderer.findViewsInArea(findViewsOption)\n\n    if (allowEdge) {\n      const edgeViews = graph.renderer\n        .findEdgeViewsInArea(findViewsOption)\n        .filter((view) => {\n          return view !== this\n        })\n      views.push(...edgeViews)\n    }\n\n    const prevView = data.closestView || null\n    const prevMagnet = data.closestMagnet || null\n\n    data.closestView = null\n    data.closestMagnet = null\n\n    let distance\n    let minDistance = Number.MAX_SAFE_INTEGER\n    const pos = new Point(x, y)\n\n    views.forEach((view) => {\n      if (view.container.getAttribute('magnet') !== 'false') {\n        // Find distance from the center of the cell to pointer coordinates\n        distance = view.cell.getBBox().getCenter().distance(pos)\n        // the connection is looked up in a circle area by `distance < r`\n        if (distance < radius && distance < minDistance) {\n          if (\n            prevMagnet === view.container ||\n            graph.hook.validateConnection(\n              ...data.getValidateConnectionArgs(view, null),\n              view.getEdgeTerminal(\n                view.container,\n                x,\n                y,\n                this.cell,\n                data.terminalType,\n              ),\n            )\n          ) {\n            minDistance = distance\n            data.closestView = view\n            data.closestMagnet = view.container\n          }\n        }\n      }\n\n      view.container.querySelectorAll('[magnet]').forEach((magnet) => {\n        if (magnet.getAttribute('magnet') !== 'false') {\n          const bbox = view.getBBoxOfElement(magnet)\n          distance = pos.distance(bbox.getCenter())\n          if (distance < radius && distance < minDistance) {\n            if (\n              prevMagnet === magnet ||\n              graph.hook.validateConnection(\n                ...data.getValidateConnectionArgs(view, magnet),\n                view.getEdgeTerminal(\n                  magnet,\n                  x,\n                  y,\n                  this.cell,\n                  data.terminalType,\n                ),\n              )\n            ) {\n              minDistance = distance\n              data.closestView = view\n              data.closestMagnet = magnet\n            }\n          }\n        }\n      })\n    })\n\n    let terminal\n    const type = data.terminalType\n    const closestView = data.closestView as any as CellView\n    const closestMagnet = data.closestMagnet as any as Element\n    const changed = prevMagnet !== closestMagnet\n\n    if (prevView && changed) {\n      prevView.unhighlight(prevMagnet, {\n        type: 'magnetAdsorbed',\n      })\n    }\n\n    if (closestView) {\n      if (!changed) {\n        return\n      }\n      closestView.highlight(closestMagnet, {\n        type: 'magnetAdsorbed',\n      })\n      terminal = closestView.getEdgeTerminal(\n        closestMagnet,\n        x,\n        y,\n        this.cell,\n        type,\n      )\n    } else {\n      terminal = { x, y }\n    }\n\n    this.cell.setTerminal(type, terminal, {}, { ...data.options, ui: true })\n  }\n\n  protected snapArrowheadEnd(data: EventData.ArrowheadDragging) {\n    // Finish off link snapping.\n    // Everything except view unhighlighting was already done on pointermove.\n    const closestView = data.closestView\n    const closestMagnet = data.closestMagnet\n    if (closestView && closestMagnet) {\n      closestView.unhighlight(closestMagnet, {\n        type: 'magnetAdsorbed',\n      })\n      data.currentMagnet = closestView.findMagnet(closestMagnet)\n    }\n\n    data.closestView = null\n    data.closestMagnet = null\n  }\n\n  protected finishEmbedding(data: EventData.ArrowheadDragging) {\n    // Resets parent of the edge if embedding is enabled\n    if (this.graph.options.embedding.enabled && this.cell.updateParent()) {\n      // Make sure we don't reverse to the original 'z' index\n      data.zIndex = null\n    }\n  }\n\n  protected fallbackConnection(data: EventData.ArrowheadDragging) {\n    switch (data.fallbackAction) {\n      case 'remove':\n        this.cell.remove({ ui: true })\n        break\n      case 'revert':\n      default:\n        this.cell.prop(data.terminalType, data.initialTerminal, {\n          ui: true,\n        })\n        break\n    }\n  }\n\n  protected notifyConnectionEvent(\n    data: EventData.ArrowheadDragging,\n    e: JQuery.MouseUpEvent,\n  ) {\n    const terminalType = data.terminalType\n    const initialTerminal = data.initialTerminal\n    const currentTerminal = this.cell[terminalType]\n    const changed =\n      currentTerminal && !Edge.equalTerminals(initialTerminal, currentTerminal)\n\n    if (changed) {\n      const graph = this.graph\n      const previous = initialTerminal as Edge.TerminalCellData\n      const previousCell = previous.cell\n        ? graph.getCellById(previous.cell)\n        : null\n      const previousPort = previous.port\n      const previousView = previousCell\n        ? graph.findViewByCell(previousCell)\n        : null\n      const previousPoint =\n        previousCell || data.isNewEdge\n          ? null\n          : Point.create(initialTerminal as Edge.TerminalPointData).toJSON()\n\n      const current = currentTerminal as Edge.TerminalCellData\n      const currentCell = current.cell ? graph.getCellById(current.cell) : null\n      const currentPort = current.port\n      const currentView = currentCell ? graph.findViewByCell(currentCell) : null\n      const currentPoint = currentCell\n        ? null\n        : Point.create(currentTerminal as Edge.TerminalPointData).toJSON()\n\n      this.notify('edge:connected', {\n        e,\n        previousCell,\n        previousPort,\n        previousView,\n        previousPoint,\n        currentCell,\n        currentView,\n        currentPort,\n        currentPoint,\n        previousMagnet: data.initialMagnet,\n        currentMagnet: data.currentMagnet,\n        edge: this.cell,\n        view: this,\n        type: terminalType,\n        isNew: data.isNewEdge,\n      })\n    }\n  }\n\n  protected highlightAvailableMagnets(data: EventData.ArrowheadDragging) {\n    const graph = this.graph\n    const cells = graph.model.getCells()\n    data.marked = {}\n\n    for (let i = 0, ii = cells.length; i < ii; i += 1) {\n      const view = graph.renderer.findViewByCell(cells[i])\n\n      if (!view) {\n        continue\n      }\n\n      const magnets: Element[] = Array.prototype.slice.call(\n        view.container.querySelectorAll('[magnet]'),\n      )\n\n      if (view.container.getAttribute('magnet') !== 'false') {\n        magnets.push(view.container)\n      }\n\n      const availableMagnets = magnets.filter((magnet) =>\n        graph.hook.validateConnection(\n          ...data.getValidateConnectionArgs(view, magnet),\n          view.getEdgeTerminal(\n            magnet,\n            data.x,\n            data.y,\n            this.cell,\n            data.terminalType,\n          ),\n        ),\n      )\n\n      if (availableMagnets.length > 0) {\n        // highlight all available magnets\n        for (let j = 0, jj = availableMagnets.length; j < jj; j += 1) {\n          view.highlight(availableMagnets[j], { type: 'magnetAvailable' })\n        }\n\n        // highlight the entire view\n        view.highlight(null, { type: 'nodeAvailable' })\n        data.marked[view.cell.id] = availableMagnets\n      }\n    }\n  }\n\n  protected unhighlightAvailableMagnets(data: EventData.ArrowheadDragging) {\n    const marked = data.marked || {}\n    Object.keys(marked).forEach((id) => {\n      const view = this.graph.renderer.findViewByCell(id)\n\n      if (view) {\n        const magnets = marked[id]\n        magnets.forEach((magnet) => {\n          view.unhighlight(magnet, { type: 'magnetAvailable' })\n        })\n\n        view.unhighlight(null, { type: 'nodeAvailable' })\n      }\n    })\n    data.marked = null\n  }\n\n  protected startArrowheadDragging(\n    e: JQuery.MouseDownEvent,\n    x: number,\n    y: number,\n  ) {\n    if (!this.can('arrowheadMovable')) {\n      this.notifyUnhandledMouseDown(e, x, y)\n      return\n    }\n\n    const elem = e.target\n    const type = elem.getAttribute('data-terminal') as Edge.TerminalType\n    const data = this.prepareArrowheadDragging(type, { x, y })\n    this.setEventData<EventData.ArrowheadDragging>(e, data)\n  }\n\n  protected dragArrowhead(e: JQuery.MouseMoveEvent, x: number, y: number) {\n    const data = this.getEventData<EventData.ArrowheadDragging>(e)\n    if (this.graph.options.connecting.snap) {\n      this.snapArrowhead(x, y, data)\n    } else {\n      this.arrowheadDragging(this.getEventTarget(e), x, y, data)\n    }\n  }\n\n  protected stopArrowheadDragging(\n    e: JQuery.MouseUpEvent,\n    x: number,\n    y: number,\n  ) {\n    const graph = this.graph\n    const data = this.getEventData<EventData.ArrowheadDragging>(e)\n    if (graph.options.connecting.snap) {\n      this.snapArrowheadEnd(data)\n    } else {\n      this.arrowheadDragged(data, x, y)\n    }\n\n    const valid = graph.hook.validateEdge(\n      this.cell,\n      data.terminalType,\n      data.initialTerminal,\n    )\n\n    if (valid) {\n      this.finishEmbedding(data)\n      this.notifyConnectionEvent(data, e)\n    } else {\n      // If the changed edge is not allowed, revert to its previous state.\n      this.fallbackConnection(data)\n    }\n    this.afterArrowheadDragging(data)\n  }\n\n  // #endregion\n\n  // #region drag lable\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  startLabelDragging(e: JQuery.MouseDownEvent, x: number, y: number) {\n    if (this.can('edgeLabelMovable')) {\n      const target = e.currentTarget\n      const index = parseInt(target.getAttribute('data-index'), 10)\n      const positionAngle = this.getLabelPositionAngle(index)\n      const labelPositionArgs = this.getLabelPositionArgs(index)\n      const defaultLabelPositionArgs = this.getDefaultLabelPositionArgs()\n      const positionArgs = this.mergeLabelPositionArgs(\n        labelPositionArgs,\n        defaultLabelPositionArgs,\n      )\n\n      this.setEventData<EventData.LabelDragging>(e, {\n        index,\n        positionAngle,\n        positionArgs,\n        stopPropagation: true,\n        action: 'drag-label',\n      })\n    } else {\n      // If labels can't be dragged no default action is triggered.\n      this.setEventData(e, { stopPropagation: true })\n    }\n\n    this.graph.view.delegateDragEvents(e, this)\n  }\n\n  dragLabel(e: JQuery.MouseMoveEvent, x: number, y: number) {\n    const data = this.getEventData<EventData.LabelDragging>(e)\n    const originLabel = this.cell.getLabelAt(data.index)\n    const label = ObjectExt.merge({}, originLabel, {\n      position: this.getLabelPosition(\n        x,\n        y,\n        data.positionAngle,\n        data.positionArgs,\n      ),\n    })\n    this.cell.setLabelAt(data.index, label)\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  stopLabelDragging(e: JQuery.MouseUpEvent, x: number, y: number) {}\n\n  // #endregion\n\n  // #region drag vertex\n\n  handleVertexAdding(e: JQuery.MouseDownEvent, x: number, y: number) {\n    if (!this.can('vertexAddable')) {\n      this.notifyUnhandledMouseDown(e, x, y)\n      return\n    }\n\n    // Store the index at which the new vertex has just been placed.\n    // We'll be update the very same vertex position in `pointermove()`.\n    const index = this.addVertex({ x, y }, { ui: true })\n    this.setEventData(e, {\n      index,\n      action: 'drag-vertex',\n    })\n  }\n\n  handleVertexRemoving(e: JQuery.MouseDownEvent, x: number, y: number) {\n    if (!this.can('vertexDeletable')) {\n      this.notifyUnhandledMouseDown(e, x, y)\n      return\n    }\n\n    const target = e.target\n    const index = parseInt(target.getAttribute('idx'), 10)\n    this.cell.removeVertexAt(index)\n  }\n\n  startVertexDragging(e: JQuery.MouseDownEvent, x: number, y: number) {\n    if (!this.can('vertexMovable')) {\n      this.notifyUnhandledMouseDown(e, x, y)\n      return\n    }\n\n    const target = e.target\n    const index = parseInt(target.getAttribute('idx'), 10)\n    this.setEventData<EventData.VertexDragging>(e, {\n      index,\n      action: 'drag-vertex',\n    })\n  }\n\n  dragVertex(e: JQuery.MouseMoveEvent, x: number, y: number) {\n    const data = this.getEventData<EventData.VertexDragging>(e)\n    this.cell.setVertexAt(data.index, { x, y }, { ui: true })\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  stopVertexDragging(e: JQuery.MouseUpEvent, x: number, y: number) {}\n\n  // #endregion\n\n  // #endregion\n}\n\nexport namespace EdgeView {\n  export interface Options extends CellView.Options {\n    perpendicular: boolean\n    doubleTools: boolean\n    shortLength: number\n    longLength: number\n    toolsOffset: number\n    doubleToolsOffset: number\n    sampleInterval: number\n  }\n\n  export interface ContainerCache {\n    connection?: Element\n    connectionWrap?: Element\n    sourceMarker?: Element\n    targetMarker?: Element\n    labels?: Element\n    vertices?: Element\n    arrowheads?: Element\n    sourceArrowhead?: Element\n    targetArrowhead?: Element\n    tools?: Element\n  }\n}\n\nexport namespace EdgeView {\n  export interface MouseEventArgs<E> {\n    e: E\n    edge: Edge\n    cell: Edge\n    view: EdgeView\n  }\n\n  export interface PositionEventArgs<E>\n    extends MouseEventArgs<E>,\n      CellView.PositionEventArgs {}\n\n  export interface EventArgs {\n    'edge:click': PositionEventArgs<JQuery.ClickEvent>\n    'edge:dblclick': PositionEventArgs<JQuery.DoubleClickEvent>\n    'edge:contextmenu': PositionEventArgs<JQuery.ContextMenuEvent>\n    'edge:mousedown': PositionEventArgs<JQuery.MouseDownEvent>\n    'edge:mousemove': PositionEventArgs<JQuery.MouseMoveEvent>\n    'edge:mouseup': PositionEventArgs<JQuery.MouseUpEvent>\n    'edge:mouseover': MouseEventArgs<JQuery.MouseOverEvent>\n    'edge:mouseout': MouseEventArgs<JQuery.MouseOutEvent>\n    'edge:mouseenter': MouseEventArgs<JQuery.MouseEnterEvent>\n    'edge:mouseleave': MouseEventArgs<JQuery.MouseLeaveEvent>\n    'edge:mousewheel': PositionEventArgs<JQuery.TriggeredEvent> &\n      CellView.MouseDeltaEventArgs\n\n    'edge:customevent': EdgeView.PositionEventArgs<JQuery.MouseDownEvent> & {\n      name: string\n    }\n\n    'edge:unhandled:mousedown': PositionEventArgs<JQuery.MouseDownEvent>\n\n    'edge:connected': {\n      e: JQuery.MouseUpEvent\n      edge: Edge\n      view: EdgeView\n      isNew: boolean\n      type: Edge.TerminalType\n      previousCell?: Cell | null\n      previousView?: CellView | null\n      previousPort?: string | null\n      previousPoint?: Point.PointLike | null\n      previousMagnet?: Element | null\n      currentCell?: Cell | null\n      currentView?: CellView | null\n      currentPort?: string | null\n      currentPoint?: Point.PointLike | null\n      currentMagnet?: Element | null\n    }\n\n    'edge:highlight': {\n      magnet: Element\n      view: EdgeView\n      edge: Edge\n      cell: Edge\n      options: CellView.HighlightOptions\n    }\n    'edge:unhighlight': EventArgs['edge:highlight']\n\n    'edge:move': PositionEventArgs<JQuery.MouseMoveEvent>\n    'edge:moving': PositionEventArgs<JQuery.MouseMoveEvent>\n    'edge:moved': PositionEventArgs<JQuery.MouseUpEvent>\n  }\n}\n\nexport namespace EdgeView {\n  export const toStringTag = `X6.${EdgeView.name}`\n\n  export function isEdgeView(instance: any): instance is EdgeView {\n    if (instance == null) {\n      return false\n    }\n\n    if (instance instanceof EdgeView) {\n      return true\n    }\n\n    const tag = instance[Symbol.toStringTag]\n    const view = instance as EdgeView\n\n    if (\n      (tag == null || tag === toStringTag) &&\n      typeof view.isNodeView === 'function' &&\n      typeof view.isEdgeView === 'function' &&\n      typeof view.confirmUpdate === 'function' &&\n      typeof view.update === 'function' &&\n      typeof view.getConnection === 'function'\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n\nnamespace EventData {\n  export interface MousemoveEventData {}\n\n  export interface EdgeDragging {\n    action: 'drag-edge'\n    moving: boolean\n    x: number\n    y: number\n  }\n\n  export type ValidateConnectionArgs = [\n    CellView | null | undefined, // source view\n    Element | null | undefined, // source magnet\n    CellView | null | undefined, // target view\n    Element | null | undefined, // target magnet\n    Edge.TerminalType,\n    EdgeView,\n  ]\n\n  export interface ArrowheadDragging {\n    action: 'drag-arrowhead'\n    x: number\n    y: number\n    isNewEdge: boolean\n    terminalType: Edge.TerminalType\n    fallbackAction: 'remove' | 'revert'\n    initialMagnet: Element | null\n    initialTerminal: Edge.TerminalData\n    getValidateConnectionArgs: (\n      cellView: CellView,\n      magnet: Element | null,\n    ) => ValidateConnectionArgs\n    zIndex?: number | null\n    pointerEvents?: string | null\n    /**\n     * Current event target.\n     */\n    currentTarget?: Element\n    /**\n     * Current view under pointer.\n     */\n    currentView?: CellView | null\n    /**\n     * Current magnet under pointer.\n     */\n    currentMagnet?: Element | null\n    closestView?: CellView | null\n    closestMagnet?: Element | null\n    marked?: KeyValue<Element[]> | null\n    options?: KeyValue\n  }\n\n  export interface LabelDragging {\n    action: 'drag-label'\n    index: number\n    positionAngle: number\n    positionArgs?: Edge.LabelPositionOptions | null\n    stopPropagation: true\n  }\n\n  export interface VertexDragging {\n    action: 'drag-vertex'\n    index: number\n  }\n}\n\nEdgeView.config<EdgeView.Options>({\n  isSvgElement: true,\n  priority: 1,\n  bootstrap: ['render', 'source', 'target'],\n  actions: {\n    view: ['render'],\n    markup: ['render'],\n    attrs: ['update'],\n    source: ['source', 'update'],\n    target: ['target', 'update'],\n    router: ['update'],\n    connector: ['update'],\n    labels: ['labels'],\n    defaultLabel: ['labels'],\n    vertices: ['vertices', 'update'],\n    vertexMarkup: ['vertices'],\n    toolMarkup: ['tools'],\n    tools: ['widget'],\n  },\n  shortLength: 105,\n  longLength: 155,\n  toolsOffset: 40,\n  doubleTools: false,\n  doubleToolsOffset: 65,\n  sampleInterval: 50,\n})\n\nEdgeView.registry.register('edge', EdgeView, true)\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}