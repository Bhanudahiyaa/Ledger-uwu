{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n// @mapbox/grid-index 并没有类似 hitTest 的单纯获取碰撞检测结果的方法，query 将导致计算大量多余的包围盒结果，因此使用改良版\nimport { mat4, vec4 } from 'gl-matrix';\nimport GridIndex from \"./grid-index\";\n/**\n * 基于网格实现文本避让，大幅提升包围盒碰撞检测效率\n * @see https://zhuanlan.zhihu.com/p/74373214\n */\nexport default class CollisionIndex {\n  constructor(width, height) {\n    _defineProperty(this, \"width\", void 0);\n    _defineProperty(this, \"height\", void 0);\n    _defineProperty(this, \"grid\", void 0);\n    _defineProperty(this, \"viewportPadding\", 100);\n    _defineProperty(this, \"screenRightBoundary\", void 0);\n    _defineProperty(this, \"screenBottomBoundary\", void 0);\n    _defineProperty(this, \"gridRightBoundary\", void 0);\n    _defineProperty(this, \"gridBottomBoundary\", void 0);\n    this.width = width;\n    this.height = height;\n    this.viewportPadding = Math.max(width, height);\n    // 创建网格索引\n    this.grid = new GridIndex(width + this.viewportPadding, height + this.viewportPadding, 25);\n    this.screenRightBoundary = width + this.viewportPadding;\n    this.screenBottomBoundary = height + this.viewportPadding;\n    this.gridRightBoundary = width + 2 * this.viewportPadding;\n    this.gridBottomBoundary = height + 2 * this.viewportPadding;\n  }\n  placeCollisionBox(collisionBox) {\n    // const projectedPoint = this.project(\n    //   mvpMatrix,\n    //   collisionBox.anchorPointX,\n    //   collisionBox.anchorPointY,\n    // );\n\n    const tlX = collisionBox.x1 + collisionBox.anchorPointX + this.viewportPadding;\n    const tlY = collisionBox.y1 + collisionBox.anchorPointY + this.viewportPadding;\n    const brX = collisionBox.x2 + collisionBox.anchorPointX + this.viewportPadding;\n    const brY = collisionBox.y2 + collisionBox.anchorPointY + this.viewportPadding;\n    if (!this.isInsideGrid(tlX, tlY, brX, brY) || this.grid.hitTest(tlX, tlY, brX, brY)) {\n      return {\n        box: []\n      };\n    }\n    return {\n      box: [tlX, tlY, brX, brY]\n    };\n  }\n  insertCollisionBox(box, featureIndex) {\n    const key = {\n      featureIndex\n    };\n    this.grid.insert(key, box[0], box[1], box[2], box[3]);\n  }\n\n  /**\n   * 后续碰撞检测都需要投影到 viewport 坐标系\n   * @param {THREE.Matrix4} mvpMatrix mvp矩阵\n   * @param {number} x P20 平面坐标X\n   * @param {number} y P20 平面坐标Y\n   * @return {Point} projectedPoint\n   */\n  project(mvpMatrix, x, y) {\n    const point = vec4.fromValues(x, y, 0, 1);\n    const out = vec4.create();\n    // @ts-ignore\n    const mat = mat4.fromValues(...mvpMatrix);\n    vec4.transformMat4(out, point, mat);\n    // GL 坐标系[-1, 1] -> viewport 坐标系[width, height]\n    return {\n      x: (out[0] / out[3] + 1) / 2 * this.width + this.viewportPadding,\n      y: (-out[1] / out[3] + 1) / 2 * this.height + this.viewportPadding\n    };\n  }\n\n  /**\n   * 判断包围盒是否在整个网格内，需要加上 buffer\n   * @param {number} x1 x1\n   * @param {number} y1 y1\n   * @param {number} x2 x2\n   * @param {number} y2 y2\n   * @return {Point} isInside\n   */\n  isInsideGrid(x1, y1, x2, y2) {\n    return x2 >= 0 && x1 < this.gridRightBoundary && y2 >= 0 && y1 < this.gridBottomBoundary;\n  }\n}","map":{"version":3,"names":["_defineProperty","mat4","vec4","GridIndex","CollisionIndex","constructor","width","height","viewportPadding","Math","max","grid","screenRightBoundary","screenBottomBoundary","gridRightBoundary","gridBottomBoundary","placeCollisionBox","collisionBox","tlX","x1","anchorPointX","tlY","y1","anchorPointY","brX","x2","brY","y2","isInsideGrid","hitTest","box","insertCollisionBox","featureIndex","key","insert","project","mvpMatrix","x","y","point","fromValues","out","create","mat","transformMat4"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/l7-layers/es/utils/collision-index.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n// @mapbox/grid-index 并没有类似 hitTest 的单纯获取碰撞检测结果的方法，query 将导致计算大量多余的包围盒结果，因此使用改良版\nimport { mat4, vec4 } from 'gl-matrix';\nimport GridIndex from \"./grid-index\";\n/**\n * 基于网格实现文本避让，大幅提升包围盒碰撞检测效率\n * @see https://zhuanlan.zhihu.com/p/74373214\n */\nexport default class CollisionIndex {\n  constructor(width, height) {\n    _defineProperty(this, \"width\", void 0);\n    _defineProperty(this, \"height\", void 0);\n    _defineProperty(this, \"grid\", void 0);\n    _defineProperty(this, \"viewportPadding\", 100);\n    _defineProperty(this, \"screenRightBoundary\", void 0);\n    _defineProperty(this, \"screenBottomBoundary\", void 0);\n    _defineProperty(this, \"gridRightBoundary\", void 0);\n    _defineProperty(this, \"gridBottomBoundary\", void 0);\n    this.width = width;\n    this.height = height;\n    this.viewportPadding = Math.max(width, height);\n    // 创建网格索引\n    this.grid = new GridIndex(width + this.viewportPadding, height + this.viewportPadding, 25);\n    this.screenRightBoundary = width + this.viewportPadding;\n    this.screenBottomBoundary = height + this.viewportPadding;\n    this.gridRightBoundary = width + 2 * this.viewportPadding;\n    this.gridBottomBoundary = height + 2 * this.viewportPadding;\n  }\n  placeCollisionBox(collisionBox) {\n    // const projectedPoint = this.project(\n    //   mvpMatrix,\n    //   collisionBox.anchorPointX,\n    //   collisionBox.anchorPointY,\n    // );\n\n    const tlX = collisionBox.x1 + collisionBox.anchorPointX + this.viewportPadding;\n    const tlY = collisionBox.y1 + collisionBox.anchorPointY + this.viewportPadding;\n    const brX = collisionBox.x2 + collisionBox.anchorPointX + this.viewportPadding;\n    const brY = collisionBox.y2 + collisionBox.anchorPointY + this.viewportPadding;\n    if (!this.isInsideGrid(tlX, tlY, brX, brY) || this.grid.hitTest(tlX, tlY, brX, brY)) {\n      return {\n        box: []\n      };\n    }\n    return {\n      box: [tlX, tlY, brX, brY]\n    };\n  }\n  insertCollisionBox(box, featureIndex) {\n    const key = {\n      featureIndex\n    };\n    this.grid.insert(key, box[0], box[1], box[2], box[3]);\n  }\n\n  /**\n   * 后续碰撞检测都需要投影到 viewport 坐标系\n   * @param {THREE.Matrix4} mvpMatrix mvp矩阵\n   * @param {number} x P20 平面坐标X\n   * @param {number} y P20 平面坐标Y\n   * @return {Point} projectedPoint\n   */\n  project(mvpMatrix, x, y) {\n    const point = vec4.fromValues(x, y, 0, 1);\n    const out = vec4.create();\n    // @ts-ignore\n    const mat = mat4.fromValues(...mvpMatrix);\n    vec4.transformMat4(out, point, mat);\n    // GL 坐标系[-1, 1] -> viewport 坐标系[width, height]\n    return {\n      x: (out[0] / out[3] + 1) / 2 * this.width + this.viewportPadding,\n      y: (-out[1] / out[3] + 1) / 2 * this.height + this.viewportPadding\n    };\n  }\n\n  /**\n   * 判断包围盒是否在整个网格内，需要加上 buffer\n   * @param {number} x1 x1\n   * @param {number} y1 y1\n   * @param {number} x2 x2\n   * @param {number} y2 y2\n   * @return {Point} isInside\n   */\n  isInsideGrid(x1, y1, x2, y2) {\n    return x2 >= 0 && x1 < this.gridRightBoundary && y2 >= 0 && y1 < this.gridBottomBoundary;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}