{"ast":null,"code":"const DEGREES_TO_RADIANS = Math.PI / 180;\nconst TILE_SIZE = 512;\n// Average circumference (40075 km equatorial, 40007 km meridional)\nconst EARTH_CIRCUMFERENCE = 40.03e6;\n/**\n * Calculate distance scales in meters around current lat/lon, both for\n * degrees and pixels.\n * In mercator projection mode, the distance scales vary significantly\n * with latitude.\n */\nexport function getDistanceScales({\n  latitude = 0,\n  zoom = 0,\n  scale,\n  highPrecision = false,\n  flipY = false\n}) {\n  // Calculate scale from zoom if not provided\n  scale = scale !== undefined ? scale : Math.pow(2, zoom);\n\n  // @ts-ignore\n  const result = {};\n  const worldSize = TILE_SIZE * scale;\n  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n\n  /**\n   * Number of pixels occupied by one degree longitude around current lat/lon:\n   *  pixelsPerDegreeX = d(lngLatToWorld([lng, lat])[0])/d(lng)\n   *     = scale * TILE_SIZE * DEGREES_TO_RADIANS / (2 * PI)\n   *   pixelsPerDegreeY = d(lngLatToWorld([lng, lat])[1])/d(lat)\n   *     = -scale * TILE_SIZE * DEGREES_TO_RADIANS / cos(lat * DEGREES_TO_RADIANS)  / (2 * PI)\n   */\n  const pixelsPerDegreeX = worldSize / 360;\n  const pixelsPerDegreeY = pixelsPerDegreeX / latCosine;\n\n  /**\n   * Number of pixels occupied by one meter around current lat/lon:\n   */\n  const altPixelsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;\n\n  /**\n   * LngLat: longitude -> east and latitude -> north (bottom left)\n   * UTM meter offset: x -> east and y -> north (bottom left)\n   * World space: x -> east and y -> south (top left)\n   *\n   * Y needs to be flipped when converting delta degree/meter to delta pixels\n   */\n  result.pixelsPerMeter = [altPixelsPerMeter, -altPixelsPerMeter, altPixelsPerMeter];\n  result.metersPerPixel = [1 / altPixelsPerMeter, -1 / altPixelsPerMeter, 1 / altPixelsPerMeter];\n  result.pixelsPerDegree = [pixelsPerDegreeX, -pixelsPerDegreeY, altPixelsPerMeter];\n  result.degreesPerPixel = [1 / pixelsPerDegreeX, -1 / pixelsPerDegreeY, 1 / altPixelsPerMeter];\n\n  /**\n   * Taylor series 2nd order for 1/latCosine\n   *  f'(a) * (x - a)\n   *     = d(1/cos(lat * DEGREES_TO_RADIANS))/d(lat) * dLat\n   *     = DEGREES_TO_RADIANS * tan(lat * DEGREES_TO_RADIANS) / cos(lat * DEGREES_TO_RADIANS) * dLat\n   */\n  if (highPrecision) {\n    const latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;\n    const pixelsPerDegreeY2 = pixelsPerDegreeX * latCosine2 / 2;\n    const altPixelsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;\n    const altPixelsPerMeter2 = altPixelsPerDegree2 / pixelsPerDegreeY * altPixelsPerMeter;\n    result.pixelsPerDegree2 = [0, -pixelsPerDegreeY2, altPixelsPerDegree2];\n    result.pixelsPerMeter2 = [altPixelsPerMeter2, 0, altPixelsPerMeter2];\n    if (flipY) {\n      result.pixelsPerDegree2[1] = -result.pixelsPerDegree2[1];\n      result.pixelsPerMeter2[1] = -result.pixelsPerMeter2[1];\n    }\n  }\n  if (flipY) {\n    result.pixelsPerMeter[1] = -result.pixelsPerMeter[1];\n    result.metersPerPixel[1] = -result.metersPerPixel[1];\n    result.pixelsPerDegree[1] = -result.pixelsPerDegree[1];\n    result.degreesPerPixel[1] = -result.degreesPerPixel[1];\n  }\n\n  // Main results, used for converting meters to latlng deltas and scaling offsets\n  return result;\n}","map":{"version":3,"names":["DEGREES_TO_RADIANS","Math","PI","TILE_SIZE","EARTH_CIRCUMFERENCE","getDistanceScales","latitude","zoom","scale","highPrecision","flipY","undefined","pow","result","worldSize","latCosine","cos","pixelsPerDegreeX","pixelsPerDegreeY","altPixelsPerMeter","pixelsPerMeter","metersPerPixel","pixelsPerDegree","degreesPerPixel","latCosine2","tan","pixelsPerDegreeY2","altPixelsPerDegree2","altPixelsPerMeter2","pixelsPerDegree2","pixelsPerMeter2"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/l7-core/es/utils/project.js"],"sourcesContent":["const DEGREES_TO_RADIANS = Math.PI / 180;\nconst TILE_SIZE = 512;\n// Average circumference (40075 km equatorial, 40007 km meridional)\nconst EARTH_CIRCUMFERENCE = 40.03e6;\n/**\n * Calculate distance scales in meters around current lat/lon, both for\n * degrees and pixels.\n * In mercator projection mode, the distance scales vary significantly\n * with latitude.\n */\nexport function getDistanceScales({\n  latitude = 0,\n  zoom = 0,\n  scale,\n  highPrecision = false,\n  flipY = false\n}) {\n  // Calculate scale from zoom if not provided\n  scale = scale !== undefined ? scale : Math.pow(2, zoom);\n\n  // @ts-ignore\n  const result = {};\n  const worldSize = TILE_SIZE * scale;\n  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n\n  /**\n   * Number of pixels occupied by one degree longitude around current lat/lon:\n   *  pixelsPerDegreeX = d(lngLatToWorld([lng, lat])[0])/d(lng)\n   *     = scale * TILE_SIZE * DEGREES_TO_RADIANS / (2 * PI)\n   *   pixelsPerDegreeY = d(lngLatToWorld([lng, lat])[1])/d(lat)\n   *     = -scale * TILE_SIZE * DEGREES_TO_RADIANS / cos(lat * DEGREES_TO_RADIANS)  / (2 * PI)\n   */\n  const pixelsPerDegreeX = worldSize / 360;\n  const pixelsPerDegreeY = pixelsPerDegreeX / latCosine;\n\n  /**\n   * Number of pixels occupied by one meter around current lat/lon:\n   */\n  const altPixelsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;\n\n  /**\n   * LngLat: longitude -> east and latitude -> north (bottom left)\n   * UTM meter offset: x -> east and y -> north (bottom left)\n   * World space: x -> east and y -> south (top left)\n   *\n   * Y needs to be flipped when converting delta degree/meter to delta pixels\n   */\n  result.pixelsPerMeter = [altPixelsPerMeter, -altPixelsPerMeter, altPixelsPerMeter];\n  result.metersPerPixel = [1 / altPixelsPerMeter, -1 / altPixelsPerMeter, 1 / altPixelsPerMeter];\n  result.pixelsPerDegree = [pixelsPerDegreeX, -pixelsPerDegreeY, altPixelsPerMeter];\n  result.degreesPerPixel = [1 / pixelsPerDegreeX, -1 / pixelsPerDegreeY, 1 / altPixelsPerMeter];\n\n  /**\n   * Taylor series 2nd order for 1/latCosine\n   *  f'(a) * (x - a)\n   *     = d(1/cos(lat * DEGREES_TO_RADIANS))/d(lat) * dLat\n   *     = DEGREES_TO_RADIANS * tan(lat * DEGREES_TO_RADIANS) / cos(lat * DEGREES_TO_RADIANS) * dLat\n   */\n  if (highPrecision) {\n    const latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;\n    const pixelsPerDegreeY2 = pixelsPerDegreeX * latCosine2 / 2;\n    const altPixelsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;\n    const altPixelsPerMeter2 = altPixelsPerDegree2 / pixelsPerDegreeY * altPixelsPerMeter;\n    result.pixelsPerDegree2 = [0, -pixelsPerDegreeY2, altPixelsPerDegree2];\n    result.pixelsPerMeter2 = [altPixelsPerMeter2, 0, altPixelsPerMeter2];\n    if (flipY) {\n      result.pixelsPerDegree2[1] = -result.pixelsPerDegree2[1];\n      result.pixelsPerMeter2[1] = -result.pixelsPerMeter2[1];\n    }\n  }\n  if (flipY) {\n    result.pixelsPerMeter[1] = -result.pixelsPerMeter[1];\n    result.metersPerPixel[1] = -result.metersPerPixel[1];\n    result.pixelsPerDegree[1] = -result.pixelsPerDegree[1];\n    result.degreesPerPixel[1] = -result.degreesPerPixel[1];\n  }\n\n  // Main results, used for converting meters to latlng deltas and scaling offsets\n  return result;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}