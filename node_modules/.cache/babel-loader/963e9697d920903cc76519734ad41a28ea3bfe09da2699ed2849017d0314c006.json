{"ast":null,"code":"/**\n * 返回文本相对锚点位置\n * @param {string} anchor 锚点位置\n * @return {alignment} alignment\n */\nfunction getAnchorAlignment(anchor) {\n  let horizontalAlign = 0.5;\n  let verticalAlign = 0.5;\n  switch (anchor) {\n    case 'right':\n    case 'top-right':\n    case 'bottom-right':\n      horizontalAlign = 1;\n      break;\n    case 'left':\n    case 'top-left':\n    case 'bottom-left':\n      horizontalAlign = 0;\n      break;\n    default:\n      horizontalAlign = 0.5;\n  }\n  switch (anchor) {\n    case 'bottom':\n    case 'bottom-right':\n    case 'bottom-left':\n      verticalAlign = 1;\n      break;\n    case 'top':\n    case 'top-right':\n    case 'top-left':\n      verticalAlign = 0;\n      break;\n    default:\n      verticalAlign = 0.5;\n  }\n  return {\n    horizontalAlign,\n    verticalAlign\n  };\n}\n\n// justify right = 1, left = 0, center = 0.5\nfunction justifyLine(positionedGlyphs, glyphMap, start, end, justify) {\n  if (!justify) {\n    return;\n  }\n  const lastPositionedGlyph = positionedGlyphs[end];\n  const glyph = lastPositionedGlyph.glyph;\n  if (glyph) {\n    const lastAdvance = glyphMap[glyph].advance * lastPositionedGlyph.scale;\n    const lineIndent = (positionedGlyphs[end].x + lastAdvance) * justify;\n    for (let j = start; j <= end; j++) {\n      positionedGlyphs[j].x -= lineIndent;\n    }\n  }\n}\n\n// justify right=1 left=0 center=0.5\n// horizontalAlign right=1 left=0 center=0.5\n// verticalAlign right=1 left=0 center=0.5\nfunction align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, lineCount) {\n  const shiftX = (justify - horizontalAlign) * maxLineLength;\n  const shiftY = (-verticalAlign * lineCount + 0.5) * lineHeight;\n  for (const glyphs of positionedGlyphs) {\n    glyphs.x += shiftX;\n    glyphs.y += shiftY;\n  }\n}\nfunction shapeLines(shaping, glyphMap, lines, lineHeight, textAnchor, textJustify, spacing) {\n  // buffer 为 4\n  const yOffset = -8;\n  let x = 0;\n  let y = yOffset;\n  let maxLineLength = 0;\n  const positionedGlyphs = shaping.positionedGlyphs;\n  const justify = textJustify === 'right' ? 1 : textJustify === 'left' ? 0 : 0.5;\n  const lineStartIndex = positionedGlyphs.length;\n  lines.forEach(line => {\n    line.split('').forEach(char => {\n      const glyph = glyphMap[char];\n      const baselineOffset = 0;\n      if (glyph) {\n        positionedGlyphs.push({\n          glyph: char,\n          x,\n          y: y + baselineOffset,\n          vertical: false,\n          // TODO：目前只支持水平方向\n          scale: 1,\n          metrics: glyph\n        });\n        x += glyph.advance + spacing;\n      }\n    });\n\n    // 左右对齐\n    if (positionedGlyphs.length !== lineStartIndex) {\n      const lineLength = x - spacing;\n      maxLineLength = Math.max(lineLength, maxLineLength);\n      justifyLine(positionedGlyphs, glyphMap, lineStartIndex, positionedGlyphs.length - 1, justify);\n    }\n    x = 0;\n    y -= lineHeight + 5;\n  });\n  const {\n    horizontalAlign,\n    verticalAlign\n  } = getAnchorAlignment(textAnchor);\n  align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, lines.length);\n\n  // 计算包围盒\n  const height = y - yOffset;\n  shaping.top += -verticalAlign * height;\n  shaping.bottom = shaping.top - height;\n  shaping.left += -horizontalAlign * maxLineLength;\n  shaping.right = shaping.left + maxLineLength;\n}\nfunction shapeIconFont(shaping, glyphMap, iconfonts, lineHeight, textAnchor, textJustify, spacing) {\n  // buffer 为 4\n  const yOffset = -8;\n  let x = 0;\n  let y = yOffset;\n  let maxLineLength = 0;\n  const positionedGlyphs = shaping.positionedGlyphs;\n  const justify = textJustify === 'right' ? 1 : textJustify === 'left' ? 0 : 0.5;\n  const lineStartIndex = positionedGlyphs.length;\n  iconfonts.forEach(iconfont => {\n    const glyph = glyphMap[iconfont];\n    const baselineOffset = 0;\n    if (glyph) {\n      positionedGlyphs.push({\n        glyph: iconfont,\n        // x,\n        /**\n         * iconfont\n         * 在计算大小的时候计算的是 unicode 字符 如 &#xe6d4;\n         * 在布局计算 icon 位置的时候应该始终保持居中（且 icon 只占一个字符的位置）\n         */\n        x: glyph.advance / 2,\n        y: y + baselineOffset,\n        vertical: false,\n        // TODO：目前只支持水平方向\n        scale: 1,\n        metrics: glyph\n      });\n      x += glyph.advance + spacing;\n    }\n\n    // 左右对齐\n    if (positionedGlyphs.length !== lineStartIndex) {\n      const lineLength = x - spacing;\n      maxLineLength = Math.max(lineLength, maxLineLength);\n      justifyLine(positionedGlyphs, glyphMap, lineStartIndex, positionedGlyphs.length - 1, justify);\n    }\n    x = 0;\n    y -= lineHeight + 5;\n  });\n  const {\n    horizontalAlign,\n    verticalAlign\n  } = getAnchorAlignment(textAnchor);\n  align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, iconfonts.length);\n\n  // 计算包围盒\n  const height = y - yOffset;\n  shaping.top += -verticalAlign * height;\n  shaping.bottom = shaping.top - height;\n  shaping.left += -horizontalAlign * maxLineLength;\n  shaping.right = shaping.left + maxLineLength;\n}\n\n/**\n * 计算文本中每个独立字符相对锚点的位置\n *\n * @param {string} text 原始文本\n * @param {*} glyphs mapping\n * @param {number} lineHeight 行高\n * @param {string} textAnchor 文本相对于锚点的位置\n * @param {string} textJustify 左右对齐\n * @param {number} spacing 字符间距\n * @param {[number, number]} translate 文本水平 & 垂直偏移量\n * @param {[boolean]} isIconFont 是否是 iconfont\n * @return {boolean|shaping} 每个字符相对于锚点的位置\n */\nexport function shapeText(text, glyphs, lineHeight, textAnchor, textJustify, spacing, translate = [0, 0], isIconFont) {\n  // TODO：处理换行\n  const lines = text.split('\\n');\n  const positionedGlyphs = [];\n  const shaping = {\n    positionedGlyphs,\n    top: translate[1],\n    bottom: translate[1],\n    left: translate[0],\n    right: translate[0],\n    lineCount: lines.length,\n    text\n  };\n  isIconFont ? shapeIconFont(shaping, glyphs, lines, lineHeight, textAnchor, textJustify, spacing) : shapeLines(shaping, glyphs, lines, lineHeight, textAnchor, textJustify, spacing);\n  if (!positionedGlyphs.length) {\n    return false;\n  }\n  return shaping;\n}\nexport function getGlyphQuads(shaping, textOffset = [0, 0], alongLine) {\n  const {\n    positionedGlyphs = []\n  } = shaping;\n  const quads = [];\n  for (const positionedGlyph of positionedGlyphs) {\n    const rect = positionedGlyph.metrics;\n\n    // The rects have an addditional buffer that is not included in their size.\n    const rectBuffer = 4;\n    const halfAdvance = rect.advance * positionedGlyph.scale / 2;\n    const glyphOffset = alongLine ? [positionedGlyph.x + halfAdvance, positionedGlyph.y] : [0, 0];\n    const builtInOffset = alongLine ? [0, 0] : [positionedGlyph.x + halfAdvance + textOffset[0], positionedGlyph.y + textOffset[1]];\n    const x1 = (0 - rectBuffer) * positionedGlyph.scale - halfAdvance + builtInOffset[0];\n    const y1 = (0 - rectBuffer) * positionedGlyph.scale + builtInOffset[1];\n    const x2 = x1 + rect.width * positionedGlyph.scale;\n    const y2 = y1 + rect.height * positionedGlyph.scale;\n    const tl = {\n      x: x1,\n      y: y1\n    };\n    const tr = {\n      x: x2,\n      y: y1\n    };\n    const bl = {\n      x: x1,\n      y: y2\n    };\n    const br = {\n      x: x2,\n      y: y2\n    };\n\n    // TODO：处理字符旋转的情况\n\n    quads.push({\n      tl,\n      tr,\n      bl,\n      br,\n      tex: rect,\n      glyphOffset\n    });\n  }\n  return quads;\n}","map":{"version":3,"names":["getAnchorAlignment","anchor","horizontalAlign","verticalAlign","justifyLine","positionedGlyphs","glyphMap","start","end","justify","lastPositionedGlyph","glyph","lastAdvance","advance","scale","lineIndent","x","j","align","maxLineLength","lineHeight","lineCount","shiftX","shiftY","glyphs","y","shapeLines","shaping","lines","textAnchor","textJustify","spacing","yOffset","lineStartIndex","length","forEach","line","split","char","baselineOffset","push","vertical","metrics","lineLength","Math","max","height","top","bottom","left","right","shapeIconFont","iconfonts","iconfont","shapeText","text","translate","isIconFont","getGlyphQuads","textOffset","alongLine","quads","positionedGlyph","rect","rectBuffer","halfAdvance","glyphOffset","builtInOffset","x1","y1","x2","width","y2","tl","tr","bl","br","tex"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/l7-layers/es/utils/symbol-layout.js"],"sourcesContent":["/**\n * 返回文本相对锚点位置\n * @param {string} anchor 锚点位置\n * @return {alignment} alignment\n */\nfunction getAnchorAlignment(anchor) {\n  let horizontalAlign = 0.5;\n  let verticalAlign = 0.5;\n  switch (anchor) {\n    case 'right':\n    case 'top-right':\n    case 'bottom-right':\n      horizontalAlign = 1;\n      break;\n    case 'left':\n    case 'top-left':\n    case 'bottom-left':\n      horizontalAlign = 0;\n      break;\n    default:\n      horizontalAlign = 0.5;\n  }\n  switch (anchor) {\n    case 'bottom':\n    case 'bottom-right':\n    case 'bottom-left':\n      verticalAlign = 1;\n      break;\n    case 'top':\n    case 'top-right':\n    case 'top-left':\n      verticalAlign = 0;\n      break;\n    default:\n      verticalAlign = 0.5;\n  }\n  return {\n    horizontalAlign,\n    verticalAlign\n  };\n}\n\n// justify right = 1, left = 0, center = 0.5\nfunction justifyLine(positionedGlyphs, glyphMap, start, end, justify) {\n  if (!justify) {\n    return;\n  }\n  const lastPositionedGlyph = positionedGlyphs[end];\n  const glyph = lastPositionedGlyph.glyph;\n  if (glyph) {\n    const lastAdvance = glyphMap[glyph].advance * lastPositionedGlyph.scale;\n    const lineIndent = (positionedGlyphs[end].x + lastAdvance) * justify;\n    for (let j = start; j <= end; j++) {\n      positionedGlyphs[j].x -= lineIndent;\n    }\n  }\n}\n\n// justify right=1 left=0 center=0.5\n// horizontalAlign right=1 left=0 center=0.5\n// verticalAlign right=1 left=0 center=0.5\nfunction align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, lineCount) {\n  const shiftX = (justify - horizontalAlign) * maxLineLength;\n  const shiftY = (-verticalAlign * lineCount + 0.5) * lineHeight;\n  for (const glyphs of positionedGlyphs) {\n    glyphs.x += shiftX;\n    glyphs.y += shiftY;\n  }\n}\nfunction shapeLines(shaping, glyphMap, lines, lineHeight, textAnchor, textJustify, spacing) {\n  // buffer 为 4\n  const yOffset = -8;\n  let x = 0;\n  let y = yOffset;\n  let maxLineLength = 0;\n  const positionedGlyphs = shaping.positionedGlyphs;\n  const justify = textJustify === 'right' ? 1 : textJustify === 'left' ? 0 : 0.5;\n  const lineStartIndex = positionedGlyphs.length;\n  lines.forEach(line => {\n    line.split('').forEach(char => {\n      const glyph = glyphMap[char];\n      const baselineOffset = 0;\n      if (glyph) {\n        positionedGlyphs.push({\n          glyph: char,\n          x,\n          y: y + baselineOffset,\n          vertical: false,\n          // TODO：目前只支持水平方向\n          scale: 1,\n          metrics: glyph\n        });\n        x += glyph.advance + spacing;\n      }\n    });\n\n    // 左右对齐\n    if (positionedGlyphs.length !== lineStartIndex) {\n      const lineLength = x - spacing;\n      maxLineLength = Math.max(lineLength, maxLineLength);\n      justifyLine(positionedGlyphs, glyphMap, lineStartIndex, positionedGlyphs.length - 1, justify);\n    }\n    x = 0;\n    y -= lineHeight + 5;\n  });\n  const {\n    horizontalAlign,\n    verticalAlign\n  } = getAnchorAlignment(textAnchor);\n  align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, lines.length);\n\n  // 计算包围盒\n  const height = y - yOffset;\n  shaping.top += -verticalAlign * height;\n  shaping.bottom = shaping.top - height;\n  shaping.left += -horizontalAlign * maxLineLength;\n  shaping.right = shaping.left + maxLineLength;\n}\nfunction shapeIconFont(shaping, glyphMap, iconfonts, lineHeight, textAnchor, textJustify, spacing) {\n  // buffer 为 4\n  const yOffset = -8;\n  let x = 0;\n  let y = yOffset;\n  let maxLineLength = 0;\n  const positionedGlyphs = shaping.positionedGlyphs;\n  const justify = textJustify === 'right' ? 1 : textJustify === 'left' ? 0 : 0.5;\n  const lineStartIndex = positionedGlyphs.length;\n  iconfonts.forEach(iconfont => {\n    const glyph = glyphMap[iconfont];\n    const baselineOffset = 0;\n    if (glyph) {\n      positionedGlyphs.push({\n        glyph: iconfont,\n        // x,\n        /**\n         * iconfont\n         * 在计算大小的时候计算的是 unicode 字符 如 &#xe6d4;\n         * 在布局计算 icon 位置的时候应该始终保持居中（且 icon 只占一个字符的位置）\n         */\n        x: glyph.advance / 2,\n        y: y + baselineOffset,\n        vertical: false,\n        // TODO：目前只支持水平方向\n        scale: 1,\n        metrics: glyph\n      });\n      x += glyph.advance + spacing;\n    }\n\n    // 左右对齐\n    if (positionedGlyphs.length !== lineStartIndex) {\n      const lineLength = x - spacing;\n      maxLineLength = Math.max(lineLength, maxLineLength);\n      justifyLine(positionedGlyphs, glyphMap, lineStartIndex, positionedGlyphs.length - 1, justify);\n    }\n    x = 0;\n    y -= lineHeight + 5;\n  });\n  const {\n    horizontalAlign,\n    verticalAlign\n  } = getAnchorAlignment(textAnchor);\n  align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, iconfonts.length);\n\n  // 计算包围盒\n  const height = y - yOffset;\n  shaping.top += -verticalAlign * height;\n  shaping.bottom = shaping.top - height;\n  shaping.left += -horizontalAlign * maxLineLength;\n  shaping.right = shaping.left + maxLineLength;\n}\n\n/**\n * 计算文本中每个独立字符相对锚点的位置\n *\n * @param {string} text 原始文本\n * @param {*} glyphs mapping\n * @param {number} lineHeight 行高\n * @param {string} textAnchor 文本相对于锚点的位置\n * @param {string} textJustify 左右对齐\n * @param {number} spacing 字符间距\n * @param {[number, number]} translate 文本水平 & 垂直偏移量\n * @param {[boolean]} isIconFont 是否是 iconfont\n * @return {boolean|shaping} 每个字符相对于锚点的位置\n */\nexport function shapeText(text, glyphs, lineHeight, textAnchor, textJustify, spacing, translate = [0, 0], isIconFont) {\n  // TODO：处理换行\n  const lines = text.split('\\n');\n  const positionedGlyphs = [];\n  const shaping = {\n    positionedGlyphs,\n    top: translate[1],\n    bottom: translate[1],\n    left: translate[0],\n    right: translate[0],\n    lineCount: lines.length,\n    text\n  };\n  isIconFont ? shapeIconFont(shaping, glyphs, lines, lineHeight, textAnchor, textJustify, spacing) : shapeLines(shaping, glyphs, lines, lineHeight, textAnchor, textJustify, spacing);\n  if (!positionedGlyphs.length) {\n    return false;\n  }\n  return shaping;\n}\nexport function getGlyphQuads(shaping, textOffset = [0, 0], alongLine) {\n  const {\n    positionedGlyphs = []\n  } = shaping;\n  const quads = [];\n  for (const positionedGlyph of positionedGlyphs) {\n    const rect = positionedGlyph.metrics;\n\n    // The rects have an addditional buffer that is not included in their size.\n    const rectBuffer = 4;\n    const halfAdvance = rect.advance * positionedGlyph.scale / 2;\n    const glyphOffset = alongLine ? [positionedGlyph.x + halfAdvance, positionedGlyph.y] : [0, 0];\n    const builtInOffset = alongLine ? [0, 0] : [positionedGlyph.x + halfAdvance + textOffset[0], positionedGlyph.y + textOffset[1]];\n    const x1 = (0 - rectBuffer) * positionedGlyph.scale - halfAdvance + builtInOffset[0];\n    const y1 = (0 - rectBuffer) * positionedGlyph.scale + builtInOffset[1];\n    const x2 = x1 + rect.width * positionedGlyph.scale;\n    const y2 = y1 + rect.height * positionedGlyph.scale;\n    const tl = {\n      x: x1,\n      y: y1\n    };\n    const tr = {\n      x: x2,\n      y: y1\n    };\n    const bl = {\n      x: x1,\n      y: y2\n    };\n    const br = {\n      x: x2,\n      y: y2\n    };\n\n    // TODO：处理字符旋转的情况\n\n    quads.push({\n      tl,\n      tr,\n      bl,\n      br,\n      tex: rect,\n      glyphOffset\n    });\n  }\n  return quads;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}