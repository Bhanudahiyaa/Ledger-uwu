{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\nvar _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2, _descriptor3, _temp;\nimport { mat4 } from 'gl-matrix';\nimport { inject, injectable } from 'inversify';\nimport { IDENTIFIER } from '../../identifier';\nexport var SceneGraphSystem = (_dec = injectable(), _dec2 = inject(IDENTIFIER.HierarchyComponentManager), _dec3 = inject(IDENTIFIER.TransformComponentManager), _dec4 = inject(IDENTIFIER.MeshComponentManager), _dec(_class = (_class2 = (_temp = /*#__PURE__*/function () {\n  function SceneGraphSystem() {\n    _classCallCheck(this, SceneGraphSystem);\n    _initializerDefineProperty(this, \"hierarchy\", _descriptor, this);\n    _initializerDefineProperty(this, \"transform\", _descriptor2, this);\n    _initializerDefineProperty(this, \"mesh\", _descriptor3, this);\n  }\n  _createClass(SceneGraphSystem, [{\n    key: \"execute\",\n    value: function () {\n      var _execute = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.runTransformUpdateSystem();\n                this.runHierarchyUpdateSystem();\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function execute() {\n        return _execute.apply(this, arguments);\n      }\n      return execute;\n    }()\n  }, {\n    key: \"tearDown\",\n    value: function tearDown() {\n      this.hierarchy.clear();\n      this.transform.clear();\n    }\n  }, {\n    key: \"getHierarchyComponentManager\",\n    value: function getHierarchyComponentManager() {\n      return this.hierarchy;\n    }\n  }, {\n    key: \"getTransformComponentManager\",\n    value: function getTransformComponentManager() {\n      return this.transform;\n    }\n  }, {\n    key: \"runTransformUpdateSystem\",\n    value: function runTransformUpdateSystem() {\n      var _this = this;\n\n      // 原版基于 JobSystem 实现\n      this.transform.forEach(function (entity, transform) {\n        if (transform.isDirty() || transform.isLocalDirty()) {\n          _this.setMeshAABBDirty(_this.mesh.getComponentByEntity(entity));\n          transform.updateTransform();\n        }\n      });\n    }\n  }, {\n    key: \"runHierarchyUpdateSystem\",\n    value: function runHierarchyUpdateSystem() {\n      var _this2 = this;\n      this.hierarchy.forEach(function (entity, parentComponent) {\n        var transformChild = _this2.transform.getComponentByEntity(entity);\n        var transformParent = _this2.transform.getComponentByEntity(parentComponent.parentID);\n        if (transformChild !== null && transformParent !== null) {\n          transformChild.updateTransformWithParent(transformParent);\n        }\n      });\n    }\n  }, {\n    key: \"attach\",\n    value: function attach(entity, parent, isChildAlreadyInLocalSpace) {\n      if (this.hierarchy.contains(entity)) {\n        this.detach(entity);\n      }\n      this.hierarchy.create(entity, {\n        parentID: parent\n      });\n      var mesh = this.mesh.getComponentByEntity(parent); // inform parent mesh to update its aabb\n\n      this.setMeshAABBDirty(mesh);\n      if (mesh && mesh.children.indexOf(entity) === -1) {\n        mesh.children.push(entity);\n      }\n      if (this.hierarchy.getCount() > 1) {\n        for (var i = this.hierarchy.getCount() - 1; i > 0; --i) {\n          var parentCandidateEntity = this.hierarchy.getEntity(i); // const parentCandidateComponent = this.hierarchy.getComponent(i);\n\n          for (var j = 0; j < i; ++j) {\n            var childCandidateEntity = this.hierarchy.getComponent(j);\n            if (childCandidateEntity.parentID === parentCandidateEntity) {\n              this.hierarchy.moveItem(i, j);\n              ++i; // next outer iteration will check the same index again as parent candidate, however things were moved upwards, so it will be a different entity!\n\n              break;\n            }\n          }\n        }\n      } // Re-query parent after potential MoveItem(), because it invalidates references:\n\n      var parentcomponent = this.hierarchy.getComponentByEntity(entity);\n      var transformParent = this.transform.getComponentByEntity(parent);\n      if (transformParent === null) {\n        transformParent = this.transform.create(parent);\n      }\n      var transformChild = this.transform.getComponentByEntity(entity);\n      if (transformChild === null) {\n        transformChild = this.transform.create(entity); // after transforms.Create(), transform_parent pointer could have become invalidated!\n\n        transformParent = this.transform.getComponentByEntity(parent);\n      }\n      transformChild.parent = transformParent;\n      if (!isChildAlreadyInLocalSpace && transformParent) {\n        transformChild.matrixTransform(mat4.invert(mat4.create(), transformParent.worldTransform));\n        transformChild.updateTransform();\n      }\n      if (transformParent) {\n        transformChild.updateTransformWithParent(transformParent);\n      }\n    }\n  }, {\n    key: \"detach\",\n    value: function detach(entity) {\n      var self = this.hierarchy.getComponentByEntity(entity);\n      if (self !== null) {\n        var transform = this.transform.getComponentByEntity(entity);\n        if (transform !== null) {\n          transform.parent = null;\n          transform.applyTransform();\n        }\n        this.hierarchy.removeKeepSorted(entity); // inform parent mesh to update its aabb\n\n        var mesh = this.mesh.getComponentByEntity(self.parentID);\n        if (mesh) {\n          var index = mesh.children.indexOf(entity);\n          mesh.children.splice(index, 1);\n        }\n        this.setMeshAABBDirty(mesh);\n      }\n    }\n  }, {\n    key: \"detachChildren\",\n    value: function detachChildren(parent) {\n      var mesh = this.mesh.getComponentByEntity(parent);\n      if (mesh) {\n        mesh.children = [];\n      }\n      for (var i = 0; i < this.hierarchy.getCount();) {\n        var _this$hierarchy$getCo;\n        if (((_this$hierarchy$getCo = this.hierarchy.getComponent(i)) === null || _this$hierarchy$getCo === void 0 ? void 0 : _this$hierarchy$getCo.parentID) === parent) {\n          var entity = this.hierarchy.getEntity(i);\n          this.detach(entity);\n        } else {\n          ++i;\n        }\n      }\n    }\n  }, {\n    key: \"setMeshAABBDirty\",\n    value: function setMeshAABBDirty(mesh) {\n      if (mesh) {\n        mesh.aabbDirty = true;\n      }\n    }\n  }]);\n  return SceneGraphSystem;\n}(), _temp), _descriptor = _applyDecoratedDescriptor(_class2.prototype, \"hierarchy\", [_dec2], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"transform\", [_dec3], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, \"mesh\", [_dec4], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _class2)) || _class);","map":{"version":3,"names":["mat4","inject","injectable","IDENTIFIER","SceneGraphSystem","_dec","_dec2","HierarchyComponentManager","_dec3","TransformComponentManager","_dec4","MeshComponentManager","_class","_class2","_temp","_classCallCheck","_initializerDefineProperty","_descriptor","_descriptor2","_descriptor3","_createClass","key","value","_execute","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","runTransformUpdateSystem","runHierarchyUpdateSystem","stop","execute","apply","arguments","tearDown","hierarchy","clear","transform","getHierarchyComponentManager","getTransformComponentManager","_this","forEach","entity","isDirty","isLocalDirty","setMeshAABBDirty","mesh","getComponentByEntity","updateTransform","_this2","parentComponent","transformChild","transformParent","parentID","updateTransformWithParent","attach","parent","isChildAlreadyInLocalSpace","contains","detach","create","children","indexOf","push","getCount","i","parentCandidateEntity","getEntity","j","childCandidateEntity","getComponent","moveItem","parentcomponent","matrixTransform","invert","worldTransform","self","applyTransform","removeKeepSorted","index","splice","detachChildren","_this$hierarchy$getCo","aabbDirty","_applyDecoratedDescriptor","prototype","configurable","enumerable","writable","initializer"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/g-webgpu-core/src/components/scenegraph/System.ts"],"sourcesContent":["import { mat4 } from 'gl-matrix';\nimport { inject, injectable } from 'inversify';\nimport { Entity, ISystem } from '../..';\nimport { Component } from '../../ComponentManager';\nimport { ComponentManager } from '../../ComponentManager';\nimport { IDENTIFIER } from '../../identifier';\nimport { MeshComponent } from '../mesh/MeshComponent';\nimport { HierarchyComponent } from './HierarchyComponent';\nimport { TransformComponent } from './TransformComponent';\n\n@injectable()\nexport class SceneGraphSystem implements ISystem {\n  @inject(IDENTIFIER.HierarchyComponentManager)\n  private readonly hierarchy: ComponentManager<HierarchyComponent>;\n\n  @inject(IDENTIFIER.TransformComponentManager)\n  private readonly transform: ComponentManager<TransformComponent>;\n\n  @inject(IDENTIFIER.MeshComponentManager)\n  private readonly mesh: ComponentManager<MeshComponent>;\n\n  public async execute() {\n    this.runTransformUpdateSystem();\n    this.runHierarchyUpdateSystem();\n  }\n\n  public tearDown() {\n    this.hierarchy.clear();\n    this.transform.clear();\n  }\n\n  public getHierarchyComponentManager() {\n    return this.hierarchy;\n  }\n\n  public getTransformComponentManager() {\n    return this.transform;\n  }\n\n  public runTransformUpdateSystem() {\n    // 原版基于 JobSystem 实现\n    this.transform.forEach((entity, transform) => {\n      if (transform.isDirty() || transform.isLocalDirty()) {\n        this.setMeshAABBDirty(this.mesh.getComponentByEntity(entity));\n        transform.updateTransform();\n      }\n    });\n  }\n\n  public runHierarchyUpdateSystem() {\n    this.hierarchy.forEach((entity, parentComponent) => {\n      const transformChild = this.transform.getComponentByEntity(entity);\n      const transformParent = this.transform.getComponentByEntity(\n        parentComponent.parentID,\n      );\n      if (transformChild !== null && transformParent !== null) {\n        transformChild.updateTransformWithParent(transformParent);\n      }\n    });\n  }\n\n  public attach(\n    entity: Entity,\n    parent: Entity,\n    isChildAlreadyInLocalSpace?: boolean,\n  ) {\n    if (this.hierarchy.contains(entity)) {\n      this.detach(entity);\n    }\n\n    this.hierarchy.create(entity, {\n      parentID: parent,\n    });\n    const mesh = this.mesh.getComponentByEntity(parent);\n    // inform parent mesh to update its aabb\n    this.setMeshAABBDirty(mesh);\n    if (mesh && mesh.children.indexOf(entity) === -1) {\n      mesh.children.push(entity);\n    }\n\n    if (this.hierarchy.getCount() > 1) {\n      for (let i = this.hierarchy.getCount() - 1; i > 0; --i) {\n        const parentCandidateEntity = this.hierarchy.getEntity(i);\n        // const parentCandidateComponent = this.hierarchy.getComponent(i);\n        for (let j = 0; j < i; ++j) {\n          const childCandidateEntity = this.hierarchy.getComponent(j);\n\n          if (childCandidateEntity.parentID === parentCandidateEntity) {\n            this.hierarchy.moveItem(i, j);\n            ++i; // next outer iteration will check the same index again as parent candidate, however things were moved upwards, so it will be a different entity!\n            break;\n          }\n        }\n      }\n    }\n\n    // Re-query parent after potential MoveItem(), because it invalidates references:\n    const parentcomponent = this.hierarchy.getComponentByEntity(entity);\n\n    let transformParent = this.transform.getComponentByEntity(parent);\n    if (transformParent === null) {\n      transformParent = this.transform.create(parent);\n    }\n\n    let transformChild = this.transform.getComponentByEntity(entity);\n    if (transformChild === null) {\n      transformChild = this.transform.create(entity);\n      // after transforms.Create(), transform_parent pointer could have become invalidated!\n      transformParent = this.transform.getComponentByEntity(parent);\n    }\n\n    transformChild.parent = transformParent;\n\n    if (!isChildAlreadyInLocalSpace && transformParent) {\n      transformChild.matrixTransform(\n        mat4.invert(mat4.create(), transformParent.worldTransform),\n      );\n      transformChild.updateTransform();\n    }\n    if (transformParent) {\n      transformChild.updateTransformWithParent(transformParent);\n    }\n  }\n\n  public detach(entity: Entity) {\n    const self = this.hierarchy.getComponentByEntity(entity);\n    if (self !== null) {\n      const transform = this.transform.getComponentByEntity(entity);\n      if (transform !== null) {\n        transform.parent = null;\n        transform.applyTransform();\n      }\n\n      this.hierarchy.removeKeepSorted(entity);\n\n      // inform parent mesh to update its aabb\n      const mesh = this.mesh.getComponentByEntity(self.parentID);\n      if (mesh) {\n        const index = mesh.children.indexOf(entity);\n        mesh.children.splice(index, 1);\n      }\n      this.setMeshAABBDirty(mesh);\n    }\n  }\n\n  public detachChildren(parent: Entity) {\n    const mesh = this.mesh.getComponentByEntity(parent);\n    if (mesh) {\n      mesh.children = [];\n    }\n    for (let i = 0; i < this.hierarchy.getCount(); ) {\n      if (this.hierarchy.getComponent(i)?.parentID === parent) {\n        const entity = this.hierarchy.getEntity(i);\n        this.detach(entity);\n      } else {\n        ++i;\n      }\n    }\n  }\n\n  private setMeshAABBDirty(\n    mesh: (Component<MeshComponent> & MeshComponent) | null,\n  ) {\n    if (mesh) {\n      mesh.aabbDirty = true;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}