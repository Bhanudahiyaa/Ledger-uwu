{"ast":null,"code":"import graphlib from '../graphlib';\nimport { slack } from './util';\nimport { minBy } from '../util';\nconst Graph = graphlib.Graph;\n/*\n * Constructs a spanning tree with tight edges and adjusted the input node's\n * ranks to achieve this. A tight edge is one that is has a length that matches\n * its \"minlen\" attribute.\n *\n * The basic structure for this function is derived from Gansner, et al., \"A\n * Technique for Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a DAG.\n *    2. Graph must be connected.\n *    3. Graph must have at least one node.\n *    5. Graph nodes must have been previously assigned a \"rank\" property that\n *       respects the \"minlen\" property of incident edges.\n *    6. Graph edges must have a \"minlen\" property.\n *\n * Post-conditions:\n *\n *    - Graph nodes will have their rank adjusted to ensure that all edges are\n *      tight.\n *\n * Returns a tree (undirected graph) that is constructed using only \"tight\"\n * edges.\n */\nconst feasibleTree = g => {\n  const t = new Graph({\n    directed: false\n  });\n  // Choose arbitrary node from which to start our tree\n  const start = g.nodes()[0];\n  const size = g.nodeCount();\n  t.setNode(start, {});\n  let edge;\n  let delta;\n  while (tightTree(t, g) < size) {\n    edge = findMinSlackEdge(t, g);\n    delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);\n    shiftRanks(t, g, delta);\n  }\n  return t;\n};\n/*\n * Finds a maximal tree of tight edges and returns the number of nodes in the\n * tree.\n */\nconst tightTree = (t, g) => {\n  const dfs = v => {\n    g.nodeEdges(v).forEach(e => {\n      const edgeV = e.v;\n      const w = v === edgeV ? e.w : edgeV;\n      if (!t.hasNode(w) && !slack(g, e)) {\n        t.setNode(w, {});\n        t.setEdge(v, w, {});\n        dfs(w);\n      }\n    });\n  };\n  t.nodes().forEach(dfs);\n  return t.nodeCount();\n};\n/*\n * Constructs a spanning tree with tight edges and adjusted the input node's\n * ranks to achieve this. A tight edge is one that is has a length that matches\n * its \"minlen\" attribute.\n *\n * The basic structure for this function is derived from Gansner, et al., \"A\n * Technique for Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a DAG.\n *    2. Graph must be connected.\n *    3. Graph must have at least one node.\n *    5. Graph nodes must have been previously assigned a \"rank\" property that\n *       respects the \"minlen\" property of incident edges.\n *    6. Graph edges must have a \"minlen\" property.\n *\n * Post-conditions:\n *\n *    - Graph nodes will have their rank adjusted to ensure that all edges are\n *      tight.\n *\n * Returns a tree (undirected graph) that is constructed using only \"tight\"\n * edges.\n */\nconst feasibleTreeWithLayer = g => {\n  const t = new Graph({\n    directed: false\n  });\n  // Choose arbitrary node from which to start our tree\n  const start = g.nodes()[0];\n  const size = g.nodeCount();\n  t.setNode(start, {});\n  let edge;\n  let delta;\n  while (tightTreeWithLayer(t, g) < size) {\n    edge = findMinSlackEdge(t, g);\n    delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);\n    shiftRanks(t, g, delta);\n  }\n  return t;\n};\n/*\n * Finds a maximal tree of tight edges and returns the number of nodes in the\n * tree.\n */\nconst tightTreeWithLayer = (t, g) => {\n  const dfs = v => {\n    var _a;\n    (_a = g.nodeEdges(v)) === null || _a === void 0 ? void 0 : _a.forEach(e => {\n      const edgeV = e.v;\n      const w = v === edgeV ? e.w : edgeV;\n      // 对于指定layer的，直接加入tight-tree，不参与调整\n      if (!t.hasNode(w) && (g.node(w).layer !== undefined || !slack(g, e))) {\n        t.setNode(w, {});\n        t.setEdge(v, w, {});\n        dfs(w);\n      }\n    });\n  };\n  t.nodes().forEach(dfs);\n  return t.nodeCount();\n};\n/*\n * Finds the edge with the smallest slack that is incident on tree and returns\n * it.\n */\nconst findMinSlackEdge = (t, g) => {\n  return minBy(g.edges(), e => {\n    if (t.hasNode(e.v) !== t.hasNode(e.w)) {\n      return slack(g, e);\n    }\n    return Infinity;\n  });\n};\nconst shiftRanks = (t, g, delta) => {\n  t.nodes().forEach(v => {\n    if (!g.node(v).rank) g.node(v).rank = 0;\n    g.node(v).rank += delta;\n  });\n};\nexport { feasibleTree, feasibleTreeWithLayer };\nexport default {\n  feasibleTree,\n  feasibleTreeWithLayer\n};","map":{"version":3,"names":["graphlib","slack","minBy","Graph","feasibleTree","g","t","directed","start","nodes","size","nodeCount","setNode","edge","delta","tightTree","findMinSlackEdge","hasNode","v","shiftRanks","dfs","nodeEdges","forEach","e","edgeV","w","setEdge","feasibleTreeWithLayer","tightTreeWithLayer","_a","node","layer","undefined","edges","Infinity","rank"],"sources":["../../../../../src/layout/dagre/src/rank/feasible-tree.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}