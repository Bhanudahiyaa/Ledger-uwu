{"ast":null,"code":"import JQuery from 'jquery';\nimport { Util, Config } from '../global';\nimport { ArrayExt, FunctionExt, Dom, Vector } from '../util';\nimport { Rectangle, Point } from '../geometry';\nimport { Cell } from '../model/cell';\nimport { CellView } from './cell';\nimport { Markup } from './markup';\nexport class NodeView extends CellView {\n  constructor() {\n    super(...arguments);\n    this.scalableNode = null;\n    this.rotatableNode = null;\n    this.scalableSelector = 'scalable';\n    this.rotatableSelector = 'rotatable';\n    this.defaultPortMarkup = Markup.getPortMarkup();\n    this.defaultPortLabelMarkup = Markup.getPortLabelMarkup();\n    this.defaultPortContainerMarkup = Markup.getPortContainerMarkup();\n    this.portsCache = {};\n    // #endregion\n  }\n  get [Symbol.toStringTag]() {\n    return NodeView.toStringTag;\n  }\n  getContainerClassName() {\n    const classList = [super.getContainerClassName(), this.prefixClassName('node')];\n    if (!this.can('nodeMovable')) {\n      classList.push(this.prefixClassName('node-immovable'));\n    }\n    return classList.join(' ');\n  }\n  updateClassName(e) {\n    const target = e.target;\n    if (target.hasAttribute('magnet')) {\n      // port\n      const className = this.prefixClassName('port-unconnectable');\n      if (this.can('magnetConnectable')) {\n        Dom.removeClass(target, className);\n      } else {\n        Dom.addClass(target, className);\n      }\n    } else {\n      // node\n      const className = this.prefixClassName('node-immovable');\n      if (this.can('nodeMovable')) {\n        this.removeClass(className);\n      } else {\n        this.addClass(className);\n      }\n    }\n  }\n  isNodeView() {\n    return true;\n  }\n  confirmUpdate(flag, options = {}) {\n    let ret = flag;\n    if (this.hasAction(ret, 'ports')) {\n      this.removePorts();\n      this.cleanPortsCache();\n    }\n    if (this.hasAction(ret, 'render')) {\n      this.render();\n      ret = this.removeAction(ret, ['render', 'update', 'resize', 'translate', 'rotate', 'ports', 'tools']);\n    } else {\n      ret = this.handleAction(ret, 'resize', () => this.resize(options), 'update');\n      ret = this.handleAction(ret, 'update', () => this.update(),\n      // `update()` will render ports when useCSSSelectors are enabled\n      Config.useCSSSelector ? 'ports' : null);\n      ret = this.handleAction(ret, 'translate', () => this.translate());\n      ret = this.handleAction(ret, 'rotate', () => this.rotate());\n      ret = this.handleAction(ret, 'ports', () => this.renderPorts());\n      ret = this.handleAction(ret, 'tools', () => this.renderTools());\n    }\n    return ret;\n  }\n  update(partialAttrs) {\n    this.cleanCache();\n    // When CSS selector strings are used, make sure no rule matches port nodes.\n    if (Config.useCSSSelector) {\n      this.removePorts();\n    }\n    const node = this.cell;\n    const size = node.getSize();\n    const attrs = node.getAttrs();\n    this.updateAttrs(this.container, attrs, {\n      attrs: partialAttrs === attrs ? null : partialAttrs,\n      rootBBox: new Rectangle(0, 0, size.width, size.height),\n      selectors: this.selectors,\n      scalableNode: this.scalableNode,\n      rotatableNode: this.rotatableNode\n    });\n    if (Config.useCSSSelector) {\n      this.renderPorts();\n    }\n  }\n  renderMarkup() {\n    const markup = this.cell.markup;\n    if (markup) {\n      if (typeof markup === 'string') {\n        return this.renderStringMarkup(markup);\n      }\n      return this.renderJSONMarkup(markup);\n    }\n    throw new TypeError('Invalid node markup.');\n  }\n  renderJSONMarkup(markup) {\n    const ret = this.parseJSONMarkup(markup, this.container);\n    const one = elems => Array.isArray(elems) ? elems[0] : elems;\n    this.selectors = ret.selectors;\n    this.rotatableNode = one(this.selectors[this.rotatableSelector]);\n    this.scalableNode = one(this.selectors[this.scalableSelector]);\n    this.container.appendChild(ret.fragment);\n  }\n  renderStringMarkup(markup) {\n    Dom.append(this.container, Vector.toNodes(Vector.createVectors(markup)));\n    this.rotatableNode = Dom.findOne(this.container, `.${this.rotatableSelector}`);\n    this.scalableNode = Dom.findOne(this.container, `.${this.scalableSelector}`);\n    this.selectors = {};\n    if (this.rootSelector) {\n      this.selectors[this.rootSelector] = this.container;\n    }\n  }\n  render() {\n    this.empty();\n    this.renderMarkup();\n    if (this.scalableNode) {\n      // Double update is necessary for elements with the scalable group only\n      // Note the `resize()` triggers the other `update`.\n      this.update();\n    }\n    this.resize();\n    if (this.rotatableNode) {\n      this.rotate();\n      this.translate();\n    } else {\n      this.updateTransform();\n    }\n    if (!Config.useCSSSelector) {\n      this.renderPorts();\n    }\n    this.renderTools();\n    return this;\n  }\n  resize(opt = {}) {\n    if (this.scalableNode) {\n      return this.updateSize(opt);\n    }\n    if (this.cell.getAngle()) {\n      this.rotate();\n    }\n    this.update();\n  }\n  translate() {\n    if (this.rotatableNode) {\n      return this.updateTranslation();\n    }\n    this.updateTransform();\n  }\n  rotate() {\n    if (this.rotatableNode) {\n      this.updateRotation();\n      // It's necessary to call the update for the nodes outside\n      // the rotatable group referencing nodes inside the group\n      this.update();\n      return;\n    }\n    this.updateTransform();\n  }\n  getTranslationString() {\n    const position = this.cell.getPosition();\n    return `translate(${position.x},${position.y})`;\n  }\n  getRotationString() {\n    const angle = this.cell.getAngle();\n    if (angle) {\n      const size = this.cell.getSize();\n      return `rotate(${angle},${size.width / 2},${size.height / 2})`;\n    }\n  }\n  updateTransform() {\n    let transform = this.getTranslationString();\n    const rot = this.getRotationString();\n    if (rot) {\n      transform += ` ${rot}`;\n    }\n    this.container.setAttribute('transform', transform);\n  }\n  updateRotation() {\n    if (this.rotatableNode != null) {\n      const transform = this.getRotationString();\n      if (transform != null) {\n        this.rotatableNode.setAttribute('transform', transform);\n      } else {\n        this.rotatableNode.removeAttribute('transform');\n      }\n    }\n  }\n  updateTranslation() {\n    this.container.setAttribute('transform', this.getTranslationString());\n  }\n  updateSize(opt = {}) {\n    const cell = this.cell;\n    const size = cell.getSize();\n    const angle = cell.getAngle();\n    const scalableNode = this.scalableNode;\n    // Getting scalable group's bbox.\n    // Due to a bug in webkit's native SVG .getBBox implementation, the\n    // bbox of groups with path children includes the paths' control points.\n    // To work around the issue, we need to check whether there are any path\n    // elements inside the scalable group.\n    let recursive = false;\n    if (scalableNode.getElementsByTagName('path').length > 0) {\n      // If scalable has at least one descendant that is a path, we need\n      // toswitch to recursive bbox calculation. Otherwise, group bbox\n      // calculation works and so we can use the (faster) native function.\n      recursive = true;\n    }\n    const scalableBBox = Dom.getBBox(scalableNode, {\n      recursive\n    });\n    // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero\n    // which can happen if the element does not have any content.\n    const sx = size.width / (scalableBBox.width || 1);\n    const sy = size.height / (scalableBBox.height || 1);\n    scalableNode.setAttribute('transform', `scale(${sx},${sy})`);\n    // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`\n    // Order of transformations is significant but we want to reconstruct the object always in the order:\n    // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,\n    // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the\n    // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation\n    // around the center of the resized object (which is a different origin then the origin of the previous rotation)\n    // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.\n    // Cancel the rotation but now around a different origin, which is the center of the scaled object.\n    const rotatableNode = this.rotatableNode;\n    if (rotatableNode != null) {\n      const transform = rotatableNode.getAttribute('transform');\n      if (transform) {\n        rotatableNode.setAttribute('transform', `${transform} rotate(${-angle},${size.width / 2},${size.height / 2})`);\n        const rotatableBBox = Dom.getBBox(scalableNode, {\n          target: this.graph.view.stage\n        });\n        // Store new x, y and perform rotate() again against the new rotation origin.\n        cell.prop('position', {\n          x: rotatableBBox.x,\n          y: rotatableBBox.y\n        }, Object.assign({\n          updated: true\n        }, opt));\n        this.translate();\n        this.rotate();\n      }\n    }\n    // Update must always be called on non-rotated element. Otherwise,\n    // relative positioning would work with wrong (rotated) bounding boxes.\n    this.update();\n  }\n  // #region ports\n  findPortElem(portId, selector) {\n    const cache = portId ? this.portsCache[portId] : null;\n    if (!cache) {\n      return null;\n    }\n    const portRoot = cache.portContentElement;\n    const portSelectors = cache.portContentSelectors || {};\n    return this.findOne(selector, portRoot, portSelectors);\n  }\n  initializePorts() {\n    this.cleanPortsCache();\n  }\n  refreshPorts() {\n    this.removePorts();\n    this.cleanPortsCache();\n    this.renderPorts();\n  }\n  cleanPortsCache() {\n    this.portsCache = {};\n  }\n  removePorts() {\n    Object.keys(this.portsCache).forEach(portId => {\n      const cached = this.portsCache[portId];\n      Dom.remove(cached.portElement);\n    });\n  }\n  renderPorts() {\n    const container = this.getPortsContainer();\n    // References to rendered elements without z-index\n    const references = [];\n    container.childNodes.forEach(child => {\n      references.push(child);\n    });\n    const portsGropsByZ = ArrayExt.groupBy(this.cell.getParsedPorts(), 'zIndex');\n    const autoZIndexKey = 'auto';\n    // render non-z first\n    if (portsGropsByZ[autoZIndexKey]) {\n      portsGropsByZ[autoZIndexKey].forEach(port => {\n        const portElement = this.getPortElement(port);\n        container.append(portElement);\n        references.push(portElement);\n      });\n    }\n    Object.keys(portsGropsByZ).forEach(key => {\n      if (key !== autoZIndexKey) {\n        const zIndex = parseInt(key, 10);\n        this.appendPorts(portsGropsByZ[key], zIndex, references);\n      }\n    });\n    this.updatePorts();\n  }\n  getPortsContainer() {\n    return this.rotatableNode || this.container;\n  }\n  appendPorts(ports, zIndex, refs) {\n    const elems = ports.map(p => this.getPortElement(p));\n    if (refs[zIndex] || zIndex < 0) {\n      Dom.before(refs[Math.max(zIndex, 0)], elems);\n    } else {\n      Dom.append(this.getPortsContainer(), elems);\n    }\n  }\n  getPortElement(port) {\n    const cached = this.portsCache[port.id];\n    if (cached) {\n      return cached.portElement;\n    }\n    return this.createPortElement(port);\n  }\n  createPortElement(port) {\n    let renderResult = Markup.renderMarkup(this.getPortContainerMarkup());\n    const portElement = renderResult.elem;\n    if (portElement == null) {\n      throw new Error('Invalid port container markup.');\n    }\n    renderResult = Markup.renderMarkup(this.getPortMarkup(port));\n    const portContentElement = renderResult.elem;\n    const portContentSelectors = renderResult.selectors;\n    if (portContentElement == null) {\n      throw new Error('Invalid port markup.');\n    }\n    this.setAttrs({\n      port: port.id,\n      'port-group': port.group\n    }, portContentElement);\n    renderResult = Markup.renderMarkup(this.getPortLabelMarkup(port.label));\n    const portLabelElement = renderResult.elem;\n    const portLabelSelectors = renderResult.selectors;\n    if (portLabelElement == null) {\n      throw new Error('Invalid port label markup.');\n    }\n    let portSelectors;\n    if (portContentSelectors && portLabelSelectors) {\n      // eslint-disable-next-line\n      for (const key in portLabelSelectors) {\n        if (portContentSelectors[key] && key !== this.rootSelector) {\n          throw new Error('Selectors within port must be unique.');\n        }\n      }\n      portSelectors = Object.assign(Object.assign({}, portContentSelectors), portLabelSelectors);\n    } else {\n      portSelectors = portContentSelectors || portLabelSelectors;\n    }\n    let portClass = 'x6-port';\n    if (port.group) {\n      portClass += ` x6-port-${port.group}`;\n    }\n    Dom.addClass(portElement, portClass);\n    Dom.addClass(portContentElement, 'x6-port-body');\n    Dom.addClass(portLabelElement, 'x6-port-label');\n    portElement.appendChild(portContentElement);\n    portElement.appendChild(portLabelElement);\n    this.portsCache[port.id] = {\n      portElement,\n      portSelectors,\n      portLabelElement,\n      portLabelSelectors,\n      portContentElement,\n      portContentSelectors\n    };\n    this.graph.hook.onPortRendered({\n      port,\n      node: this.cell,\n      container: portElement,\n      selectors: portSelectors,\n      labelContainer: portLabelElement,\n      labelSelectors: portLabelSelectors,\n      contentContainer: portContentElement,\n      contentSelectors: portContentSelectors\n    });\n    return portElement;\n  }\n  updatePorts() {\n    // Layout ports without group\n    this.updatePortGroup();\n    // Layout ports with explicit group\n    const groups = this.cell.getParsedGroups();\n    Object.keys(groups).forEach(groupName => this.updatePortGroup(groupName));\n  }\n  updatePortGroup(groupName) {\n    const bbox = Rectangle.fromSize(this.cell.getSize());\n    const metrics = this.cell.getPortsLayoutByGroup(groupName, bbox);\n    for (let i = 0, n = metrics.length; i < n; i += 1) {\n      const metric = metrics[i];\n      const portId = metric.portId;\n      const cached = this.portsCache[portId] || {};\n      const portLayout = metric.portLayout;\n      this.applyPortTransform(cached.portElement, portLayout);\n      if (metric.portAttrs != null) {\n        const options = {\n          selectors: cached.portSelectors || {}\n        };\n        if (metric.portSize) {\n          options.rootBBox = Rectangle.fromSize(metric.portSize);\n        }\n        this.updateAttrs(cached.portElement, metric.portAttrs, options);\n      }\n      const labelLayout = metric.labelLayout;\n      if (labelLayout) {\n        this.applyPortTransform(cached.portLabelElement, labelLayout, -(portLayout.angle || 0));\n        if (labelLayout.attrs) {\n          const options = {\n            selectors: cached.portLabelSelectors || {}\n          };\n          if (metric.labelSize) {\n            options.rootBBox = Rectangle.fromSize(metric.labelSize);\n          }\n          this.updateAttrs(cached.portLabelElement, labelLayout.attrs, options);\n        }\n      }\n    }\n  }\n  applyPortTransform(element, layout, initialAngle = 0) {\n    const angle = layout.angle;\n    const position = layout.position;\n    const matrix = Dom.createSVGMatrix().rotate(initialAngle).translate(position.x || 0, position.y || 0).rotate(angle || 0);\n    Dom.transform(element, matrix, {\n      absolute: true\n    });\n  }\n  getPortContainerMarkup() {\n    return this.cell.getPortContainerMarkup() || this.defaultPortContainerMarkup;\n  }\n  getPortMarkup(port) {\n    return port.markup || this.cell.portMarkup || this.defaultPortMarkup;\n  }\n  getPortLabelMarkup(label) {\n    return label.markup || this.cell.portLabelMarkup || this.defaultPortLabelMarkup;\n  }\n  getEventArgs(e, x, y) {\n    const view = this; // eslint-disable-line\n    const node = view.cell;\n    const cell = node;\n    if (x == null || y == null) {\n      return {\n        e,\n        view,\n        node,\n        cell\n      };\n    }\n    return {\n      e,\n      x,\n      y,\n      view,\n      node,\n      cell\n    };\n  }\n  notifyMouseDown(e, x, y) {\n    super.onMouseDown(e, x, y);\n    this.notify('node:mousedown', this.getEventArgs(e, x, y));\n  }\n  notifyMouseMove(e, x, y) {\n    super.onMouseMove(e, x, y);\n    this.notify('node:mousemove', this.getEventArgs(e, x, y));\n  }\n  notifyMouseUp(e, x, y) {\n    // Problem: super will call stopBatch before event listeners\n    // attached to this **node** run. Those events will not count\n    // towards this batch, despite being triggered by the same UI event.\n    //\n    // This complicates a lot of stuff e.g. history recording.\n    //\n    // See https://github.com/antvis/X6/issues/2421 for background.\n    super.onMouseUp(e, x, y);\n    this.notify('node:mouseup', this.getEventArgs(e, x, y));\n  }\n  onClick(e, x, y) {\n    super.onClick(e, x, y);\n    this.notify('node:click', this.getEventArgs(e, x, y));\n  }\n  onDblClick(e, x, y) {\n    super.onDblClick(e, x, y);\n    this.notify('node:dblclick', this.getEventArgs(e, x, y));\n  }\n  onContextMenu(e, x, y) {\n    super.onContextMenu(e, x, y);\n    this.notify('node:contextmenu', this.getEventArgs(e, x, y));\n  }\n  onMouseDown(e, x, y) {\n    if (this.isPropagationStopped(e)) {\n      return;\n    }\n    // 避免处于foreignObject内部元素触发onMouseDown导致节点被拖拽\n    // 拖拽的时候是以onMouseDown启动的\n    const target = e.target;\n    if (Dom.clickable(target) || Dom.isInputElement(target)) {\n      return;\n    }\n    this.notifyMouseDown(e, x, y);\n    this.startNodeDragging(e, x, y);\n  }\n  onMouseMove(e, x, y) {\n    const data = this.getEventData(e);\n    const action = data.action;\n    if (action === 'magnet') {\n      this.dragMagnet(e, x, y);\n    } else {\n      if (action === 'move') {\n        const meta = data;\n        const view = meta.targetView || this;\n        view.dragNode(e, x, y);\n        view.notify('node:moving', {\n          e,\n          x,\n          y,\n          view,\n          cell: view.cell,\n          node: view.cell\n        });\n      }\n      this.notifyMouseMove(e, x, y);\n    }\n    this.setEventData(e, data);\n  }\n  onMouseUp(e, x, y) {\n    const data = this.getEventData(e);\n    const action = data.action;\n    if (action === 'magnet') {\n      this.stopMagnetDragging(e, x, y);\n    } else {\n      // 避免处于foreignObject内部元素触发onMouseUp导致节点被选中\n      // 选中的时候是以onMouseUp启动的\n      const target = e.target;\n      if (Dom.clickable(target) || Dom.isInputElement(target)) {\n        return;\n      }\n      this.notifyMouseUp(e, x, y);\n      if (action === 'move') {\n        const meta = data;\n        const view = meta.targetView || this;\n        view.stopNodeDragging(e, x, y);\n      }\n    }\n    const magnet = data.targetMagnet;\n    if (magnet) {\n      this.onMagnetClick(e, magnet, x, y);\n    }\n    this.checkMouseleave(e);\n  }\n  onMouseOver(e) {\n    super.onMouseOver(e);\n    this.notify('node:mouseover', this.getEventArgs(e));\n  }\n  onMouseOut(e) {\n    super.onMouseOut(e);\n    this.notify('node:mouseout', this.getEventArgs(e));\n  }\n  onMouseEnter(e) {\n    this.updateClassName(e);\n    super.onMouseEnter(e);\n    this.notify('node:mouseenter', this.getEventArgs(e));\n  }\n  onMouseLeave(e) {\n    super.onMouseLeave(e);\n    this.notify('node:mouseleave', this.getEventArgs(e));\n  }\n  onMouseWheel(e, x, y, delta) {\n    super.onMouseWheel(e, x, y, delta);\n    this.notify('node:mousewheel', Object.assign({\n      delta\n    }, this.getEventArgs(e, x, y)));\n  }\n  onMagnetClick(e, magnet, x, y) {\n    const count = this.graph.view.getMouseMovedCount(e);\n    if (count > this.graph.options.clickThreshold) {\n      return;\n    }\n    this.notify('node:magnet:click', Object.assign({\n      magnet\n    }, this.getEventArgs(e, x, y)));\n  }\n  onMagnetDblClick(e, magnet, x, y) {\n    this.notify('node:magnet:dblclick', Object.assign({\n      magnet\n    }, this.getEventArgs(e, x, y)));\n  }\n  onMagnetContextMenu(e, magnet, x, y) {\n    this.notify('node:magnet:contextmenu', Object.assign({\n      magnet\n    }, this.getEventArgs(e, x, y)));\n  }\n  onMagnetMouseDown(e, magnet, x, y) {\n    this.startMagnetDragging(e, x, y);\n  }\n  onCustomEvent(e, name, x, y) {\n    this.notify('node:customevent', Object.assign({\n      name\n    }, this.getEventArgs(e, x, y)));\n    super.onCustomEvent(e, name, x, y);\n  }\n  prepareEmbedding(e) {\n    // const cell = data.cell || this.cell\n    // const graph = data.graph || this.graph\n    // const model = graph.model\n    // model.startBatch('to-front')\n    // // Bring the model to the front with all his embeds.\n    // cell.toFront({ deep: true, ui: true })\n    // const maxZ = model\n    //   .getNodes()\n    //   .reduce((max, cell) => Math.max(max, cell.getZIndex() || 0), 0)\n    // const connectedEdges = model.getConnectedEdges(cell, {\n    //   deep: true,\n    //   enclosed: true,\n    // })\n    // connectedEdges.forEach((edge) => {\n    //   const zIndex = edge.getZIndex() || 0\n    //   if (zIndex <= maxZ) {\n    //     edge.setZIndex(maxZ + 1, { ui: true })\n    //   }\n    // })\n    // model.stopBatch('to-front')\n    // Before we start looking for suitable parent we remove the current one.\n    // const parent = cell.getParent()\n    // if (parent) {\n    //   parent.unembed(cell, { ui: true })\n    // }\n    const data = this.getEventData(e);\n    const node = data.cell || this.cell;\n    const view = this.graph.findViewByCell(node);\n    const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);\n    this.notify('node:embed', {\n      e,\n      node,\n      view,\n      cell: node,\n      x: localPoint.x,\n      y: localPoint.y,\n      currentParent: node.getParent()\n    });\n  }\n  processEmbedding(e, data) {\n    const cell = data.cell || this.cell;\n    const graph = data.graph || this.graph;\n    const options = graph.options.embedding;\n    const findParent = options.findParent;\n    let candidates = typeof findParent === 'function' ? FunctionExt.call(findParent, graph, {\n      view: this,\n      node: this.cell\n    }).filter(c => {\n      return Cell.isCell(c) && this.cell.id !== c.id && !c.isDescendantOf(this.cell);\n    }) : graph.model.getNodesUnderNode(cell, {\n      by: findParent\n    });\n    // Picks the node with the highest `z` index\n    if (options.frontOnly) {\n      if (candidates.length > 0) {\n        const zIndexMap = ArrayExt.groupBy(candidates, 'zIndex');\n        const maxZIndex = ArrayExt.max(Object.keys(zIndexMap).map(z => parseInt(z, 10)));\n        if (maxZIndex) {\n          candidates = zIndexMap[maxZIndex];\n        }\n      }\n    }\n    // Filter the nodes which is invisiable\n    candidates = candidates.filter(candidate => candidate.visible);\n    let newCandidateView = null;\n    const prevCandidateView = data.candidateEmbedView;\n    const validateEmbeding = options.validate;\n    for (let i = candidates.length - 1; i >= 0; i -= 1) {\n      const candidate = candidates[i];\n      if (prevCandidateView && prevCandidateView.cell.id === candidate.id) {\n        // candidate remains the same\n        newCandidateView = prevCandidateView;\n        break;\n      } else {\n        const view = candidate.findView(graph);\n        if (FunctionExt.call(validateEmbeding, graph, {\n          child: this.cell,\n          parent: view.cell,\n          childView: this,\n          parentView: view\n        })) {\n          // flip to the new candidate\n          newCandidateView = view;\n          break;\n        }\n      }\n    }\n    this.clearEmbedding(data);\n    if (newCandidateView) {\n      newCandidateView.highlight(null, {\n        type: 'embedding'\n      });\n    }\n    data.candidateEmbedView = newCandidateView;\n    const localPoint = graph.snapToGrid(e.clientX, e.clientY);\n    this.notify('node:embedding', {\n      e,\n      cell,\n      node: cell,\n      view: graph.findViewByCell(cell),\n      x: localPoint.x,\n      y: localPoint.y,\n      currentParent: cell.getParent(),\n      candidateParent: newCandidateView ? newCandidateView.cell : null\n    });\n  }\n  clearEmbedding(data) {\n    const candidateView = data.candidateEmbedView;\n    if (candidateView) {\n      candidateView.unhighlight(null, {\n        type: 'embedding'\n      });\n      data.candidateEmbedView = null;\n    }\n  }\n  finalizeEmbedding(e, data) {\n    this.graph.startBatch('embedding');\n    const cell = data.cell || this.cell;\n    const graph = data.graph || this.graph;\n    const view = graph.findViewByCell(cell);\n    const parent = cell.getParent();\n    const candidateView = data.candidateEmbedView;\n    if (candidateView) {\n      // Candidate view is chosen to become the parent of the node.\n      candidateView.unhighlight(null, {\n        type: 'embedding'\n      });\n      data.candidateEmbedView = null;\n      if (parent == null || parent.id !== candidateView.cell.id) {\n        candidateView.cell.insertChild(cell, undefined, {\n          ui: true\n        });\n      }\n    } else if (parent) {\n      parent.unembed(cell, {\n        ui: true\n      });\n    }\n    graph.model.getConnectedEdges(cell, {\n      deep: true\n    }).forEach(edge => {\n      edge.updateParent({\n        ui: true\n      });\n    });\n    if (view && candidateView) {\n      const localPoint = graph.snapToGrid(e.clientX, e.clientY);\n      view.notify('node:embedded', {\n        e,\n        cell,\n        x: localPoint.x,\n        y: localPoint.y,\n        node: cell,\n        view: graph.findViewByCell(cell),\n        previousParent: parent,\n        currentParent: cell.getParent()\n      });\n    }\n    this.graph.stopBatch('embedding');\n  }\n  getDelegatedView() {\n    let cell = this.cell;\n    let view = this; // eslint-disable-line\n    while (view) {\n      if (cell.isEdge()) {\n        break;\n      }\n      if (!cell.hasParent() || view.can('stopDelegateOnDragging')) {\n        return view;\n      }\n      cell = cell.getParent();\n      view = this.graph.renderer.findViewByCell(cell);\n    }\n    return null;\n  }\n  startMagnetDragging(e, x, y) {\n    if (!this.can('magnetConnectable')) {\n      return;\n    }\n    e.stopPropagation();\n    const magnet = e.currentTarget;\n    const graph = this.graph;\n    this.setEventData(e, {\n      targetMagnet: magnet\n    });\n    if (graph.hook.validateMagnet(this, magnet, e)) {\n      if (graph.options.magnetThreshold <= 0) {\n        this.startConnectting(e, magnet, x, y);\n      }\n      this.setEventData(e, {\n        action: 'magnet'\n      });\n      this.stopPropagation(e);\n    } else {\n      // 只需要阻止port的冒泡 #2258\n      if (Dom.hasClass(magnet, 'x6-port-body') || JQuery(magnet).closest('.x6-port-body').length > 0) {\n        this.stopPropagation(e);\n      }\n      this.onMouseDown(e, x, y);\n    }\n    graph.view.delegateDragEvents(e, this);\n  }\n  startConnectting(e, magnet, x, y) {\n    this.graph.model.startBatch('add-edge');\n    const edgeView = this.createEdgeFromMagnet(magnet, x, y);\n    edgeView.notifyMouseDown(e, x, y); // backwards compatibility events\n    edgeView.setEventData(e, edgeView.prepareArrowheadDragging('target', {\n      x,\n      y,\n      isNewEdge: true,\n      fallbackAction: 'remove'\n    }));\n    this.setEventData(e, {\n      edgeView\n    });\n  }\n  createEdgeFromMagnet(magnet, x, y) {\n    const graph = this.graph;\n    const model = graph.model;\n    const edge = graph.hook.getDefaultEdge(this, magnet);\n    edge.setSource(Object.assign(Object.assign({}, edge.getSource()), this.getEdgeTerminal(magnet, x, y, edge, 'source')));\n    edge.setTarget(Object.assign(Object.assign({}, edge.getTarget()), {\n      x,\n      y\n    }));\n    edge.addTo(model, {\n      async: false,\n      ui: true\n    });\n    return edge.findView(graph);\n  }\n  dragMagnet(e, x, y) {\n    const data = this.getEventData(e);\n    const edgeView = data.edgeView;\n    if (edgeView) {\n      edgeView.onMouseMove(e, x, y);\n      this.autoScrollGraph(e.clientX, e.clientY);\n    } else {\n      const graph = this.graph;\n      const magnetThreshold = graph.options.magnetThreshold;\n      const currentTarget = this.getEventTarget(e);\n      const targetMagnet = data.targetMagnet;\n      // magnetThreshold when the pointer leaves the magnet\n      if (magnetThreshold === 'onleave') {\n        if (targetMagnet === currentTarget || targetMagnet.contains(currentTarget)) {\n          return;\n        }\n        // eslint-disable-next-line no-lonely-if\n      } else {\n        // magnetThreshold defined as a number of movements\n        if (graph.view.getMouseMovedCount(e) <= magnetThreshold) {\n          return;\n        }\n      }\n      this.startConnectting(e, targetMagnet, x, y);\n    }\n  }\n  stopMagnetDragging(e, x, y) {\n    const data = this.eventData(e);\n    const edgeView = data.edgeView;\n    if (edgeView) {\n      edgeView.onMouseUp(e, x, y);\n      this.graph.model.stopBatch('add-edge');\n    }\n  }\n  notifyUnhandledMouseDown(e, x, y) {\n    this.notify('node:unhandled:mousedown', {\n      e,\n      x,\n      y,\n      view: this,\n      cell: this.cell,\n      node: this.cell\n    });\n  }\n  notifyNodeMove(name, e, x, y, cell) {\n    let cells = [cell];\n    const selection = this.graph.selection.widget;\n    if (selection && selection.options.movable) {\n      const selectedCells = this.graph.getSelectedCells();\n      if (selectedCells.includes(cell)) {\n        cells = selectedCells.filter(c => c.isNode());\n      }\n    }\n    cells.forEach(c => {\n      this.notify(name, {\n        e,\n        x,\n        y,\n        cell: c,\n        node: c,\n        view: c.findView(this.graph)\n      });\n    });\n  }\n  startNodeDragging(e, x, y) {\n    const targetView = this.getDelegatedView();\n    if (targetView == null || !targetView.can('nodeMovable')) {\n      return this.notifyUnhandledMouseDown(e, x, y);\n    }\n    this.setEventData(e, {\n      targetView,\n      action: 'move'\n    });\n    const position = Point.create(targetView.cell.getPosition());\n    targetView.setEventData(e, {\n      moving: false,\n      offset: position.diff(x, y),\n      restrict: this.graph.hook.getRestrictArea(targetView)\n    });\n  }\n  dragNode(e, x, y) {\n    const node = this.cell;\n    const graph = this.graph;\n    const gridSize = graph.getGridSize();\n    const data = this.getEventData(e);\n    const offset = data.offset;\n    const restrict = data.restrict;\n    if (!data.moving) {\n      data.moving = true;\n      this.addClass('node-moving');\n      this.notifyNodeMove('node:move', e, x, y, this.cell);\n    }\n    this.autoScrollGraph(e.clientX, e.clientY);\n    const posX = Util.snapToGrid(x + offset.x, gridSize);\n    const posY = Util.snapToGrid(y + offset.y, gridSize);\n    node.setPosition(posX, posY, {\n      restrict,\n      deep: true,\n      ui: true\n    });\n    if (graph.options.embedding.enabled) {\n      if (!data.embedding) {\n        this.prepareEmbedding(e);\n        data.embedding = true;\n      }\n      this.processEmbedding(e, data);\n    }\n  }\n  stopNodeDragging(e, x, y) {\n    const data = this.getEventData(e);\n    if (data.embedding) {\n      this.finalizeEmbedding(e, data);\n    }\n    if (data.moving) {\n      this.removeClass('node-moving');\n      this.notifyNodeMove('node:moved', e, x, y, this.cell);\n    }\n    data.moving = false;\n    data.embedding = false;\n  }\n  autoScrollGraph(x, y) {\n    const scroller = this.graph.scroller.widget;\n    if (scroller) {\n      scroller.autoScroll(x, y);\n    }\n  }\n}\n(function (NodeView) {\n  NodeView.toStringTag = `X6.${NodeView.name}`;\n  function isNodeView(instance) {\n    if (instance == null) {\n      return false;\n    }\n    if (instance instanceof NodeView) {\n      return true;\n    }\n    const tag = instance[Symbol.toStringTag];\n    const view = instance;\n    if ((tag == null || tag === NodeView.toStringTag) && typeof view.isNodeView === 'function' && typeof view.isEdgeView === 'function' && typeof view.confirmUpdate === 'function' && typeof view.update === 'function' && typeof view.findPortElem === 'function' && typeof view.resize === 'function' && typeof view.rotate === 'function' && typeof view.translate === 'function') {\n      return true;\n    }\n    return false;\n  }\n  NodeView.isNodeView = isNodeView;\n})(NodeView || (NodeView = {}));\nNodeView.config({\n  isSvgElement: true,\n  priority: 0,\n  bootstrap: ['render'],\n  actions: {\n    view: ['render'],\n    markup: ['render'],\n    attrs: ['update'],\n    size: ['resize', 'ports', 'tools'],\n    angle: ['rotate', 'tools'],\n    position: ['translate', 'tools'],\n    ports: ['ports'],\n    tools: ['tools']\n  }\n});\nNodeView.registry.register('node', NodeView, true);","map":{"version":3,"names":["JQuery","Util","Config","ArrayExt","FunctionExt","Dom","Vector","Rectangle","Point","Cell","CellView","Markup","NodeView","constructor","scalableNode","rotatableNode","scalableSelector","rotatableSelector","defaultPortMarkup","getPortMarkup","defaultPortLabelMarkup","getPortLabelMarkup","defaultPortContainerMarkup","getPortContainerMarkup","portsCache","Symbol","toStringTag","getContainerClassName","classList","prefixClassName","can","push","join","updateClassName","e","target","hasAttribute","className","removeClass","addClass","isNodeView","confirmUpdate","flag","options","ret","hasAction","removePorts","cleanPortsCache","render","removeAction","handleAction","resize","update","useCSSSelector","translate","rotate","renderPorts","renderTools","partialAttrs","cleanCache","node","cell","size","getSize","attrs","getAttrs","updateAttrs","container","rootBBox","width","height","selectors","renderMarkup","markup","renderStringMarkup","renderJSONMarkup","TypeError","parseJSONMarkup","one","elems","Array","isArray","appendChild","fragment","append","toNodes","createVectors","findOne","rootSelector","empty","updateTransform","opt","updateSize","getAngle","updateTranslation","updateRotation","getTranslationString","position","getPosition","x","y","getRotationString","angle","transform","rot","setAttribute","removeAttribute","recursive","getElementsByTagName","length","scalableBBox","getBBox","sx","sy","getAttribute","rotatableBBox","graph","view","stage","prop","Object","assign","updated","findPortElem","portId","selector","cache","portRoot","portContentElement","portSelectors","portContentSelectors","initializePorts","refreshPorts","keys","forEach","cached","remove","portElement","getPortsContainer","references","childNodes","child","portsGropsByZ","groupBy","getParsedPorts","autoZIndexKey","port","getPortElement","key","zIndex","parseInt","appendPorts","updatePorts","ports","refs","map","p","before","Math","max","id","createPortElement","renderResult","elem","Error","setAttrs","group","label","portLabelElement","portLabelSelectors","portClass","hook","onPortRendered","labelContainer","labelSelectors","contentContainer","contentSelectors","updatePortGroup","groups","getParsedGroups","groupName","bbox","fromSize","metrics","getPortsLayoutByGroup","i","n","metric","portLayout","applyPortTransform","portAttrs","portSize","labelLayout","labelSize","element","layout","initialAngle","matrix","createSVGMatrix","absolute","portMarkup","portLabelMarkup","getEventArgs","notifyMouseDown","onMouseDown","notify","notifyMouseMove","onMouseMove","notifyMouseUp","onMouseUp","onClick","onDblClick","onContextMenu","isPropagationStopped","clickable","isInputElement","startNodeDragging","data","getEventData","action","dragMagnet","meta","targetView","dragNode","setEventData","stopMagnetDragging","stopNodeDragging","magnet","targetMagnet","onMagnetClick","checkMouseleave","onMouseOver","onMouseOut","onMouseEnter","onMouseLeave","onMouseWheel","delta","count","getMouseMovedCount","clickThreshold","onMagnetDblClick","onMagnetContextMenu","onMagnetMouseDown","startMagnetDragging","onCustomEvent","name","prepareEmbedding","findViewByCell","localPoint","snapToGrid","clientX","clientY","currentParent","getParent","processEmbedding","embedding","findParent","candidates","call","filter","c","isCell","isDescendantOf","model","getNodesUnderNode","by","frontOnly","zIndexMap","maxZIndex","z","candidate","visible","newCandidateView","prevCandidateView","candidateEmbedView","validateEmbeding","validate","findView","parent","childView","parentView","clearEmbedding","highlight","type","candidateParent","candidateView","unhighlight","finalizeEmbedding","startBatch","insertChild","undefined","ui","unembed","getConnectedEdges","deep","edge","updateParent","previousParent","stopBatch","getDelegatedView","isEdge","hasParent","renderer","stopPropagation","currentTarget","validateMagnet","magnetThreshold","startConnectting","hasClass","closest","delegateDragEvents","edgeView","createEdgeFromMagnet","prepareArrowheadDragging","isNewEdge","fallbackAction","getDefaultEdge","setSource","getSource","getEdgeTerminal","setTarget","getTarget","addTo","async","autoScrollGraph","getEventTarget","contains","eventData","notifyUnhandledMouseDown","notifyNodeMove","cells","selection","widget","movable","selectedCells","getSelectedCells","includes","isNode","create","moving","offset","diff","restrict","getRestrictArea","gridSize","getGridSize","posX","posY","setPosition","enabled","scroller","autoScroll","instance","tag","isEdgeView","config","isSvgElement","priority","bootstrap","actions","tools","registry","register"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/view/node.ts"],"sourcesContent":["import JQuery from 'jquery'\nimport { Util, Config } from '../global'\nimport { ArrayExt, FunctionExt, Dom, Vector } from '../util'\nimport { Rectangle, Point } from '../geometry'\nimport { Attr, PortLayout } from '../registry'\nimport { Cell } from '../model/cell'\nimport { Node } from '../model/node'\nimport { PortManager } from '../model/port'\nimport { Graph } from '../graph'\nimport { CellView } from './cell'\nimport { EdgeView } from './edge'\nimport { Markup } from './markup'\nimport { AttrManager } from './attr'\n\nexport class NodeView<\n  Entity extends Node = Node,\n  Options extends NodeView.Options = NodeView.Options,\n> extends CellView<Entity, Options> {\n  public scalableNode: Element | null = null\n  public rotatableNode: Element | null = null\n  protected readonly scalableSelector: string = 'scalable'\n  protected readonly rotatableSelector: string = 'rotatable'\n  protected readonly defaultPortMarkup = Markup.getPortMarkup()\n  protected readonly defaultPortLabelMarkup = Markup.getPortLabelMarkup()\n  protected readonly defaultPortContainerMarkup =\n    Markup.getPortContainerMarkup()\n  protected portsCache: { [id: string]: NodeView.PortCache } = {}\n\n  protected get [Symbol.toStringTag]() {\n    return NodeView.toStringTag\n  }\n\n  protected getContainerClassName() {\n    const classList = [\n      super.getContainerClassName(),\n      this.prefixClassName('node'),\n    ]\n    if (!this.can('nodeMovable')) {\n      classList.push(this.prefixClassName('node-immovable'))\n    }\n    return classList.join(' ')\n  }\n\n  protected updateClassName(e: JQuery.MouseEnterEvent) {\n    const target = e.target\n    if (target.hasAttribute('magnet')) {\n      // port\n      const className = this.prefixClassName('port-unconnectable')\n      if (this.can('magnetConnectable')) {\n        Dom.removeClass(target, className)\n      } else {\n        Dom.addClass(target, className)\n      }\n    } else {\n      // node\n      const className = this.prefixClassName('node-immovable')\n      if (this.can('nodeMovable')) {\n        this.removeClass(className)\n      } else {\n        this.addClass(className)\n      }\n    }\n  }\n\n  isNodeView(): this is NodeView {\n    return true\n  }\n\n  confirmUpdate(flag: number, options: any = {}) {\n    let ret = flag\n    if (this.hasAction(ret, 'ports')) {\n      this.removePorts()\n      this.cleanPortsCache()\n    }\n\n    if (this.hasAction(ret, 'render')) {\n      this.render()\n      ret = this.removeAction(ret, [\n        'render',\n        'update',\n        'resize',\n        'translate',\n        'rotate',\n        'ports',\n        'tools',\n      ])\n    } else {\n      ret = this.handleAction(\n        ret,\n        'resize',\n        () => this.resize(options),\n        'update', // Resize method is calling `update()` internally\n      )\n\n      ret = this.handleAction(\n        ret,\n        'update',\n        () => this.update(),\n        // `update()` will render ports when useCSSSelectors are enabled\n        Config.useCSSSelector ? 'ports' : null,\n      )\n\n      ret = this.handleAction(ret, 'translate', () => this.translate())\n      ret = this.handleAction(ret, 'rotate', () => this.rotate())\n      ret = this.handleAction(ret, 'ports', () => this.renderPorts())\n      ret = this.handleAction(ret, 'tools', () => this.renderTools())\n    }\n\n    return ret\n  }\n\n  update(partialAttrs?: Attr.CellAttrs) {\n    this.cleanCache()\n\n    // When CSS selector strings are used, make sure no rule matches port nodes.\n    if (Config.useCSSSelector) {\n      this.removePorts()\n    }\n\n    const node = this.cell\n    const size = node.getSize()\n    const attrs = node.getAttrs()\n    this.updateAttrs(this.container, attrs, {\n      attrs: partialAttrs === attrs ? null : partialAttrs,\n      rootBBox: new Rectangle(0, 0, size.width, size.height),\n      selectors: this.selectors,\n      scalableNode: this.scalableNode,\n      rotatableNode: this.rotatableNode,\n    })\n\n    if (Config.useCSSSelector) {\n      this.renderPorts()\n    }\n  }\n\n  protected renderMarkup() {\n    const markup = this.cell.markup\n    if (markup) {\n      if (typeof markup === 'string') {\n        return this.renderStringMarkup(markup)\n      }\n\n      return this.renderJSONMarkup(markup)\n    }\n\n    throw new TypeError('Invalid node markup.')\n  }\n\n  protected renderJSONMarkup(markup: Markup.JSONMarkup | Markup.JSONMarkup[]) {\n    const ret = this.parseJSONMarkup(markup, this.container)\n    const one = (elems: Element | Element[] | null) =>\n      Array.isArray(elems) ? elems[0] : elems\n    this.selectors = ret.selectors\n    this.rotatableNode = one(this.selectors[this.rotatableSelector])\n    this.scalableNode = one(this.selectors[this.scalableSelector])\n    this.container.appendChild(ret.fragment)\n  }\n\n  protected renderStringMarkup(markup: string) {\n    Dom.append(this.container, Vector.toNodes(Vector.createVectors(markup)))\n    this.rotatableNode = Dom.findOne(\n      this.container,\n      `.${this.rotatableSelector}`,\n    )\n    this.scalableNode = Dom.findOne(this.container, `.${this.scalableSelector}`)\n    this.selectors = {}\n    if (this.rootSelector) {\n      this.selectors[this.rootSelector] = this.container\n    }\n  }\n\n  render() {\n    this.empty()\n    this.renderMarkup()\n\n    if (this.scalableNode) {\n      // Double update is necessary for elements with the scalable group only\n      // Note the `resize()` triggers the other `update`.\n      this.update()\n    }\n\n    this.resize()\n\n    if (this.rotatableNode) {\n      this.rotate()\n      this.translate()\n    } else {\n      this.updateTransform()\n    }\n\n    if (!Config.useCSSSelector) {\n      this.renderPorts()\n    }\n\n    this.renderTools()\n\n    return this\n  }\n\n  resize(opt: any = {}) {\n    if (this.scalableNode) {\n      return this.updateSize(opt)\n    }\n\n    if (this.cell.getAngle()) {\n      this.rotate()\n    }\n\n    this.update()\n  }\n\n  translate() {\n    if (this.rotatableNode) {\n      return this.updateTranslation()\n    }\n\n    this.updateTransform()\n  }\n\n  rotate() {\n    if (this.rotatableNode) {\n      this.updateRotation()\n      // It's necessary to call the update for the nodes outside\n      // the rotatable group referencing nodes inside the group\n      this.update()\n      return\n    }\n\n    this.updateTransform()\n  }\n\n  protected getTranslationString() {\n    const position = this.cell.getPosition()\n    return `translate(${position.x},${position.y})`\n  }\n\n  protected getRotationString() {\n    const angle = this.cell.getAngle()\n    if (angle) {\n      const size = this.cell.getSize()\n      return `rotate(${angle},${size.width / 2},${size.height / 2})`\n    }\n  }\n\n  protected updateTransform() {\n    let transform = this.getTranslationString()\n    const rot = this.getRotationString()\n    if (rot) {\n      transform += ` ${rot}`\n    }\n    this.container.setAttribute('transform', transform)\n  }\n\n  protected updateRotation() {\n    if (this.rotatableNode != null) {\n      const transform = this.getRotationString()\n      if (transform != null) {\n        this.rotatableNode.setAttribute('transform', transform)\n      } else {\n        this.rotatableNode.removeAttribute('transform')\n      }\n    }\n  }\n\n  protected updateTranslation() {\n    this.container.setAttribute('transform', this.getTranslationString())\n  }\n\n  protected updateSize(opt: any = {}) {\n    const cell = this.cell\n    const size = cell.getSize()\n    const angle = cell.getAngle()\n    const scalableNode = this.scalableNode!\n\n    // Getting scalable group's bbox.\n    // Due to a bug in webkit's native SVG .getBBox implementation, the\n    // bbox of groups with path children includes the paths' control points.\n    // To work around the issue, we need to check whether there are any path\n    // elements inside the scalable group.\n    let recursive = false\n    if (scalableNode.getElementsByTagName('path').length > 0) {\n      // If scalable has at least one descendant that is a path, we need\n      // toswitch to recursive bbox calculation. Otherwise, group bbox\n      // calculation works and so we can use the (faster) native function.\n      recursive = true\n    }\n    const scalableBBox = Dom.getBBox(scalableNode as SVGElement, { recursive })\n\n    // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero\n    // which can happen if the element does not have any content.\n    const sx = size.width / (scalableBBox.width || 1)\n    const sy = size.height / (scalableBBox.height || 1)\n    scalableNode.setAttribute('transform', `scale(${sx},${sy})`)\n\n    // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`\n    // Order of transformations is significant but we want to reconstruct the object always in the order:\n    // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,\n    // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the\n    // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation\n    // around the center of the resized object (which is a different origin then the origin of the previous rotation)\n    // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.\n\n    // Cancel the rotation but now around a different origin, which is the center of the scaled object.\n    const rotatableNode = this.rotatableNode\n    if (rotatableNode != null) {\n      const transform = rotatableNode.getAttribute('transform')\n      if (transform) {\n        rotatableNode.setAttribute(\n          'transform',\n          `${transform} rotate(${-angle},${size.width / 2},${size.height / 2})`,\n        )\n        const rotatableBBox = Dom.getBBox(scalableNode as SVGElement, {\n          target: this.graph.view.stage,\n        })\n\n        // Store new x, y and perform rotate() again against the new rotation origin.\n        cell.prop(\n          'position',\n          { x: rotatableBBox.x, y: rotatableBBox.y },\n          { updated: true, ...opt },\n        )\n        this.translate()\n        this.rotate()\n      }\n    }\n\n    // Update must always be called on non-rotated element. Otherwise,\n    // relative positioning would work with wrong (rotated) bounding boxes.\n    this.update()\n  }\n\n  // #region ports\n\n  findPortElem(portId?: string, selector?: string) {\n    const cache = portId ? this.portsCache[portId] : null\n    if (!cache) {\n      return null\n    }\n    const portRoot = cache.portContentElement\n    const portSelectors = cache.portContentSelectors || {}\n    return this.findOne(selector, portRoot, portSelectors)\n  }\n\n  protected initializePorts() {\n    this.cleanPortsCache()\n  }\n\n  protected refreshPorts() {\n    this.removePorts()\n    this.cleanPortsCache()\n    this.renderPorts()\n  }\n\n  protected cleanPortsCache() {\n    this.portsCache = {}\n  }\n\n  protected removePorts() {\n    Object.keys(this.portsCache).forEach((portId) => {\n      const cached = this.portsCache[portId]\n      Dom.remove(cached.portElement)\n    })\n  }\n\n  protected renderPorts() {\n    const container = this.getPortsContainer()\n    // References to rendered elements without z-index\n    const references: Element[] = []\n    container.childNodes.forEach((child) => {\n      references.push(child as Element)\n    })\n\n    const portsGropsByZ = ArrayExt.groupBy(this.cell.getParsedPorts(), 'zIndex')\n    const autoZIndexKey = 'auto'\n\n    // render non-z first\n    if (portsGropsByZ[autoZIndexKey]) {\n      portsGropsByZ[autoZIndexKey].forEach((port) => {\n        const portElement = this.getPortElement(port)\n        container.append(portElement)\n        references.push(portElement)\n      })\n    }\n\n    Object.keys(portsGropsByZ).forEach((key) => {\n      if (key !== autoZIndexKey) {\n        const zIndex = parseInt(key, 10)\n        this.appendPorts(portsGropsByZ[key], zIndex, references)\n      }\n    })\n\n    this.updatePorts()\n  }\n\n  protected getPortsContainer() {\n    return this.rotatableNode || this.container\n  }\n\n  protected appendPorts(\n    ports: PortManager.Port[],\n    zIndex: number,\n    refs: Element[],\n  ) {\n    const elems = ports.map((p) => this.getPortElement(p))\n    if (refs[zIndex] || zIndex < 0) {\n      Dom.before(refs[Math.max(zIndex, 0)], elems)\n    } else {\n      Dom.append(this.getPortsContainer(), elems)\n    }\n  }\n\n  protected getPortElement(port: PortManager.Port) {\n    const cached = this.portsCache[port.id]\n    if (cached) {\n      return cached.portElement\n    }\n    return this.createPortElement(port)\n  }\n\n  protected createPortElement(port: PortManager.Port) {\n    let renderResult = Markup.renderMarkup(this.getPortContainerMarkup())\n    const portElement = renderResult.elem\n    if (portElement == null) {\n      throw new Error('Invalid port container markup.')\n    }\n\n    renderResult = Markup.renderMarkup(this.getPortMarkup(port))\n    const portContentElement = renderResult.elem\n    const portContentSelectors = renderResult.selectors\n\n    if (portContentElement == null) {\n      throw new Error('Invalid port markup.')\n    }\n\n    this.setAttrs(\n      {\n        port: port.id,\n        'port-group': port.group,\n      },\n      portContentElement,\n    )\n\n    renderResult = Markup.renderMarkup(this.getPortLabelMarkup(port.label))\n    const portLabelElement = renderResult.elem\n    const portLabelSelectors = renderResult.selectors\n\n    if (portLabelElement == null) {\n      throw new Error('Invalid port label markup.')\n    }\n\n    let portSelectors: Markup.Selectors | undefined\n    if (portContentSelectors && portLabelSelectors) {\n      // eslint-disable-next-line\n      for (const key in portLabelSelectors) {\n        if (portContentSelectors[key] && key !== this.rootSelector) {\n          throw new Error('Selectors within port must be unique.')\n        }\n      }\n      portSelectors = {\n        ...portContentSelectors,\n        ...portLabelSelectors,\n      }\n    } else {\n      portSelectors = portContentSelectors || portLabelSelectors\n    }\n\n    let portClass = 'x6-port'\n    if (port.group) {\n      portClass += ` x6-port-${port.group}`\n    }\n    Dom.addClass(portElement, portClass)\n    Dom.addClass(portContentElement, 'x6-port-body')\n    Dom.addClass(portLabelElement, 'x6-port-label')\n\n    portElement.appendChild(portContentElement)\n    portElement.appendChild(portLabelElement)\n\n    this.portsCache[port.id] = {\n      portElement,\n      portSelectors,\n      portLabelElement,\n      portLabelSelectors,\n      portContentElement,\n      portContentSelectors,\n    }\n\n    this.graph.hook.onPortRendered({\n      port,\n      node: this.cell,\n      container: portElement,\n      selectors: portSelectors,\n      labelContainer: portLabelElement,\n      labelSelectors: portLabelSelectors,\n      contentContainer: portContentElement,\n      contentSelectors: portContentSelectors,\n    })\n\n    return portElement\n  }\n\n  protected updatePorts() {\n    // Layout ports without group\n    this.updatePortGroup()\n\n    // Layout ports with explicit group\n    const groups = this.cell.getParsedGroups()\n    Object.keys(groups).forEach((groupName) => this.updatePortGroup(groupName))\n  }\n\n  protected updatePortGroup(groupName?: string) {\n    const bbox = Rectangle.fromSize(this.cell.getSize())\n    const metrics = this.cell.getPortsLayoutByGroup(groupName, bbox)\n\n    for (let i = 0, n = metrics.length; i < n; i += 1) {\n      const metric = metrics[i]\n      const portId = metric.portId\n      const cached = this.portsCache[portId] || {}\n      const portLayout = metric.portLayout\n      this.applyPortTransform(cached.portElement, portLayout)\n      if (metric.portAttrs != null) {\n        const options: Partial<AttrManager.UpdateOptions> = {\n          selectors: cached.portSelectors || {},\n        }\n\n        if (metric.portSize) {\n          options.rootBBox = Rectangle.fromSize(metric.portSize)\n        }\n\n        this.updateAttrs(cached.portElement, metric.portAttrs, options)\n      }\n\n      const labelLayout = metric.labelLayout\n      if (labelLayout) {\n        this.applyPortTransform(\n          cached.portLabelElement,\n          labelLayout,\n          -(portLayout.angle || 0),\n        )\n\n        if (labelLayout.attrs) {\n          const options: Partial<AttrManager.UpdateOptions> = {\n            selectors: cached.portLabelSelectors || {},\n          }\n\n          if (metric.labelSize) {\n            options.rootBBox = Rectangle.fromSize(metric.labelSize)\n          }\n\n          this.updateAttrs(cached.portLabelElement, labelLayout.attrs, options)\n        }\n      }\n    }\n  }\n\n  protected applyPortTransform(\n    element: Element,\n    layout: PortLayout.Result,\n    initialAngle = 0,\n  ) {\n    const angle = layout.angle\n    const position = layout.position\n    const matrix = Dom.createSVGMatrix()\n      .rotate(initialAngle)\n      .translate(position.x || 0, position.y || 0)\n      .rotate(angle || 0)\n\n    Dom.transform(element as SVGElement, matrix, { absolute: true })\n  }\n\n  protected getPortContainerMarkup() {\n    return this.cell.getPortContainerMarkup() || this.defaultPortContainerMarkup\n  }\n\n  protected getPortMarkup(port: PortManager.Port) {\n    return port.markup || this.cell.portMarkup || this.defaultPortMarkup\n  }\n\n  protected getPortLabelMarkup(label: PortManager.Label) {\n    return (\n      label.markup || this.cell.portLabelMarkup || this.defaultPortLabelMarkup\n    )\n  }\n\n  // #endregion\n\n  // #region events\n\n  protected getEventArgs<E>(e: E): NodeView.MouseEventArgs<E>\n  protected getEventArgs<E>(\n    e: E,\n    x: number,\n    y: number,\n  ): NodeView.PositionEventArgs<E>\n  protected getEventArgs<E>(e: E, x?: number, y?: number) {\n    const view = this // eslint-disable-line\n    const node = view.cell\n    const cell = node\n    if (x == null || y == null) {\n      return { e, view, node, cell } as NodeView.MouseEventArgs<E>\n    }\n    return { e, x, y, view, node, cell } as NodeView.PositionEventArgs<E>\n  }\n\n  notifyMouseDown(e: JQuery.MouseDownEvent, x: number, y: number) {\n    super.onMouseDown(e, x, y)\n    this.notify('node:mousedown', this.getEventArgs(e, x, y))\n  }\n\n  notifyMouseMove(e: JQuery.MouseMoveEvent, x: number, y: number) {\n    super.onMouseMove(e, x, y)\n    this.notify('node:mousemove', this.getEventArgs(e, x, y))\n  }\n\n  notifyMouseUp(e: JQuery.MouseUpEvent, x: number, y: number) {\n    // Problem: super will call stopBatch before event listeners\n    // attached to this **node** run. Those events will not count\n    // towards this batch, despite being triggered by the same UI event.\n    //\n    // This complicates a lot of stuff e.g. history recording.\n    //\n    // See https://github.com/antvis/X6/issues/2421 for background.\n    super.onMouseUp(e, x, y)\n    this.notify('node:mouseup', this.getEventArgs(e, x, y))\n  }\n\n  onClick(e: JQuery.ClickEvent, x: number, y: number) {\n    super.onClick(e, x, y)\n    this.notify('node:click', this.getEventArgs(e, x, y))\n  }\n\n  onDblClick(e: JQuery.DoubleClickEvent, x: number, y: number) {\n    super.onDblClick(e, x, y)\n    this.notify('node:dblclick', this.getEventArgs(e, x, y))\n  }\n\n  onContextMenu(e: JQuery.ContextMenuEvent, x: number, y: number) {\n    super.onContextMenu(e, x, y)\n    this.notify('node:contextmenu', this.getEventArgs(e, x, y))\n  }\n\n  onMouseDown(e: JQuery.MouseDownEvent, x: number, y: number) {\n    if (this.isPropagationStopped(e)) {\n      return\n    }\n    // 避免处于foreignObject内部元素触发onMouseDown导致节点被拖拽\n    // 拖拽的时候是以onMouseDown启动的\n    const target = e.target as Element\n    if (Dom.clickable(target) || Dom.isInputElement(target)) {\n      return\n    }\n    this.notifyMouseDown(e, x, y)\n    this.startNodeDragging(e, x, y)\n  }\n\n  onMouseMove(e: JQuery.MouseMoveEvent, x: number, y: number) {\n    const data = this.getEventData<EventData.Mousemove>(e)\n    const action = data.action\n    if (action === 'magnet') {\n      this.dragMagnet(e, x, y)\n    } else {\n      if (action === 'move') {\n        const meta = data as EventData.Moving\n        const view = meta.targetView || this\n        view.dragNode(e, x, y)\n        view.notify('node:moving', {\n          e,\n          x,\n          y,\n          view,\n          cell: view.cell,\n          node: view.cell,\n        })\n      }\n      this.notifyMouseMove(e, x, y)\n    }\n\n    this.setEventData<EventData.Mousemove>(e, data)\n  }\n\n  onMouseUp(e: JQuery.MouseUpEvent, x: number, y: number) {\n    const data = this.getEventData<EventData.Mousemove>(e)\n    const action = data.action\n    if (action === 'magnet') {\n      this.stopMagnetDragging(e, x, y)\n    } else {\n      // 避免处于foreignObject内部元素触发onMouseUp导致节点被选中\n      // 选中的时候是以onMouseUp启动的\n      const target = e.target as Element\n      if (Dom.clickable(target) || Dom.isInputElement(target)) {\n        return\n      }\n      this.notifyMouseUp(e, x, y)\n      if (action === 'move') {\n        const meta = data as EventData.Moving\n        const view = meta.targetView || this\n        view.stopNodeDragging(e, x, y)\n      }\n    }\n\n    const magnet = (data as EventData.Magnet).targetMagnet\n    if (magnet) {\n      this.onMagnetClick(e, magnet, x, y)\n    }\n\n    this.checkMouseleave(e)\n  }\n\n  onMouseOver(e: JQuery.MouseOverEvent) {\n    super.onMouseOver(e)\n    this.notify('node:mouseover', this.getEventArgs(e))\n  }\n\n  onMouseOut(e: JQuery.MouseOutEvent) {\n    super.onMouseOut(e)\n    this.notify('node:mouseout', this.getEventArgs(e))\n  }\n\n  onMouseEnter(e: JQuery.MouseEnterEvent) {\n    this.updateClassName(e)\n    super.onMouseEnter(e)\n    this.notify('node:mouseenter', this.getEventArgs(e))\n  }\n\n  onMouseLeave(e: JQuery.MouseLeaveEvent) {\n    super.onMouseLeave(e)\n    this.notify('node:mouseleave', this.getEventArgs(e))\n  }\n\n  onMouseWheel(e: JQuery.TriggeredEvent, x: number, y: number, delta: number) {\n    super.onMouseWheel(e, x, y, delta)\n    this.notify('node:mousewheel', {\n      delta,\n      ...this.getEventArgs(e, x, y),\n    })\n  }\n\n  onMagnetClick(e: JQuery.MouseUpEvent, magnet: Element, x: number, y: number) {\n    const count = this.graph.view.getMouseMovedCount(e)\n    if (count > this.graph.options.clickThreshold) {\n      return\n    }\n    this.notify('node:magnet:click', {\n      magnet,\n      ...this.getEventArgs(e, x, y),\n    })\n  }\n\n  onMagnetDblClick(\n    e: JQuery.DoubleClickEvent,\n    magnet: Element,\n    x: number,\n    y: number,\n  ) {\n    this.notify('node:magnet:dblclick', {\n      magnet,\n      ...this.getEventArgs(e, x, y),\n    })\n  }\n\n  onMagnetContextMenu(\n    e: JQuery.ContextMenuEvent,\n    magnet: Element,\n    x: number,\n    y: number,\n  ) {\n    this.notify('node:magnet:contextmenu', {\n      magnet,\n      ...this.getEventArgs(e, x, y),\n    })\n  }\n\n  onMagnetMouseDown(\n    e: JQuery.MouseDownEvent,\n    magnet: Element,\n    x: number,\n    y: number,\n  ) {\n    this.startMagnetDragging(e, x, y)\n  }\n\n  onCustomEvent(e: JQuery.MouseDownEvent, name: string, x: number, y: number) {\n    this.notify('node:customevent', { name, ...this.getEventArgs(e, x, y) })\n    super.onCustomEvent(e, name, x, y)\n  }\n\n  protected prepareEmbedding(e: JQuery.MouseMoveEvent) {\n    // const cell = data.cell || this.cell\n    // const graph = data.graph || this.graph\n    // const model = graph.model\n\n    // model.startBatch('to-front')\n\n    // // Bring the model to the front with all his embeds.\n    // cell.toFront({ deep: true, ui: true })\n\n    // const maxZ = model\n    //   .getNodes()\n    //   .reduce((max, cell) => Math.max(max, cell.getZIndex() || 0), 0)\n\n    // const connectedEdges = model.getConnectedEdges(cell, {\n    //   deep: true,\n    //   enclosed: true,\n    // })\n\n    // connectedEdges.forEach((edge) => {\n    //   const zIndex = edge.getZIndex() || 0\n    //   if (zIndex <= maxZ) {\n    //     edge.setZIndex(maxZ + 1, { ui: true })\n    //   }\n    // })\n\n    // model.stopBatch('to-front')\n\n    // Before we start looking for suitable parent we remove the current one.\n    // const parent = cell.getParent()\n    // if (parent) {\n    //   parent.unembed(cell, { ui: true })\n    // }\n\n    const data = this.getEventData<EventData.MovingTargetNode>(e)\n    const node = data.cell || this.cell\n    const view = this.graph.findViewByCell(node)\n    const localPoint = this.graph.snapToGrid(e.clientX, e.clientY)\n\n    this.notify('node:embed', {\n      e,\n      node,\n      view,\n      cell: node,\n      x: localPoint.x,\n      y: localPoint.y,\n      currentParent: node.getParent(),\n    })\n  }\n\n  processEmbedding(e: JQuery.MouseMoveEvent, data: EventData.MovingTargetNode) {\n    const cell = data.cell || this.cell\n    const graph = data.graph || this.graph\n    const options = graph.options.embedding\n    const findParent = options.findParent\n\n    let candidates =\n      typeof findParent === 'function'\n        ? (\n            FunctionExt.call(findParent, graph, {\n              view: this,\n              node: this.cell,\n            }) as Cell[]\n          ).filter((c) => {\n            return (\n              Cell.isCell(c) &&\n              this.cell.id !== c.id &&\n              !c.isDescendantOf(this.cell)\n            )\n          })\n        : graph.model.getNodesUnderNode(cell, {\n            by: findParent as Rectangle.KeyPoint,\n          })\n\n    // Picks the node with the highest `z` index\n    if (options.frontOnly) {\n      if (candidates.length > 0) {\n        const zIndexMap = ArrayExt.groupBy(candidates, 'zIndex')\n        const maxZIndex = ArrayExt.max(\n          Object.keys(zIndexMap).map((z) => parseInt(z, 10)),\n        )\n        if (maxZIndex) {\n          candidates = zIndexMap[maxZIndex]\n        }\n      }\n    }\n\n    // Filter the nodes which is invisiable\n    candidates = candidates.filter((candidate) => candidate.visible)\n\n    let newCandidateView = null\n    const prevCandidateView = data.candidateEmbedView\n    const validateEmbeding = options.validate\n    for (let i = candidates.length - 1; i >= 0; i -= 1) {\n      const candidate = candidates[i]\n\n      if (prevCandidateView && prevCandidateView.cell.id === candidate.id) {\n        // candidate remains the same\n        newCandidateView = prevCandidateView\n        break\n      } else {\n        const view = candidate.findView(graph) as NodeView\n        if (\n          FunctionExt.call(validateEmbeding, graph, {\n            child: this.cell,\n            parent: view.cell,\n            childView: this,\n            parentView: view,\n          })\n        ) {\n          // flip to the new candidate\n          newCandidateView = view\n          break\n        }\n      }\n    }\n\n    this.clearEmbedding(data)\n    if (newCandidateView) {\n      newCandidateView.highlight(null, { type: 'embedding' })\n    }\n    data.candidateEmbedView = newCandidateView\n\n    const localPoint = graph.snapToGrid(e.clientX, e.clientY)\n    this.notify('node:embedding', {\n      e,\n      cell,\n      node: cell,\n      view: graph.findViewByCell(cell),\n      x: localPoint.x,\n      y: localPoint.y,\n      currentParent: cell.getParent(),\n      candidateParent: newCandidateView ? newCandidateView.cell : null,\n    })\n  }\n\n  clearEmbedding(data: EventData.MovingTargetNode) {\n    const candidateView = data.candidateEmbedView\n    if (candidateView) {\n      candidateView.unhighlight(null, { type: 'embedding' })\n      data.candidateEmbedView = null\n    }\n  }\n\n  finalizeEmbedding(e: JQuery.MouseUpEvent, data: EventData.MovingTargetNode) {\n    this.graph.startBatch('embedding')\n    const cell = data.cell || this.cell\n    const graph = data.graph || this.graph\n    const view = graph.findViewByCell(cell)\n    const parent = cell.getParent()\n    const candidateView = data.candidateEmbedView\n    if (candidateView) {\n      // Candidate view is chosen to become the parent of the node.\n      candidateView.unhighlight(null, { type: 'embedding' })\n      data.candidateEmbedView = null\n      if (parent == null || parent.id !== candidateView.cell.id) {\n        candidateView.cell.insertChild(cell, undefined, { ui: true })\n      }\n    } else if (parent) {\n      parent.unembed(cell, { ui: true })\n    }\n\n    graph.model.getConnectedEdges(cell, { deep: true }).forEach((edge) => {\n      edge.updateParent({ ui: true })\n    })\n\n    if (view && candidateView) {\n      const localPoint = graph.snapToGrid(e.clientX, e.clientY)\n      view.notify('node:embedded', {\n        e,\n        cell,\n        x: localPoint.x,\n        y: localPoint.y,\n        node: cell,\n        view: graph.findViewByCell(cell),\n        previousParent: parent,\n        currentParent: cell.getParent(),\n      })\n    }\n    this.graph.stopBatch('embedding')\n  }\n\n  getDelegatedView() {\n    let cell = this.cell\n    let view: NodeView = this // eslint-disable-line\n\n    while (view) {\n      if (cell.isEdge()) {\n        break\n      }\n      if (!cell.hasParent() || view.can('stopDelegateOnDragging')) {\n        return view\n      }\n      cell = cell.getParent() as Entity\n      view = this.graph.renderer.findViewByCell(cell) as NodeView\n    }\n\n    return null\n  }\n\n  protected startMagnetDragging(\n    e: JQuery.MouseDownEvent,\n    x: number,\n    y: number,\n  ) {\n    if (!this.can('magnetConnectable')) {\n      return\n    }\n\n    e.stopPropagation()\n\n    const magnet = e.currentTarget\n    const graph = this.graph\n\n    this.setEventData<Partial<EventData.Magnet>>(e, {\n      targetMagnet: magnet,\n    })\n\n    if (graph.hook.validateMagnet(this, magnet, e)) {\n      if (graph.options.magnetThreshold <= 0) {\n        this.startConnectting(e, magnet, x, y)\n      }\n      this.setEventData<Partial<EventData.Magnet>>(e, {\n        action: 'magnet',\n      })\n      this.stopPropagation(e)\n    } else {\n      // 只需要阻止port的冒泡 #2258\n      if (\n        Dom.hasClass(magnet, 'x6-port-body') ||\n        JQuery(magnet).closest('.x6-port-body').length > 0\n      ) {\n        this.stopPropagation(e)\n      }\n      this.onMouseDown(e, x, y)\n    }\n\n    graph.view.delegateDragEvents(e, this)\n  }\n\n  protected startConnectting(\n    e: JQuery.MouseDownEvent,\n    magnet: Element,\n    x: number,\n    y: number,\n  ) {\n    this.graph.model.startBatch('add-edge')\n    const edgeView = this.createEdgeFromMagnet(magnet, x, y)\n    edgeView.notifyMouseDown(e, x, y) // backwards compatibility events\n    edgeView.setEventData(\n      e,\n      edgeView.prepareArrowheadDragging('target', {\n        x,\n        y,\n        isNewEdge: true,\n        fallbackAction: 'remove',\n      }),\n    )\n    this.setEventData<Partial<EventData.Magnet>>(e, { edgeView })\n  }\n\n  protected createEdgeFromMagnet(magnet: Element, x: number, y: number) {\n    const graph = this.graph\n    const model = graph.model\n    const edge = graph.hook.getDefaultEdge(this, magnet)\n\n    edge.setSource({\n      ...edge.getSource(),\n      ...this.getEdgeTerminal(magnet, x, y, edge, 'source'),\n    })\n    edge.setTarget({ ...edge.getTarget(), x, y })\n    edge.addTo(model, { async: false, ui: true })\n\n    return edge.findView(graph) as EdgeView\n  }\n\n  protected dragMagnet(e: JQuery.MouseMoveEvent, x: number, y: number) {\n    const data = this.getEventData<EventData.Magnet>(e)\n    const edgeView = data.edgeView\n    if (edgeView) {\n      edgeView.onMouseMove(e, x, y)\n      this.autoScrollGraph(e.clientX, e.clientY)\n    } else {\n      const graph = this.graph\n      const magnetThreshold = graph.options.magnetThreshold as any\n      const currentTarget = this.getEventTarget(e)\n      const targetMagnet = data.targetMagnet\n\n      // magnetThreshold when the pointer leaves the magnet\n      if (magnetThreshold === 'onleave') {\n        if (\n          targetMagnet === currentTarget ||\n          targetMagnet.contains(currentTarget)\n        ) {\n          return\n        }\n        // eslint-disable-next-line no-lonely-if\n      } else {\n        // magnetThreshold defined as a number of movements\n        if (graph.view.getMouseMovedCount(e) <= magnetThreshold) {\n          return\n        }\n      }\n      this.startConnectting(e as any, targetMagnet, x, y)\n    }\n  }\n\n  protected stopMagnetDragging(e: JQuery.MouseUpEvent, x: number, y: number) {\n    const data = this.eventData<EventData.Magnet>(e)\n    const edgeView = data.edgeView\n    if (edgeView) {\n      edgeView.onMouseUp(e, x, y)\n      this.graph.model.stopBatch('add-edge')\n    }\n  }\n\n  protected notifyUnhandledMouseDown(\n    e: JQuery.MouseDownEvent,\n    x: number,\n    y: number,\n  ) {\n    this.notify('node:unhandled:mousedown', {\n      e,\n      x,\n      y,\n      view: this,\n      cell: this.cell,\n      node: this.cell,\n    })\n  }\n\n  protected notifyNodeMove<Key extends keyof NodeView.EventArgs>(\n    name: Key,\n    e: JQuery.MouseMoveEvent | JQuery.MouseUpEvent,\n    x: number,\n    y: number,\n    cell: Cell,\n  ) {\n    let cells = [cell]\n\n    const selection = this.graph.selection.widget\n    if (selection && selection.options.movable) {\n      const selectedCells = this.graph.getSelectedCells()\n      if (selectedCells.includes(cell)) {\n        cells = selectedCells.filter((c: Cell) => c.isNode())\n      }\n    }\n\n    cells.forEach((c: Cell) => {\n      this.notify(name, {\n        e,\n        x,\n        y,\n        cell: c,\n        node: c,\n        view: c.findView(this.graph),\n      })\n    })\n  }\n\n  protected startNodeDragging(e: JQuery.MouseDownEvent, x: number, y: number) {\n    const targetView = this.getDelegatedView()\n    if (targetView == null || !targetView.can('nodeMovable')) {\n      return this.notifyUnhandledMouseDown(e, x, y)\n    }\n\n    this.setEventData<EventData.Moving>(e, {\n      targetView,\n      action: 'move',\n    })\n\n    const position = Point.create(targetView.cell.getPosition())\n    targetView.setEventData<EventData.MovingTargetNode>(e, {\n      moving: false,\n      offset: position.diff(x, y),\n      restrict: this.graph.hook.getRestrictArea(targetView),\n    })\n  }\n\n  protected dragNode(e: JQuery.MouseMoveEvent, x: number, y: number) {\n    const node = this.cell\n    const graph = this.graph\n    const gridSize = graph.getGridSize()\n    const data = this.getEventData<EventData.MovingTargetNode>(e)\n    const offset = data.offset\n    const restrict = data.restrict\n\n    if (!data.moving) {\n      data.moving = true\n      this.addClass('node-moving')\n      this.notifyNodeMove('node:move', e, x, y, this.cell)\n    }\n\n    this.autoScrollGraph(e.clientX, e.clientY)\n\n    const posX = Util.snapToGrid(x + offset.x, gridSize)\n    const posY = Util.snapToGrid(y + offset.y, gridSize)\n    node.setPosition(posX, posY, {\n      restrict,\n      deep: true,\n      ui: true,\n    })\n\n    if (graph.options.embedding.enabled) {\n      if (!data.embedding) {\n        this.prepareEmbedding(e)\n        data.embedding = true\n      }\n      this.processEmbedding(e, data)\n    }\n  }\n\n  protected stopNodeDragging(e: JQuery.MouseUpEvent, x: number, y: number) {\n    const data = this.getEventData<EventData.MovingTargetNode>(e)\n    if (data.embedding) {\n      this.finalizeEmbedding(e, data)\n    }\n\n    if (data.moving) {\n      this.removeClass('node-moving')\n      this.notifyNodeMove('node:moved', e, x, y, this.cell)\n    }\n\n    data.moving = false\n    data.embedding = false\n  }\n\n  protected autoScrollGraph(x: number, y: number) {\n    const scroller = this.graph.scroller.widget\n    if (scroller) {\n      scroller.autoScroll(x, y)\n    }\n  }\n\n  // #endregion\n}\n\nexport namespace NodeView {\n  export interface Options extends CellView.Options {}\n\n  export interface PortCache {\n    portElement: Element\n    portSelectors?: Markup.Selectors | null\n    portLabelElement: Element\n    portLabelSelectors?: Markup.Selectors | null\n    portContentElement: Element\n    portContentSelectors?: Markup.Selectors | null\n  }\n}\n\nexport namespace NodeView {\n  interface MagnetEventArgs {\n    magnet: Element\n  }\n\n  export interface MouseEventArgs<E> {\n    e: E\n    node: Node\n    cell: Node\n    view: NodeView\n  }\n\n  export interface PositionEventArgs<E>\n    extends MouseEventArgs<E>,\n      CellView.PositionEventArgs {}\n\n  export interface TranslateEventArgs<E> extends PositionEventArgs<E> {}\n\n  export interface ResizeEventArgs<E> extends PositionEventArgs<E> {}\n\n  export interface RotateEventArgs<E> extends PositionEventArgs<E> {}\n\n  export interface EventArgs {\n    'node:click': PositionEventArgs<JQuery.ClickEvent>\n    'node:dblclick': PositionEventArgs<JQuery.DoubleClickEvent>\n    'node:contextmenu': PositionEventArgs<JQuery.ContextMenuEvent>\n    'node:mousedown': PositionEventArgs<JQuery.MouseDownEvent>\n    'node:mousemove': PositionEventArgs<JQuery.MouseMoveEvent>\n    'node:mouseup': PositionEventArgs<JQuery.MouseUpEvent>\n    'node:mouseover': MouseEventArgs<JQuery.MouseOverEvent>\n    'node:mouseout': MouseEventArgs<JQuery.MouseOutEvent>\n    'node:mouseenter': MouseEventArgs<JQuery.MouseEnterEvent>\n    'node:mouseleave': MouseEventArgs<JQuery.MouseLeaveEvent>\n    'node:mousewheel': PositionEventArgs<JQuery.TriggeredEvent> &\n      CellView.MouseDeltaEventArgs\n\n    'node:customevent': PositionEventArgs<JQuery.MouseDownEvent> & {\n      name: string\n    }\n\n    'node:unhandled:mousedown': PositionEventArgs<JQuery.MouseDownEvent>\n\n    'node:highlight': {\n      magnet: Element\n      view: NodeView\n      node: Node\n      cell: Node\n      options: CellView.HighlightOptions\n    }\n    'node:unhighlight': EventArgs['node:highlight']\n\n    'node:magnet:click': PositionEventArgs<JQuery.MouseUpEvent> &\n      MagnetEventArgs\n    'node:magnet:dblclick': PositionEventArgs<JQuery.DoubleClickEvent> &\n      MagnetEventArgs\n    'node:magnet:contextmenu': PositionEventArgs<JQuery.ContextMenuEvent> &\n      MagnetEventArgs\n\n    'node:move': TranslateEventArgs<JQuery.MouseMoveEvent>\n    'node:moving': TranslateEventArgs<JQuery.MouseMoveEvent>\n    'node:moved': TranslateEventArgs<JQuery.MouseUpEvent>\n\n    'node:resize': ResizeEventArgs<JQuery.MouseDownEvent>\n    'node:resizing': ResizeEventArgs<JQuery.MouseMoveEvent>\n    'node:resized': ResizeEventArgs<JQuery.MouseUpEvent>\n\n    'node:rotate': RotateEventArgs<JQuery.MouseDownEvent>\n    'node:rotating': RotateEventArgs<JQuery.MouseMoveEvent>\n    'node:rotated': RotateEventArgs<JQuery.MouseUpEvent>\n\n    'node:embed': PositionEventArgs<JQuery.MouseMoveEvent> & {\n      currentParent: Node | null\n    }\n    'node:embedding': PositionEventArgs<JQuery.MouseMoveEvent> & {\n      currentParent: Node | null\n      candidateParent: Node | null\n    }\n    'node:embedded': PositionEventArgs<JQuery.MouseUpEvent> & {\n      currentParent: Node | null\n      previousParent: Node | null\n    }\n  }\n}\n\nexport namespace NodeView {\n  export const toStringTag = `X6.${NodeView.name}`\n\n  export function isNodeView(instance: any): instance is NodeView {\n    if (instance == null) {\n      return false\n    }\n\n    if (instance instanceof NodeView) {\n      return true\n    }\n\n    const tag = instance[Symbol.toStringTag]\n    const view = instance as NodeView\n\n    if (\n      (tag == null || tag === toStringTag) &&\n      typeof view.isNodeView === 'function' &&\n      typeof view.isEdgeView === 'function' &&\n      typeof view.confirmUpdate === 'function' &&\n      typeof view.update === 'function' &&\n      typeof view.findPortElem === 'function' &&\n      typeof view.resize === 'function' &&\n      typeof view.rotate === 'function' &&\n      typeof view.translate === 'function'\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n\nnamespace EventData {\n  export type Mousemove = Moving | Magnet\n\n  export interface Magnet {\n    action: 'magnet'\n    targetMagnet: Element\n    edgeView?: EdgeView\n  }\n\n  export interface Moving {\n    action: 'move'\n    targetView: NodeView\n  }\n\n  export interface MovingTargetNode {\n    moving: boolean\n    offset: Point.PointLike\n    restrict?: Rectangle.RectangleLike | null\n    embedding?: boolean\n    candidateEmbedView?: NodeView | null\n    cell?: Node\n    graph?: Graph\n  }\n}\n\nNodeView.config({\n  isSvgElement: true,\n  priority: 0,\n  bootstrap: ['render'],\n  actions: {\n    view: ['render'],\n    markup: ['render'],\n    attrs: ['update'],\n    size: ['resize', 'ports', 'tools'],\n    angle: ['rotate', 'tools'],\n    position: ['translate', 'tools'],\n    ports: ['ports'],\n    tools: ['tools'],\n  },\n})\n\nNodeView.registry.register('node', NodeView, true)\n"],"mappings":"AAAA,OAAOA,MAAM,MAAM,QAAQ;AAC3B,SAASC,IAAI,EAAEC,MAAM,QAAQ,WAAW;AACxC,SAASC,QAAQ,EAAEC,WAAW,EAAEC,GAAG,EAAEC,MAAM,QAAQ,SAAS;AAC5D,SAASC,SAAS,EAAEC,KAAK,QAAQ,aAAa;AAE9C,SAASC,IAAI,QAAQ,eAAe;AAIpC,SAASC,QAAQ,QAAQ,QAAQ;AAEjC,SAASC,MAAM,QAAQ,UAAU;AAGjC,OAAM,MAAOC,QAGX,SAAQF,QAAyB;EAHnCG,YAAA;;IAIS,KAAAC,YAAY,GAAmB,IAAI;IACnC,KAAAC,aAAa,GAAmB,IAAI;IACxB,KAAAC,gBAAgB,GAAW,UAAU;IACrC,KAAAC,iBAAiB,GAAW,WAAW;IACvC,KAAAC,iBAAiB,GAAGP,MAAM,CAACQ,aAAa,EAAE;IAC1C,KAAAC,sBAAsB,GAAGT,MAAM,CAACU,kBAAkB,EAAE;IACpD,KAAAC,0BAA0B,GAC3CX,MAAM,CAACY,sBAAsB,EAAE;IACvB,KAAAC,UAAU,GAAyC,EAAE;IAyqC/D;EACF;EAxqCE,KAAeC,MAAM,CAACC,WAAW,IAAC;IAChC,OAAOd,QAAQ,CAACc,WAAW;EAC7B;EAEUC,qBAAqBA,CAAA;IAC7B,MAAMC,SAAS,GAAG,CAChB,KAAK,CAACD,qBAAqB,EAAE,EAC7B,IAAI,CAACE,eAAe,CAAC,MAAM,CAAC,CAC7B;IACD,IAAI,CAAC,IAAI,CAACC,GAAG,CAAC,aAAa,CAAC,EAAE;MAC5BF,SAAS,CAACG,IAAI,CAAC,IAAI,CAACF,eAAe,CAAC,gBAAgB,CAAC,CAAC;;IAExD,OAAOD,SAAS,CAACI,IAAI,CAAC,GAAG,CAAC;EAC5B;EAEUC,eAAeA,CAACC,CAAyB;IACjD,MAAMC,MAAM,GAAGD,CAAC,CAACC,MAAM;IACvB,IAAIA,MAAM,CAACC,YAAY,CAAC,QAAQ,CAAC,EAAE;MACjC;MACA,MAAMC,SAAS,GAAG,IAAI,CAACR,eAAe,CAAC,oBAAoB,CAAC;MAC5D,IAAI,IAAI,CAACC,GAAG,CAAC,mBAAmB,CAAC,EAAE;QACjCzB,GAAG,CAACiC,WAAW,CAACH,MAAM,EAAEE,SAAS,CAAC;OACnC,MAAM;QACLhC,GAAG,CAACkC,QAAQ,CAACJ,MAAM,EAAEE,SAAS,CAAC;;KAElC,MAAM;MACL;MACA,MAAMA,SAAS,GAAG,IAAI,CAACR,eAAe,CAAC,gBAAgB,CAAC;MACxD,IAAI,IAAI,CAACC,GAAG,CAAC,aAAa,CAAC,EAAE;QAC3B,IAAI,CAACQ,WAAW,CAACD,SAAS,CAAC;OAC5B,MAAM;QACL,IAAI,CAACE,QAAQ,CAACF,SAAS,CAAC;;;EAG9B;EAEAG,UAAUA,CAAA;IACR,OAAO,IAAI;EACb;EAEAC,aAAaA,CAACC,IAAY,EAAEC,OAAA,GAAe,EAAE;IAC3C,IAAIC,GAAG,GAAGF,IAAI;IACd,IAAI,IAAI,CAACG,SAAS,CAACD,GAAG,EAAE,OAAO,CAAC,EAAE;MAChC,IAAI,CAACE,WAAW,EAAE;MAClB,IAAI,CAACC,eAAe,EAAE;;IAGxB,IAAI,IAAI,CAACF,SAAS,CAACD,GAAG,EAAE,QAAQ,CAAC,EAAE;MACjC,IAAI,CAACI,MAAM,EAAE;MACbJ,GAAG,GAAG,IAAI,CAACK,YAAY,CAACL,GAAG,EAAE,CAC3B,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,WAAW,EACX,QAAQ,EACR,OAAO,EACP,OAAO,CACR,CAAC;KACH,MAAM;MACLA,GAAG,GAAG,IAAI,CAACM,YAAY,CACrBN,GAAG,EACH,QAAQ,EACR,MAAM,IAAI,CAACO,MAAM,CAACR,OAAO,CAAC,EAC1B,QAAQ,CACT;MAEDC,GAAG,GAAG,IAAI,CAACM,YAAY,CACrBN,GAAG,EACH,QAAQ,EACR,MAAM,IAAI,CAACQ,MAAM,EAAE;MACnB;MACAlD,MAAM,CAACmD,cAAc,GAAG,OAAO,GAAG,IAAI,CACvC;MAEDT,GAAG,GAAG,IAAI,CAACM,YAAY,CAACN,GAAG,EAAE,WAAW,EAAE,MAAM,IAAI,CAACU,SAAS,EAAE,CAAC;MACjEV,GAAG,GAAG,IAAI,CAACM,YAAY,CAACN,GAAG,EAAE,QAAQ,EAAE,MAAM,IAAI,CAACW,MAAM,EAAE,CAAC;MAC3DX,GAAG,GAAG,IAAI,CAACM,YAAY,CAACN,GAAG,EAAE,OAAO,EAAE,MAAM,IAAI,CAACY,WAAW,EAAE,CAAC;MAC/DZ,GAAG,GAAG,IAAI,CAACM,YAAY,CAACN,GAAG,EAAE,OAAO,EAAE,MAAM,IAAI,CAACa,WAAW,EAAE,CAAC;;IAGjE,OAAOb,GAAG;EACZ;EAEAQ,MAAMA,CAACM,YAA6B;IAClC,IAAI,CAACC,UAAU,EAAE;IAEjB;IACA,IAAIzD,MAAM,CAACmD,cAAc,EAAE;MACzB,IAAI,CAACP,WAAW,EAAE;;IAGpB,MAAMc,IAAI,GAAG,IAAI,CAACC,IAAI;IACtB,MAAMC,IAAI,GAAGF,IAAI,CAACG,OAAO,EAAE;IAC3B,MAAMC,KAAK,GAAGJ,IAAI,CAACK,QAAQ,EAAE;IAC7B,IAAI,CAACC,WAAW,CAAC,IAAI,CAACC,SAAS,EAAEH,KAAK,EAAE;MACtCA,KAAK,EAAEN,YAAY,KAAKM,KAAK,GAAG,IAAI,GAAGN,YAAY;MACnDU,QAAQ,EAAE,IAAI7D,SAAS,CAAC,CAAC,EAAE,CAAC,EAAEuD,IAAI,CAACO,KAAK,EAAEP,IAAI,CAACQ,MAAM,CAAC;MACtDC,SAAS,EAAE,IAAI,CAACA,SAAS;MACzBzD,YAAY,EAAE,IAAI,CAACA,YAAY;MAC/BC,aAAa,EAAE,IAAI,CAACA;KACrB,CAAC;IAEF,IAAIb,MAAM,CAACmD,cAAc,EAAE;MACzB,IAAI,CAACG,WAAW,EAAE;;EAEtB;EAEUgB,YAAYA,CAAA;IACpB,MAAMC,MAAM,GAAG,IAAI,CAACZ,IAAI,CAACY,MAAM;IAC/B,IAAIA,MAAM,EAAE;MACV,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;QAC9B,OAAO,IAAI,CAACC,kBAAkB,CAACD,MAAM,CAAC;;MAGxC,OAAO,IAAI,CAACE,gBAAgB,CAACF,MAAM,CAAC;;IAGtC,MAAM,IAAIG,SAAS,CAAC,sBAAsB,CAAC;EAC7C;EAEUD,gBAAgBA,CAACF,MAA+C;IACxE,MAAM7B,GAAG,GAAG,IAAI,CAACiC,eAAe,CAACJ,MAAM,EAAE,IAAI,CAACN,SAAS,CAAC;IACxD,MAAMW,GAAG,GAAIC,KAAiC,IAC5CC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK;IACzC,IAAI,CAACR,SAAS,GAAG3B,GAAG,CAAC2B,SAAS;IAC9B,IAAI,CAACxD,aAAa,GAAG+D,GAAG,CAAC,IAAI,CAACP,SAAS,CAAC,IAAI,CAACtD,iBAAiB,CAAC,CAAC;IAChE,IAAI,CAACH,YAAY,GAAGgE,GAAG,CAAC,IAAI,CAACP,SAAS,CAAC,IAAI,CAACvD,gBAAgB,CAAC,CAAC;IAC9D,IAAI,CAACmD,SAAS,CAACe,WAAW,CAACtC,GAAG,CAACuC,QAAQ,CAAC;EAC1C;EAEUT,kBAAkBA,CAACD,MAAc;IACzCpE,GAAG,CAAC+E,MAAM,CAAC,IAAI,CAACjB,SAAS,EAAE7D,MAAM,CAAC+E,OAAO,CAAC/E,MAAM,CAACgF,aAAa,CAACb,MAAM,CAAC,CAAC,CAAC;IACxE,IAAI,CAAC1D,aAAa,GAAGV,GAAG,CAACkF,OAAO,CAC9B,IAAI,CAACpB,SAAS,EACd,IAAI,IAAI,CAAClD,iBAAiB,EAAE,CAC7B;IACD,IAAI,CAACH,YAAY,GAAGT,GAAG,CAACkF,OAAO,CAAC,IAAI,CAACpB,SAAS,EAAE,IAAI,IAAI,CAACnD,gBAAgB,EAAE,CAAC;IAC5E,IAAI,CAACuD,SAAS,GAAG,EAAE;IACnB,IAAI,IAAI,CAACiB,YAAY,EAAE;MACrB,IAAI,CAACjB,SAAS,CAAC,IAAI,CAACiB,YAAY,CAAC,GAAG,IAAI,CAACrB,SAAS;;EAEtD;EAEAnB,MAAMA,CAAA;IACJ,IAAI,CAACyC,KAAK,EAAE;IACZ,IAAI,CAACjB,YAAY,EAAE;IAEnB,IAAI,IAAI,CAAC1D,YAAY,EAAE;MACrB;MACA;MACA,IAAI,CAACsC,MAAM,EAAE;;IAGf,IAAI,CAACD,MAAM,EAAE;IAEb,IAAI,IAAI,CAACpC,aAAa,EAAE;MACtB,IAAI,CAACwC,MAAM,EAAE;MACb,IAAI,CAACD,SAAS,EAAE;KACjB,MAAM;MACL,IAAI,CAACoC,eAAe,EAAE;;IAGxB,IAAI,CAACxF,MAAM,CAACmD,cAAc,EAAE;MAC1B,IAAI,CAACG,WAAW,EAAE;;IAGpB,IAAI,CAACC,WAAW,EAAE;IAElB,OAAO,IAAI;EACb;EAEAN,MAAMA,CAACwC,GAAA,GAAW,EAAE;IAClB,IAAI,IAAI,CAAC7E,YAAY,EAAE;MACrB,OAAO,IAAI,CAAC8E,UAAU,CAACD,GAAG,CAAC;;IAG7B,IAAI,IAAI,CAAC9B,IAAI,CAACgC,QAAQ,EAAE,EAAE;MACxB,IAAI,CAACtC,MAAM,EAAE;;IAGf,IAAI,CAACH,MAAM,EAAE;EACf;EAEAE,SAASA,CAAA;IACP,IAAI,IAAI,CAACvC,aAAa,EAAE;MACtB,OAAO,IAAI,CAAC+E,iBAAiB,EAAE;;IAGjC,IAAI,CAACJ,eAAe,EAAE;EACxB;EAEAnC,MAAMA,CAAA;IACJ,IAAI,IAAI,CAACxC,aAAa,EAAE;MACtB,IAAI,CAACgF,cAAc,EAAE;MACrB;MACA;MACA,IAAI,CAAC3C,MAAM,EAAE;MACb;;IAGF,IAAI,CAACsC,eAAe,EAAE;EACxB;EAEUM,oBAAoBA,CAAA;IAC5B,MAAMC,QAAQ,GAAG,IAAI,CAACpC,IAAI,CAACqC,WAAW,EAAE;IACxC,OAAO,aAAaD,QAAQ,CAACE,CAAC,IAAIF,QAAQ,CAACG,CAAC,GAAG;EACjD;EAEUC,iBAAiBA,CAAA;IACzB,MAAMC,KAAK,GAAG,IAAI,CAACzC,IAAI,CAACgC,QAAQ,EAAE;IAClC,IAAIS,KAAK,EAAE;MACT,MAAMxC,IAAI,GAAG,IAAI,CAACD,IAAI,CAACE,OAAO,EAAE;MAChC,OAAO,UAAUuC,KAAK,IAAIxC,IAAI,CAACO,KAAK,GAAG,CAAC,IAAIP,IAAI,CAACQ,MAAM,GAAG,CAAC,GAAG;;EAElE;EAEUoB,eAAeA,CAAA;IACvB,IAAIa,SAAS,GAAG,IAAI,CAACP,oBAAoB,EAAE;IAC3C,MAAMQ,GAAG,GAAG,IAAI,CAACH,iBAAiB,EAAE;IACpC,IAAIG,GAAG,EAAE;MACPD,SAAS,IAAI,IAAIC,GAAG,EAAE;;IAExB,IAAI,CAACrC,SAAS,CAACsC,YAAY,CAAC,WAAW,EAAEF,SAAS,CAAC;EACrD;EAEUR,cAAcA,CAAA;IACtB,IAAI,IAAI,CAAChF,aAAa,IAAI,IAAI,EAAE;MAC9B,MAAMwF,SAAS,GAAG,IAAI,CAACF,iBAAiB,EAAE;MAC1C,IAAIE,SAAS,IAAI,IAAI,EAAE;QACrB,IAAI,CAACxF,aAAa,CAAC0F,YAAY,CAAC,WAAW,EAAEF,SAAS,CAAC;OACxD,MAAM;QACL,IAAI,CAACxF,aAAa,CAAC2F,eAAe,CAAC,WAAW,CAAC;;;EAGrD;EAEUZ,iBAAiBA,CAAA;IACzB,IAAI,CAAC3B,SAAS,CAACsC,YAAY,CAAC,WAAW,EAAE,IAAI,CAACT,oBAAoB,EAAE,CAAC;EACvE;EAEUJ,UAAUA,CAACD,GAAA,GAAW,EAAE;IAChC,MAAM9B,IAAI,GAAG,IAAI,CAACA,IAAI;IACtB,MAAMC,IAAI,GAAGD,IAAI,CAACE,OAAO,EAAE;IAC3B,MAAMuC,KAAK,GAAGzC,IAAI,CAACgC,QAAQ,EAAE;IAC7B,MAAM/E,YAAY,GAAG,IAAI,CAACA,YAAa;IAEvC;IACA;IACA;IACA;IACA;IACA,IAAI6F,SAAS,GAAG,KAAK;IACrB,IAAI7F,YAAY,CAAC8F,oBAAoB,CAAC,MAAM,CAAC,CAACC,MAAM,GAAG,CAAC,EAAE;MACxD;MACA;MACA;MACAF,SAAS,GAAG,IAAI;;IAElB,MAAMG,YAAY,GAAGzG,GAAG,CAAC0G,OAAO,CAACjG,YAA0B,EAAE;MAAE6F;IAAS,CAAE,CAAC;IAE3E;IACA;IACA,MAAMK,EAAE,GAAGlD,IAAI,CAACO,KAAK,IAAIyC,YAAY,CAACzC,KAAK,IAAI,CAAC,CAAC;IACjD,MAAM4C,EAAE,GAAGnD,IAAI,CAACQ,MAAM,IAAIwC,YAAY,CAACxC,MAAM,IAAI,CAAC,CAAC;IACnDxD,YAAY,CAAC2F,YAAY,CAAC,WAAW,EAAE,SAASO,EAAE,IAAIC,EAAE,GAAG,CAAC;IAE5D;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA,MAAMlG,aAAa,GAAG,IAAI,CAACA,aAAa;IACxC,IAAIA,aAAa,IAAI,IAAI,EAAE;MACzB,MAAMwF,SAAS,GAAGxF,aAAa,CAACmG,YAAY,CAAC,WAAW,CAAC;MACzD,IAAIX,SAAS,EAAE;QACbxF,aAAa,CAAC0F,YAAY,CACxB,WAAW,EACX,GAAGF,SAAS,WAAW,CAACD,KAAK,IAAIxC,IAAI,CAACO,KAAK,GAAG,CAAC,IAAIP,IAAI,CAACQ,MAAM,GAAG,CAAC,GAAG,CACtE;QACD,MAAM6C,aAAa,GAAG9G,GAAG,CAAC0G,OAAO,CAACjG,YAA0B,EAAE;UAC5DqB,MAAM,EAAE,IAAI,CAACiF,KAAK,CAACC,IAAI,CAACC;SACzB,CAAC;QAEF;QACAzD,IAAI,CAAC0D,IAAI,CACP,UAAU,EACV;UAAEpB,CAAC,EAAEgB,aAAa,CAAChB,CAAC;UAAEC,CAAC,EAAEe,aAAa,CAACf;QAAC,CAAE,EAAAoB,MAAA,CAAAC,MAAA;UACxCC,OAAO,EAAE;QAAI,GAAK/B,GAAG,EACxB;QACD,IAAI,CAACrC,SAAS,EAAE;QAChB,IAAI,CAACC,MAAM,EAAE;;;IAIjB;IACA;IACA,IAAI,CAACH,MAAM,EAAE;EACf;EAEA;EAEAuE,YAAYA,CAACC,MAAe,EAAEC,QAAiB;IAC7C,MAAMC,KAAK,GAAGF,MAAM,GAAG,IAAI,CAACpG,UAAU,CAACoG,MAAM,CAAC,GAAG,IAAI;IACrD,IAAI,CAACE,KAAK,EAAE;MACV,OAAO,IAAI;;IAEb,MAAMC,QAAQ,GAAGD,KAAK,CAACE,kBAAkB;IACzC,MAAMC,aAAa,GAAGH,KAAK,CAACI,oBAAoB,IAAI,EAAE;IACtD,OAAO,IAAI,CAAC3C,OAAO,CAACsC,QAAQ,EAAEE,QAAQ,EAAEE,aAAa,CAAC;EACxD;EAEUE,eAAeA,CAAA;IACvB,IAAI,CAACpF,eAAe,EAAE;EACxB;EAEUqF,YAAYA,CAAA;IACpB,IAAI,CAACtF,WAAW,EAAE;IAClB,IAAI,CAACC,eAAe,EAAE;IACtB,IAAI,CAACS,WAAW,EAAE;EACpB;EAEUT,eAAeA,CAAA;IACvB,IAAI,CAACvB,UAAU,GAAG,EAAE;EACtB;EAEUsB,WAAWA,CAAA;IACnB0E,MAAM,CAACa,IAAI,CAAC,IAAI,CAAC7G,UAAU,CAAC,CAAC8G,OAAO,CAAEV,MAAM,IAAI;MAC9C,MAAMW,MAAM,GAAG,IAAI,CAAC/G,UAAU,CAACoG,MAAM,CAAC;MACtCvH,GAAG,CAACmI,MAAM,CAACD,MAAM,CAACE,WAAW,CAAC;IAChC,CAAC,CAAC;EACJ;EAEUjF,WAAWA,CAAA;IACnB,MAAMW,SAAS,GAAG,IAAI,CAACuE,iBAAiB,EAAE;IAC1C;IACA,MAAMC,UAAU,GAAc,EAAE;IAChCxE,SAAS,CAACyE,UAAU,CAACN,OAAO,CAAEO,KAAK,IAAI;MACrCF,UAAU,CAAC5G,IAAI,CAAC8G,KAAgB,CAAC;IACnC,CAAC,CAAC;IAEF,MAAMC,aAAa,GAAG3I,QAAQ,CAAC4I,OAAO,CAAC,IAAI,CAAClF,IAAI,CAACmF,cAAc,EAAE,EAAE,QAAQ,CAAC;IAC5E,MAAMC,aAAa,GAAG,MAAM;IAE5B;IACA,IAAIH,aAAa,CAACG,aAAa,CAAC,EAAE;MAChCH,aAAa,CAACG,aAAa,CAAC,CAACX,OAAO,CAAEY,IAAI,IAAI;QAC5C,MAAMT,WAAW,GAAG,IAAI,CAACU,cAAc,CAACD,IAAI,CAAC;QAC7C/E,SAAS,CAACiB,MAAM,CAACqD,WAAW,CAAC;QAC7BE,UAAU,CAAC5G,IAAI,CAAC0G,WAAW,CAAC;MAC9B,CAAC,CAAC;;IAGJjB,MAAM,CAACa,IAAI,CAACS,aAAa,CAAC,CAACR,OAAO,CAAEc,GAAG,IAAI;MACzC,IAAIA,GAAG,KAAKH,aAAa,EAAE;QACzB,MAAMI,MAAM,GAAGC,QAAQ,CAACF,GAAG,EAAE,EAAE,CAAC;QAChC,IAAI,CAACG,WAAW,CAACT,aAAa,CAACM,GAAG,CAAC,EAAEC,MAAM,EAAEV,UAAU,CAAC;;IAE5D,CAAC,CAAC;IAEF,IAAI,CAACa,WAAW,EAAE;EACpB;EAEUd,iBAAiBA,CAAA;IACzB,OAAO,IAAI,CAAC3H,aAAa,IAAI,IAAI,CAACoD,SAAS;EAC7C;EAEUoF,WAAWA,CACnBE,KAAyB,EACzBJ,MAAc,EACdK,IAAe;IAEf,MAAM3E,KAAK,GAAG0E,KAAK,CAACE,GAAG,CAAEC,CAAC,IAAK,IAAI,CAACT,cAAc,CAACS,CAAC,CAAC,CAAC;IACtD,IAAIF,IAAI,CAACL,MAAM,CAAC,IAAIA,MAAM,GAAG,CAAC,EAAE;MAC9BhJ,GAAG,CAACwJ,MAAM,CAACH,IAAI,CAACI,IAAI,CAACC,GAAG,CAACV,MAAM,EAAE,CAAC,CAAC,CAAC,EAAEtE,KAAK,CAAC;KAC7C,MAAM;MACL1E,GAAG,CAAC+E,MAAM,CAAC,IAAI,CAACsD,iBAAiB,EAAE,EAAE3D,KAAK,CAAC;;EAE/C;EAEUoE,cAAcA,CAACD,IAAsB;IAC7C,MAAMX,MAAM,GAAG,IAAI,CAAC/G,UAAU,CAAC0H,IAAI,CAACc,EAAE,CAAC;IACvC,IAAIzB,MAAM,EAAE;MACV,OAAOA,MAAM,CAACE,WAAW;;IAE3B,OAAO,IAAI,CAACwB,iBAAiB,CAACf,IAAI,CAAC;EACrC;EAEUe,iBAAiBA,CAACf,IAAsB;IAChD,IAAIgB,YAAY,GAAGvJ,MAAM,CAAC6D,YAAY,CAAC,IAAI,CAACjD,sBAAsB,EAAE,CAAC;IACrE,MAAMkH,WAAW,GAAGyB,YAAY,CAACC,IAAI;IACrC,IAAI1B,WAAW,IAAI,IAAI,EAAE;MACvB,MAAM,IAAI2B,KAAK,CAAC,gCAAgC,CAAC;;IAGnDF,YAAY,GAAGvJ,MAAM,CAAC6D,YAAY,CAAC,IAAI,CAACrD,aAAa,CAAC+H,IAAI,CAAC,CAAC;IAC5D,MAAMlB,kBAAkB,GAAGkC,YAAY,CAACC,IAAI;IAC5C,MAAMjC,oBAAoB,GAAGgC,YAAY,CAAC3F,SAAS;IAEnD,IAAIyD,kBAAkB,IAAI,IAAI,EAAE;MAC9B,MAAM,IAAIoC,KAAK,CAAC,sBAAsB,CAAC;;IAGzC,IAAI,CAACC,QAAQ,CACX;MACEnB,IAAI,EAAEA,IAAI,CAACc,EAAE;MACb,YAAY,EAAEd,IAAI,CAACoB;KACpB,EACDtC,kBAAkB,CACnB;IAEDkC,YAAY,GAAGvJ,MAAM,CAAC6D,YAAY,CAAC,IAAI,CAACnD,kBAAkB,CAAC6H,IAAI,CAACqB,KAAK,CAAC,CAAC;IACvE,MAAMC,gBAAgB,GAAGN,YAAY,CAACC,IAAI;IAC1C,MAAMM,kBAAkB,GAAGP,YAAY,CAAC3F,SAAS;IAEjD,IAAIiG,gBAAgB,IAAI,IAAI,EAAE;MAC5B,MAAM,IAAIJ,KAAK,CAAC,4BAA4B,CAAC;;IAG/C,IAAInC,aAA2C;IAC/C,IAAIC,oBAAoB,IAAIuC,kBAAkB,EAAE;MAC9C;MACA,KAAK,MAAMrB,GAAG,IAAIqB,kBAAkB,EAAE;QACpC,IAAIvC,oBAAoB,CAACkB,GAAG,CAAC,IAAIA,GAAG,KAAK,IAAI,CAAC5D,YAAY,EAAE;UAC1D,MAAM,IAAI4E,KAAK,CAAC,uCAAuC,CAAC;;;MAG5DnC,aAAa,GAAAT,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACRS,oBAAoB,GACpBuC,kBAAkB,CACtB;KACF,MAAM;MACLxC,aAAa,GAAGC,oBAAoB,IAAIuC,kBAAkB;;IAG5D,IAAIC,SAAS,GAAG,SAAS;IACzB,IAAIxB,IAAI,CAACoB,KAAK,EAAE;MACdI,SAAS,IAAI,YAAYxB,IAAI,CAACoB,KAAK,EAAE;;IAEvCjK,GAAG,CAACkC,QAAQ,CAACkG,WAAW,EAAEiC,SAAS,CAAC;IACpCrK,GAAG,CAACkC,QAAQ,CAACyF,kBAAkB,EAAE,cAAc,CAAC;IAChD3H,GAAG,CAACkC,QAAQ,CAACiI,gBAAgB,EAAE,eAAe,CAAC;IAE/C/B,WAAW,CAACvD,WAAW,CAAC8C,kBAAkB,CAAC;IAC3CS,WAAW,CAACvD,WAAW,CAACsF,gBAAgB,CAAC;IAEzC,IAAI,CAAChJ,UAAU,CAAC0H,IAAI,CAACc,EAAE,CAAC,GAAG;MACzBvB,WAAW;MACXR,aAAa;MACbuC,gBAAgB;MAChBC,kBAAkB;MAClBzC,kBAAkB;MAClBE;KACD;IAED,IAAI,CAACd,KAAK,CAACuD,IAAI,CAACC,cAAc,CAAC;MAC7B1B,IAAI;MACJtF,IAAI,EAAE,IAAI,CAACC,IAAI;MACfM,SAAS,EAAEsE,WAAW;MACtBlE,SAAS,EAAE0D,aAAa;MACxB4C,cAAc,EAAEL,gBAAgB;MAChCM,cAAc,EAAEL,kBAAkB;MAClCM,gBAAgB,EAAE/C,kBAAkB;MACpCgD,gBAAgB,EAAE9C;KACnB,CAAC;IAEF,OAAOO,WAAW;EACpB;EAEUe,WAAWA,CAAA;IACnB;IACA,IAAI,CAACyB,eAAe,EAAE;IAEtB;IACA,MAAMC,MAAM,GAAG,IAAI,CAACrH,IAAI,CAACsH,eAAe,EAAE;IAC1C3D,MAAM,CAACa,IAAI,CAAC6C,MAAM,CAAC,CAAC5C,OAAO,CAAE8C,SAAS,IAAK,IAAI,CAACH,eAAe,CAACG,SAAS,CAAC,CAAC;EAC7E;EAEUH,eAAeA,CAACG,SAAkB;IAC1C,MAAMC,IAAI,GAAG9K,SAAS,CAAC+K,QAAQ,CAAC,IAAI,CAACzH,IAAI,CAACE,OAAO,EAAE,CAAC;IACpD,MAAMwH,OAAO,GAAG,IAAI,CAAC1H,IAAI,CAAC2H,qBAAqB,CAACJ,SAAS,EAAEC,IAAI,CAAC;IAEhE,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGH,OAAO,CAAC1E,MAAM,EAAE4E,CAAC,GAAGC,CAAC,EAAED,CAAC,IAAI,CAAC,EAAE;MACjD,MAAME,MAAM,GAAGJ,OAAO,CAACE,CAAC,CAAC;MACzB,MAAM7D,MAAM,GAAG+D,MAAM,CAAC/D,MAAM;MAC5B,MAAMW,MAAM,GAAG,IAAI,CAAC/G,UAAU,CAACoG,MAAM,CAAC,IAAI,EAAE;MAC5C,MAAMgE,UAAU,GAAGD,MAAM,CAACC,UAAU;MACpC,IAAI,CAACC,kBAAkB,CAACtD,MAAM,CAACE,WAAW,EAAEmD,UAAU,CAAC;MACvD,IAAID,MAAM,CAACG,SAAS,IAAI,IAAI,EAAE;QAC5B,MAAMnJ,OAAO,GAAuC;UAClD4B,SAAS,EAAEgE,MAAM,CAACN,aAAa,IAAI;SACpC;QAED,IAAI0D,MAAM,CAACI,QAAQ,EAAE;UACnBpJ,OAAO,CAACyB,QAAQ,GAAG7D,SAAS,CAAC+K,QAAQ,CAACK,MAAM,CAACI,QAAQ,CAAC;;QAGxD,IAAI,CAAC7H,WAAW,CAACqE,MAAM,CAACE,WAAW,EAAEkD,MAAM,CAACG,SAAS,EAAEnJ,OAAO,CAAC;;MAGjE,MAAMqJ,WAAW,GAAGL,MAAM,CAACK,WAAW;MACtC,IAAIA,WAAW,EAAE;QACf,IAAI,CAACH,kBAAkB,CACrBtD,MAAM,CAACiC,gBAAgB,EACvBwB,WAAW,EACX,EAAEJ,UAAU,CAACtF,KAAK,IAAI,CAAC,CAAC,CACzB;QAED,IAAI0F,WAAW,CAAChI,KAAK,EAAE;UACrB,MAAMrB,OAAO,GAAuC;YAClD4B,SAAS,EAAEgE,MAAM,CAACkC,kBAAkB,IAAI;WACzC;UAED,IAAIkB,MAAM,CAACM,SAAS,EAAE;YACpBtJ,OAAO,CAACyB,QAAQ,GAAG7D,SAAS,CAAC+K,QAAQ,CAACK,MAAM,CAACM,SAAS,CAAC;;UAGzD,IAAI,CAAC/H,WAAW,CAACqE,MAAM,CAACiC,gBAAgB,EAAEwB,WAAW,CAAChI,KAAK,EAAErB,OAAO,CAAC;;;;EAI7E;EAEUkJ,kBAAkBA,CAC1BK,OAAgB,EAChBC,MAAyB,EACzBC,YAAY,GAAG,CAAC;IAEhB,MAAM9F,KAAK,GAAG6F,MAAM,CAAC7F,KAAK;IAC1B,MAAML,QAAQ,GAAGkG,MAAM,CAAClG,QAAQ;IAChC,MAAMoG,MAAM,GAAGhM,GAAG,CAACiM,eAAe,EAAE,CACjC/I,MAAM,CAAC6I,YAAY,CAAC,CACpB9I,SAAS,CAAC2C,QAAQ,CAACE,CAAC,IAAI,CAAC,EAAEF,QAAQ,CAACG,CAAC,IAAI,CAAC,CAAC,CAC3C7C,MAAM,CAAC+C,KAAK,IAAI,CAAC,CAAC;IAErBjG,GAAG,CAACkG,SAAS,CAAC2F,OAAqB,EAAEG,MAAM,EAAE;MAAEE,QAAQ,EAAE;IAAI,CAAE,CAAC;EAClE;EAEUhL,sBAAsBA,CAAA;IAC9B,OAAO,IAAI,CAACsC,IAAI,CAACtC,sBAAsB,EAAE,IAAI,IAAI,CAACD,0BAA0B;EAC9E;EAEUH,aAAaA,CAAC+H,IAAsB;IAC5C,OAAOA,IAAI,CAACzE,MAAM,IAAI,IAAI,CAACZ,IAAI,CAAC2I,UAAU,IAAI,IAAI,CAACtL,iBAAiB;EACtE;EAEUG,kBAAkBA,CAACkJ,KAAwB;IACnD,OACEA,KAAK,CAAC9F,MAAM,IAAI,IAAI,CAACZ,IAAI,CAAC4I,eAAe,IAAI,IAAI,CAACrL,sBAAsB;EAE5E;EAYUsL,YAAYA,CAAIxK,CAAI,EAAEiE,CAAU,EAAEC,CAAU;IACpD,MAAMiB,IAAI,GAAG,IAAI,EAAC;IAClB,MAAMzD,IAAI,GAAGyD,IAAI,CAACxD,IAAI;IACtB,MAAMA,IAAI,GAAGD,IAAI;IACjB,IAAIuC,CAAC,IAAI,IAAI,IAAIC,CAAC,IAAI,IAAI,EAAE;MAC1B,OAAO;QAAElE,CAAC;QAAEmF,IAAI;QAAEzD,IAAI;QAAEC;MAAI,CAAgC;;IAE9D,OAAO;MAAE3B,CAAC;MAAEiE,CAAC;MAAEC,CAAC;MAAEiB,IAAI;MAAEzD,IAAI;MAAEC;IAAI,CAAmC;EACvE;EAEA8I,eAAeA,CAACzK,CAAwB,EAAEiE,CAAS,EAAEC,CAAS;IAC5D,KAAK,CAACwG,WAAW,CAAC1K,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC;IAC1B,IAAI,CAACyG,MAAM,CAAC,gBAAgB,EAAE,IAAI,CAACH,YAAY,CAACxK,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC,CAAC;EAC3D;EAEA0G,eAAeA,CAAC5K,CAAwB,EAAEiE,CAAS,EAAEC,CAAS;IAC5D,KAAK,CAAC2G,WAAW,CAAC7K,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC;IAC1B,IAAI,CAACyG,MAAM,CAAC,gBAAgB,EAAE,IAAI,CAACH,YAAY,CAACxK,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC,CAAC;EAC3D;EAEA4G,aAAaA,CAAC9K,CAAsB,EAAEiE,CAAS,EAAEC,CAAS;IACxD;IACA;IACA;IACA;IACA;IACA;IACA;IACA,KAAK,CAAC6G,SAAS,CAAC/K,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC;IACxB,IAAI,CAACyG,MAAM,CAAC,cAAc,EAAE,IAAI,CAACH,YAAY,CAACxK,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC,CAAC;EACzD;EAEA8G,OAAOA,CAAChL,CAAoB,EAAEiE,CAAS,EAAEC,CAAS;IAChD,KAAK,CAAC8G,OAAO,CAAChL,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC;IACtB,IAAI,CAACyG,MAAM,CAAC,YAAY,EAAE,IAAI,CAACH,YAAY,CAACxK,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC,CAAC;EACvD;EAEA+G,UAAUA,CAACjL,CAA0B,EAAEiE,CAAS,EAAEC,CAAS;IACzD,KAAK,CAAC+G,UAAU,CAACjL,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC;IACzB,IAAI,CAACyG,MAAM,CAAC,eAAe,EAAE,IAAI,CAACH,YAAY,CAACxK,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC,CAAC;EAC1D;EAEAgH,aAAaA,CAAClL,CAA0B,EAAEiE,CAAS,EAAEC,CAAS;IAC5D,KAAK,CAACgH,aAAa,CAAClL,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC;IAC5B,IAAI,CAACyG,MAAM,CAAC,kBAAkB,EAAE,IAAI,CAACH,YAAY,CAACxK,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC,CAAC;EAC7D;EAEAwG,WAAWA,CAAC1K,CAAwB,EAAEiE,CAAS,EAAEC,CAAS;IACxD,IAAI,IAAI,CAACiH,oBAAoB,CAACnL,CAAC,CAAC,EAAE;MAChC;;IAEF;IACA;IACA,MAAMC,MAAM,GAAGD,CAAC,CAACC,MAAiB;IAClC,IAAI9B,GAAG,CAACiN,SAAS,CAACnL,MAAM,CAAC,IAAI9B,GAAG,CAACkN,cAAc,CAACpL,MAAM,CAAC,EAAE;MACvD;;IAEF,IAAI,CAACwK,eAAe,CAACzK,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC;IAC7B,IAAI,CAACoH,iBAAiB,CAACtL,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC;EACjC;EAEA2G,WAAWA,CAAC7K,CAAwB,EAAEiE,CAAS,EAAEC,CAAS;IACxD,MAAMqH,IAAI,GAAG,IAAI,CAACC,YAAY,CAAsBxL,CAAC,CAAC;IACtD,MAAMyL,MAAM,GAAGF,IAAI,CAACE,MAAM;IAC1B,IAAIA,MAAM,KAAK,QAAQ,EAAE;MACvB,IAAI,CAACC,UAAU,CAAC1L,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC;KACzB,MAAM;MACL,IAAIuH,MAAM,KAAK,MAAM,EAAE;QACrB,MAAME,IAAI,GAAGJ,IAAwB;QACrC,MAAMpG,IAAI,GAAGwG,IAAI,CAACC,UAAU,IAAI,IAAI;QACpCzG,IAAI,CAAC0G,QAAQ,CAAC7L,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC;QACtBiB,IAAI,CAACwF,MAAM,CAAC,aAAa,EAAE;UACzB3K,CAAC;UACDiE,CAAC;UACDC,CAAC;UACDiB,IAAI;UACJxD,IAAI,EAAEwD,IAAI,CAACxD,IAAI;UACfD,IAAI,EAAEyD,IAAI,CAACxD;SACZ,CAAC;;MAEJ,IAAI,CAACiJ,eAAe,CAAC5K,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC;;IAG/B,IAAI,CAAC4H,YAAY,CAAsB9L,CAAC,EAAEuL,IAAI,CAAC;EACjD;EAEAR,SAASA,CAAC/K,CAAsB,EAAEiE,CAAS,EAAEC,CAAS;IACpD,MAAMqH,IAAI,GAAG,IAAI,CAACC,YAAY,CAAsBxL,CAAC,CAAC;IACtD,MAAMyL,MAAM,GAAGF,IAAI,CAACE,MAAM;IAC1B,IAAIA,MAAM,KAAK,QAAQ,EAAE;MACvB,IAAI,CAACM,kBAAkB,CAAC/L,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC;KACjC,MAAM;MACL;MACA;MACA,MAAMjE,MAAM,GAAGD,CAAC,CAACC,MAAiB;MAClC,IAAI9B,GAAG,CAACiN,SAAS,CAACnL,MAAM,CAAC,IAAI9B,GAAG,CAACkN,cAAc,CAACpL,MAAM,CAAC,EAAE;QACvD;;MAEF,IAAI,CAAC6K,aAAa,CAAC9K,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC;MAC3B,IAAIuH,MAAM,KAAK,MAAM,EAAE;QACrB,MAAME,IAAI,GAAGJ,IAAwB;QACrC,MAAMpG,IAAI,GAAGwG,IAAI,CAACC,UAAU,IAAI,IAAI;QACpCzG,IAAI,CAAC6G,gBAAgB,CAAChM,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC;;;IAIlC,MAAM+H,MAAM,GAAIV,IAAyB,CAACW,YAAY;IACtD,IAAID,MAAM,EAAE;MACV,IAAI,CAACE,aAAa,CAACnM,CAAC,EAAEiM,MAAM,EAAEhI,CAAC,EAAEC,CAAC,CAAC;;IAGrC,IAAI,CAACkI,eAAe,CAACpM,CAAC,CAAC;EACzB;EAEAqM,WAAWA,CAACrM,CAAwB;IAClC,KAAK,CAACqM,WAAW,CAACrM,CAAC,CAAC;IACpB,IAAI,CAAC2K,MAAM,CAAC,gBAAgB,EAAE,IAAI,CAACH,YAAY,CAACxK,CAAC,CAAC,CAAC;EACrD;EAEAsM,UAAUA,CAACtM,CAAuB;IAChC,KAAK,CAACsM,UAAU,CAACtM,CAAC,CAAC;IACnB,IAAI,CAAC2K,MAAM,CAAC,eAAe,EAAE,IAAI,CAACH,YAAY,CAACxK,CAAC,CAAC,CAAC;EACpD;EAEAuM,YAAYA,CAACvM,CAAyB;IACpC,IAAI,CAACD,eAAe,CAACC,CAAC,CAAC;IACvB,KAAK,CAACuM,YAAY,CAACvM,CAAC,CAAC;IACrB,IAAI,CAAC2K,MAAM,CAAC,iBAAiB,EAAE,IAAI,CAACH,YAAY,CAACxK,CAAC,CAAC,CAAC;EACtD;EAEAwM,YAAYA,CAACxM,CAAyB;IACpC,KAAK,CAACwM,YAAY,CAACxM,CAAC,CAAC;IACrB,IAAI,CAAC2K,MAAM,CAAC,iBAAiB,EAAE,IAAI,CAACH,YAAY,CAACxK,CAAC,CAAC,CAAC;EACtD;EAEAyM,YAAYA,CAACzM,CAAwB,EAAEiE,CAAS,EAAEC,CAAS,EAAEwI,KAAa;IACxE,KAAK,CAACD,YAAY,CAACzM,CAAC,EAAEiE,CAAC,EAAEC,CAAC,EAAEwI,KAAK,CAAC;IAClC,IAAI,CAAC/B,MAAM,CAAC,iBAAiB,EAAArF,MAAA,CAAAC,MAAA;MAC3BmH;IAAK,GACF,IAAI,CAAClC,YAAY,CAACxK,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC,EAC7B;EACJ;EAEAiI,aAAaA,CAACnM,CAAsB,EAAEiM,MAAe,EAAEhI,CAAS,EAAEC,CAAS;IACzE,MAAMyI,KAAK,GAAG,IAAI,CAACzH,KAAK,CAACC,IAAI,CAACyH,kBAAkB,CAAC5M,CAAC,CAAC;IACnD,IAAI2M,KAAK,GAAG,IAAI,CAACzH,KAAK,CAACzE,OAAO,CAACoM,cAAc,EAAE;MAC7C;;IAEF,IAAI,CAAClC,MAAM,CAAC,mBAAmB,EAAArF,MAAA,CAAAC,MAAA;MAC7B0G;IAAM,GACH,IAAI,CAACzB,YAAY,CAACxK,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC,EAC7B;EACJ;EAEA4I,gBAAgBA,CACd9M,CAA0B,EAC1BiM,MAAe,EACfhI,CAAS,EACTC,CAAS;IAET,IAAI,CAACyG,MAAM,CAAC,sBAAsB,EAAArF,MAAA,CAAAC,MAAA;MAChC0G;IAAM,GACH,IAAI,CAACzB,YAAY,CAACxK,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC,EAC7B;EACJ;EAEA6I,mBAAmBA,CACjB/M,CAA0B,EAC1BiM,MAAe,EACfhI,CAAS,EACTC,CAAS;IAET,IAAI,CAACyG,MAAM,CAAC,yBAAyB,EAAArF,MAAA,CAAAC,MAAA;MACnC0G;IAAM,GACH,IAAI,CAACzB,YAAY,CAACxK,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC,EAC7B;EACJ;EAEA8I,iBAAiBA,CACfhN,CAAwB,EACxBiM,MAAe,EACfhI,CAAS,EACTC,CAAS;IAET,IAAI,CAAC+I,mBAAmB,CAACjN,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC;EACnC;EAEAgJ,aAAaA,CAAClN,CAAwB,EAAEmN,IAAY,EAAElJ,CAAS,EAAEC,CAAS;IACxE,IAAI,CAACyG,MAAM,CAAC,kBAAkB,EAAArF,MAAA,CAAAC,MAAA;MAAI4H;IAAI,GAAK,IAAI,CAAC3C,YAAY,CAACxK,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC,EAAG;IACxE,KAAK,CAACgJ,aAAa,CAAClN,CAAC,EAAEmN,IAAI,EAAElJ,CAAC,EAAEC,CAAC,CAAC;EACpC;EAEUkJ,gBAAgBA,CAACpN,CAAwB;IACjD;IACA;IACA;IAEA;IAEA;IACA;IAEA;IACA;IACA;IAEA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IACA;IAEA;IAEA;IACA;IACA;IACA;IACA;IAEA,MAAMuL,IAAI,GAAG,IAAI,CAACC,YAAY,CAA6BxL,CAAC,CAAC;IAC7D,MAAM0B,IAAI,GAAG6J,IAAI,CAAC5J,IAAI,IAAI,IAAI,CAACA,IAAI;IACnC,MAAMwD,IAAI,GAAG,IAAI,CAACD,KAAK,CAACmI,cAAc,CAAC3L,IAAI,CAAC;IAC5C,MAAM4L,UAAU,GAAG,IAAI,CAACpI,KAAK,CAACqI,UAAU,CAACvN,CAAC,CAACwN,OAAO,EAAExN,CAAC,CAACyN,OAAO,CAAC;IAE9D,IAAI,CAAC9C,MAAM,CAAC,YAAY,EAAE;MACxB3K,CAAC;MACD0B,IAAI;MACJyD,IAAI;MACJxD,IAAI,EAAED,IAAI;MACVuC,CAAC,EAAEqJ,UAAU,CAACrJ,CAAC;MACfC,CAAC,EAAEoJ,UAAU,CAACpJ,CAAC;MACfwJ,aAAa,EAAEhM,IAAI,CAACiM,SAAS;KAC9B,CAAC;EACJ;EAEAC,gBAAgBA,CAAC5N,CAAwB,EAAEuL,IAAgC;IACzE,MAAM5J,IAAI,GAAG4J,IAAI,CAAC5J,IAAI,IAAI,IAAI,CAACA,IAAI;IACnC,MAAMuD,KAAK,GAAGqG,IAAI,CAACrG,KAAK,IAAI,IAAI,CAACA,KAAK;IACtC,MAAMzE,OAAO,GAAGyE,KAAK,CAACzE,OAAO,CAACoN,SAAS;IACvC,MAAMC,UAAU,GAAGrN,OAAO,CAACqN,UAAU;IAErC,IAAIC,UAAU,GACZ,OAAOD,UAAU,KAAK,UAAU,GAE1B5P,WAAW,CAAC8P,IAAI,CAACF,UAAU,EAAE5I,KAAK,EAAE;MAClCC,IAAI,EAAE,IAAI;MACVzD,IAAI,EAAE,IAAI,CAACC;KACZ,CACF,CAACsM,MAAM,CAAEC,CAAC,IAAI;MACb,OACE3P,IAAI,CAAC4P,MAAM,CAACD,CAAC,CAAC,IACd,IAAI,CAACvM,IAAI,CAACmG,EAAE,KAAKoG,CAAC,CAACpG,EAAE,IACrB,CAACoG,CAAC,CAACE,cAAc,CAAC,IAAI,CAACzM,IAAI,CAAC;IAEhC,CAAC,CAAC,GACFuD,KAAK,CAACmJ,KAAK,CAACC,iBAAiB,CAAC3M,IAAI,EAAE;MAClC4M,EAAE,EAAET;KACL,CAAC;IAER;IACA,IAAIrN,OAAO,CAAC+N,SAAS,EAAE;MACrB,IAAIT,UAAU,CAACpJ,MAAM,GAAG,CAAC,EAAE;QACzB,MAAM8J,SAAS,GAAGxQ,QAAQ,CAAC4I,OAAO,CAACkH,UAAU,EAAE,QAAQ,CAAC;QACxD,MAAMW,SAAS,GAAGzQ,QAAQ,CAAC4J,GAAG,CAC5BvC,MAAM,CAACa,IAAI,CAACsI,SAAS,CAAC,CAAChH,GAAG,CAAEkH,CAAC,IAAKvH,QAAQ,CAACuH,CAAC,EAAE,EAAE,CAAC,CAAC,CACnD;QACD,IAAID,SAAS,EAAE;UACbX,UAAU,GAAGU,SAAS,CAACC,SAAS,CAAC;;;;IAKvC;IACAX,UAAU,GAAGA,UAAU,CAACE,MAAM,CAAEW,SAAS,IAAKA,SAAS,CAACC,OAAO,CAAC;IAEhE,IAAIC,gBAAgB,GAAG,IAAI;IAC3B,MAAMC,iBAAiB,GAAGxD,IAAI,CAACyD,kBAAkB;IACjD,MAAMC,gBAAgB,GAAGxO,OAAO,CAACyO,QAAQ;IACzC,KAAK,IAAI3F,CAAC,GAAGwE,UAAU,CAACpJ,MAAM,GAAG,CAAC,EAAE4E,CAAC,IAAI,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;MAClD,MAAMqF,SAAS,GAAGb,UAAU,CAACxE,CAAC,CAAC;MAE/B,IAAIwF,iBAAiB,IAAIA,iBAAiB,CAACpN,IAAI,CAACmG,EAAE,KAAK8G,SAAS,CAAC9G,EAAE,EAAE;QACnE;QACAgH,gBAAgB,GAAGC,iBAAiB;QACpC;OACD,MAAM;QACL,MAAM5J,IAAI,GAAGyJ,SAAS,CAACO,QAAQ,CAACjK,KAAK,CAAa;QAClD,IACEhH,WAAW,CAAC8P,IAAI,CAACiB,gBAAgB,EAAE/J,KAAK,EAAE;UACxCyB,KAAK,EAAE,IAAI,CAAChF,IAAI;UAChByN,MAAM,EAAEjK,IAAI,CAACxD,IAAI;UACjB0N,SAAS,EAAE,IAAI;UACfC,UAAU,EAAEnK;SACb,CAAC,EACF;UACA;UACA2J,gBAAgB,GAAG3J,IAAI;UACvB;;;;IAKN,IAAI,CAACoK,cAAc,CAAChE,IAAI,CAAC;IACzB,IAAIuD,gBAAgB,EAAE;MACpBA,gBAAgB,CAACU,SAAS,CAAC,IAAI,EAAE;QAAEC,IAAI,EAAE;MAAW,CAAE,CAAC;;IAEzDlE,IAAI,CAACyD,kBAAkB,GAAGF,gBAAgB;IAE1C,MAAMxB,UAAU,GAAGpI,KAAK,CAACqI,UAAU,CAACvN,CAAC,CAACwN,OAAO,EAAExN,CAAC,CAACyN,OAAO,CAAC;IACzD,IAAI,CAAC9C,MAAM,CAAC,gBAAgB,EAAE;MAC5B3K,CAAC;MACD2B,IAAI;MACJD,IAAI,EAAEC,IAAI;MACVwD,IAAI,EAAED,KAAK,CAACmI,cAAc,CAAC1L,IAAI,CAAC;MAChCsC,CAAC,EAAEqJ,UAAU,CAACrJ,CAAC;MACfC,CAAC,EAAEoJ,UAAU,CAACpJ,CAAC;MACfwJ,aAAa,EAAE/L,IAAI,CAACgM,SAAS,EAAE;MAC/B+B,eAAe,EAAEZ,gBAAgB,GAAGA,gBAAgB,CAACnN,IAAI,GAAG;KAC7D,CAAC;EACJ;EAEA4N,cAAcA,CAAChE,IAAgC;IAC7C,MAAMoE,aAAa,GAAGpE,IAAI,CAACyD,kBAAkB;IAC7C,IAAIW,aAAa,EAAE;MACjBA,aAAa,CAACC,WAAW,CAAC,IAAI,EAAE;QAAEH,IAAI,EAAE;MAAW,CAAE,CAAC;MACtDlE,IAAI,CAACyD,kBAAkB,GAAG,IAAI;;EAElC;EAEAa,iBAAiBA,CAAC7P,CAAsB,EAAEuL,IAAgC;IACxE,IAAI,CAACrG,KAAK,CAAC4K,UAAU,CAAC,WAAW,CAAC;IAClC,MAAMnO,IAAI,GAAG4J,IAAI,CAAC5J,IAAI,IAAI,IAAI,CAACA,IAAI;IACnC,MAAMuD,KAAK,GAAGqG,IAAI,CAACrG,KAAK,IAAI,IAAI,CAACA,KAAK;IACtC,MAAMC,IAAI,GAAGD,KAAK,CAACmI,cAAc,CAAC1L,IAAI,CAAC;IACvC,MAAMyN,MAAM,GAAGzN,IAAI,CAACgM,SAAS,EAAE;IAC/B,MAAMgC,aAAa,GAAGpE,IAAI,CAACyD,kBAAkB;IAC7C,IAAIW,aAAa,EAAE;MACjB;MACAA,aAAa,CAACC,WAAW,CAAC,IAAI,EAAE;QAAEH,IAAI,EAAE;MAAW,CAAE,CAAC;MACtDlE,IAAI,CAACyD,kBAAkB,GAAG,IAAI;MAC9B,IAAII,MAAM,IAAI,IAAI,IAAIA,MAAM,CAACtH,EAAE,KAAK6H,aAAa,CAAChO,IAAI,CAACmG,EAAE,EAAE;QACzD6H,aAAa,CAAChO,IAAI,CAACoO,WAAW,CAACpO,IAAI,EAAEqO,SAAS,EAAE;UAAEC,EAAE,EAAE;QAAI,CAAE,CAAC;;KAEhE,MAAM,IAAIb,MAAM,EAAE;MACjBA,MAAM,CAACc,OAAO,CAACvO,IAAI,EAAE;QAAEsO,EAAE,EAAE;MAAI,CAAE,CAAC;;IAGpC/K,KAAK,CAACmJ,KAAK,CAAC8B,iBAAiB,CAACxO,IAAI,EAAE;MAAEyO,IAAI,EAAE;IAAI,CAAE,CAAC,CAAChK,OAAO,CAAEiK,IAAI,IAAI;MACnEA,IAAI,CAACC,YAAY,CAAC;QAAEL,EAAE,EAAE;MAAI,CAAE,CAAC;IACjC,CAAC,CAAC;IAEF,IAAI9K,IAAI,IAAIwK,aAAa,EAAE;MACzB,MAAMrC,UAAU,GAAGpI,KAAK,CAACqI,UAAU,CAACvN,CAAC,CAACwN,OAAO,EAAExN,CAAC,CAACyN,OAAO,CAAC;MACzDtI,IAAI,CAACwF,MAAM,CAAC,eAAe,EAAE;QAC3B3K,CAAC;QACD2B,IAAI;QACJsC,CAAC,EAAEqJ,UAAU,CAACrJ,CAAC;QACfC,CAAC,EAAEoJ,UAAU,CAACpJ,CAAC;QACfxC,IAAI,EAAEC,IAAI;QACVwD,IAAI,EAAED,KAAK,CAACmI,cAAc,CAAC1L,IAAI,CAAC;QAChC4O,cAAc,EAAEnB,MAAM;QACtB1B,aAAa,EAAE/L,IAAI,CAACgM,SAAS;OAC9B,CAAC;;IAEJ,IAAI,CAACzI,KAAK,CAACsL,SAAS,CAAC,WAAW,CAAC;EACnC;EAEAC,gBAAgBA,CAAA;IACd,IAAI9O,IAAI,GAAG,IAAI,CAACA,IAAI;IACpB,IAAIwD,IAAI,GAAa,IAAI,EAAC;IAE1B,OAAOA,IAAI,EAAE;MACX,IAAIxD,IAAI,CAAC+O,MAAM,EAAE,EAAE;QACjB;;MAEF,IAAI,CAAC/O,IAAI,CAACgP,SAAS,EAAE,IAAIxL,IAAI,CAACvF,GAAG,CAAC,wBAAwB,CAAC,EAAE;QAC3D,OAAOuF,IAAI;;MAEbxD,IAAI,GAAGA,IAAI,CAACgM,SAAS,EAAY;MACjCxI,IAAI,GAAG,IAAI,CAACD,KAAK,CAAC0L,QAAQ,CAACvD,cAAc,CAAC1L,IAAI,CAAa;;IAG7D,OAAO,IAAI;EACb;EAEUsL,mBAAmBA,CAC3BjN,CAAwB,EACxBiE,CAAS,EACTC,CAAS;IAET,IAAI,CAAC,IAAI,CAACtE,GAAG,CAAC,mBAAmB,CAAC,EAAE;MAClC;;IAGFI,CAAC,CAAC6Q,eAAe,EAAE;IAEnB,MAAM5E,MAAM,GAAGjM,CAAC,CAAC8Q,aAAa;IAC9B,MAAM5L,KAAK,GAAG,IAAI,CAACA,KAAK;IAExB,IAAI,CAAC4G,YAAY,CAA4B9L,CAAC,EAAE;MAC9CkM,YAAY,EAAED;KACf,CAAC;IAEF,IAAI/G,KAAK,CAACuD,IAAI,CAACsI,cAAc,CAAC,IAAI,EAAE9E,MAAM,EAAEjM,CAAC,CAAC,EAAE;MAC9C,IAAIkF,KAAK,CAACzE,OAAO,CAACuQ,eAAe,IAAI,CAAC,EAAE;QACtC,IAAI,CAACC,gBAAgB,CAACjR,CAAC,EAAEiM,MAAM,EAAEhI,CAAC,EAAEC,CAAC,CAAC;;MAExC,IAAI,CAAC4H,YAAY,CAA4B9L,CAAC,EAAE;QAC9CyL,MAAM,EAAE;OACT,CAAC;MACF,IAAI,CAACoF,eAAe,CAAC7Q,CAAC,CAAC;KACxB,MAAM;MACL;MACA,IACE7B,GAAG,CAAC+S,QAAQ,CAACjF,MAAM,EAAE,cAAc,CAAC,IACpCnO,MAAM,CAACmO,MAAM,CAAC,CAACkF,OAAO,CAAC,eAAe,CAAC,CAACxM,MAAM,GAAG,CAAC,EAClD;QACA,IAAI,CAACkM,eAAe,CAAC7Q,CAAC,CAAC;;MAEzB,IAAI,CAAC0K,WAAW,CAAC1K,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC;;IAG3BgB,KAAK,CAACC,IAAI,CAACiM,kBAAkB,CAACpR,CAAC,EAAE,IAAI,CAAC;EACxC;EAEUiR,gBAAgBA,CACxBjR,CAAwB,EACxBiM,MAAe,EACfhI,CAAS,EACTC,CAAS;IAET,IAAI,CAACgB,KAAK,CAACmJ,KAAK,CAACyB,UAAU,CAAC,UAAU,CAAC;IACvC,MAAMuB,QAAQ,GAAG,IAAI,CAACC,oBAAoB,CAACrF,MAAM,EAAEhI,CAAC,EAAEC,CAAC,CAAC;IACxDmN,QAAQ,CAAC5G,eAAe,CAACzK,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC,EAAC;IAClCmN,QAAQ,CAACvF,YAAY,CACnB9L,CAAC,EACDqR,QAAQ,CAACE,wBAAwB,CAAC,QAAQ,EAAE;MAC1CtN,CAAC;MACDC,CAAC;MACDsN,SAAS,EAAE,IAAI;MACfC,cAAc,EAAE;KACjB,CAAC,CACH;IACD,IAAI,CAAC3F,YAAY,CAA4B9L,CAAC,EAAE;MAAEqR;IAAQ,CAAE,CAAC;EAC/D;EAEUC,oBAAoBA,CAACrF,MAAe,EAAEhI,CAAS,EAAEC,CAAS;IAClE,MAAMgB,KAAK,GAAG,IAAI,CAACA,KAAK;IACxB,MAAMmJ,KAAK,GAAGnJ,KAAK,CAACmJ,KAAK;IACzB,MAAMgC,IAAI,GAAGnL,KAAK,CAACuD,IAAI,CAACiJ,cAAc,CAAC,IAAI,EAAEzF,MAAM,CAAC;IAEpDoE,IAAI,CAACsB,SAAS,CAAArM,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACT8K,IAAI,CAACuB,SAAS,EAAE,GAChB,IAAI,CAACC,eAAe,CAAC5F,MAAM,EAAEhI,CAAC,EAAEC,CAAC,EAAEmM,IAAI,EAAE,QAAQ,CAAC,EACrD;IACFA,IAAI,CAACyB,SAAS,CAAAxM,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAM8K,IAAI,CAAC0B,SAAS,EAAE;MAAE9N,CAAC;MAAEC;IAAC,GAAG;IAC7CmM,IAAI,CAAC2B,KAAK,CAAC3D,KAAK,EAAE;MAAE4D,KAAK,EAAE,KAAK;MAAEhC,EAAE,EAAE;IAAI,CAAE,CAAC;IAE7C,OAAOI,IAAI,CAAClB,QAAQ,CAACjK,KAAK,CAAa;EACzC;EAEUwG,UAAUA,CAAC1L,CAAwB,EAAEiE,CAAS,EAAEC,CAAS;IACjE,MAAMqH,IAAI,GAAG,IAAI,CAACC,YAAY,CAAmBxL,CAAC,CAAC;IACnD,MAAMqR,QAAQ,GAAG9F,IAAI,CAAC8F,QAAQ;IAC9B,IAAIA,QAAQ,EAAE;MACZA,QAAQ,CAACxG,WAAW,CAAC7K,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC;MAC7B,IAAI,CAACgO,eAAe,CAAClS,CAAC,CAACwN,OAAO,EAAExN,CAAC,CAACyN,OAAO,CAAC;KAC3C,MAAM;MACL,MAAMvI,KAAK,GAAG,IAAI,CAACA,KAAK;MACxB,MAAM8L,eAAe,GAAG9L,KAAK,CAACzE,OAAO,CAACuQ,eAAsB;MAC5D,MAAMF,aAAa,GAAG,IAAI,CAACqB,cAAc,CAACnS,CAAC,CAAC;MAC5C,MAAMkM,YAAY,GAAGX,IAAI,CAACW,YAAY;MAEtC;MACA,IAAI8E,eAAe,KAAK,SAAS,EAAE;QACjC,IACE9E,YAAY,KAAK4E,aAAa,IAC9B5E,YAAY,CAACkG,QAAQ,CAACtB,aAAa,CAAC,EACpC;UACA;;QAEF;OACD,MAAM;QACL;QACA,IAAI5L,KAAK,CAACC,IAAI,CAACyH,kBAAkB,CAAC5M,CAAC,CAAC,IAAIgR,eAAe,EAAE;UACvD;;;MAGJ,IAAI,CAACC,gBAAgB,CAACjR,CAAQ,EAAEkM,YAAY,EAAEjI,CAAC,EAAEC,CAAC,CAAC;;EAEvD;EAEU6H,kBAAkBA,CAAC/L,CAAsB,EAAEiE,CAAS,EAAEC,CAAS;IACvE,MAAMqH,IAAI,GAAG,IAAI,CAAC8G,SAAS,CAAmBrS,CAAC,CAAC;IAChD,MAAMqR,QAAQ,GAAG9F,IAAI,CAAC8F,QAAQ;IAC9B,IAAIA,QAAQ,EAAE;MACZA,QAAQ,CAACtG,SAAS,CAAC/K,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC;MAC3B,IAAI,CAACgB,KAAK,CAACmJ,KAAK,CAACmC,SAAS,CAAC,UAAU,CAAC;;EAE1C;EAEU8B,wBAAwBA,CAChCtS,CAAwB,EACxBiE,CAAS,EACTC,CAAS;IAET,IAAI,CAACyG,MAAM,CAAC,0BAA0B,EAAE;MACtC3K,CAAC;MACDiE,CAAC;MACDC,CAAC;MACDiB,IAAI,EAAE,IAAI;MACVxD,IAAI,EAAE,IAAI,CAACA,IAAI;MACfD,IAAI,EAAE,IAAI,CAACC;KACZ,CAAC;EACJ;EAEU4Q,cAAcA,CACtBpF,IAAS,EACTnN,CAA8C,EAC9CiE,CAAS,EACTC,CAAS,EACTvC,IAAU;IAEV,IAAI6Q,KAAK,GAAG,CAAC7Q,IAAI,CAAC;IAElB,MAAM8Q,SAAS,GAAG,IAAI,CAACvN,KAAK,CAACuN,SAAS,CAACC,MAAM;IAC7C,IAAID,SAAS,IAAIA,SAAS,CAAChS,OAAO,CAACkS,OAAO,EAAE;MAC1C,MAAMC,aAAa,GAAG,IAAI,CAAC1N,KAAK,CAAC2N,gBAAgB,EAAE;MACnD,IAAID,aAAa,CAACE,QAAQ,CAACnR,IAAI,CAAC,EAAE;QAChC6Q,KAAK,GAAGI,aAAa,CAAC3E,MAAM,CAAEC,CAAO,IAAKA,CAAC,CAAC6E,MAAM,EAAE,CAAC;;;IAIzDP,KAAK,CAACpM,OAAO,CAAE8H,CAAO,IAAI;MACxB,IAAI,CAACvD,MAAM,CAACwC,IAAI,EAAE;QAChBnN,CAAC;QACDiE,CAAC;QACDC,CAAC;QACDvC,IAAI,EAAEuM,CAAC;QACPxM,IAAI,EAAEwM,CAAC;QACP/I,IAAI,EAAE+I,CAAC,CAACiB,QAAQ,CAAC,IAAI,CAACjK,KAAK;OAC5B,CAAC;IACJ,CAAC,CAAC;EACJ;EAEUoG,iBAAiBA,CAACtL,CAAwB,EAAEiE,CAAS,EAAEC,CAAS;IACxE,MAAM0H,UAAU,GAAG,IAAI,CAAC6E,gBAAgB,EAAE;IAC1C,IAAI7E,UAAU,IAAI,IAAI,IAAI,CAACA,UAAU,CAAChM,GAAG,CAAC,aAAa,CAAC,EAAE;MACxD,OAAO,IAAI,CAAC0S,wBAAwB,CAACtS,CAAC,EAAEiE,CAAC,EAAEC,CAAC,CAAC;;IAG/C,IAAI,CAAC4H,YAAY,CAAmB9L,CAAC,EAAE;MACrC4L,UAAU;MACVH,MAAM,EAAE;KACT,CAAC;IAEF,MAAM1H,QAAQ,GAAGzF,KAAK,CAAC0U,MAAM,CAACpH,UAAU,CAACjK,IAAI,CAACqC,WAAW,EAAE,CAAC;IAC5D4H,UAAU,CAACE,YAAY,CAA6B9L,CAAC,EAAE;MACrDiT,MAAM,EAAE,KAAK;MACbC,MAAM,EAAEnP,QAAQ,CAACoP,IAAI,CAAClP,CAAC,EAAEC,CAAC,CAAC;MAC3BkP,QAAQ,EAAE,IAAI,CAAClO,KAAK,CAACuD,IAAI,CAAC4K,eAAe,CAACzH,UAAU;KACrD,CAAC;EACJ;EAEUC,QAAQA,CAAC7L,CAAwB,EAAEiE,CAAS,EAAEC,CAAS;IAC/D,MAAMxC,IAAI,GAAG,IAAI,CAACC,IAAI;IACtB,MAAMuD,KAAK,GAAG,IAAI,CAACA,KAAK;IACxB,MAAMoO,QAAQ,GAAGpO,KAAK,CAACqO,WAAW,EAAE;IACpC,MAAMhI,IAAI,GAAG,IAAI,CAACC,YAAY,CAA6BxL,CAAC,CAAC;IAC7D,MAAMkT,MAAM,GAAG3H,IAAI,CAAC2H,MAAM;IAC1B,MAAME,QAAQ,GAAG7H,IAAI,CAAC6H,QAAQ;IAE9B,IAAI,CAAC7H,IAAI,CAAC0H,MAAM,EAAE;MAChB1H,IAAI,CAAC0H,MAAM,GAAG,IAAI;MAClB,IAAI,CAAC5S,QAAQ,CAAC,aAAa,CAAC;MAC5B,IAAI,CAACkS,cAAc,CAAC,WAAW,EAAEvS,CAAC,EAAEiE,CAAC,EAAEC,CAAC,EAAE,IAAI,CAACvC,IAAI,CAAC;;IAGtD,IAAI,CAACuQ,eAAe,CAAClS,CAAC,CAACwN,OAAO,EAAExN,CAAC,CAACyN,OAAO,CAAC;IAE1C,MAAM+F,IAAI,GAAGzV,IAAI,CAACwP,UAAU,CAACtJ,CAAC,GAAGiP,MAAM,CAACjP,CAAC,EAAEqP,QAAQ,CAAC;IACpD,MAAMG,IAAI,GAAG1V,IAAI,CAACwP,UAAU,CAACrJ,CAAC,GAAGgP,MAAM,CAAChP,CAAC,EAAEoP,QAAQ,CAAC;IACpD5R,IAAI,CAACgS,WAAW,CAACF,IAAI,EAAEC,IAAI,EAAE;MAC3BL,QAAQ;MACRhD,IAAI,EAAE,IAAI;MACVH,EAAE,EAAE;KACL,CAAC;IAEF,IAAI/K,KAAK,CAACzE,OAAO,CAACoN,SAAS,CAAC8F,OAAO,EAAE;MACnC,IAAI,CAACpI,IAAI,CAACsC,SAAS,EAAE;QACnB,IAAI,CAACT,gBAAgB,CAACpN,CAAC,CAAC;QACxBuL,IAAI,CAACsC,SAAS,GAAG,IAAI;;MAEvB,IAAI,CAACD,gBAAgB,CAAC5N,CAAC,EAAEuL,IAAI,CAAC;;EAElC;EAEUS,gBAAgBA,CAAChM,CAAsB,EAAEiE,CAAS,EAAEC,CAAS;IACrE,MAAMqH,IAAI,GAAG,IAAI,CAACC,YAAY,CAA6BxL,CAAC,CAAC;IAC7D,IAAIuL,IAAI,CAACsC,SAAS,EAAE;MAClB,IAAI,CAACgC,iBAAiB,CAAC7P,CAAC,EAAEuL,IAAI,CAAC;;IAGjC,IAAIA,IAAI,CAAC0H,MAAM,EAAE;MACf,IAAI,CAAC7S,WAAW,CAAC,aAAa,CAAC;MAC/B,IAAI,CAACmS,cAAc,CAAC,YAAY,EAAEvS,CAAC,EAAEiE,CAAC,EAAEC,CAAC,EAAE,IAAI,CAACvC,IAAI,CAAC;;IAGvD4J,IAAI,CAAC0H,MAAM,GAAG,KAAK;IACnB1H,IAAI,CAACsC,SAAS,GAAG,KAAK;EACxB;EAEUqE,eAAeA,CAACjO,CAAS,EAAEC,CAAS;IAC5C,MAAM0P,QAAQ,GAAG,IAAI,CAAC1O,KAAK,CAAC0O,QAAQ,CAAClB,MAAM;IAC3C,IAAIkB,QAAQ,EAAE;MACZA,QAAQ,CAACC,UAAU,CAAC5P,CAAC,EAAEC,CAAC,CAAC;;EAE7B;;AAsGF,WAAiBxF,QAAQ;EACVA,QAAA,CAAAc,WAAW,GAAG,MAAMd,QAAQ,CAACyO,IAAI,EAAE;EAEhD,SAAgB7M,UAAUA,CAACwT,QAAa;IACtC,IAAIA,QAAQ,IAAI,IAAI,EAAE;MACpB,OAAO,KAAK;;IAGd,IAAIA,QAAQ,YAAYpV,QAAQ,EAAE;MAChC,OAAO,IAAI;;IAGb,MAAMqV,GAAG,GAAGD,QAAQ,CAACvU,MAAM,CAACC,WAAW,CAAC;IACxC,MAAM2F,IAAI,GAAG2O,QAAoB;IAEjC,IACE,CAACC,GAAG,IAAI,IAAI,IAAIA,GAAG,KAAKrV,QAAA,CAAAc,WAAW,KACnC,OAAO2F,IAAI,CAAC7E,UAAU,KAAK,UAAU,IACrC,OAAO6E,IAAI,CAAC6O,UAAU,KAAK,UAAU,IACrC,OAAO7O,IAAI,CAAC5E,aAAa,KAAK,UAAU,IACxC,OAAO4E,IAAI,CAACjE,MAAM,KAAK,UAAU,IACjC,OAAOiE,IAAI,CAACM,YAAY,KAAK,UAAU,IACvC,OAAON,IAAI,CAAClE,MAAM,KAAK,UAAU,IACjC,OAAOkE,IAAI,CAAC9D,MAAM,KAAK,UAAU,IACjC,OAAO8D,IAAI,CAAC/D,SAAS,KAAK,UAAU,EACpC;MACA,OAAO,IAAI;;IAGb,OAAO,KAAK;EACd;EA3BgB1C,QAAA,CAAA4B,UAAU,GAAAA,UA2BzB;AACH,CAAC,EA/BgB5B,QAAQ,KAARA,QAAQ;AA0DzBA,QAAQ,CAACuV,MAAM,CAAC;EACdC,YAAY,EAAE,IAAI;EAClBC,QAAQ,EAAE,CAAC;EACXC,SAAS,EAAE,CAAC,QAAQ,CAAC;EACrBC,OAAO,EAAE;IACPlP,IAAI,EAAE,CAAC,QAAQ,CAAC;IAChB5C,MAAM,EAAE,CAAC,QAAQ,CAAC;IAClBT,KAAK,EAAE,CAAC,QAAQ,CAAC;IACjBF,IAAI,EAAE,CAAC,QAAQ,EAAE,OAAO,EAAE,OAAO,CAAC;IAClCwC,KAAK,EAAE,CAAC,QAAQ,EAAE,OAAO,CAAC;IAC1BL,QAAQ,EAAE,CAAC,WAAW,EAAE,OAAO,CAAC;IAChCwD,KAAK,EAAE,CAAC,OAAO,CAAC;IAChB+M,KAAK,EAAE,CAAC,OAAO;;CAElB,CAAC;AAEF5V,QAAQ,CAAC6V,QAAQ,CAACC,QAAQ,CAAC,MAAM,EAAE9V,QAAQ,EAAE,IAAI,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}