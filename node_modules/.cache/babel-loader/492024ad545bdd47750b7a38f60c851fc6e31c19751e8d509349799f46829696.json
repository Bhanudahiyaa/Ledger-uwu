{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { rgb2arr } from '@antv/l7-utils';\nimport BaseModel from \"../../core/BaseModel\";\nimport { PolygonExtrudeTriangulation } from \"../../core/triangulation\";\n/* babel-plugin-inline-import '../shaders/build_frag.glsl' */\nconst buildFrag = \"precision highp float;\\nlayout(std140) uniform commonUniforms {\\n  vec4 u_baseColor: [ 1.0, 0, 0, 1.0 ];\\n  vec4 u_brightColor: [ 1.0, 0, 0, 1.0 ];\\n  vec4 u_windowColor: [ 1.0, 0, 0, 1.0 ];\\n  vec4 u_circleSweepColor;\\n  vec2 u_cityCenter;\\n  float u_circleSweep;\\n  float u_cityMinSize;\\n  float u_circleSweepSpeed;\\n  float u_opacity: 1.0;\\n  float u_near: 0;\\n  float u_far: 1;\\n  float u_time;\\n};\\nin vec4 v_Color;\\nin vec2 v_texCoord;\\nin float v_worldDis;\\nout vec4 outputColor;\\n\\n#pragma include \\\"picking\\\"\\n#pragma include \\\"scene_uniforms\\\"\\n\\nvec3 getWindowColor(float n, float hot, vec3 brightColor, vec3 darkColor) {\\n    float s = step(hot, n);\\n    vec3 color = mix(brightColor,vec3(0.9,0.9,1.0),n);\\n\\n    return mix(darkColor, color, s);\\n}\\nfloat random (vec2 st) {\\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\\n}\\n\\nfloat LinearizeDepth()\\n{\\n    float z = gl_FragCoord.z * 2.0 - 1.0;\\n    return (2.0 * u_near * u_far) / (u_far + u_near - z * (u_far - u_near));\\n}\\n\\nvec3 fog(vec3 color, vec3 fogColor, float depth){\\n    float fogFactor=clamp(depth,0.0,1.0);\\n    vec3 output_color=mix(fogColor,color,fogFactor);\\n    return output_color;\\n}\\n\\nfloat sdRect(vec2 p, vec2 sz) {\\n  vec2 d = abs(p) - sz;\\n  float outside = length(max(d, 0.));\\n  float inside = min(max(d.x, d.y), 0.);\\n  return outside + inside;\\n}\\n\\nvoid main() {\\n  outputColor = v_Color;\\n  vec3 baseColor = u_baseColor.xyz;\\n  vec3 brightColor = u_brightColor.xyz;\\n  vec3 windowColor = u_windowColor.xyz;\\n  float targetColId = 5.;\\n  float depth = 1.0 - LinearizeDepth() / u_far * u_Zoom;\\n  vec3 fogColor = vec3(23.0/255.0,31.0/255.0,51.0/255.0);\\n  if(v_texCoord.x < 0.) { //\\u9876\\u90E8\\u989C\\u8272\\n       vec3 foggedColor = fog(baseColor.xyz + vec3(0.12*0.9,0.2*0.9,0.3*0.9),fogColor,depth);\\n       outputColor = vec4( foggedColor, v_Color.w);\\n  }else { // \\u4FA7\\u9762\\u989C\\u8272\\n        vec2 st = v_texCoord;\\n        vec2  UvScale = v_texCoord;\\n        float tStep = min(0.08,max(0.05* (18.0-u_Zoom),0.02));\\n        float tStart = 0.25 * tStep;\\n        float tEnd = 0.75 * tStep;\\n        float u = mod(UvScale.x, tStep);\\n        float v = mod(UvScale.y, tStep);\\n        float ux = floor(UvScale.x/tStep);\\n        float uy = floor(UvScale.y/tStep);\\n        float n = random(vec2(ux,uy));\\n        float lightP = u_time;\\n        float head = 1.0- step(0.005,st.y);\\n        /*step3*/\\n        // \\u5C06\\u7A97\\u6237\\u989C\\u8272\\u548C\\u5899\\u9762\\u989C\\u8272\\u533A\\u522B\\u5F00\\u6765\\n        float sU = step(tStart, u) - step(tEnd, u);\\n        float sV = step(tStart, v) - step(tEnd, v);\\n        vec2 windowSize = vec2(abs(tEnd-tStart),abs(tEnd-tStart));\\n        float dist = sdRect(vec2(u,v), windowSize);\\n        float s = sU * sV;\\n\\n        float curColId = floor(UvScale.x / tStep);\\n        float sCol = step(targetColId - 0.2, curColId) - step(targetColId + 0.2, curColId);\\n\\n        float mLightP = mod(lightP, 2.);\\n        float sRow = step(mLightP - 0.2, st.y) - step(mLightP, st.y);\\n        if(ux == targetColId){\\n            n =0.;\\n        }\\n        float timeP = min(0.75, abs ( sin(u_time/3.0) ) );\\n        float hot = smoothstep(1.0,0.0,timeP);\\n        vec3 color = mix(baseColor, getWindowColor(n,hot,brightColor,windowColor), s);\\n        //vec3 color = mix(baseColor, getWindowColor(n,hot,brightColor,windowColor), 1.0);\\n        float sFinal = s * sCol * sRow;\\n        color += mix(baseColor, brightColor, sFinal*n);\\n        if (st.y<0.01){\\n        color = baseColor;\\n         }\\n        if(head ==1.0) { // \\u9876\\u90E8\\u4EAE\\u7EBF\\n            color = brightColor;\\n        }\\n        color = color * v_Color.rgb;\\n\\n        vec3 foggedColor = fog(color,fogColor,depth);\\n\\n        outputColor = vec4(foggedColor,1.0);\\n  }\\n\\n\\n  if(u_circleSweep > 0.0 && v_worldDis < u_cityMinSize) {\\n    float r = fract(((v_worldDis/u_cityMinSize) - u_time * u_circleSweepSpeed) * 2.0);\\n    outputColor.rgb += r * r * u_circleSweepColor.rgb;\\n  }\\n\\n  outputColor.a *= u_opacity;\\n  outputColor = filterColor(outputColor);\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/build_vert.glsl' */\nconst buildVert = \"precision highp float;\\n\\n#define ambientRatio 0.5\\n#define diffuseRatio 0.3\\n#define specularRatio 0.2\\n\\nlayout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\\n\\nout vec2 v_texCoord;\\nout vec4 v_Color;\\nout float v_worldDis;\\n\\nlayout(std140) uniform commonUniforms {\\n  vec4 u_baseColor : [ 1.0, 0, 0, 1.0 ];\\n  vec4 u_brightColor : [ 1.0, 0, 0, 1.0 ];\\n  vec4 u_windowColor : [ 1.0, 0, 0, 1.0 ];\\n  vec4 u_circleSweepColor;\\n  vec2 u_cityCenter;\\n  float u_circleSweep;\\n  float u_cityMinSize;\\n  float u_circleSweepSpeed;\\n  float u_opacity: 1.0;\\n  float u_near : 0;\\n  float u_far : 1;\\n  float u_time;\\n};\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"light\\\"\\n#pragma include \\\"picking\\\"\\n\\n\\nvoid main() {\\n  vec4 pos = vec4(a_Position.xy, a_Position.z * a_Size, 1.0);\\n  vec4 project_pos = project_position(pos);\\n\\n   v_texCoord = a_Uv;\\n\\n  if(u_circleSweep > 0.0) {\\n     vec2 lnglatscale = vec2(0.0);\\n    lnglatscale = (a_Position.xy - u_cityCenter) * vec2(0.0, 0.135);\\n    v_worldDis = length(a_Position.xy + lnglatscale - u_cityCenter);\\n  }\\n\\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\\n\\n  float lightWeight = calc_lighting(pos);\\n  // v_Color = a_Color;\\n  v_Color = vec4(a_Color.rgb * lightWeight, a_Color.w);\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\nexport default class CityBuildModel extends BaseModel {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"cityCenter\", void 0);\n    _defineProperty(this, \"cityMinSize\", void 0);\n  }\n  get attributeLocation() {\n    return Object.assign(super.attributeLocation, {\n      MAX: super.attributeLocation.MAX,\n      SIZE: 9,\n      NORMAL: 10,\n      UV: 11\n    });\n  }\n  getCommonUniformsInfo() {\n    const {\n      opacity = 1,\n      baseColor = 'rgb(16,16,16)',\n      brightColor = 'rgb(255,176,38)',\n      windowColor = 'rgb(30,60,89)',\n      time = 0,\n      sweep = {\n        enable: false,\n        sweepRadius: 1,\n        sweepColor: 'rgb(255, 255, 255)',\n        sweepSpeed: 0.4,\n        sweepCenter: this.cityCenter\n      }\n    } = this.layer.getLayerConfig();\n    const commonOptions = {\n      u_baseColor: rgb2arr(baseColor),\n      u_brightColor: rgb2arr(brightColor),\n      u_windowColor: rgb2arr(windowColor),\n      u_circleSweepColor: [...rgb2arr(sweep.sweepColor).slice(0, 3), 1.0],\n      u_cityCenter: sweep.sweepCenter || this.cityCenter,\n      u_circleSweep: sweep.enable ? 1.0 : 0.0,\n      u_cityMinSize: this.cityMinSize * sweep.sweepRadius,\n      u_circleSweepSpeed: sweep.sweepSpeed,\n      u_opacity: opacity,\n      u_near: 0,\n      u_far: 1,\n      u_time: this.layer.getLayerAnimateTime() || time\n    };\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  calCityGeo() {\n    // @ts-ignore\n    const [minLng, minLat, maxLng, maxLat] = this.layer.getSource().extent;\n    const w = maxLng - minLng;\n    const h = maxLat - minLat;\n    this.cityCenter = [(maxLng + minLng) / 2, (maxLat + minLat) / 2];\n    this.cityMinSize = Math.sqrt(Math.pow(w, 2) + Math.pow(h, 2)) / 4;\n  }\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.calCityGeo();\n      _this.initUniformsBuffer();\n      _this.startModelAnimate();\n      return _this.buildModels();\n    })();\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const model = yield _this2.layer.buildLayerModel({\n        moduleName: 'cityBuilding',\n        vertexShader: buildVert,\n        fragmentShader: buildFrag,\n        triangulation: PolygonExtrudeTriangulation,\n        depth: {\n          enable: true\n        },\n        defines: _this2.getDefines(),\n        inject: _this2.getInject(),\n        cull: {\n          enable: true,\n          face: gl.BACK\n        }\n      });\n      return [model];\n    })();\n  }\n  registerBuiltinAttributes() {\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'normal',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Normal',\n        shaderLocation: this.attributeLocation.NORMAL,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.STATIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        update: (feature, featureIdx, vertex, attributeIdx, normal) => {\n          return normal;\n        }\n      }\n    });\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Size',\n        shaderLocation: this.attributeLocation.SIZE,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 1,\n        update: feature => {\n          const {\n            size = 10\n          } = feature;\n          return Array.isArray(size) ? [size[0]] : [size];\n        }\n      }\n    });\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'uv',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Uv',\n        shaderLocation: this.attributeLocation.UV,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 2,\n        update: (feature, featureIdx, vertex) => {\n          return [vertex[3], vertex[4]];\n        }\n      }\n    });\n  }\n}","map":{"version":3,"names":["_asyncToGenerator","_defineProperty","AttributeType","gl","rgb2arr","BaseModel","PolygonExtrudeTriangulation","buildFrag","buildVert","CityBuildModel","constructor","args","attributeLocation","Object","assign","MAX","SIZE","NORMAL","UV","getCommonUniformsInfo","opacity","baseColor","brightColor","windowColor","time","sweep","enable","sweepRadius","sweepColor","sweepSpeed","sweepCenter","cityCenter","layer","getLayerConfig","commonOptions","u_baseColor","u_brightColor","u_windowColor","u_circleSweepColor","slice","u_cityCenter","u_circleSweep","u_cityMinSize","cityMinSize","u_circleSweepSpeed","u_opacity","u_near","u_far","u_time","getLayerAnimateTime","commonBufferInfo","getUniformsBufferInfo","calCityGeo","minLng","minLat","maxLng","maxLat","getSource","extent","w","h","Math","sqrt","pow","initModels","_this","initUniformsBuffer","startModelAnimate","buildModels","_this2","model","buildLayerModel","moduleName","vertexShader","fragmentShader","triangulation","depth","defines","getDefines","inject","getInject","cull","face","BACK","registerBuiltinAttributes","styleAttributeService","registerStyleAttribute","name","type","Attribute","descriptor","shaderLocation","buffer","usage","STATIC_DRAW","data","FLOAT","size","update","feature","featureIdx","vertex","attributeIdx","normal","DYNAMIC_DRAW","Array","isArray"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/l7-layers/es/citybuliding/models/build.js"],"sourcesContent":["import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { rgb2arr } from '@antv/l7-utils';\nimport BaseModel from \"../../core/BaseModel\";\nimport { PolygonExtrudeTriangulation } from \"../../core/triangulation\";\n/* babel-plugin-inline-import '../shaders/build_frag.glsl' */\nconst buildFrag = \"precision highp float;\\nlayout(std140) uniform commonUniforms {\\n  vec4 u_baseColor: [ 1.0, 0, 0, 1.0 ];\\n  vec4 u_brightColor: [ 1.0, 0, 0, 1.0 ];\\n  vec4 u_windowColor: [ 1.0, 0, 0, 1.0 ];\\n  vec4 u_circleSweepColor;\\n  vec2 u_cityCenter;\\n  float u_circleSweep;\\n  float u_cityMinSize;\\n  float u_circleSweepSpeed;\\n  float u_opacity: 1.0;\\n  float u_near: 0;\\n  float u_far: 1;\\n  float u_time;\\n};\\nin vec4 v_Color;\\nin vec2 v_texCoord;\\nin float v_worldDis;\\nout vec4 outputColor;\\n\\n#pragma include \\\"picking\\\"\\n#pragma include \\\"scene_uniforms\\\"\\n\\nvec3 getWindowColor(float n, float hot, vec3 brightColor, vec3 darkColor) {\\n    float s = step(hot, n);\\n    vec3 color = mix(brightColor,vec3(0.9,0.9,1.0),n);\\n\\n    return mix(darkColor, color, s);\\n}\\nfloat random (vec2 st) {\\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\\n}\\n\\nfloat LinearizeDepth()\\n{\\n    float z = gl_FragCoord.z * 2.0 - 1.0;\\n    return (2.0 * u_near * u_far) / (u_far + u_near - z * (u_far - u_near));\\n}\\n\\nvec3 fog(vec3 color, vec3 fogColor, float depth){\\n    float fogFactor=clamp(depth,0.0,1.0);\\n    vec3 output_color=mix(fogColor,color,fogFactor);\\n    return output_color;\\n}\\n\\nfloat sdRect(vec2 p, vec2 sz) {\\n  vec2 d = abs(p) - sz;\\n  float outside = length(max(d, 0.));\\n  float inside = min(max(d.x, d.y), 0.);\\n  return outside + inside;\\n}\\n\\nvoid main() {\\n  outputColor = v_Color;\\n  vec3 baseColor = u_baseColor.xyz;\\n  vec3 brightColor = u_brightColor.xyz;\\n  vec3 windowColor = u_windowColor.xyz;\\n  float targetColId = 5.;\\n  float depth = 1.0 - LinearizeDepth() / u_far * u_Zoom;\\n  vec3 fogColor = vec3(23.0/255.0,31.0/255.0,51.0/255.0);\\n  if(v_texCoord.x < 0.) { //\\u9876\\u90E8\\u989C\\u8272\\n       vec3 foggedColor = fog(baseColor.xyz + vec3(0.12*0.9,0.2*0.9,0.3*0.9),fogColor,depth);\\n       outputColor = vec4( foggedColor, v_Color.w);\\n  }else { // \\u4FA7\\u9762\\u989C\\u8272\\n        vec2 st = v_texCoord;\\n        vec2  UvScale = v_texCoord;\\n        float tStep = min(0.08,max(0.05* (18.0-u_Zoom),0.02));\\n        float tStart = 0.25 * tStep;\\n        float tEnd = 0.75 * tStep;\\n        float u = mod(UvScale.x, tStep);\\n        float v = mod(UvScale.y, tStep);\\n        float ux = floor(UvScale.x/tStep);\\n        float uy = floor(UvScale.y/tStep);\\n        float n = random(vec2(ux,uy));\\n        float lightP = u_time;\\n        float head = 1.0- step(0.005,st.y);\\n        /*step3*/\\n        // \\u5C06\\u7A97\\u6237\\u989C\\u8272\\u548C\\u5899\\u9762\\u989C\\u8272\\u533A\\u522B\\u5F00\\u6765\\n        float sU = step(tStart, u) - step(tEnd, u);\\n        float sV = step(tStart, v) - step(tEnd, v);\\n        vec2 windowSize = vec2(abs(tEnd-tStart),abs(tEnd-tStart));\\n        float dist = sdRect(vec2(u,v), windowSize);\\n        float s = sU * sV;\\n\\n        float curColId = floor(UvScale.x / tStep);\\n        float sCol = step(targetColId - 0.2, curColId) - step(targetColId + 0.2, curColId);\\n\\n        float mLightP = mod(lightP, 2.);\\n        float sRow = step(mLightP - 0.2, st.y) - step(mLightP, st.y);\\n        if(ux == targetColId){\\n            n =0.;\\n        }\\n        float timeP = min(0.75, abs ( sin(u_time/3.0) ) );\\n        float hot = smoothstep(1.0,0.0,timeP);\\n        vec3 color = mix(baseColor, getWindowColor(n,hot,brightColor,windowColor), s);\\n        //vec3 color = mix(baseColor, getWindowColor(n,hot,brightColor,windowColor), 1.0);\\n        float sFinal = s * sCol * sRow;\\n        color += mix(baseColor, brightColor, sFinal*n);\\n        if (st.y<0.01){\\n        color = baseColor;\\n         }\\n        if(head ==1.0) { // \\u9876\\u90E8\\u4EAE\\u7EBF\\n            color = brightColor;\\n        }\\n        color = color * v_Color.rgb;\\n\\n        vec3 foggedColor = fog(color,fogColor,depth);\\n\\n        outputColor = vec4(foggedColor,1.0);\\n  }\\n\\n\\n  if(u_circleSweep > 0.0 && v_worldDis < u_cityMinSize) {\\n    float r = fract(((v_worldDis/u_cityMinSize) - u_time * u_circleSweepSpeed) * 2.0);\\n    outputColor.rgb += r * r * u_circleSweepColor.rgb;\\n  }\\n\\n  outputColor.a *= u_opacity;\\n  outputColor = filterColor(outputColor);\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/build_vert.glsl' */\nconst buildVert = \"precision highp float;\\n\\n#define ambientRatio 0.5\\n#define diffuseRatio 0.3\\n#define specularRatio 0.2\\n\\nlayout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\\n\\nout vec2 v_texCoord;\\nout vec4 v_Color;\\nout float v_worldDis;\\n\\nlayout(std140) uniform commonUniforms {\\n  vec4 u_baseColor : [ 1.0, 0, 0, 1.0 ];\\n  vec4 u_brightColor : [ 1.0, 0, 0, 1.0 ];\\n  vec4 u_windowColor : [ 1.0, 0, 0, 1.0 ];\\n  vec4 u_circleSweepColor;\\n  vec2 u_cityCenter;\\n  float u_circleSweep;\\n  float u_cityMinSize;\\n  float u_circleSweepSpeed;\\n  float u_opacity: 1.0;\\n  float u_near : 0;\\n  float u_far : 1;\\n  float u_time;\\n};\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"light\\\"\\n#pragma include \\\"picking\\\"\\n\\n\\nvoid main() {\\n  vec4 pos = vec4(a_Position.xy, a_Position.z * a_Size, 1.0);\\n  vec4 project_pos = project_position(pos);\\n\\n   v_texCoord = a_Uv;\\n\\n  if(u_circleSweep > 0.0) {\\n     vec2 lnglatscale = vec2(0.0);\\n    lnglatscale = (a_Position.xy - u_cityCenter) * vec2(0.0, 0.135);\\n    v_worldDis = length(a_Position.xy + lnglatscale - u_cityCenter);\\n  }\\n\\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\\n\\n  float lightWeight = calc_lighting(pos);\\n  // v_Color = a_Color;\\n  v_Color = vec4(a_Color.rgb * lightWeight, a_Color.w);\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\nexport default class CityBuildModel extends BaseModel {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"cityCenter\", void 0);\n    _defineProperty(this, \"cityMinSize\", void 0);\n  }\n  get attributeLocation() {\n    return Object.assign(super.attributeLocation, {\n      MAX: super.attributeLocation.MAX,\n      SIZE: 9,\n      NORMAL: 10,\n      UV: 11\n    });\n  }\n  getCommonUniformsInfo() {\n    const {\n      opacity = 1,\n      baseColor = 'rgb(16,16,16)',\n      brightColor = 'rgb(255,176,38)',\n      windowColor = 'rgb(30,60,89)',\n      time = 0,\n      sweep = {\n        enable: false,\n        sweepRadius: 1,\n        sweepColor: 'rgb(255, 255, 255)',\n        sweepSpeed: 0.4,\n        sweepCenter: this.cityCenter\n      }\n    } = this.layer.getLayerConfig();\n    const commonOptions = {\n      u_baseColor: rgb2arr(baseColor),\n      u_brightColor: rgb2arr(brightColor),\n      u_windowColor: rgb2arr(windowColor),\n      u_circleSweepColor: [...rgb2arr(sweep.sweepColor).slice(0, 3), 1.0],\n      u_cityCenter: sweep.sweepCenter || this.cityCenter,\n      u_circleSweep: sweep.enable ? 1.0 : 0.0,\n      u_cityMinSize: this.cityMinSize * sweep.sweepRadius,\n      u_circleSweepSpeed: sweep.sweepSpeed,\n      u_opacity: opacity,\n      u_near: 0,\n      u_far: 1,\n      u_time: this.layer.getLayerAnimateTime() || time\n    };\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  calCityGeo() {\n    // @ts-ignore\n    const [minLng, minLat, maxLng, maxLat] = this.layer.getSource().extent;\n    const w = maxLng - minLng;\n    const h = maxLat - minLat;\n    this.cityCenter = [(maxLng + minLng) / 2, (maxLat + minLat) / 2];\n    this.cityMinSize = Math.sqrt(Math.pow(w, 2) + Math.pow(h, 2)) / 4;\n  }\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.calCityGeo();\n      _this.initUniformsBuffer();\n      _this.startModelAnimate();\n      return _this.buildModels();\n    })();\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const model = yield _this2.layer.buildLayerModel({\n        moduleName: 'cityBuilding',\n        vertexShader: buildVert,\n        fragmentShader: buildFrag,\n        triangulation: PolygonExtrudeTriangulation,\n        depth: {\n          enable: true\n        },\n        defines: _this2.getDefines(),\n        inject: _this2.getInject(),\n        cull: {\n          enable: true,\n          face: gl.BACK\n        }\n      });\n      return [model];\n    })();\n  }\n  registerBuiltinAttributes() {\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'normal',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Normal',\n        shaderLocation: this.attributeLocation.NORMAL,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.STATIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        update: (feature, featureIdx, vertex, attributeIdx, normal) => {\n          return normal;\n        }\n      }\n    });\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Size',\n        shaderLocation: this.attributeLocation.SIZE,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 1,\n        update: feature => {\n          const {\n            size = 10\n          } = feature;\n          return Array.isArray(size) ? [size[0]] : [size];\n        }\n      }\n    });\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'uv',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Uv',\n        shaderLocation: this.attributeLocation.UV,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 2,\n        update: (feature, featureIdx, vertex) => {\n          return [vertex[3], vertex[4]];\n        }\n      }\n    });\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}