{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _typeof from \"@babel/runtime/helpers/typeof\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport { gl, isSafari } from '@antv/g-webgpu-core';\nimport * as WebGPUConstants from '@webgpu/types/dist/constants';\nimport { extractUniforms } from '../utils/uniform';\nimport { getColorStateDescriptors, getCullMode, getDepthStencilStateDescriptor, primitiveMap } from './constants';\nimport WebGPUBuffer from './WebGPUBuffer';\n\n// @ts-ignore\nfunction concatenate(resultConstructor) {\n  var totalLength = 0;\n  for (var _len = arguments.length, arrays = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    arrays[_key - 1] = arguments[_key];\n  }\n  for (var _i = 0, _arrays = arrays; _i < _arrays.length; _i++) {\n    var arr = _arrays[_i];\n    totalLength += arr.length;\n  }\n  var result = new resultConstructor(totalLength);\n  var offset = 0;\n  for (var _i2 = 0, _arrays2 = arrays; _i2 < _arrays2.length; _i2++) {\n    var _arr = _arrays2[_i2];\n    result.set(_arr, offset);\n    offset += _arr.length;\n  }\n  return result;\n}\nvar WebGPUModel = /*#__PURE__*/function () {\n  /**\n   * 用于后续渲染时动态更新\n   */\n\n  /**\n   * vertex\n   */\n\n  /**\n   * indices's buffer\n   */\n  function WebGPUModel(engine, options) {\n    _classCallCheck(this, WebGPUModel);\n    this.engine = engine;\n    this.options = options;\n    this.pipelineLayout = void 0;\n    this.renderPipeline = void 0;\n    this.uniformsBindGroupLayout = void 0;\n    this.uniformBindGroup = void 0;\n    this.uniformBuffer = void 0;\n    this.uniforms = {};\n    this.uniformGPUBufferLayout = [];\n    this.attributeCache = {};\n    this.indexBuffer = void 0;\n    this.indexCount = void 0;\n  }\n  _createClass(WebGPUModel, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n        var _this$options, vs, fs, attributes, uniforms, primitive, count, elements, depth, blend, stencil, cull, instances, _yield$this$compilePi, vertexStage, fragmentStage, vertexState, descriptor;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _this$options = this.options, vs = _this$options.vs, fs = _this$options.fs, attributes = _this$options.attributes, uniforms = _this$options.uniforms, primitive = _this$options.primitive, count = _this$options.count, elements = _this$options.elements, depth = _this$options.depth, blend = _this$options.blend, stencil = _this$options.stencil, cull = _this$options.cull, instances = _this$options.instances; // build shaders first\n\n                _context.next = 3;\n                return this.compilePipelineStageDescriptor(vs, fs, null);\n              case 3:\n                _yield$this$compilePi = _context.sent;\n                vertexStage = _yield$this$compilePi.vertexStage;\n                fragmentStage = _yield$this$compilePi.fragmentStage;\n                if (uniforms) {\n                  // create uniform bind groups & layout\n                  this.buildUniformBindGroup(uniforms);\n                }\n                if (elements) {\n                  this.indexBuffer = elements.get();\n                  this.indexCount = elements.indexCount;\n                } // TODO: instanced array\n\n                vertexState = {\n                  vertexBuffers: Object.keys(attributes).map(function (attributeName, i) {\n                    var attribute = attributes[attributeName];\n                    var _attribute$get = attribute.get(),\n                      arrayStride = _attribute$get.arrayStride,\n                      stepMode = _attribute$get.stepMode,\n                      ats = _attribute$get.attributes;\n                    _this.attributeCache[attributeName] = attribute;\n                    return {\n                      arrayStride: arrayStride,\n                      stepMode: stepMode,\n                      attributes: ats\n                    };\n                  })\n                };\n                descriptor = {\n                  sampleCount: this.engine.mainPassSampleCount,\n                  primitiveTopology: primitiveMap[primitive || gl.TRIANGLES],\n                  rasterizationState: _objectSpread(_objectSpread({}, this.getDefaultRasterizationStateDescriptor()), {}, {\n                    // TODO: support frontface\n                    cullMode: getCullMode({\n                      cull: cull\n                    })\n                  }),\n                  depthStencilState: getDepthStencilStateDescriptor({\n                    depth: depth,\n                    stencil: stencil\n                  }),\n                  colorStates: getColorStateDescriptors({\n                    blend: blend\n                  }, this.engine.options.swapChainFormat),\n                  layout: this.pipelineLayout,\n                  vertexStage: vertexStage,\n                  fragmentStage: fragmentStage,\n                  vertexState: vertexState\n                }; // create pipeline\n\n                this.renderPipeline = this.engine.device.createRenderPipeline(descriptor);\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function init() {\n        return _init.apply(this, arguments);\n      }\n      return init;\n    }()\n  }, {\n    key: \"addUniforms\",\n    value: function addUniforms(uniforms) {\n      this.uniforms = _objectSpread(_objectSpread({}, this.uniforms), extractUniforms(uniforms));\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(options) {\n      var _this2 = this;\n      var renderPass = this.engine.getCurrentRenderPass();\n      var uniforms = _objectSpread(_objectSpread({}, this.uniforms), extractUniforms(options.uniforms || {}));\n      var bindGroupBindings = []; // TODO: uniform 发生修改\n\n      Object.keys(uniforms).forEach(function (uniformName) {\n        var type = _typeof(uniforms[uniformName]);\n        if (type === 'boolean' || type === 'number' || Array.isArray(uniforms[uniformName]) ||\n        // @ts-ignore\n        uniforms[uniformName].BYTES_PER_ELEMENT) {\n          var _this2$uniformGPUBuff;\n          var offset = (_this2$uniformGPUBuff = _this2.uniformGPUBufferLayout.find(function (_ref) {\n            var name = _ref.name;\n            return name === uniformName;\n          })) === null || _this2$uniformGPUBuff === void 0 ? void 0 : _this2$uniformGPUBuff.offset;\n          if (offset !== null) {\n            _this2.uniformBuffer.subData({\n              // @ts-ignore\n              data: uniforms[uniformName],\n              // @ts-ignore\n              offset: offset\n            });\n          }\n        } else {\n          var _this2$uniformGPUBuff2;\n          var _offset = (_this2$uniformGPUBuff2 = _this2.uniformGPUBufferLayout.find(function (_ref2) {\n            var name = _ref2.name;\n            return name === uniformName;\n          })) === null || _this2$uniformGPUBuff2 === void 0 ? void 0 : _this2$uniformGPUBuff2.offset;\n          if (_offset !== null) {\n            var textureOrFramebuffer = uniforms[uniformName].get();\n            var _ref3 =\n              // @ts-ignore\n              textureOrFramebuffer.color || textureOrFramebuffer,\n              texture = _ref3.texture,\n              sampler = _ref3.sampler;\n            if (sampler) {\n              bindGroupBindings.push({\n                // @ts-ignore\n                binding: _offset,\n                resource: sampler\n              }); // @ts-ignore\n\n              _offset++;\n            }\n            bindGroupBindings.push({\n              // @ts-ignore\n              binding: _offset,\n              resource: texture.createView()\n            });\n          }\n        }\n      });\n      if (this.uniformBuffer) {\n        bindGroupBindings[0] = {\n          binding: 0,\n          resource: {\n            buffer: this.uniformBuffer.get() // 返回 GPUBuffer 原生对象\n          }\n        };\n      }\n      this.uniformBindGroup = this.engine.device.createBindGroup({\n        layout: this.uniformsBindGroupLayout,\n        entries: bindGroupBindings\n      });\n      if (this.renderPipeline) {\n        renderPass.setPipeline(this.renderPipeline);\n      }\n      renderPass.setBindGroup(0, this.uniformBindGroup);\n      if (this.indexBuffer) {\n        renderPass.setIndexBuffer(this.indexBuffer.get(), WebGPUConstants.IndexFormat.Uint32, 0);\n      }\n      Object.keys(this.attributeCache).forEach(function (attributeName, i) {\n        renderPass.setVertexBuffer(0 + i, _this2.attributeCache[attributeName].get().buffer, 0);\n      }); // renderPass.draw(verticesCount, instancesCount, verticesStart, 0);\n\n      if (this.indexBuffer) {\n        renderPass.drawIndexed(this.indexCount, this.options.instances || 1, 0, 0, 0);\n      } else {\n        renderPass.draw(this.options.count || 0, this.options.instances || 0, 0, 0);\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"compilePipelineStageDescriptor\",\n    value: function () {\n      var _compilePipelineStageDescriptor = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(vertexCode, fragmentCode, defines) {\n        var shaderVersion, vertexShader, fragmentShader;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                shaderVersion = '#version 450\\n';\n                vertexShader = vertexCode;\n                fragmentShader = fragmentCode;\n                if (this.engine.options.useWGSL) {\n                  _context2.next = 10;\n                  break;\n                }\n                _context2.next = 6;\n                return this.compileShaderToSpirV(vertexCode, 'vertex', shaderVersion);\n              case 6:\n                vertexShader = _context2.sent;\n                _context2.next = 9;\n                return this.compileShaderToSpirV(fragmentCode, 'fragment', shaderVersion);\n              case 9:\n                fragmentShader = _context2.sent;\n              case 10:\n                return _context2.abrupt(\"return\", this.createPipelineStageDescriptor(vertexShader, fragmentShader));\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function compilePipelineStageDescriptor(_x, _x2, _x3) {\n        return _compilePipelineStageDescriptor.apply(this, arguments);\n      }\n      return compilePipelineStageDescriptor;\n    }()\n  }, {\n    key: \"compileShaderToSpirV\",\n    value: function compileShaderToSpirV(source, type, shaderVersion) {\n      return this.compileRawShaderToSpirV(shaderVersion + source, type);\n    }\n  }, {\n    key: \"compileRawShaderToSpirV\",\n    value: function compileRawShaderToSpirV(source, type) {\n      return this.engine.glslang.compileGLSL(source, type);\n    }\n  }, {\n    key: \"createPipelineStageDescriptor\",\n    value: function createPipelineStageDescriptor(vertexShader, fragmentShader) {\n      return {\n        vertexStage: {\n          module: this.engine.device.createShaderModule({\n            code: vertexShader,\n            // @ts-ignore\n            isWHLSL: isSafari\n          }),\n          entryPoint: 'main'\n        },\n        fragmentStage: {\n          module: this.engine.device.createShaderModule({\n            code: fragmentShader,\n            // @ts-ignore\n            isWHLSL: isSafari\n          }),\n          entryPoint: 'main'\n        }\n      };\n    }\n    /**\n     * @see https://gpuweb.github.io/gpuweb/#rasterization-state\n     */\n  }, {\n    key: \"getDefaultRasterizationStateDescriptor\",\n    value: function getDefaultRasterizationStateDescriptor() {\n      return {\n        frontFace: WebGPUConstants.FrontFace.CCW,\n        cullMode: WebGPUConstants.CullMode.None,\n        depthBias: 0,\n        depthBiasSlopeScale: 0,\n        depthBiasClamp: 0\n      };\n    }\n  }, {\n    key: \"buildUniformBindGroup\",\n    value: function buildUniformBindGroup(uniforms) {\n      var _this3 = this;\n      var offset = 0; // FIXME: 所有 uniform 合并成一个 buffer，固定使用 Float32Array 存储，确实会造成一些内存的浪费\n\n      var mergedUniformData = concatenate.apply(void 0, [Float32Array].concat(_toConsumableArray(Object.keys(uniforms).map(function (uniformName) {\n        if (uniforms[uniformName]) {\n          _this3.uniformGPUBufferLayout.push({\n            name: uniformName,\n            offset: offset\n          }); // @ts-ignore\n\n          offset += (uniforms[uniformName].length || 1) * 4;\n          return uniforms[uniformName];\n        } else {\n          // texture & framebuffer\n          return [];\n        }\n      }))));\n      var entries = [];\n      var hasUniform = false;\n      if (mergedUniformData.length) {\n        hasUniform = true; // TODO: 所有 uniform 绑定到 slot 0，通过解析 Shader 代码判定可见性\n\n        entries.push({\n          // TODO: 暂时都绑定到 slot 0\n          binding: 0,\n          visibility: WebGPUConstants.ShaderStage.Fragment | WebGPUConstants.ShaderStage.Vertex,\n          // TODO: 暂时 VS 和 FS 都可见\n          type: WebGPUConstants.BindingType.UniformBuffer\n        });\n      } // 声明 texture & sampler\n\n      Object.keys(uniforms).filter(function (uniformName) {\n        return uniforms[uniformName] === null;\n      }).forEach(function (uniformName, i) {\n        _this3.uniformGPUBufferLayout.push({\n          name: uniformName,\n          offset: i * 2 + (hasUniform ? 1 : 0)\n        });\n        entries.push({\n          // Sampler\n          binding: i * 2 + (hasUniform ? 1 : 0),\n          visibility: WebGPUConstants.ShaderStage.Fragment,\n          type: WebGPUConstants.BindingType.Sampler\n        }, {\n          // Texture view\n          binding: i * 2 + (hasUniform ? 1 : 0) + 1,\n          visibility: WebGPUConstants.ShaderStage.Fragment,\n          type: WebGPUConstants.BindingType.SampledTexture\n        });\n      });\n      this.uniformsBindGroupLayout = this.engine.device.createBindGroupLayout({\n        // 最新 API 0.0.22 版本使用 entries。Chrome Canary 84.0.4110.0 已实现。\n        // 使用 bindings 会报 Warning: GPUBindGroupLayoutDescriptor.bindings is deprecated: renamed to entries\n        // @see https://github.com/antvis/GWebGPUEngine/issues/5\n        entries: entries\n      });\n      this.pipelineLayout = this.engine.device.createPipelineLayout({\n        bindGroupLayouts: [this.uniformsBindGroupLayout]\n      });\n      if (hasUniform) {\n        this.uniformBuffer = new WebGPUBuffer(this.engine, {\n          // TODO: 处理 Struct 和 boolean\n          // @ts-ignore\n          data: mergedUniformData instanceof Array ?\n          // @ts-ignore\n          new Float32Array(mergedUniformData) : mergedUniformData,\n          usage: WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst\n        });\n      }\n    }\n  }]);\n  return WebGPUModel;\n}();\nexport { WebGPUModel as default };","map":{"version":3,"names":["gl","isSafari","WebGPUConstants","extractUniforms","getColorStateDescriptors","getCullMode","getDepthStencilStateDescriptor","primitiveMap","WebGPUBuffer","concatenate","resultConstructor","totalLength","_len","arguments","length","arrays","Array","_key","_i","_arrays","arr","result","offset","_i2","_arrays2","_arr","set","WebGPUModel","engine","options","_classCallCheck","pipelineLayout","renderPipeline","uniformsBindGroupLayout","uniformBindGroup","uniformBuffer","uniforms","uniformGPUBufferLayout","attributeCache","indexBuffer","indexCount","vs","fs","attributes","primitive","count","elements","depth","blend","stencil","cull","instances","compilePipelineStageDescriptor","vertexStage","fragmentStage","buildUniformBindGroup","get","vertexState","vertexBuffers","Object","keys","map","attributeName","i","attribute","_attribute$get","arrayStride","stepMode","ats","_this","descriptor","sampleCount","mainPassSampleCount","primitiveTopology","TRIANGLES","rasterizationState","_objectSpread","getDefaultRasterizationStateDescriptor","cullMode","depthStencilState","colorStates","swapChainFormat","layout","device","createRenderPipeline","_this2","renderPass","getCurrentRenderPass","bindGroupBindings","forEach","uniformName","type","_typeof","isArray","BYTES_PER_ELEMENT","_this2$uniformGPUBuff","find","_ref","name","subData","data","_this2$uniformGPUBuff2","_offset","_ref2","textureOrFramebuffer","_ref3","color","texture","sampler","push","binding","resource","createView","buffer","createBindGroup","entries","setPipeline","setBindGroup","setIndexBuffer","IndexFormat","Uint32","setVertexBuffer","drawIndexed","draw","Error","vertexCode","fragmentCode","defines","shaderVersion","vertexShader","fragmentShader","useWGSL","compileShaderToSpirV","createPipelineStageDescriptor","source","compileRawShaderToSpirV","glslang","compileGLSL","module","createShaderModule","code","isWHLSL","entryPoint","frontFace","FrontFace","CCW","CullMode","None","depthBias","depthBiasSlopeScale","depthBiasClamp","_this3","mergedUniformData","apply","Float32Array","concat","_toConsumableArray","hasUniform","visibility","ShaderStage","Fragment","Vertex","BindingType","UniformBuffer","filter","Sampler","SampledTexture","createBindGroupLayout","createPipelineLayout","bindGroupLayouts","usage","BufferUsage","Uniform","CopyDst"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/g-webgpu-engine/src/webgpu/WebGPUModel.ts"],"sourcesContent":["import {\n  gl,\n  IModel,\n  IModelDrawOptions,\n  IModelInitializationOptions,\n  isSafari,\n  IUniform,\n} from '@antv/g-webgpu-core';\nimport * as WebGPUConstants from '@webgpu/types/dist/constants';\nimport { WebGPUEngine } from '.';\nimport { extractUniforms } from '../utils/uniform';\nimport {\n  getColorStateDescriptors,\n  getCullMode,\n  getDepthStencilStateDescriptor,\n  primitiveMap,\n} from './constants';\nimport WebGPUAttribute from './WebGPUAttribute';\nimport WebGPUBuffer from './WebGPUBuffer';\nimport WebGPUElements from './WebGPUElements';\nimport WebGPUFramebuffer from './WebGPUFramebuffer';\nimport WebGPUTexture2D from './WebGPUTexture2D';\n\n// @ts-ignore\nfunction concatenate(resultConstructor, ...arrays) {\n  let totalLength = 0;\n  for (const arr of arrays) {\n    totalLength += arr.length;\n  }\n  const result = new resultConstructor(totalLength);\n  let offset = 0;\n  for (const arr of arrays) {\n    result.set(arr, offset);\n    offset += arr.length;\n  }\n  return result;\n}\n\nexport default class WebGPUModel implements IModel {\n  private pipelineLayout: GPUPipelineLayout;\n  private renderPipeline: GPURenderPipeline;\n  private uniformsBindGroupLayout: GPUBindGroupLayout;\n  private uniformBindGroup: GPUBindGroup;\n  private uniformBuffer: WebGPUBuffer;\n\n  private uniforms: {\n    [key: string]: IUniform;\n  } = {};\n\n  /**\n   * 用于后续渲染时动态更新\n   */\n  private uniformGPUBufferLayout: Array<{\n    name: string;\n    offset: number;\n  }> = [];\n\n  /**\n   * vertex\n   */\n  private attributeCache: {\n    [attributeName: string]: WebGPUAttribute;\n  } = {};\n\n  /**\n   * indices's buffer\n   */\n  private indexBuffer: WebGPUBuffer;\n  private indexCount: number;\n\n  constructor(\n    private engine: WebGPUEngine,\n    private options: IModelInitializationOptions,\n  ) {}\n\n  public async init() {\n    const {\n      vs,\n      fs,\n      attributes,\n      uniforms,\n      primitive,\n      count,\n      elements,\n      depth,\n      blend,\n      stencil,\n      cull,\n      instances,\n    } = this.options;\n\n    // build shaders first\n    const {\n      vertexStage,\n      fragmentStage,\n    } = await this.compilePipelineStageDescriptor(vs, fs, null);\n\n    if (uniforms) {\n      // create uniform bind groups & layout\n      this.buildUniformBindGroup(uniforms);\n    }\n\n    if (elements) {\n      this.indexBuffer = (elements as WebGPUElements).get() as WebGPUBuffer;\n      this.indexCount = (elements as WebGPUElements).indexCount;\n    }\n\n    // TODO: instanced array\n\n    const vertexState = {\n      vertexBuffers: Object.keys(attributes).map((attributeName, i) => {\n        const attribute = attributes[attributeName] as WebGPUAttribute;\n        const { arrayStride, stepMode, attributes: ats } = attribute.get();\n        this.attributeCache[attributeName] = attribute;\n        return {\n          arrayStride,\n          stepMode,\n          attributes: ats,\n        };\n      }),\n    };\n\n    const descriptor = {\n      sampleCount: this.engine.mainPassSampleCount,\n      primitiveTopology: primitiveMap[primitive || gl.TRIANGLES],\n      rasterizationState: {\n        ...this.getDefaultRasterizationStateDescriptor(),\n        // TODO: support frontface\n        cullMode: getCullMode({ cull }),\n      },\n      depthStencilState: getDepthStencilStateDescriptor({\n        depth,\n        stencil,\n      }),\n      colorStates: getColorStateDescriptors(\n        { blend },\n        this.engine.options.swapChainFormat!,\n      ),\n      layout: this.pipelineLayout,\n      vertexStage,\n      fragmentStage,\n      vertexState,\n    };\n\n    // create pipeline\n    this.renderPipeline = this.engine.device.createRenderPipeline(descriptor);\n  }\n\n  public addUniforms(uniforms: { [key: string]: IUniform }): void {\n    this.uniforms = {\n      ...this.uniforms,\n      ...extractUniforms(uniforms),\n    };\n  }\n\n  public draw(options: IModelDrawOptions): void {\n    const renderPass = this.engine.getCurrentRenderPass();\n\n    const uniforms: {\n      [key: string]: IUniform;\n    } = {\n      ...this.uniforms,\n      ...extractUniforms(options.uniforms || {}),\n    };\n\n    const bindGroupBindings: GPUBindGroupEntry[] = [];\n\n    // TODO: uniform 发生修改\n    Object.keys(uniforms).forEach((uniformName: string) => {\n      const type = typeof uniforms[uniformName];\n      if (\n        type === 'boolean' ||\n        type === 'number' ||\n        Array.isArray(uniforms[uniformName]) ||\n        // @ts-ignore\n        uniforms[uniformName].BYTES_PER_ELEMENT\n      ) {\n        const offset = this.uniformGPUBufferLayout.find(\n          ({ name }) => name === uniformName,\n        )?.offset;\n        if (offset !== null) {\n          this.uniformBuffer.subData({\n            // @ts-ignore\n            data: uniforms[uniformName],\n            // @ts-ignore\n            offset,\n          });\n        }\n      } else {\n        let offset = this.uniformGPUBufferLayout.find(\n          ({ name }) => name === uniformName,\n        )?.offset;\n        if (offset !== null) {\n          const textureOrFramebuffer = (uniforms[uniformName] as\n            | WebGPUTexture2D\n            | WebGPUFramebuffer).get();\n          const { texture, sampler } =\n            // @ts-ignore\n            textureOrFramebuffer.color || textureOrFramebuffer;\n          if (sampler) {\n            bindGroupBindings.push({\n              // @ts-ignore\n              binding: offset,\n              resource: sampler,\n            });\n            // @ts-ignore\n            offset++;\n          }\n          bindGroupBindings.push({\n            // @ts-ignore\n            binding: offset,\n            resource: texture.createView(),\n          });\n        }\n      }\n    });\n\n    if (this.uniformBuffer) {\n      bindGroupBindings[0] = {\n        binding: 0,\n        resource: {\n          buffer: this.uniformBuffer.get(), // 返回 GPUBuffer 原生对象\n        },\n      };\n    }\n\n    this.uniformBindGroup = this.engine.device.createBindGroup({\n      layout: this.uniformsBindGroupLayout,\n      entries: bindGroupBindings,\n    });\n\n    if (this.renderPipeline) {\n      renderPass.setPipeline(this.renderPipeline);\n    }\n\n    renderPass.setBindGroup(0, this.uniformBindGroup);\n\n    if (this.indexBuffer) {\n      renderPass.setIndexBuffer(\n        this.indexBuffer.get(),\n        WebGPUConstants.IndexFormat.Uint32,\n        0,\n      );\n    }\n\n    Object.keys(this.attributeCache).forEach((attributeName: string, i) => {\n      renderPass.setVertexBuffer(\n        0 + i,\n        this.attributeCache[attributeName].get().buffer,\n        0,\n      );\n    });\n\n    // renderPass.draw(verticesCount, instancesCount, verticesStart, 0);\n    if (this.indexBuffer) {\n      renderPass.drawIndexed(\n        this.indexCount,\n        this.options.instances || 1,\n        0,\n        0,\n        0,\n      );\n    } else {\n      renderPass.draw(\n        this.options.count || 0,\n        this.options.instances || 0,\n        0,\n        0,\n      );\n    }\n  }\n\n  public destroy(): void {\n    throw new Error('Method not implemented.');\n  }\n\n  private async compilePipelineStageDescriptor(\n    vertexCode: string,\n    fragmentCode: string,\n    defines: string | null,\n  ): Promise<\n    Pick<GPURenderPipelineDescriptor, 'vertexStage' | 'fragmentStage'>\n  > {\n    const shaderVersion = '#version 450\\n';\n\n    let vertexShader: Uint32Array | string = vertexCode;\n    let fragmentShader: Uint32Array | string = fragmentCode;\n    if (!this.engine.options.useWGSL) {\n      vertexShader = await this.compileShaderToSpirV(\n        vertexCode,\n        'vertex',\n        shaderVersion,\n      );\n      fragmentShader = await this.compileShaderToSpirV(\n        fragmentCode,\n        'fragment',\n        shaderVersion,\n      );\n    }\n\n    return this.createPipelineStageDescriptor(vertexShader, fragmentShader);\n  }\n\n  private compileShaderToSpirV(\n    source: string,\n    type: string,\n    shaderVersion: string,\n  ): Promise<Uint32Array> {\n    return this.compileRawShaderToSpirV(shaderVersion + source, type);\n  }\n\n  private compileRawShaderToSpirV(\n    source: string,\n    type: string,\n  ): Promise<Uint32Array> {\n    return this.engine.glslang.compileGLSL(source, type);\n  }\n\n  private createPipelineStageDescriptor(\n    vertexShader: Uint32Array | string,\n    fragmentShader: Uint32Array | string,\n  ): Pick<GPURenderPipelineDescriptor, 'vertexStage' | 'fragmentStage'> {\n    return {\n      vertexStage: {\n        module: this.engine.device.createShaderModule({\n          code: vertexShader,\n          // @ts-ignore\n          isWHLSL: isSafari,\n        }),\n        entryPoint: 'main',\n      },\n      fragmentStage: {\n        module: this.engine.device.createShaderModule({\n          code: fragmentShader,\n          // @ts-ignore\n          isWHLSL: isSafari,\n        }),\n        entryPoint: 'main',\n      },\n    };\n  }\n\n  /**\n   * @see https://gpuweb.github.io/gpuweb/#rasterization-state\n   */\n  private getDefaultRasterizationStateDescriptor(): GPURasterizationStateDescriptor {\n    return {\n      frontFace: WebGPUConstants.FrontFace.CCW,\n      cullMode: WebGPUConstants.CullMode.None,\n      depthBias: 0,\n      depthBiasSlopeScale: 0,\n      depthBiasClamp: 0,\n    };\n  }\n\n  private buildUniformBindGroup(uniforms: { [key: string]: IUniform }) {\n    let offset = 0;\n    // FIXME: 所有 uniform 合并成一个 buffer，固定使用 Float32Array 存储，确实会造成一些内存的浪费\n    const mergedUniformData = concatenate(\n      Float32Array,\n      ...Object.keys(uniforms).map((uniformName) => {\n        if (uniforms[uniformName]) {\n          this.uniformGPUBufferLayout.push({\n            name: uniformName,\n            offset,\n          });\n          // @ts-ignore\n          offset += (uniforms[uniformName].length || 1) * 4;\n          return uniforms[uniformName];\n        } else {\n          // texture & framebuffer\n          return [];\n        }\n      }),\n    );\n\n    const entries: GPUBindGroupLayoutEntry[] = [];\n    let hasUniform = false;\n    if (mergedUniformData.length) {\n      hasUniform = true;\n      // TODO: 所有 uniform 绑定到 slot 0，通过解析 Shader 代码判定可见性\n      entries.push({\n        // TODO: 暂时都绑定到 slot 0\n        binding: 0,\n        visibility:\n          WebGPUConstants.ShaderStage.Fragment |\n          WebGPUConstants.ShaderStage.Vertex, // TODO: 暂时 VS 和 FS 都可见\n        type: WebGPUConstants.BindingType.UniformBuffer,\n      });\n    }\n\n    // 声明 texture & sampler\n    Object.keys(uniforms)\n      .filter((uniformName) => uniforms[uniformName] === null)\n      .forEach((uniformName, i) => {\n        this.uniformGPUBufferLayout.push({\n          name: uniformName,\n          offset: i * 2 + (hasUniform ? 1 : 0),\n        });\n        entries.push(\n          {\n            // Sampler\n            binding: i * 2 + (hasUniform ? 1 : 0),\n            visibility: WebGPUConstants.ShaderStage.Fragment,\n            type: WebGPUConstants.BindingType.Sampler,\n          },\n          {\n            // Texture view\n            binding: i * 2 + (hasUniform ? 1 : 0) + 1,\n            visibility: WebGPUConstants.ShaderStage.Fragment,\n            type: WebGPUConstants.BindingType.SampledTexture,\n          },\n        );\n      });\n\n    this.uniformsBindGroupLayout = this.engine.device.createBindGroupLayout({\n      // 最新 API 0.0.22 版本使用 entries。Chrome Canary 84.0.4110.0 已实现。\n      // 使用 bindings 会报 Warning: GPUBindGroupLayoutDescriptor.bindings is deprecated: renamed to entries\n      // @see https://github.com/antvis/GWebGPUEngine/issues/5\n      entries,\n    });\n\n    this.pipelineLayout = this.engine.device.createPipelineLayout({\n      bindGroupLayouts: [this.uniformsBindGroupLayout],\n    });\n\n    if (hasUniform) {\n      this.uniformBuffer = new WebGPUBuffer(this.engine, {\n        // TODO: 处理 Struct 和 boolean\n        // @ts-ignore\n        data:\n          mergedUniformData instanceof Array\n            ? // @ts-ignore\n              new Float32Array(mergedUniformData)\n            : mergedUniformData,\n        usage:\n          WebGPUConstants.BufferUsage.Uniform |\n          WebGPUConstants.BufferUsage.CopyDst,\n      });\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SACEA,EADF,EAKEC,QALF,QAOO,qBAPP;AAQA,OAAO,KAAKC,eAAZ,MAAiC,8BAAjC;AAEA,SAASC,eAAT,QAAgC,kBAAhC;AACA,SACEC,wBADF,EAEEC,WAFF,EAGEC,8BAHF,EAIEC,YAJF,QAKO,aALP;AAOA,OAAOC,YAAP,MAAyB,gBAAzB;;AAKA;AACA,SAASC,WAATA,CAAqBC,iBAArB,EAAmD;EACjD,IAAIC,WAAW,GAAG,CAAlB;EADiD,SAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAARC,MAAQ,OAAAC,KAAA,CAAAJ,IAAA,OAAAA,IAAA,WAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;IAARF,MAAQ,CAAAE,IAAA,QAAAJ,SAAA,CAAAI,IAAA;EAAA;EAEjD,SAAAC,EAAA,MAAAC,OAAA,GAAkBJ,MAAlB,EAAAG,EAAA,GAAAC,OAAA,CAAAL,MAAA,EAAAI,EAAA,IAA0B;IAArB,IAAME,GAAG,GAAAD,OAAA,CAAAD,EAAA,CAAT;IACHP,WAAW,IAAIS,GAAG,CAACN,MAAnB;EACD;EACD,IAAMO,MAAM,GAAG,IAAIX,iBAAJ,CAAsBC,WAAtB,CAAf;EACA,IAAIW,MAAM,GAAG,CAAb;EACA,SAAAC,GAAA,MAAAC,QAAA,GAAkBT,MAAlB,EAAAQ,GAAA,GAAAC,QAAA,CAAAV,MAAA,EAAAS,GAAA,IAA0B;IAArB,IAAME,IAAG,GAAAD,QAAA,CAAAD,GAAA,CAAT;IACHF,MAAM,CAACK,GAAP,CAAWD,IAAX,EAAgBH,MAAhB;IACAA,MAAM,IAAIG,IAAG,CAACX,MAAd;EACD;EACD,OAAOO,MAAP;AACD;IAEoBM,W;EAWnB;AACF;AACA;;EAME;AACF;AACA;;EAKE;AACF;AACA;EAIE,SAAAA,YACUC,MADV,EAEUC,OAFV,EAGE;IAAAC,eAAA,OAAAH,WAAA;IAAA,KAFQC,MAER,GAFQA,MAER;IAAA,KADQC,OACR,GADQA,OACR;IAAA,KAlCME,cAkCN;IAAA,KAjCMC,cAiCN;IAAA,KAhCMC,uBAgCN;IAAA,KA/BMC,gBA+BN;IAAA,KA9BMC,aA8BN;IAAA,KA5BMC,QA4BN,GA1BE,EA0BF;IAAA,KArBMC,sBAqBN,GAlBG,EAkBH;IAAA,KAbMC,cAaN,GAXE,EAWF;IAAA,KANMC,WAMN;IAAA,KALMC,UAKN;EAAE;;;;;;;;;;;gCAgBE,KAAKX,O,EAZPY,E,iBAAAA,E,EACAC,E,iBAAAA,E,EACAC,U,iBAAAA,U,EACAP,Q,iBAAAA,Q,EACAQ,S,iBAAAA,S,EACAC,K,iBAAAA,K,EACAC,Q,iBAAAA,Q,EACAC,K,iBAAAA,K,EACAC,K,iBAAAA,K,EACAC,O,iBAAAA,O,EACAC,I,iBAAAA,I,EACAC,S,iBAAAA,S,EAGF;;;uBAIU,KAAKC,8BAAL,CAAoCX,EAApC,EAAwCC,EAAxC,EAA4C,IAA5C,C;;;gBAFRW,W,yBAAAA,W;gBACAC,a,yBAAAA,a;gBAGF,IAAIlB,QAAJ,EAAc;kBACZ;kBACA,KAAKmB,qBAAL,CAA2BnB,QAA3B;gBACD;gBAED,IAAIU,QAAJ,EAAc;kBACZ,KAAKP,WAAL,GAAoBO,QAAD,CAA6BU,GAA7B,EAAnB;kBACA,KAAKhB,UAAL,GAAmBM,QAAD,CAA6BN,UAA/C;gBACD,C,CAED;;gBAEMiB,W,GAAc;kBAClBC,aAAa,EAAEC,MAAM,CAACC,IAAP,CAAYjB,UAAZ,EAAwBkB,GAAxB,CAA4B,UAACC,aAAD,EAAgBC,CAAhB,EAAsB;oBAC/D,IAAMC,SAAS,GAAGrB,UAAU,CAACmB,aAAD,CAA5B;oBAD+D,IAAAG,cAAA,GAEZD,SAAS,CAACR,GAAV,EAFY;sBAEvDU,WAFuD,GAAAD,cAAA,CAEvDC,WAFuD;sBAE1CC,QAF0C,GAAAF,cAAA,CAE1CE,QAF0C;sBAEpBC,GAFoB,GAAAH,cAAA,CAEhCtB,UAFgC;oBAG/D0B,KAAI,CAAC/B,cAAL,CAAoBwB,aAApB,IAAqCE,SAArC;oBACA,OAAO;sBACLE,WAAW,EAAXA,WADK;sBAELC,QAAQ,EAARA,QAFK;sBAGLxB,UAAU,EAAEyB;oBAHP,CAAP;kBAKD,CATc;gBADG,C;gBAadE,U,GAAa;kBACjBC,WAAW,EAAE,KAAK3C,MAAL,CAAY4C,mBADR;kBAEjBC,iBAAiB,EAAElE,YAAY,CAACqC,SAAS,IAAI5C,EAAE,CAAC0E,SAAjB,CAFd;kBAGjBC,kBAAkB,EAAAC,aAAA,CAAAA,aAAA,KACb,KAAKC,sCAAL,EADa;oBAEhB;oBACAC,QAAQ,EAAEzE,WAAW,CAAC;sBAAE6C,IAAI,EAAJA;oBAAF,CAAD;kBAHL,EAHD;kBAQjB6B,iBAAiB,EAAEzE,8BAA8B,CAAC;oBAChDyC,KAAK,EAALA,KADgD;oBAEhDE,OAAO,EAAPA;kBAFgD,CAAD,CARhC;kBAYjB+B,WAAW,EAAE5E,wBAAwB,CACnC;oBAAE4C,KAAK,EAALA;kBAAF,CADmC,EAEnC,KAAKpB,MAAL,CAAYC,OAAZ,CAAoBoD,eAFe,CAZpB;kBAgBjBC,MAAM,EAAE,KAAKnD,cAhBI;kBAiBjBsB,WAAW,EAAXA,WAjBiB;kBAkBjBC,aAAa,EAAbA,aAlBiB;kBAmBjBG,WAAW,EAAXA;gBAnBiB,C,EAsBnB;;gBACA,KAAKzB,cAAL,GAAsB,KAAKJ,MAAL,CAAYuD,MAAZ,CAAmBC,oBAAnB,CAAwCd,UAAxC,CAAtB;;;;;;;;;;;;;;;gCAGiBlC,Q,EAA6C;MAC9D,KAAKA,QAAL,GAAAwC,aAAA,CAAAA,aAAA,KACK,KAAKxC,QADV,GAEKjC,eAAe,CAACiC,QAAD,CAFpB;IAID;;;yBAEWP,O,EAAkC;MAAA,IAAAwD,MAAA;MAC5C,IAAMC,UAAU,GAAG,KAAK1D,MAAL,CAAY2D,oBAAZ,EAAnB;MAEA,IAAMnD,QAEL,GAAAwC,aAAA,CAAAA,aAAA,KACI,KAAKxC,QADT,GAEIjC,eAAe,CAAC0B,OAAO,CAACO,QAAR,IAAoB,EAArB,CAFnB,CAFD;MAOA,IAAMoD,iBAAsC,GAAG,EAA/C,CAV4C,CAY5C;;MACA7B,MAAM,CAACC,IAAP,CAAYxB,QAAZ,EAAsBqD,OAAtB,CAA8B,UAACC,WAAD,EAAyB;QACrD,IAAMC,IAAI,GAAAC,OAAA,CAAUxD,QAAQ,CAACsD,WAAD,CAAlB,CAAV;QACA,IACEC,IAAI,KAAK,SAAT,IACAA,IAAI,KAAK,QADT,IAEA3E,KAAK,CAAC6E,OAAN,CAAczD,QAAQ,CAACsD,WAAD,CAAtB,CAFA;QAGA;QACAtD,QAAQ,CAACsD,WAAD,CAAR,CAAsBI,iBALxB,EAME;UAAA,IAAAC,qBAAA;UACA,IAAMzE,MAAM,IAAAyE,qBAAA,GAAGV,MAAI,CAAChD,sBAAL,CAA4B2D,IAA5B,CACb,UAAAC,IAAA;YAAA,IAAGC,IAAH,GAAAD,IAAA,CAAGC,IAAH;YAAA,OAAcA,IAAI,KAAKR,WAAvB;UAAA,CADa,CAAH,cAAAK,qBAAA,uBAAGA,qBAAA,CAEZzE,MAFH;UAGA,IAAIA,MAAM,KAAK,IAAf,EAAqB;YACnB+D,MAAI,CAAClD,aAAL,CAAmBgE,OAAnB,CAA2B;cACzB;cACAC,IAAI,EAAEhE,QAAQ,CAACsD,WAAD,CAFW;cAGzB;cACApE,MAAM,EAANA;YAJyB,CAA3B;UAMD;QACF,CAlBD,MAkBO;UAAA,IAAA+E,sBAAA;UACL,IAAIC,OAAM,IAAAD,sBAAA,GAAGhB,MAAI,CAAChD,sBAAL,CAA4B2D,IAA5B,CACX,UAAAO,KAAA;YAAA,IAAGL,IAAH,GAAAK,KAAA,CAAGL,IAAH;YAAA,OAAcA,IAAI,KAAKR,WAAvB;UAAA,CADW,CAAH,cAAAW,sBAAA,uBAAGA,sBAAA,CAEV/E,MAFH;UAGA,IAAIgF,OAAM,KAAK,IAAf,EAAqB;YACnB,IAAME,oBAAoB,GAAIpE,QAAQ,CAACsD,WAAD,CAAT,CAENlC,GAFM,EAA7B;YADmB,IAAAiD,KAAA;cAKjB;cACAD,oBAAoB,CAACE,KAArB,IAA8BF,oBANb;cAIXG,OAJW,GAAAF,KAAA,CAIXE,OAJW;cAIFC,OAJE,GAAAH,KAAA,CAIFG,OAJE;YAOnB,IAAIA,OAAJ,EAAa;cACXpB,iBAAiB,CAACqB,IAAlB,CAAuB;gBACrB;gBACAC,OAAO,EAAER,OAFY;gBAGrBS,QAAQ,EAAEH;cAHW,CAAvB,EADW,CAMX;;cACAN,OAAM;YACP;YACDd,iBAAiB,CAACqB,IAAlB,CAAuB;cACrB;cACAC,OAAO,EAAER,OAFY;cAGrBS,QAAQ,EAAEJ,OAAO,CAACK,UAAR;YAHW,CAAvB;UAKD;QACF;MACF,CA/CD;MAiDA,IAAI,KAAK7E,aAAT,EAAwB;QACtBqD,iBAAiB,CAAC,CAAD,CAAjB,GAAuB;UACrBsB,OAAO,EAAE,CADY;UAErBC,QAAQ,EAAE;YACRE,MAAM,EAAE,KAAK9E,aAAL,CAAmBqB,GAAnB,EADA,CAC0B;UAD1B;QAFW,CAAvB;MAMD;MAED,KAAKtB,gBAAL,GAAwB,KAAKN,MAAL,CAAYuD,MAAZ,CAAmB+B,eAAnB,CAAmC;QACzDhC,MAAM,EAAE,KAAKjD,uBAD4C;QAEzDkF,OAAO,EAAE3B;MAFgD,CAAnC,CAAxB;MAKA,IAAI,KAAKxD,cAAT,EAAyB;QACvBsD,UAAU,CAAC8B,WAAX,CAAuB,KAAKpF,cAA5B;MACD;MAEDsD,UAAU,CAAC+B,YAAX,CAAwB,CAAxB,EAA2B,KAAKnF,gBAAhC;MAEA,IAAI,KAAKK,WAAT,EAAsB;QACpB+C,UAAU,CAACgC,cAAX,CACE,KAAK/E,WAAL,CAAiBiB,GAAjB,EADF,EAEEtD,eAAe,CAACqH,WAAhB,CAA4BC,MAF9B,EAGE,CAHF;MAKD;MAED7D,MAAM,CAACC,IAAP,CAAY,KAAKtB,cAAjB,EAAiCmD,OAAjC,CAAyC,UAAC3B,aAAD,EAAwBC,CAAxB,EAA8B;QACrEuB,UAAU,CAACmC,eAAX,CACE,IAAI1D,CADN,EAEEsB,MAAI,CAAC/C,cAAL,CAAoBwB,aAApB,EAAmCN,GAAnC,GAAyCyD,MAF3C,EAGE,CAHF;MAKD,CAND,EA1F4C,CAkG5C;;MACA,IAAI,KAAK1E,WAAT,EAAsB;QACpB+C,UAAU,CAACoC,WAAX,CACE,KAAKlF,UADP,EAEE,KAAKX,OAAL,CAAasB,SAAb,IAA0B,CAF5B,EAGE,CAHF,EAIE,CAJF,EAKE,CALF;MAOD,CARD,MAQO;QACLmC,UAAU,CAACqC,IAAX,CACE,KAAK9F,OAAL,CAAagB,KAAb,IAAsB,CADxB,EAEE,KAAKhB,OAAL,CAAasB,SAAb,IAA0B,CAF5B,EAGE,CAHF,EAIE,CAJF;MAMD;IACF;;;8BAEsB;MACrB,MAAM,IAAIyE,KAAJ,CAAU,yBAAV,CAAN;IACD;;;;sHAGCC,U,EACAC,Y,EACAC,O;;;;;;gBAIMC,a,GAAgB,gB;gBAElBC,Y,GAAqCJ,U;gBACrCK,c,GAAuCJ,Y;oBACtC,KAAKlG,MAAL,CAAYC,OAAZ,CAAoBsG,O;;;;;uBACF,KAAKC,oBAAL,CACnBP,UADmB,EAEnB,QAFmB,EAGnBG,aAHmB,C;;gBAArBC,Y;;uBAKuB,KAAKG,oBAAL,CACrBN,YADqB,EAErB,UAFqB,EAGrBE,aAHqB,C;;gBAAvBE,c;;kDAOK,KAAKG,6BAAL,CAAmCJ,YAAnC,EAAiDC,cAAjD,C;;;;;;;;;;;;;;;yCAIPI,M,EACA3C,I,EACAqC,a,EACsB;MACtB,OAAO,KAAKO,uBAAL,CAA6BP,aAAa,GAAGM,MAA7C,EAAqD3C,IAArD,CAAP;IACD;;;4CAGC2C,M,EACA3C,I,EACsB;MACtB,OAAO,KAAK/D,MAAL,CAAY4G,OAAZ,CAAoBC,WAApB,CAAgCH,MAAhC,EAAwC3C,IAAxC,CAAP;IACD;;;kDAGCsC,Y,EACAC,c,EACoE;MACpE,OAAO;QACL7E,WAAW,EAAE;UACXqF,MAAM,EAAE,KAAK9G,MAAL,CAAYuD,MAAZ,CAAmBwD,kBAAnB,CAAsC;YAC5CC,IAAI,EAAEX,YADsC;YAE5C;YACAY,OAAO,EAAE5I;UAHmC,CAAtC,CADG;UAMX6I,UAAU,EAAE;QAND,CADR;QASLxF,aAAa,EAAE;UACboF,MAAM,EAAE,KAAK9G,MAAL,CAAYuD,MAAZ,CAAmBwD,kBAAnB,CAAsC;YAC5CC,IAAI,EAAEV,cADsC;YAE5C;YACAW,OAAO,EAAE5I;UAHmC,CAAtC,CADK;UAMb6I,UAAU,EAAE;QANC;MATV,CAAP;IAkBD;IAED;AACF;AACA;;;6DACoF;MAChF,OAAO;QACLC,SAAS,EAAE7I,eAAe,CAAC8I,SAAhB,CAA0BC,GADhC;QAELnE,QAAQ,EAAE5E,eAAe,CAACgJ,QAAhB,CAAyBC,IAF9B;QAGLC,SAAS,EAAE,CAHN;QAILC,mBAAmB,EAAE,CAJhB;QAKLC,cAAc,EAAE;MALX,CAAP;IAOD;;;0CAE6BlH,Q,EAAuC;MAAA,IAAAmH,MAAA;MACnE,IAAIjI,MAAM,GAAG,CAAb,CADmE,CAEnE;;MACA,IAAMkI,iBAAiB,GAAG/I,WAAW,CAAAgJ,KAAX,UACxBC,YADwB,EAAAC,MAAA,CAAAC,kBAAA,CAErBjG,MAAM,CAACC,IAAP,CAAYxB,QAAZ,EAAsByB,GAAtB,CAA0B,UAAC6B,WAAD,EAAiB;QAC5C,IAAItD,QAAQ,CAACsD,WAAD,CAAZ,EAA2B;UACzB6D,MAAI,CAAClH,sBAAL,CAA4BwE,IAA5B,CAAiC;YAC/BX,IAAI,EAAER,WADyB;YAE/BpE,MAAM,EAANA;UAF+B,CAAjC,EADyB,CAKzB;;UACAA,MAAM,IAAI,CAACc,QAAQ,CAACsD,WAAD,CAAR,CAAsB5E,MAAtB,IAAgC,CAAjC,IAAsC,CAAhD;UACA,OAAOsB,QAAQ,CAACsD,WAAD,CAAf;QACD,CARD,MAQO;UACL;UACA,OAAO,EAAP;QACD;MACF,CAbE,CAFqB,GAA1B;MAkBA,IAAMyB,OAAkC,GAAG,EAA3C;MACA,IAAI0C,UAAU,GAAG,KAAjB;MACA,IAAIL,iBAAiB,CAAC1I,MAAtB,EAA8B;QAC5B+I,UAAU,GAAG,IAAb,CAD4B,CAE5B;;QACA1C,OAAO,CAACN,IAAR,CAAa;UACX;UACAC,OAAO,EAAE,CAFE;UAGXgD,UAAU,EACR5J,eAAe,CAAC6J,WAAhB,CAA4BC,QAA5B,GACA9J,eAAe,CAAC6J,WAAhB,CAA4BE,MALnB;UAK2B;UACtCtE,IAAI,EAAEzF,eAAe,CAACgK,WAAhB,CAA4BC;QANvB,CAAb;MAQD,CAlCkE,CAoCnE;;MACAxG,MAAM,CAACC,IAAP,CAAYxB,QAAZ,EACGgI,MADH,CACU,UAAC1E,WAAD;QAAA,OAAiBtD,QAAQ,CAACsD,WAAD,CAAR,KAA0B,IAA3C;MAAA,CADV,EAEGD,OAFH,CAEW,UAACC,WAAD,EAAc3B,CAAd,EAAoB;QAC3BwF,MAAI,CAAClH,sBAAL,CAA4BwE,IAA5B,CAAiC;UAC/BX,IAAI,EAAER,WADyB;UAE/BpE,MAAM,EAAEyC,CAAC,GAAG,CAAJ,IAAS8F,UAAU,GAAG,CAAH,GAAO,CAA1B;QAFuB,CAAjC;QAIA1C,OAAO,CAACN,IAAR,CACE;UACE;UACAC,OAAO,EAAE/C,CAAC,GAAG,CAAJ,IAAS8F,UAAU,GAAG,CAAH,GAAO,CAA1B,CAFX;UAGEC,UAAU,EAAE5J,eAAe,CAAC6J,WAAhB,CAA4BC,QAH1C;UAIErE,IAAI,EAAEzF,eAAe,CAACgK,WAAhB,CAA4BG;QAJpC,CADF,EAOE;UACE;UACAvD,OAAO,EAAE/C,CAAC,GAAG,CAAJ,IAAS8F,UAAU,GAAG,CAAH,GAAO,CAA1B,IAA+B,CAF1C;UAGEC,UAAU,EAAE5J,eAAe,CAAC6J,WAAhB,CAA4BC,QAH1C;UAIErE,IAAI,EAAEzF,eAAe,CAACgK,WAAhB,CAA4BI;QAJpC,CAPF;MAcD,CArBH;MAuBA,KAAKrI,uBAAL,GAA+B,KAAKL,MAAL,CAAYuD,MAAZ,CAAmBoF,qBAAnB,CAAyC;QACtE;QACA;QACA;QACApD,OAAO,EAAPA;MAJsE,CAAzC,CAA/B;MAOA,KAAKpF,cAAL,GAAsB,KAAKH,MAAL,CAAYuD,MAAZ,CAAmBqF,oBAAnB,CAAwC;QAC5DC,gBAAgB,EAAE,CAAC,KAAKxI,uBAAN;MAD0C,CAAxC,CAAtB;MAIA,IAAI4H,UAAJ,EAAgB;QACd,KAAK1H,aAAL,GAAqB,IAAI3B,YAAJ,CAAiB,KAAKoB,MAAtB,EAA8B;UACjD;UACA;UACAwE,IAAI,EACFoD,iBAAiB,YAAYxI,KAA7B;UACI;UACA,IAAI0I,YAAJ,CAAiBF,iBAAjB,CAFJ,GAGIA,iBAP2C;UAQjDkB,KAAK,EACHxK,eAAe,CAACyK,WAAhB,CAA4BC,OAA5B,GACA1K,eAAe,CAACyK,WAAhB,CAA4BE;QAVmB,CAA9B,CAArB;MAYD;IACF;;;;SAlZkBlJ,W","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}