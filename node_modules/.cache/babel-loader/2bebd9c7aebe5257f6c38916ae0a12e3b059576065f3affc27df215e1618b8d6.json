{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { ObjectExt, FunctionExt } from '../util';\nimport { Basecoat } from '../common';\nimport { Model } from '../model/model';\nexport class HistoryManager extends Basecoat {\n  constructor(options) {\n    super();\n    this.batchCommands = null;\n    this.batchLevel = 0;\n    this.lastBatchIndex = -1;\n    this.freezed = false;\n    this.handlers = [];\n    this.graph = options.graph;\n    this.model = options.graph.model;\n    this.options = Util.getOptions(options);\n    this.validator = new HistoryManager.Validator({\n      history: this,\n      cancelInvalid: this.options.cancelInvalid\n    });\n    this.clean();\n    this.startListening();\n  }\n  get disabled() {\n    return this.options.enabled !== true;\n  }\n  enable() {\n    if (this.disabled) {\n      this.options.enabled = true;\n    }\n  }\n  disable() {\n    if (!this.disabled) {\n      this.options.enabled = false;\n    }\n  }\n  undo(options = {}) {\n    if (!this.disabled) {\n      const cmd = this.undoStack.pop();\n      if (cmd) {\n        this.revertCommand(cmd, options);\n        this.redoStack.push(cmd);\n        this.notify('undo', cmd, options);\n      }\n    }\n    return this;\n  }\n  redo(options = {}) {\n    if (!this.disabled) {\n      const cmd = this.redoStack.pop();\n      if (cmd) {\n        this.applyCommand(cmd, options);\n        this.undoStack.push(cmd);\n        this.notify('redo', cmd, options);\n      }\n    }\n    return this;\n  }\n  /**\n   * Same as `undo()` but does not store the undo-ed command to the\n   * `redoStack`. Canceled command therefore cannot be redo-ed.\n   */\n  cancel(options = {}) {\n    if (!this.disabled) {\n      const cmd = this.undoStack.pop();\n      if (cmd) {\n        this.revertCommand(cmd, options);\n        this.redoStack = [];\n        this.notify('cancel', cmd, options);\n      }\n    }\n    return this;\n  }\n  clean(options = {}) {\n    this.undoStack = [];\n    this.redoStack = [];\n    this.notify('clean', null, options);\n    return this;\n  }\n  canUndo() {\n    return !this.disabled && this.undoStack.length > 0;\n  }\n  canRedo() {\n    return !this.disabled && this.redoStack.length > 0;\n  }\n  validate(events, ...callbacks) {\n    this.validator.validate(events, ...callbacks);\n    return this;\n  }\n  dispose() {\n    this.validator.dispose();\n    this.clean();\n    this.stopListening();\n  }\n  startListening() {\n    this.model.on('batch:start', this.initBatchCommand, this);\n    this.model.on('batch:stop', this.storeBatchCommand, this);\n    if (this.options.eventNames) {\n      this.options.eventNames.forEach((name, index) => {\n        this.handlers[index] = this.addCommand.bind(this, name);\n        this.model.on(name, this.handlers[index]);\n      });\n    }\n    this.validator.on('invalid', args => this.trigger('invalid', args));\n  }\n  stopListening() {\n    this.model.off('batch:start', this.initBatchCommand, this);\n    this.model.off('batch:stop', this.storeBatchCommand, this);\n    if (this.options.eventNames) {\n      this.options.eventNames.forEach((name, index) => {\n        this.model.off(name, this.handlers[index]);\n      });\n      this.handlers.length = 0;\n    }\n    this.validator.off('invalid');\n  }\n  createCommand(options) {\n    return {\n      batch: options ? options.batch : false,\n      data: {}\n    };\n  }\n  revertCommand(cmd, options) {\n    this.freezed = true;\n    const cmds = Array.isArray(cmd) ? Util.sortBatchCommands(cmd) : [cmd];\n    for (let i = cmds.length - 1; i >= 0; i -= 1) {\n      const cmd = cmds[i];\n      const localOptions = Object.assign(Object.assign({}, options), ObjectExt.pick(cmd.options, this.options.revertOptionsList || []));\n      this.executeCommand(cmd, true, localOptions);\n    }\n    this.freezed = false;\n  }\n  applyCommand(cmd, options) {\n    this.freezed = true;\n    const cmds = Array.isArray(cmd) ? Util.sortBatchCommands(cmd) : [cmd];\n    for (let i = 0; i < cmds.length; i += 1) {\n      const cmd = cmds[i];\n      const localOptions = Object.assign(Object.assign({}, options), ObjectExt.pick(cmd.options, this.options.applyOptionsList || []));\n      this.executeCommand(cmd, false, localOptions);\n    }\n    this.freezed = false;\n  }\n  executeCommand(cmd, revert, options) {\n    const model = this.model;\n    // const cell = cmd.modelChange ? model : model.getCell(cmd.data.id!)\n    const cell = model.getCell(cmd.data.id);\n    const event = cmd.event;\n    if (Util.isAddEvent(event) && revert || Util.isRemoveEvent(event) && !revert) {\n      cell && cell.remove(options);\n    } else if (Util.isAddEvent(event) && !revert || Util.isRemoveEvent(event) && revert) {\n      const data = cmd.data;\n      if (data.node) {\n        model.addNode(data.props, options);\n      } else if (data.edge) {\n        model.addEdge(data.props, options);\n      }\n    } else if (Util.isChangeEvent(event)) {\n      const data = cmd.data;\n      const key = data.key;\n      if (key && cell) {\n        const value = revert ? data.prev[key] : data.next[key];\n        cell.prop(key, value, options);\n      }\n    } else {\n      const executeCommand = this.options.executeCommand;\n      if (executeCommand) {\n        FunctionExt.call(executeCommand, this, cmd, revert, options);\n      }\n    }\n  }\n  addCommand(event, args) {\n    if (this.freezed || this.disabled) {\n      return;\n    }\n    const eventArgs = args;\n    const options = eventArgs.options || {};\n    if (options.dryrun) {\n      return;\n    }\n    if (Util.isAddEvent(event) && this.options.ignoreAdd || Util.isRemoveEvent(event) && this.options.ignoreRemove || Util.isChangeEvent(event) && this.options.ignoreChange) {\n      return;\n    }\n    // before\n    // ------\n    const before = this.options.beforeAddCommand;\n    if (before != null && FunctionExt.call(before, this, event, args) === false) {\n      return;\n    }\n    if (event === 'cell:change:*') {\n      // eslint-disable-next-line\n      event = `cell:change:${eventArgs.key}`;\n    }\n    const cell = eventArgs.cell;\n    const isModelChange = Model.isModel(cell);\n    let cmd;\n    if (this.batchCommands) {\n      // In most cases we are working with same object, doing\n      // same action etc. translate an object piece by piece.\n      cmd = this.batchCommands[Math.max(this.lastBatchIndex, 0)];\n      // Check if we are start working with new object or performing different\n      // action with it. Note, that command is uninitialized when lastCmdIndex\n      // equals -1. In that case we are done, command we were looking for is\n      // already set\n      const diffId = isModelChange && !cmd.modelChange || cmd.data.id !== cell.id;\n      const diffName = cmd.event !== event;\n      if (this.lastBatchIndex >= 0 && (diffId || diffName)) {\n        // Trying to find command first, which was performing same\n        // action with the object as we are doing now with cell.\n        const index = this.batchCommands.findIndex(cmd => (isModelChange && cmd.modelChange || cmd.data.id === cell.id) && cmd.event === event);\n        if (index < 0 || Util.isAddEvent(event) || Util.isRemoveEvent(event)) {\n          cmd = this.createCommand({\n            batch: true\n          });\n        } else {\n          cmd = this.batchCommands[index];\n          this.batchCommands.splice(index, 1);\n        }\n        this.batchCommands.push(cmd);\n        this.lastBatchIndex = this.batchCommands.length - 1;\n      }\n    } else {\n      cmd = this.createCommand({\n        batch: false\n      });\n    }\n    // add & remove\n    // ------------\n    if (Util.isAddEvent(event) || Util.isRemoveEvent(event)) {\n      const data = cmd.data;\n      cmd.event = event;\n      cmd.options = options;\n      data.id = cell.id;\n      data.props = ObjectExt.cloneDeep(cell.toJSON());\n      if (cell.isEdge()) {\n        data.edge = true;\n      } else if (cell.isNode()) {\n        data.node = true;\n      }\n      return this.push(cmd, options);\n    }\n    // change:*\n    // --------\n    if (Util.isChangeEvent(event)) {\n      const key = args.key;\n      const data = cmd.data;\n      if (!cmd.batch || !cmd.event) {\n        // Do this only once. Set previous data and action (also\n        // serves as a flag so that we don't repeat this branche).\n        cmd.event = event;\n        cmd.options = options;\n        data.key = key;\n        if (data.prev == null) {\n          data.prev = {};\n        }\n        data.prev[key] = ObjectExt.clone(cell.previous(key));\n        if (isModelChange) {\n          cmd.modelChange = true;\n        } else {\n          data.id = cell.id;\n        }\n      }\n      if (data.next == null) {\n        data.next = {};\n      }\n      data.next[key] = ObjectExt.clone(cell.prop(key));\n      return this.push(cmd, options);\n    }\n    // others\n    // ------\n    const afterAddCommand = this.options.afterAddCommand;\n    if (afterAddCommand) {\n      FunctionExt.call(afterAddCommand, this, event, args, cmd);\n    }\n    this.push(cmd, options);\n  }\n  /**\n   * Gather multiple changes into a single command. These commands could\n   * be reverted with single `undo()` call. From the moment the function\n   * is called every change made on model is not stored into the undoStack.\n   * Changes are temporarily kept until `storeBatchCommand()` is called.\n   */\n  // eslint-disable-next-line\n  initBatchCommand(options) {\n    if (this.freezed) {\n      return;\n    }\n    if (this.batchCommands) {\n      this.batchLevel += 1;\n    } else {\n      this.batchCommands = [this.createCommand({\n        batch: true\n      })];\n      this.batchLevel = 0;\n      this.lastBatchIndex = -1;\n    }\n  }\n  /**\n   * Store changes temporarily kept in the undoStack. You have to call this\n   * function as many times as `initBatchCommand()` been called.\n   */\n  storeBatchCommand(options) {\n    if (this.freezed) {\n      return;\n    }\n    if (this.batchCommands && this.batchLevel <= 0) {\n      const cmds = this.filterBatchCommand(this.batchCommands);\n      if (cmds.length > 0) {\n        this.redoStack = [];\n        this.undoStack.push(cmds);\n        this.consolidateCommands();\n        this.notify('add', cmds, options);\n      }\n      this.batchCommands = null;\n      this.lastBatchIndex = -1;\n      this.batchLevel = 0;\n    } else if (this.batchCommands && this.batchLevel > 0) {\n      this.batchLevel -= 1;\n    }\n  }\n  filterBatchCommand(batchCommands) {\n    let cmds = batchCommands.slice();\n    const result = [];\n    while (cmds.length > 0) {\n      const cmd = cmds.shift();\n      const evt = cmd.event;\n      const id = cmd.data.id;\n      if (evt != null && (id != null || cmd.modelChange)) {\n        if (Util.isAddEvent(evt)) {\n          const index = cmds.findIndex(c => Util.isRemoveEvent(c.event) && c.data.id === id);\n          if (index >= 0) {\n            cmds = cmds.filter((c, i) => index < i || c.data.id !== id);\n            continue;\n          }\n        } else if (Util.isRemoveEvent(evt)) {\n          const index = cmds.findIndex(c => Util.isAddEvent(c.event) && c.data.id === id);\n          if (index >= 0) {\n            cmds.splice(index, 1);\n            continue;\n          }\n        } else if (Util.isChangeEvent(evt)) {\n          const data = cmd.data;\n          if (ObjectExt.isEqual(data.prev, data.next)) {\n            continue;\n          }\n        } else {\n          // pass\n        }\n        result.push(cmd);\n      }\n    }\n    return result;\n  }\n  notify(event, cmd, options) {\n    const cmds = cmd == null ? null : Array.isArray(cmd) ? cmd : [cmd];\n    this.emit(event, {\n      cmds,\n      options\n    });\n    this.emit('change', {\n      cmds,\n      options\n    });\n  }\n  push(cmd, options) {\n    this.redoStack = [];\n    if (cmd.batch) {\n      this.lastBatchIndex = Math.max(this.lastBatchIndex, 0);\n      this.emit('batch', {\n        cmd,\n        options\n      });\n    } else {\n      this.undoStack.push(cmd);\n      this.consolidateCommands();\n      this.notify('add', cmd, options);\n    }\n  }\n  /**\n   * Conditionally combine multiple undo items into one.\n   *\n   * Currently this is only used combine a `cell:changed:position` event\n   * followed by multiple `cell:change:parent` and `cell:change:children`\n   * events, such that a \"move + embed\" action can be undone in one step.\n   *\n   * See https://github.com/antvis/X6/issues/2421\n   *\n   * This is an ugly WORKAROUND. It does not solve deficiencies in the batch\n   * system itself.\n   */\n  consolidateCommands() {\n    var _a;\n    const lastCommandGroup = this.undoStack[this.undoStack.length - 1];\n    const penultimateCommandGroup = this.undoStack[this.undoStack.length - 2];\n    // We are looking for at least one cell:change:parent\n    // and one cell:change:children\n    if (!Array.isArray(lastCommandGroup)) {\n      return;\n    }\n    const eventTypes = new Set(lastCommandGroup.map(cmd => cmd.event));\n    if (eventTypes.size !== 2 || !eventTypes.has('cell:change:parent') || !eventTypes.has('cell:change:children')) {\n      return;\n    }\n    // We are looking for events from user interactions\n    if (!lastCommandGroup.every(cmd => {\n      var _a;\n      return cmd.batch && ((_a = cmd.options) === null || _a === void 0 ? void 0 : _a.ui);\n    })) {\n      return;\n    }\n    // We are looking for a command group with exactly one event, whose event\n    // type is cell:change:position, and is from user interactions\n    if (!Array.isArray(penultimateCommandGroup) || penultimateCommandGroup.length !== 1) {\n      return;\n    }\n    const maybePositionChange = penultimateCommandGroup[0];\n    if (maybePositionChange.event !== 'cell:change:position' || !((_a = maybePositionChange.options) === null || _a === void 0 ? void 0 : _a.ui)) {\n      return;\n    }\n    // Actually consolidating the commands we get\n    penultimateCommandGroup.push(...lastCommandGroup);\n    this.undoStack.pop();\n  }\n}\n__decorate([Basecoat.dispose()], HistoryManager.prototype, \"dispose\", null);\n(function (HistoryManager) {\n  /**\n   * Runs a set of callbacks to determine if a command is valid. This is\n   * useful for checking if a certain action in your application does\n   * lead to an invalid state of the graph.\n   */\n  class Validator extends Basecoat {\n    constructor(options) {\n      super();\n      this.map = {};\n      this.command = options.history;\n      this.cancelInvalid = options.cancelInvalid !== false;\n      this.command.on('add', this.onCommandAdded, this);\n    }\n    onCommandAdded({\n      cmds\n    }) {\n      return Array.isArray(cmds) ? cmds.every(cmd => this.isValidCommand(cmd)) : this.isValidCommand(cmds);\n    }\n    isValidCommand(cmd) {\n      if (cmd.options && cmd.options.validation === false) {\n        return true;\n      }\n      const callbacks = cmd.event && this.map[cmd.event] || [];\n      let handoverErr = null;\n      callbacks.forEach(routes => {\n        let i = 0;\n        const rollup = err => {\n          const fn = routes[i];\n          i += 1;\n          try {\n            if (fn) {\n              fn(err, cmd, rollup);\n            } else {\n              handoverErr = err;\n              return;\n            }\n          } catch (err) {\n            rollup(err);\n          }\n        };\n        rollup(handoverErr);\n      });\n      if (handoverErr) {\n        if (this.cancelInvalid) {\n          this.command.cancel();\n        }\n        this.emit('invalid', {\n          err: handoverErr\n        });\n        return false;\n      }\n      return true;\n    }\n    validate(events, ...callbacks) {\n      const evts = Array.isArray(events) ? events : events.split(/\\s+/);\n      callbacks.forEach(callback => {\n        if (typeof callback !== 'function') {\n          throw new Error(`${evts.join(' ')} requires callback functions.`);\n        }\n      });\n      evts.forEach(event => {\n        if (this.map[event] == null) {\n          this.map[event] = [];\n        }\n        this.map[event].push(callbacks);\n      });\n      return this;\n    }\n    dispose() {\n      this.command.off('add', this.onCommandAdded, this);\n    }\n  }\n  __decorate([Basecoat.dispose()], Validator.prototype, \"dispose\", null);\n  HistoryManager.Validator = Validator;\n})(HistoryManager || (HistoryManager = {}));\nvar Util;\n(function (Util) {\n  function isAddEvent(event) {\n    return event === 'cell:added';\n  }\n  Util.isAddEvent = isAddEvent;\n  function isRemoveEvent(event) {\n    return event === 'cell:removed';\n  }\n  Util.isRemoveEvent = isRemoveEvent;\n  function isChangeEvent(event) {\n    return event != null && event.startsWith('cell:change:');\n  }\n  Util.isChangeEvent = isChangeEvent;\n  function getOptions(options) {\n    const {\n        graph\n      } = options,\n      others = __rest(options, [\"graph\"]);\n    const reservedNames = ['cell:added', 'cell:removed', 'cell:change:*'];\n    const batchEvents = ['batch:start', 'batch:stop'];\n    const eventNames = options.eventNames ? options.eventNames.filter(event => !(Util.isChangeEvent(event) || reservedNames.includes(event) || batchEvents.includes(event))) : reservedNames;\n    return Object.assign(Object.assign({}, others), {\n      eventNames,\n      applyOptionsList: options.applyOptionsList || ['propertyPath'],\n      revertOptionsList: options.revertOptionsList || ['propertyPath']\n    });\n  }\n  Util.getOptions = getOptions;\n  function sortBatchCommands(cmds) {\n    const results = [];\n    for (let i = 0, ii = cmds.length; i < ii; i += 1) {\n      const cmd = cmds[i];\n      let index = null;\n      if (Util.isAddEvent(cmd.event)) {\n        const id = cmd.data.id;\n        for (let j = 0; j < i; j += 1) {\n          if (cmds[j].data.id === id) {\n            index = j;\n            break;\n          }\n        }\n      }\n      if (index !== null) {\n        results.splice(index, 0, cmd);\n      } else {\n        results.push(cmd);\n      }\n    }\n    return results;\n  }\n  Util.sortBatchCommands = sortBatchCommands;\n})(Util || (Util = {}));","map":{"version":3,"names":["ObjectExt","FunctionExt","Basecoat","Model","HistoryManager","constructor","options","batchCommands","batchLevel","lastBatchIndex","freezed","handlers","graph","model","Util","getOptions","validator","Validator","history","cancelInvalid","clean","startListening","disabled","enabled","enable","disable","undo","cmd","undoStack","pop","revertCommand","redoStack","push","notify","redo","applyCommand","cancel","canUndo","length","canRedo","validate","events","callbacks","dispose","stopListening","on","initBatchCommand","storeBatchCommand","eventNames","forEach","name","index","addCommand","bind","args","trigger","off","createCommand","batch","data","cmds","Array","isArray","sortBatchCommands","i","localOptions","Object","assign","pick","revertOptionsList","executeCommand","applyOptionsList","revert","cell","getCell","id","event","isAddEvent","isRemoveEvent","remove","node","addNode","props","edge","addEdge","isChangeEvent","key","value","prev","next","prop","call","eventArgs","dryrun","ignoreAdd","ignoreRemove","ignoreChange","before","beforeAddCommand","isModelChange","isModel","Math","max","diffId","modelChange","diffName","findIndex","splice","cloneDeep","toJSON","isEdge","isNode","clone","previous","afterAddCommand","filterBatchCommand","consolidateCommands","slice","result","shift","evt","c","filter","isEqual","emit","lastCommandGroup","penultimateCommandGroup","eventTypes","Set","map","size","has","every","_a","ui","maybePositionChange","__decorate","command","onCommandAdded","isValidCommand","validation","handoverErr","routes","rollup","err","fn","evts","split","callback","Error","join","startsWith","others","__rest","reservedNames","batchEvents","includes","results","ii","j"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/graph/history.ts"],"sourcesContent":["import { KeyValue } from '../types'\nimport { ObjectExt, FunctionExt } from '../util'\nimport { Basecoat, IDisablable } from '../common'\nimport { Cell } from '../model/cell'\nimport { Model } from '../model/model'\nimport { Graph } from './graph'\n\nexport class HistoryManager\n  extends Basecoat<HistoryManager.EventArgs>\n  implements IDisablable\n{\n  public readonly model: Model\n  public readonly graph: Graph\n  public readonly options: HistoryManager.CommonOptions\n  public readonly validator: HistoryManager.Validator\n  protected redoStack: HistoryManager.Commands[]\n  protected undoStack: HistoryManager.Commands[]\n  protected batchCommands: HistoryManager.Command[] | null = null\n  protected batchLevel = 0\n  protected lastBatchIndex = -1\n  protected freezed = false\n\n  protected readonly handlers: (<T extends HistoryManager.ModelEvents>(\n    event: T,\n    args: Model.EventArgs[T],\n  ) => any)[] = []\n\n  constructor(options: HistoryManager.Options) {\n    super()\n    this.graph = options.graph\n    this.model = options.graph.model\n    this.options = Util.getOptions(options)\n    this.validator = new HistoryManager.Validator({\n      history: this,\n      cancelInvalid: this.options.cancelInvalid,\n    })\n    this.clean()\n    this.startListening()\n  }\n\n  get disabled() {\n    return this.options.enabled !== true\n  }\n\n  enable() {\n    if (this.disabled) {\n      this.options.enabled = true\n    }\n  }\n\n  disable() {\n    if (!this.disabled) {\n      this.options.enabled = false\n    }\n  }\n\n  undo(options: KeyValue = {}) {\n    if (!this.disabled) {\n      const cmd = this.undoStack.pop()\n      if (cmd) {\n        this.revertCommand(cmd, options)\n        this.redoStack.push(cmd)\n        this.notify('undo', cmd, options)\n      }\n    }\n    return this\n  }\n\n  redo(options: KeyValue = {}) {\n    if (!this.disabled) {\n      const cmd = this.redoStack.pop()\n      if (cmd) {\n        this.applyCommand(cmd, options)\n        this.undoStack.push(cmd)\n        this.notify('redo', cmd, options)\n      }\n    }\n    return this\n  }\n\n  /**\n   * Same as `undo()` but does not store the undo-ed command to the\n   * `redoStack`. Canceled command therefore cannot be redo-ed.\n   */\n  cancel(options: KeyValue = {}) {\n    if (!this.disabled) {\n      const cmd = this.undoStack.pop()\n      if (cmd) {\n        this.revertCommand(cmd, options)\n        this.redoStack = []\n        this.notify('cancel', cmd, options)\n      }\n    }\n    return this\n  }\n\n  clean(options: KeyValue = {}) {\n    this.undoStack = []\n    this.redoStack = []\n    this.notify('clean', null, options)\n    return this\n  }\n\n  canUndo() {\n    return !this.disabled && this.undoStack.length > 0\n  }\n\n  canRedo() {\n    return !this.disabled && this.redoStack.length > 0\n  }\n\n  validate(\n    events: string | string[],\n    ...callbacks: HistoryManager.Validator.Callback[]\n  ) {\n    this.validator.validate(events, ...callbacks)\n    return this\n  }\n\n  @Basecoat.dispose()\n  dispose() {\n    this.validator.dispose()\n    this.clean()\n    this.stopListening()\n  }\n\n  protected startListening() {\n    this.model.on('batch:start', this.initBatchCommand, this)\n    this.model.on('batch:stop', this.storeBatchCommand, this)\n    if (this.options.eventNames) {\n      this.options.eventNames.forEach((name, index) => {\n        this.handlers[index] = this.addCommand.bind(this, name)\n        this.model.on(name, this.handlers[index])\n      })\n    }\n\n    this.validator.on('invalid', (args) => this.trigger('invalid', args))\n  }\n\n  protected stopListening() {\n    this.model.off('batch:start', this.initBatchCommand, this)\n    this.model.off('batch:stop', this.storeBatchCommand, this)\n    if (this.options.eventNames) {\n      this.options.eventNames.forEach((name, index) => {\n        this.model.off(name, this.handlers[index])\n      })\n      this.handlers.length = 0\n    }\n    this.validator.off('invalid')\n  }\n\n  protected createCommand(options?: {\n    batch: boolean\n  }): HistoryManager.Command {\n    return {\n      batch: options ? options.batch : false,\n      data: {} as HistoryManager.CreationData,\n    }\n  }\n\n  protected revertCommand(cmd: HistoryManager.Commands, options?: KeyValue) {\n    this.freezed = true\n\n    const cmds = Array.isArray(cmd) ? Util.sortBatchCommands(cmd) : [cmd]\n    for (let i = cmds.length - 1; i >= 0; i -= 1) {\n      const cmd = cmds[i]\n      const localOptions = {\n        ...options,\n        ...ObjectExt.pick(cmd.options, this.options.revertOptionsList || []),\n      }\n      this.executeCommand(cmd, true, localOptions)\n    }\n\n    this.freezed = false\n  }\n\n  protected applyCommand(cmd: HistoryManager.Commands, options?: KeyValue) {\n    this.freezed = true\n\n    const cmds = Array.isArray(cmd) ? Util.sortBatchCommands(cmd) : [cmd]\n    for (let i = 0; i < cmds.length; i += 1) {\n      const cmd = cmds[i]\n      const localOptions = {\n        ...options,\n        ...ObjectExt.pick(cmd.options, this.options.applyOptionsList || []),\n      }\n      this.executeCommand(cmd, false, localOptions)\n    }\n\n    this.freezed = false\n  }\n\n  protected executeCommand(\n    cmd: HistoryManager.Command,\n    revert: boolean,\n    options: KeyValue,\n  ) {\n    const model = this.model\n    // const cell = cmd.modelChange ? model : model.getCell(cmd.data.id!)\n    const cell = model.getCell(cmd.data.id!)\n    const event = cmd.event\n\n    if (\n      (Util.isAddEvent(event) && revert) ||\n      (Util.isRemoveEvent(event) && !revert)\n    ) {\n      cell && cell.remove(options)\n    } else if (\n      (Util.isAddEvent(event) && !revert) ||\n      (Util.isRemoveEvent(event) && revert)\n    ) {\n      const data = cmd.data as HistoryManager.CreationData\n      if (data.node) {\n        model.addNode(data.props, options)\n      } else if (data.edge) {\n        model.addEdge(data.props, options)\n      }\n    } else if (Util.isChangeEvent(event)) {\n      const data = cmd.data as HistoryManager.ChangingData\n      const key = data.key\n      if (key && cell) {\n        const value = revert ? data.prev[key] : data.next[key]\n        cell.prop(key, value, options)\n      }\n    } else {\n      const executeCommand = this.options.executeCommand\n      if (executeCommand) {\n        FunctionExt.call(executeCommand, this, cmd, revert, options)\n      }\n    }\n  }\n\n  protected addCommand<T extends keyof Model.EventArgs>(\n    event: T,\n    args: Model.EventArgs[T],\n  ) {\n    if (this.freezed || this.disabled) {\n      return\n    }\n\n    const eventArgs = args as Model.EventArgs['cell:change:*']\n    const options = eventArgs.options || {}\n    if (options.dryrun) {\n      return\n    }\n\n    if (\n      (Util.isAddEvent(event) && this.options.ignoreAdd) ||\n      (Util.isRemoveEvent(event) && this.options.ignoreRemove) ||\n      (Util.isChangeEvent(event) && this.options.ignoreChange)\n    ) {\n      return\n    }\n\n    // before\n    // ------\n    const before = this.options.beforeAddCommand\n    if (\n      before != null &&\n      FunctionExt.call(before, this, event, args) === false\n    ) {\n      return\n    }\n\n    if (event === 'cell:change:*') {\n      // eslint-disable-next-line\n      event = `cell:change:${eventArgs.key}` as T\n    }\n\n    const cell = eventArgs.cell\n    const isModelChange = Model.isModel(cell)\n    let cmd: HistoryManager.Command\n\n    if (this.batchCommands) {\n      // In most cases we are working with same object, doing\n      // same action etc. translate an object piece by piece.\n      cmd = this.batchCommands[Math.max(this.lastBatchIndex, 0)]\n\n      // Check if we are start working with new object or performing different\n      // action with it. Note, that command is uninitialized when lastCmdIndex\n      // equals -1. In that case we are done, command we were looking for is\n      // already set\n\n      const diffId =\n        (isModelChange && !cmd.modelChange) || cmd.data.id !== cell.id\n      const diffName = cmd.event !== event\n\n      if (this.lastBatchIndex >= 0 && (diffId || diffName)) {\n        // Trying to find command first, which was performing same\n        // action with the object as we are doing now with cell.\n        const index = this.batchCommands.findIndex(\n          (cmd) =>\n            ((isModelChange && cmd.modelChange) || cmd.data.id === cell.id) &&\n            cmd.event === event,\n        )\n\n        if (index < 0 || Util.isAddEvent(event) || Util.isRemoveEvent(event)) {\n          cmd = this.createCommand({ batch: true })\n        } else {\n          cmd = this.batchCommands[index]\n          this.batchCommands.splice(index, 1)\n        }\n        this.batchCommands.push(cmd)\n        this.lastBatchIndex = this.batchCommands.length - 1\n      }\n    } else {\n      cmd = this.createCommand({ batch: false })\n    }\n\n    // add & remove\n    // ------------\n    if (Util.isAddEvent(event) || Util.isRemoveEvent(event)) {\n      const data = cmd.data as HistoryManager.CreationData\n      cmd.event = event\n      cmd.options = options\n      data.id = cell.id\n      data.props = ObjectExt.cloneDeep(cell.toJSON())\n      if (cell.isEdge()) {\n        data.edge = true\n      } else if (cell.isNode()) {\n        data.node = true\n      }\n\n      return this.push(cmd, options)\n    }\n\n    // change:*\n    // --------\n    if (Util.isChangeEvent(event)) {\n      const key = (args as Model.EventArgs['cell:change:*']).key\n      const data = cmd.data as HistoryManager.ChangingData\n\n      if (!cmd.batch || !cmd.event) {\n        // Do this only once. Set previous data and action (also\n        // serves as a flag so that we don't repeat this branche).\n        cmd.event = event\n        cmd.options = options\n        data.key = key as string\n        if (data.prev == null) {\n          data.prev = {}\n        }\n        data.prev[key] = ObjectExt.clone(cell.previous(key))\n\n        if (isModelChange) {\n          cmd.modelChange = true\n        } else {\n          data.id = cell.id\n        }\n      }\n\n      if (data.next == null) {\n        data.next = {}\n      }\n      data.next[key] = ObjectExt.clone(cell.prop(key))\n      return this.push(cmd, options)\n    }\n\n    // others\n    // ------\n    const afterAddCommand = this.options.afterAddCommand\n    if (afterAddCommand) {\n      FunctionExt.call(afterAddCommand, this, event, args, cmd)\n    }\n    this.push(cmd, options)\n  }\n\n  /**\n   * Gather multiple changes into a single command. These commands could\n   * be reverted with single `undo()` call. From the moment the function\n   * is called every change made on model is not stored into the undoStack.\n   * Changes are temporarily kept until `storeBatchCommand()` is called.\n   */\n  // eslint-disable-next-line\n  protected initBatchCommand(options: KeyValue) {\n    if (this.freezed) {\n      return\n    }\n    if (this.batchCommands) {\n      this.batchLevel += 1\n    } else {\n      this.batchCommands = [this.createCommand({ batch: true })]\n      this.batchLevel = 0\n      this.lastBatchIndex = -1\n    }\n  }\n\n  /**\n   * Store changes temporarily kept in the undoStack. You have to call this\n   * function as many times as `initBatchCommand()` been called.\n   */\n  protected storeBatchCommand(options: KeyValue) {\n    if (this.freezed) {\n      return\n    }\n\n    if (this.batchCommands && this.batchLevel <= 0) {\n      const cmds = this.filterBatchCommand(this.batchCommands)\n      if (cmds.length > 0) {\n        this.redoStack = []\n        this.undoStack.push(cmds)\n        this.consolidateCommands()\n        this.notify('add', cmds, options)\n      }\n      this.batchCommands = null\n      this.lastBatchIndex = -1\n      this.batchLevel = 0\n    } else if (this.batchCommands && this.batchLevel > 0) {\n      this.batchLevel -= 1\n    }\n  }\n\n  protected filterBatchCommand(batchCommands: HistoryManager.Command[]) {\n    let cmds = batchCommands.slice()\n    const result = []\n\n    while (cmds.length > 0) {\n      const cmd = cmds.shift()!\n      const evt = cmd.event\n      const id = cmd.data.id\n\n      if (evt != null && (id != null || cmd.modelChange)) {\n        if (Util.isAddEvent(evt)) {\n          const index = cmds.findIndex(\n            (c) => Util.isRemoveEvent(c.event) && c.data.id === id,\n          )\n\n          if (index >= 0) {\n            cmds = cmds.filter((c, i) => index < i || c.data.id !== id)\n            continue\n          }\n        } else if (Util.isRemoveEvent(evt)) {\n          const index = cmds.findIndex(\n            (c) => Util.isAddEvent(c.event) && c.data.id === id,\n          )\n          if (index >= 0) {\n            cmds.splice(index, 1)\n            continue\n          }\n        } else if (Util.isChangeEvent(evt)) {\n          const data = cmd.data as HistoryManager.ChangingData\n\n          if (ObjectExt.isEqual(data.prev, data.next)) {\n            continue\n          }\n        } else {\n          // pass\n        }\n\n        result.push(cmd)\n      }\n    }\n\n    return result\n  }\n\n  protected notify(\n    event: keyof HistoryManager.EventArgs,\n    cmd: HistoryManager.Commands | null,\n    options: KeyValue,\n  ) {\n    const cmds = cmd == null ? null : Array.isArray(cmd) ? cmd : [cmd]\n    this.emit(event, { cmds, options })\n    this.emit('change', { cmds, options })\n  }\n\n  protected push(cmd: HistoryManager.Command, options: KeyValue) {\n    this.redoStack = []\n    if (cmd.batch) {\n      this.lastBatchIndex = Math.max(this.lastBatchIndex, 0)\n      this.emit('batch', { cmd, options })\n    } else {\n      this.undoStack.push(cmd)\n      this.consolidateCommands()\n      this.notify('add', cmd, options)\n    }\n  }\n\n  /**\n   * Conditionally combine multiple undo items into one.\n   *\n   * Currently this is only used combine a `cell:changed:position` event\n   * followed by multiple `cell:change:parent` and `cell:change:children`\n   * events, such that a \"move + embed\" action can be undone in one step.\n   *\n   * See https://github.com/antvis/X6/issues/2421\n   *\n   * This is an ugly WORKAROUND. It does not solve deficiencies in the batch\n   * system itself.\n   */\n  private consolidateCommands() {\n    const lastCommandGroup = this.undoStack[this.undoStack.length - 1]\n    const penultimateCommandGroup = this.undoStack[this.undoStack.length - 2]\n\n    // We are looking for at least one cell:change:parent\n    // and one cell:change:children\n    if (!Array.isArray(lastCommandGroup)) {\n      return\n    }\n    const eventTypes = new Set(lastCommandGroup.map((cmd) => cmd.event))\n    if (\n      eventTypes.size !== 2 ||\n      !eventTypes.has('cell:change:parent') ||\n      !eventTypes.has('cell:change:children')\n    ) {\n      return\n    }\n\n    // We are looking for events from user interactions\n    if (!lastCommandGroup.every((cmd) => cmd.batch && cmd.options?.ui)) {\n      return\n    }\n\n    // We are looking for a command group with exactly one event, whose event\n    // type is cell:change:position, and is from user interactions\n    if (\n      !Array.isArray(penultimateCommandGroup) ||\n      penultimateCommandGroup.length !== 1\n    ) {\n      return\n    }\n    const maybePositionChange = penultimateCommandGroup[0]\n    if (\n      maybePositionChange.event !== 'cell:change:position' ||\n      !maybePositionChange.options?.ui\n    ) {\n      return\n    }\n\n    // Actually consolidating the commands we get\n    penultimateCommandGroup.push(...lastCommandGroup)\n    this.undoStack.pop()\n  }\n}\n\nexport namespace HistoryManager {\n  export type ModelEvents = keyof Model.EventArgs\n\n  export interface CommonOptions {\n    enabled?: boolean\n    ignoreAdd?: boolean\n    ignoreRemove?: boolean\n    ignoreChange?: boolean\n    eventNames?: (keyof Model.EventArgs)[]\n    /**\n     * A function evaluated before any command is added. If the function\n     * returns `false`, the command does not get stored. This way you can\n     * control which commands do not get registered for undo/redo.\n     */\n    beforeAddCommand?: <T extends ModelEvents>(\n      this: HistoryManager,\n      event: T,\n      args: Model.EventArgs[T],\n    ) => any\n    afterAddCommand?: <T extends ModelEvents>(\n      this: HistoryManager,\n      event: T,\n      args: Model.EventArgs[T],\n      cmd: Command,\n    ) => any\n    executeCommand?: (\n      this: HistoryManager,\n      cmd: Command,\n      revert: boolean,\n      options: KeyValue,\n    ) => any\n    /**\n     * An array of options property names that passed in undo actions.\n     */\n    revertOptionsList?: string[]\n    /**\n     * An array of options property names that passed in redo actions.\n     */\n    applyOptionsList?: string[]\n    /**\n     * Determine whether to cancel an invalid command or not.\n     */\n    cancelInvalid?: boolean\n  }\n\n  export interface Options extends Partial<CommonOptions> {\n    graph: Graph\n  }\n\n  interface Data {\n    id?: string\n  }\n\n  export interface CreationData extends Data {\n    edge?: boolean\n    node?: boolean\n    props: Cell.Properties\n  }\n\n  export interface ChangingData extends Data {\n    key: string\n    prev: KeyValue\n    next: KeyValue\n  }\n\n  export interface Command {\n    batch: boolean\n    modelChange?: boolean\n    event?: ModelEvents\n    data: CreationData | ChangingData\n    options?: KeyValue\n  }\n\n  export type Commands = HistoryManager.Command[] | HistoryManager.Command\n}\n\nexport namespace HistoryManager {\n  interface Args<T = never> {\n    cmds: Command[] | T\n    options: KeyValue\n  }\n\n  export interface EventArgs extends Validator.EventArgs {\n    /**\n     * Triggered when a command was undone.\n     */\n    undo: Args\n    /**\n     * Triggered when a command were redone.\n     */\n    redo: Args\n    /**\n     * Triggered when a command was canceled.\n     */\n    cancel: Args\n    /**\n     * Triggered when command(s) were added to the stack.\n     */\n    add: Args\n    /**\n     * Triggered when all commands were clean.\n     */\n    clean: Args<null>\n    /**\n     * Triggered when any change was made to stacks.\n     */\n    change: Args<null>\n    /**\n     * Triggered when a batch command received.\n     */\n    batch: { cmd: Command; options: KeyValue }\n  }\n}\n\nexport namespace HistoryManager {\n  /**\n   * Runs a set of callbacks to determine if a command is valid. This is\n   * useful for checking if a certain action in your application does\n   * lead to an invalid state of the graph.\n   */\n  export class Validator extends Basecoat<Validator.EventArgs> {\n    protected readonly command: HistoryManager\n\n    protected readonly cancelInvalid: boolean\n\n    protected readonly map: { [event: string]: Validator.Callback[][] }\n\n    constructor(options: Validator.Options) {\n      super()\n      this.map = {}\n      this.command = options.history\n      this.cancelInvalid = options.cancelInvalid !== false\n      this.command.on('add', this.onCommandAdded, this)\n    }\n\n    protected onCommandAdded({ cmds }: HistoryManager.EventArgs['add']) {\n      return Array.isArray(cmds)\n        ? cmds.every((cmd) => this.isValidCommand(cmd))\n        : this.isValidCommand(cmds)\n    }\n\n    protected isValidCommand(cmd: HistoryManager.Command) {\n      if (cmd.options && cmd.options.validation === false) {\n        return true\n      }\n\n      const callbacks = (cmd.event && this.map[cmd.event]) || []\n\n      let handoverErr: Error | null = null\n\n      callbacks.forEach((routes) => {\n        let i = 0\n\n        const rollup = (err: Error | null) => {\n          const fn = routes[i]\n          i += 1\n\n          try {\n            if (fn) {\n              fn(err, cmd, rollup)\n            } else {\n              handoverErr = err\n              return\n            }\n          } catch (err) {\n            rollup(err)\n          }\n        }\n\n        rollup(handoverErr)\n      })\n\n      if (handoverErr) {\n        if (this.cancelInvalid) {\n          this.command.cancel()\n        }\n        this.emit('invalid', { err: handoverErr })\n        return false\n      }\n\n      return true\n    }\n\n    validate(events: string | string[], ...callbacks: Validator.Callback[]) {\n      const evts = Array.isArray(events) ? events : events.split(/\\s+/)\n\n      callbacks.forEach((callback) => {\n        if (typeof callback !== 'function') {\n          throw new Error(`${evts.join(' ')} requires callback functions.`)\n        }\n      })\n\n      evts.forEach((event) => {\n        if (this.map[event] == null) {\n          this.map[event] = []\n        }\n        this.map[event].push(callbacks)\n      })\n\n      return this\n    }\n\n    @Basecoat.dispose()\n    dispose() {\n      this.command.off('add', this.onCommandAdded, this)\n    }\n  }\n\n  export namespace Validator {\n    export interface Options {\n      history: HistoryManager\n      /**\n       * To cancel (= undo + delete from redo stack) a command if is not valid.\n       */\n      cancelInvalid?: boolean\n    }\n\n    export type Callback = (\n      err: Error | null,\n      cmd: HistoryManager.Command,\n      next: (err: Error | null) => any,\n    ) => any\n\n    export interface EventArgs {\n      invalid: { err: Error }\n    }\n  }\n}\n\nnamespace Util {\n  export function isAddEvent(event?: HistoryManager.ModelEvents) {\n    return event === 'cell:added'\n  }\n\n  export function isRemoveEvent(event?: HistoryManager.ModelEvents) {\n    return event === 'cell:removed'\n  }\n\n  export function isChangeEvent(event?: HistoryManager.ModelEvents) {\n    return event != null && event.startsWith('cell:change:')\n  }\n\n  export function getOptions(\n    options: HistoryManager.Options,\n  ): HistoryManager.CommonOptions {\n    const { graph, ...others } = options\n    const reservedNames: HistoryManager.ModelEvents[] = [\n      'cell:added',\n      'cell:removed',\n      'cell:change:*',\n    ]\n\n    const batchEvents: HistoryManager.ModelEvents[] = [\n      'batch:start',\n      'batch:stop',\n    ]\n\n    const eventNames = options.eventNames\n      ? options.eventNames.filter(\n          (event) =>\n            !(\n              Util.isChangeEvent(event) ||\n              reservedNames.includes(event) ||\n              batchEvents.includes(event)\n            ),\n        )\n      : reservedNames\n\n    return {\n      ...others,\n      eventNames,\n      applyOptionsList: options.applyOptionsList || ['propertyPath'],\n      revertOptionsList: options.revertOptionsList || ['propertyPath'],\n    }\n  }\n\n  export function sortBatchCommands(cmds: HistoryManager.Command[]) {\n    const results: HistoryManager.Command[] = []\n    for (let i = 0, ii = cmds.length; i < ii; i += 1) {\n      const cmd = cmds[i]\n      let index: number | null = null\n\n      if (Util.isAddEvent(cmd.event)) {\n        const id = cmd.data.id\n        for (let j = 0; j < i; j += 1) {\n          if (cmds[j].data.id === id) {\n            index = j\n            break\n          }\n        }\n      }\n\n      if (index !== null) {\n        results.splice(index, 0, cmd)\n      } else {\n        results.push(cmd)\n      }\n    }\n    return results\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}