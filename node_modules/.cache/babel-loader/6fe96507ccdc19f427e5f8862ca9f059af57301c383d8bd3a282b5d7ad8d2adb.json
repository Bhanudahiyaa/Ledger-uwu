{"ast":null,"code":"import { FunctionExt } from '../../../util';\nimport { Point, Rectangle } from '../../../geometry';\nimport { SortedSet } from './sorted-set';\nimport { ObstacleMap } from './obstacle-map';\nimport * as util from './util';\nimport { resolveOptions } from './options';\n/**\n * Finds the route between two points (`from`, `to`).\n */\nfunction findRoute(edgeView, from, to, map, options) {\n  const precision = options.precision;\n  let sourceEndpoint;\n  let targetEndpoint;\n  if (Rectangle.isRectangle(from)) {\n    sourceEndpoint = util.round(util.getSourceEndpoint(edgeView, options).clone(), precision);\n  } else {\n    sourceEndpoint = util.round(from.clone(), precision);\n  }\n  if (Rectangle.isRectangle(to)) {\n    targetEndpoint = util.round(util.getTargetEndpoint(edgeView, options).clone(), precision);\n  } else {\n    targetEndpoint = util.round(to.clone(), precision);\n  }\n  // Get grid for this route.\n  const grid = util.getGrid(options.step, sourceEndpoint, targetEndpoint);\n  // Get pathfinding points.\n  // -----------------------\n  const startPoint = sourceEndpoint;\n  const endPoint = targetEndpoint;\n  let startPoints;\n  let endPoints;\n  if (Rectangle.isRectangle(from)) {\n    startPoints = util.getRectPoints(startPoint, from, options.startDirections, grid, options);\n  } else {\n    startPoints = [startPoint];\n  }\n  if (Rectangle.isRectangle(to)) {\n    endPoints = util.getRectPoints(targetEndpoint, to, options.endDirections, grid, options);\n  } else {\n    endPoints = [endPoint];\n  }\n  // take into account only accessible rect points (those not under obstacles)\n  startPoints = startPoints.filter(p => map.isAccessible(p));\n  endPoints = endPoints.filter(p => map.isAccessible(p));\n  // There is an accessible route point on both sides.\n  if (startPoints.length > 0 && endPoints.length > 0) {\n    const openSet = new SortedSet();\n    // Keeps the actual points for given nodes of the open set.\n    const points = {};\n    // Keeps the point that is immediate predecessor of given element.\n    const parents = {};\n    // Cost from start to a point along best known path.\n    const costs = {};\n    for (let i = 0, n = startPoints.length; i < n; i += 1) {\n      // startPoint is assumed to be aligned already\n      const startPoint = startPoints[i];\n      const key = util.getKey(startPoint);\n      openSet.add(key, util.getCost(startPoint, endPoints));\n      points[key] = startPoint;\n      costs[key] = 0;\n    }\n    const previousRouteDirectionAngle = options.previousDirectionAngle;\n    // undefined for first route\n    const isPathBeginning = previousRouteDirectionAngle === undefined;\n    // directions\n    let direction;\n    let directionChange;\n    const directions = util.getGridOffsets(grid, options);\n    const numDirections = directions.length;\n    const endPointsKeys = endPoints.reduce((res, endPoint) => {\n      const key = util.getKey(endPoint);\n      res.push(key);\n      return res;\n    }, []);\n    // main route finding loop\n    const sameStartEndPoints = Point.equalPoints(startPoints, endPoints);\n    let loopsRemaining = options.maxLoopCount;\n    while (!openSet.isEmpty() && loopsRemaining > 0) {\n      // Get the closest item and mark it CLOSED\n      const currentKey = openSet.pop();\n      const currentPoint = points[currentKey];\n      const currentParent = parents[currentKey];\n      const currentCost = costs[currentKey];\n      const isStartPoint = currentPoint.equals(startPoint);\n      const isRouteBeginning = currentParent == null;\n      let previousDirectionAngle;\n      if (!isRouteBeginning) {\n        previousDirectionAngle = util.getDirectionAngle(currentParent, currentPoint, numDirections, grid, options);\n      } else if (!isPathBeginning) {\n        // a vertex on the route\n        previousDirectionAngle = previousRouteDirectionAngle;\n      } else if (!isStartPoint) {\n        // beginning of route on the path\n        previousDirectionAngle = util.getDirectionAngle(startPoint, currentPoint, numDirections, grid, options);\n      } else {\n        previousDirectionAngle = null;\n      }\n      // Check if we reached any endpoint\n      const skipEndCheck = isRouteBeginning && sameStartEndPoints;\n      if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {\n        options.previousDirectionAngle = previousDirectionAngle;\n        return util.reconstructRoute(parents, points, currentPoint, startPoint, endPoint);\n      }\n      // Go over all possible directions and find neighbors\n      for (let i = 0; i < numDirections; i += 1) {\n        direction = directions[i];\n        const directionAngle = direction.angle;\n        directionChange = util.getDirectionChange(previousDirectionAngle, directionAngle);\n        // Don't use the point changed rapidly.\n        if (!(isPathBeginning && isStartPoint) && directionChange > options.maxDirectionChange) {\n          continue;\n        }\n        const neighborPoint = util.align(currentPoint.clone().translate(direction.gridOffsetX || 0, direction.gridOffsetY || 0), grid, precision);\n        const neighborKey = util.getKey(neighborPoint);\n        // Closed points were already evaluated.\n        if (openSet.isClose(neighborKey) || !map.isAccessible(neighborPoint)) {\n          continue;\n        }\n        // Neighbor is an end point.\n        if (endPointsKeys.indexOf(neighborKey) >= 0) {\n          const isEndPoint = neighborPoint.equals(endPoint);\n          if (!isEndPoint) {\n            const endDirectionAngle = util.getDirectionAngle(neighborPoint, endPoint, numDirections, grid, options);\n            const endDirectionChange = util.getDirectionChange(directionAngle, endDirectionAngle);\n            if (endDirectionChange > options.maxDirectionChange) {\n              continue;\n            }\n          }\n        }\n        // The current direction is ok.\n        // ----------------------------\n        const neighborCost = direction.cost;\n        const neighborPenalty = isStartPoint ? 0 : options.penalties[directionChange];\n        const costFromStart = currentCost + neighborCost + neighborPenalty;\n        // Neighbor point has not been processed yet or the cost of\n        // the path from start is lower than previously calculated.\n        if (!openSet.isOpen(neighborKey) || costFromStart < costs[neighborKey]) {\n          points[neighborKey] = neighborPoint;\n          parents[neighborKey] = currentPoint;\n          costs[neighborKey] = costFromStart;\n          openSet.add(neighborKey, costFromStart + util.getCost(neighborPoint, endPoints));\n        }\n      }\n      loopsRemaining -= 1;\n    }\n  }\n  if (options.fallbackRoute) {\n    return FunctionExt.call(options.fallbackRoute, this, startPoint, endPoint, options);\n  }\n  return null;\n}\nexport const router = function (vertices, optionsRaw, edgeView) {\n  const options = resolveOptions(optionsRaw);\n  const sourceBBox = util.getSourceBBox(edgeView, options);\n  const targetBBox = util.getTargetBBox(edgeView, options);\n  const sourceEndpoint = util.getSourceEndpoint(edgeView, options);\n  // pathfinding\n  const map = new ObstacleMap(options).build(edgeView.graph.model, edgeView.cell);\n  const oldVertices = vertices.map(p => Point.create(p));\n  const newVertices = [];\n  // The origin of first route's grid, does not need snapping\n  let tailPoint = sourceEndpoint;\n  let from;\n  let to;\n  for (let i = 0, len = oldVertices.length; i <= len; i += 1) {\n    let partialRoute = null;\n    from = to || sourceBBox;\n    to = oldVertices[i];\n    // This is the last iteration\n    if (to == null) {\n      to = targetBBox;\n      // If the target is a point, we should use dragging route\n      // instead of main routing method if it has been provided.\n      const edge = edgeView.cell;\n      const isEndingAtPoint = edge.getSourceCellId() == null || edge.getTargetCellId() == null;\n      if (isEndingAtPoint && typeof options.draggingRouter === 'function') {\n        const dragFrom = from === sourceBBox ? sourceEndpoint : from;\n        const dragTo = to.getOrigin();\n        partialRoute = FunctionExt.call(options.draggingRouter, edgeView, dragFrom, dragTo, options);\n      }\n    }\n    // Find the partial route\n    if (partialRoute == null) {\n      partialRoute = findRoute(edgeView, from, to, map, options);\n    }\n    // Cannot found the partial route.\n    if (partialRoute === null) {\n      // eslint-next-line\n      console.warn(`Unable to execute manhattan algorithm, use orth instead`);\n      return FunctionExt.call(options.fallbackRouter, this, vertices, options, edgeView);\n    }\n    // Remove the first point if the previous partial route has\n    // the same point as last.\n    const leadPoint = partialRoute[0];\n    if (leadPoint && leadPoint.equals(tailPoint)) {\n      partialRoute.shift();\n    }\n    // Save tailPoint for next iteration\n    tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;\n    newVertices.push(...partialRoute);\n  }\n  return newVertices;\n};","map":{"version":3,"names":["FunctionExt","Point","Rectangle","SortedSet","ObstacleMap","util","resolveOptions","findRoute","edgeView","from","to","map","options","precision","sourceEndpoint","targetEndpoint","isRectangle","round","getSourceEndpoint","clone","getTargetEndpoint","grid","getGrid","step","startPoint","endPoint","startPoints","endPoints","getRectPoints","startDirections","endDirections","filter","p","isAccessible","length","openSet","points","parents","costs","i","n","key","getKey","add","getCost","previousRouteDirectionAngle","previousDirectionAngle","isPathBeginning","undefined","direction","directionChange","directions","getGridOffsets","numDirections","endPointsKeys","reduce","res","push","sameStartEndPoints","equalPoints","loopsRemaining","maxLoopCount","isEmpty","currentKey","pop","currentPoint","currentParent","currentCost","isStartPoint","equals","isRouteBeginning","getDirectionAngle","skipEndCheck","indexOf","reconstructRoute","directionAngle","angle","getDirectionChange","maxDirectionChange","neighborPoint","align","translate","gridOffsetX","gridOffsetY","neighborKey","isClose","isEndPoint","endDirectionAngle","endDirectionChange","neighborCost","cost","neighborPenalty","penalties","costFromStart","isOpen","fallbackRoute","call","router","vertices","optionsRaw","sourceBBox","getSourceBBox","targetBBox","getTargetBBox","build","graph","model","cell","oldVertices","create","newVertices","tailPoint","len","partialRoute","edge","isEndingAtPoint","getSourceCellId","getTargetCellId","draggingRouter","dragFrom","dragTo","getOrigin","console","warn","fallbackRouter","leadPoint","shift"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/registry/router/manhattan/router.ts"],"sourcesContent":["import { KeyValue } from '../../../types'\nimport { FunctionExt } from '../../../util'\nimport { Point, Rectangle } from '../../../geometry'\nimport { EdgeView } from '../../../view'\nimport { Router } from '../index'\nimport { SortedSet } from './sorted-set'\nimport { ObstacleMap } from './obstacle-map'\nimport * as util from './util'\nimport {\n  resolveOptions,\n  ResolvedOptions,\n  ManhattanRouterOptions,\n} from './options'\n\n/**\n * Finds the route between two points (`from`, `to`).\n */\nfunction findRoute(\n  edgeView: EdgeView,\n  from: Point | Rectangle,\n  to: Point | Rectangle,\n  map: ObstacleMap,\n  options: ResolvedOptions,\n) {\n  const precision = options.precision\n\n  let sourceEndpoint\n  let targetEndpoint\n\n  if (Rectangle.isRectangle(from)) {\n    sourceEndpoint = util.round(\n      util.getSourceEndpoint(edgeView, options).clone(),\n      precision,\n    )\n  } else {\n    sourceEndpoint = util.round(from.clone(), precision)\n  }\n\n  if (Rectangle.isRectangle(to)) {\n    targetEndpoint = util.round(\n      util.getTargetEndpoint(edgeView, options).clone(),\n      precision,\n    )\n  } else {\n    targetEndpoint = util.round(to.clone(), precision)\n  }\n\n  // Get grid for this route.\n  const grid = util.getGrid(options.step, sourceEndpoint, targetEndpoint)\n\n  // Get pathfinding points.\n  // -----------------------\n\n  const startPoint = sourceEndpoint\n  const endPoint = targetEndpoint\n  let startPoints\n  let endPoints\n\n  if (Rectangle.isRectangle(from)) {\n    startPoints = util.getRectPoints(\n      startPoint,\n      from,\n      options.startDirections,\n      grid,\n      options,\n    )\n  } else {\n    startPoints = [startPoint]\n  }\n\n  if (Rectangle.isRectangle(to)) {\n    endPoints = util.getRectPoints(\n      targetEndpoint,\n      to,\n      options.endDirections,\n      grid,\n      options,\n    )\n  } else {\n    endPoints = [endPoint]\n  }\n\n  // take into account only accessible rect points (those not under obstacles)\n  startPoints = startPoints.filter((p) => map.isAccessible(p))\n  endPoints = endPoints.filter((p) => map.isAccessible(p))\n\n  // There is an accessible route point on both sides.\n  if (startPoints.length > 0 && endPoints.length > 0) {\n    const openSet = new SortedSet()\n    // Keeps the actual points for given nodes of the open set.\n    const points: KeyValue<Point> = {}\n    // Keeps the point that is immediate predecessor of given element.\n    const parents: KeyValue<Point> = {}\n    // Cost from start to a point along best known path.\n    const costs: KeyValue<number> = {}\n\n    for (let i = 0, n = startPoints.length; i < n; i += 1) {\n      // startPoint is assumed to be aligned already\n      const startPoint = startPoints[i]\n      const key = util.getKey(startPoint)\n      openSet.add(key, util.getCost(startPoint, endPoints))\n      points[key] = startPoint\n      costs[key] = 0\n    }\n\n    const previousRouteDirectionAngle = options.previousDirectionAngle\n    // undefined for first route\n    const isPathBeginning = previousRouteDirectionAngle === undefined\n\n    // directions\n    let direction\n    let directionChange\n    const directions = util.getGridOffsets(grid, options)\n    const numDirections = directions.length\n    const endPointsKeys = endPoints.reduce<string[]>((res, endPoint) => {\n      const key = util.getKey(endPoint)\n      res.push(key)\n      return res\n    }, [])\n\n    // main route finding loop\n    const sameStartEndPoints = Point.equalPoints(startPoints, endPoints)\n    let loopsRemaining = options.maxLoopCount\n    while (!openSet.isEmpty() && loopsRemaining > 0) {\n      // Get the closest item and mark it CLOSED\n      const currentKey = openSet.pop()!\n      const currentPoint = points[currentKey]\n      const currentParent = parents[currentKey]\n      const currentCost = costs[currentKey]\n\n      const isStartPoint = currentPoint.equals(startPoint)\n      const isRouteBeginning = currentParent == null\n\n      let previousDirectionAngle: number | null | undefined\n      if (!isRouteBeginning) {\n        previousDirectionAngle = util.getDirectionAngle(\n          currentParent,\n          currentPoint,\n          numDirections,\n          grid,\n          options,\n        )\n      } else if (!isPathBeginning) {\n        // a vertex on the route\n        previousDirectionAngle = previousRouteDirectionAngle\n      } else if (!isStartPoint) {\n        // beginning of route on the path\n        previousDirectionAngle = util.getDirectionAngle(\n          startPoint,\n          currentPoint,\n          numDirections,\n          grid,\n          options,\n        )\n      } else {\n        previousDirectionAngle = null\n      }\n\n      // Check if we reached any endpoint\n      const skipEndCheck = isRouteBeginning && sameStartEndPoints\n      if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {\n        options.previousDirectionAngle = previousDirectionAngle\n        return util.reconstructRoute(\n          parents,\n          points,\n          currentPoint,\n          startPoint,\n          endPoint,\n        )\n      }\n\n      // Go over all possible directions and find neighbors\n      for (let i = 0; i < numDirections; i += 1) {\n        direction = directions[i]\n\n        const directionAngle = direction.angle!\n        directionChange = util.getDirectionChange(\n          previousDirectionAngle!,\n          directionAngle,\n        )\n\n        // Don't use the point changed rapidly.\n        if (\n          !(isPathBeginning && isStartPoint) &&\n          directionChange > options.maxDirectionChange\n        ) {\n          continue\n        }\n\n        const neighborPoint = util.align(\n          currentPoint\n            .clone()\n            .translate(direction.gridOffsetX || 0, direction.gridOffsetY || 0),\n          grid,\n          precision,\n        )\n        const neighborKey = util.getKey(neighborPoint)\n\n        // Closed points were already evaluated.\n        if (openSet.isClose(neighborKey) || !map.isAccessible(neighborPoint)) {\n          continue\n        }\n\n        // Neighbor is an end point.\n        if (endPointsKeys.indexOf(neighborKey) >= 0) {\n          const isEndPoint = neighborPoint.equals(endPoint)\n          if (!isEndPoint) {\n            const endDirectionAngle = util.getDirectionAngle(\n              neighborPoint,\n              endPoint,\n              numDirections,\n              grid,\n              options,\n            )\n\n            const endDirectionChange = util.getDirectionChange(\n              directionAngle,\n              endDirectionAngle,\n            )\n\n            if (endDirectionChange > options.maxDirectionChange) {\n              continue\n            }\n          }\n        }\n\n        // The current direction is ok.\n        // ----------------------------\n\n        const neighborCost = direction.cost\n        const neighborPenalty = isStartPoint\n          ? 0\n          : options.penalties[directionChange]\n        const costFromStart = currentCost + neighborCost + neighborPenalty\n\n        // Neighbor point has not been processed yet or the cost of\n        // the path from start is lower than previously calculated.\n        if (\n          !openSet.isOpen(neighborKey) ||\n          costFromStart < costs[neighborKey]\n        ) {\n          points[neighborKey] = neighborPoint\n          parents[neighborKey] = currentPoint\n          costs[neighborKey] = costFromStart\n          openSet.add(\n            neighborKey,\n            costFromStart + util.getCost(neighborPoint, endPoints),\n          )\n        }\n      }\n\n      loopsRemaining -= 1\n    }\n  }\n\n  if (options.fallbackRoute) {\n    return FunctionExt.call(\n      options.fallbackRoute,\n      this,\n      startPoint,\n      endPoint,\n      options,\n    )\n  }\n\n  return null\n}\n\nexport const router: Router.Definition<ManhattanRouterOptions> = function (\n  vertices,\n  optionsRaw,\n  edgeView,\n) {\n  const options = resolveOptions(optionsRaw)\n  const sourceBBox = util.getSourceBBox(edgeView, options)\n  const targetBBox = util.getTargetBBox(edgeView, options)\n  const sourceEndpoint = util.getSourceEndpoint(edgeView, options)\n\n  // pathfinding\n  const map = new ObstacleMap(options).build(\n    edgeView.graph.model,\n    edgeView.cell,\n  )\n\n  const oldVertices = vertices.map((p) => Point.create(p))\n  const newVertices: Point[] = []\n\n  // The origin of first route's grid, does not need snapping\n  let tailPoint = sourceEndpoint\n\n  let from\n  let to\n\n  for (let i = 0, len = oldVertices.length; i <= len; i += 1) {\n    let partialRoute: Point[] | null = null\n\n    from = to || sourceBBox\n    to = oldVertices[i]\n\n    // This is the last iteration\n    if (to == null) {\n      to = targetBBox\n\n      // If the target is a point, we should use dragging route\n      // instead of main routing method if it has been provided.\n      const edge = edgeView.cell\n      const isEndingAtPoint =\n        edge.getSourceCellId() == null || edge.getTargetCellId() == null\n\n      if (isEndingAtPoint && typeof options.draggingRouter === 'function') {\n        const dragFrom = from === sourceBBox ? sourceEndpoint : from\n        const dragTo = to.getOrigin()\n        partialRoute = FunctionExt.call(\n          options.draggingRouter,\n          edgeView,\n          dragFrom,\n          dragTo,\n          options,\n        )\n      }\n    }\n\n    // Find the partial route\n    if (partialRoute == null) {\n      partialRoute = findRoute(edgeView, from, to, map, options)\n    }\n\n    // Cannot found the partial route.\n    if (partialRoute === null) {\n      // eslint-next-line\n      console.warn(`Unable to execute manhattan algorithm, use orth instead`)\n      return FunctionExt.call(\n        options.fallbackRouter,\n        this,\n        vertices,\n        options,\n        edgeView,\n      )\n    }\n\n    // Remove the first point if the previous partial route has\n    // the same point as last.\n    const leadPoint = partialRoute[0]\n    if (leadPoint && leadPoint.equals(tailPoint)) {\n      partialRoute.shift()\n    }\n\n    // Save tailPoint for next iteration\n    tailPoint = partialRoute[partialRoute.length - 1] || tailPoint\n    newVertices.push(...partialRoute)\n  }\n\n  return newVertices\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}