{"ast":null,"code":"import * as util from './util';\nimport { Angle } from './angle';\nimport { Geometry } from './geometry';\nexport class Point extends Geometry {\n  constructor(x, y) {\n    super();\n    this.x = x == null ? 0 : x;\n    this.y = y == null ? 0 : y;\n  }\n  get [Symbol.toStringTag]() {\n    return Point.toStringTag;\n  }\n  /**\n   * Rounds the point to the given precision.\n   */\n  round(precision = 0) {\n    this.x = util.round(this.x, precision);\n    this.y = util.round(this.y, precision);\n    return this;\n  }\n  add(x, y) {\n    const p = Point.create(x, y);\n    this.x += p.x;\n    this.y += p.y;\n    return this;\n  }\n  update(x, y) {\n    const p = Point.create(x, y);\n    this.x = p.x;\n    this.y = p.y;\n    return this;\n  }\n  translate(dx, dy) {\n    const t = Point.create(dx, dy);\n    this.x += t.x;\n    this.y += t.y;\n    return this;\n  }\n  /**\n   * Rotate the point by `degree` around `center`.\n   */\n  rotate(degree, center) {\n    const p = Point.rotate(this, degree, center);\n    this.x = p.x;\n    this.y = p.y;\n    return this;\n  }\n  /**\n   * Scale point by `sx` and `sy` around the given `origin`. If origin is not\n   * specified, the point is scaled around `0,0`.\n   */\n  scale(sx, sy, origin = new Point()) {\n    const ref = Point.create(origin);\n    this.x = ref.x + sx * (this.x - ref.x);\n    this.y = ref.y + sy * (this.y - ref.y);\n    return this;\n  }\n  /**\n   * Chooses the point closest to this point from among `points`. If `points`\n   * is an empty array, `null` is returned.\n   */\n  closest(points) {\n    if (points.length === 1) {\n      return Point.create(points[0]);\n    }\n    let ret = null;\n    let min = Infinity;\n    points.forEach(p => {\n      const dist = this.squaredDistance(p);\n      if (dist < min) {\n        ret = p;\n        min = dist;\n      }\n    });\n    return ret ? Point.create(ret) : null;\n  }\n  /**\n   * Returns the distance between the point and another point `p`.\n   */\n  distance(p) {\n    return Math.sqrt(this.squaredDistance(p));\n  }\n  /**\n   * Returns the squared distance between the point and another point `p`.\n   *\n   * Useful for distance comparisons in which real distance is not necessary\n   * (saves one `Math.sqrt()` operation).\n   */\n  squaredDistance(p) {\n    const ref = Point.create(p);\n    const dx = this.x - ref.x;\n    const dy = this.y - ref.y;\n    return dx * dx + dy * dy;\n  }\n  manhattanDistance(p) {\n    const ref = Point.create(p);\n    return Math.abs(ref.x - this.x) + Math.abs(ref.y - this.y);\n  }\n  /**\n   * Returns the magnitude of the point vector.\n   *\n   * @see http://en.wikipedia.org/wiki/Magnitude_(mathematics)\n   */\n  magnitude() {\n    return Math.sqrt(this.x * this.x + this.y * this.y) || 0.01;\n  }\n  /**\n   * Returns the angle(in degrees) between vector from this point to `p` and\n   * the x-axis.\n   */\n  theta(p = new Point()) {\n    const ref = Point.create(p);\n    const y = -(ref.y - this.y); // invert the y-axis.\n    const x = ref.x - this.x;\n    let rad = Math.atan2(y, x);\n    // Correction for III. and IV. quadrant.\n    if (rad < 0) {\n      rad = 2 * Math.PI + rad;\n    }\n    return 180 * rad / Math.PI;\n  }\n  /**\n   * Returns the angle(in degrees) between vector from this point to `p1` and\n   * the vector from this point to `p2`.\n   *\n   * The ordering of points `p1` and `p2` is important.\n   *\n   * The function returns a value between `0` and `180` when the angle (in the\n   * direction from `p1` to `p2`) is clockwise, and a value between `180` and\n   * `360` when the angle is counterclockwise.\n   *\n   * Returns `NaN` if either of the points `p1` and `p2` is equal with this point.\n   */\n  angleBetween(p1, p2) {\n    if (this.equals(p1) || this.equals(p2)) {\n      return NaN;\n    }\n    let angle = this.theta(p2) - this.theta(p1);\n    if (angle < 0) {\n      angle += 360;\n    }\n    return angle;\n  }\n  /**\n   * Returns the angle(in degrees) between the line from `(0,0)` and this point\n   * and the line from `(0,0)` to `p`.\n   *\n   * The function returns a value between `0` and `180` when the angle (in the\n   * direction from this point to `p`) is clockwise, and a value between `180`\n   * and `360` when the angle is counterclockwise. Returns `NaN` if called from\n   * point `(0,0)` or if `p` is `(0,0)`.\n   */\n  vectorAngle(p) {\n    const zero = new Point(0, 0);\n    return zero.angleBetween(this, p);\n  }\n  /**\n   * Converts rectangular to polar coordinates.\n   */\n  toPolar(origin) {\n    this.update(Point.toPolar(this, origin));\n    return this;\n  }\n  /**\n   * Returns the change in angle(in degrees) that is the result of moving the\n   * point from its previous position to its current position.\n   *\n   * More specifically, this function computes the angle between the line from\n   * the ref point to the previous position of this point(i.e. current position\n   * `-dx`, `-dy`) and the line from the `ref` point to the current position of\n   * this point.\n   *\n   * The function returns a positive value between `0` and `180` when the angle\n   * (in the direction from previous position of this point to its current\n   * position) is clockwise, and a negative value between `0` and `-180` when\n   * the angle is counterclockwise.\n   *\n   * The function returns `0` if the previous and current positions of this\n   * point are the same (i.e. both `dx` and `dy` are `0`).\n   */\n  changeInAngle(dx, dy, ref = new Point()) {\n    // Revert the translation and measure the change in angle around x-axis.\n    return this.clone().translate(-dx, -dy).theta(ref) - this.theta(ref);\n  }\n  /**\n   * If the point lies outside the rectangle `rect`, adjust the point so that\n   * it becomes the nearest point on the boundary of `rect`.\n   */\n  adhereToRect(rect) {\n    if (!util.containsPoint(rect, this)) {\n      this.x = Math.min(Math.max(this.x, rect.x), rect.x + rect.width);\n      this.y = Math.min(Math.max(this.y, rect.y), rect.y + rect.height);\n    }\n    return this;\n  }\n  /**\n   * Returns the bearing(cardinal direction) between me and the given point.\n   *\n   * @see https://en.wikipedia.org/wiki/Cardinal_direction\n   */\n  bearing(p) {\n    const ref = Point.create(p);\n    const lat1 = Angle.toRad(this.y);\n    const lat2 = Angle.toRad(ref.y);\n    const lon1 = this.x;\n    const lon2 = ref.x;\n    const dLon = Angle.toRad(lon2 - lon1);\n    const y = Math.sin(dLon) * Math.cos(lat2);\n    const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);\n    const brng = Angle.toDeg(Math.atan2(y, x));\n    const bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];\n    let index = brng - 22.5;\n    if (index < 0) {\n      index += 360;\n    }\n    index = parseInt(index / 45, 10);\n    return bearings[index];\n  }\n  /**\n   * Returns the cross product of the vector from me to `p1` and the vector\n   * from me to `p2`.\n   *\n   * The left-hand rule is used because the coordinate system is left-handed.\n   */\n  cross(p1, p2) {\n    if (p1 != null && p2 != null) {\n      const a = Point.create(p1);\n      const b = Point.create(p2);\n      return (b.x - this.x) * (a.y - this.y) - (b.y - this.y) * (a.x - this.x);\n    }\n    return NaN;\n  }\n  /**\n   * Returns the dot product of this point with given other point.\n   */\n  dot(p) {\n    const ref = Point.create(p);\n    return this.x * ref.x + this.y * ref.y;\n  }\n  diff(dx, dy) {\n    if (typeof dx === 'number') {\n      return new Point(this.x - dx, this.y - dy);\n    }\n    const p = Point.create(dx);\n    return new Point(this.x - p.x, this.y - p.y);\n  }\n  /**\n   * Returns an interpolation between me and point `p` for a parametert in\n   * the closed interval `[0, 1]`.\n   */\n  lerp(p, t) {\n    const ref = Point.create(p);\n    return new Point((1 - t) * this.x + t * ref.x, (1 - t) * this.y + t * ref.y);\n  }\n  /**\n   * Normalize the point vector, scale the line segment between `(0, 0)`\n   * and the point in order for it to have the given length. If length is\n   * not specified, it is considered to be `1`; in that case, a unit vector\n   * is computed.\n   */\n  normalize(length = 1) {\n    const scale = length / this.magnitude();\n    return this.scale(scale, scale);\n  }\n  /**\n   * Moves this point along the line starting from `ref` to this point by a\n   * certain `distance`.\n   */\n  move(ref, distance) {\n    const p = Point.create(ref);\n    const rad = Angle.toRad(p.theta(this));\n    return this.translate(Math.cos(rad) * distance, -Math.sin(rad) * distance);\n  }\n  /**\n   * Returns a point that is the reflection of me with the center of inversion\n   * in `ref` point.\n   */\n  reflection(ref) {\n    return Point.create(ref).move(this, this.distance(ref));\n  }\n  snapToGrid(gx, gy) {\n    this.x = util.snapToGrid(this.x, gx);\n    this.y = util.snapToGrid(this.y, gy == null ? gx : gy);\n    return this;\n  }\n  equals(p) {\n    const ref = Point.create(p);\n    return ref != null && ref.x === this.x && ref.y === this.y;\n  }\n  clone() {\n    return Point.clone(this);\n  }\n  /**\n   * Returns the point as a simple JSON object. For example: `{ x: 0, y: 0 }`.\n   */\n  toJSON() {\n    return Point.toJSON(this);\n  }\n  serialize() {\n    return `${this.x} ${this.y}`;\n  }\n}\n(function (Point) {\n  Point.toStringTag = `X6.Geometry.${Point.name}`;\n  function isPoint(instance) {\n    if (instance == null) {\n      return false;\n    }\n    if (instance instanceof Point) {\n      return true;\n    }\n    const tag = instance[Symbol.toStringTag];\n    const point = instance;\n    if ((tag == null || tag === Point.toStringTag) && typeof point.x === 'number' && typeof point.y === 'number' && typeof point.toPolar === 'function') {\n      return true;\n    }\n    return false;\n  }\n  Point.isPoint = isPoint;\n})(Point || (Point = {}));\n(function (Point) {\n  function isPointLike(p) {\n    return p != null && typeof p === 'object' && typeof p.x === 'number' && typeof p.y === 'number';\n  }\n  Point.isPointLike = isPointLike;\n  function isPointData(p) {\n    return p != null && Array.isArray(p) && p.length === 2 && typeof p[0] === 'number' && typeof p[1] === 'number';\n  }\n  Point.isPointData = isPointData;\n})(Point || (Point = {}));\n(function (Point) {\n  function create(x, y) {\n    if (x == null || typeof x === 'number') {\n      return new Point(x, y);\n    }\n    return clone(x);\n  }\n  Point.create = create;\n  function clone(p) {\n    if (Point.isPoint(p)) {\n      return new Point(p.x, p.y);\n    }\n    if (Array.isArray(p)) {\n      return new Point(p[0], p[1]);\n    }\n    return new Point(p.x, p.y);\n  }\n  Point.clone = clone;\n  function toJSON(p) {\n    if (Point.isPoint(p)) {\n      return {\n        x: p.x,\n        y: p.y\n      };\n    }\n    if (Array.isArray(p)) {\n      return {\n        x: p[0],\n        y: p[1]\n      };\n    }\n    return {\n      x: p.x,\n      y: p.y\n    };\n  }\n  Point.toJSON = toJSON;\n  /**\n   * Returns a new Point object from the given polar coordinates.\n   * @see http://en.wikipedia.org/wiki/Polar_coordinate_system\n   */\n  function fromPolar(r, rad, origin = new Point()) {\n    let x = Math.abs(r * Math.cos(rad));\n    let y = Math.abs(r * Math.sin(rad));\n    const org = clone(origin);\n    const deg = Angle.normalize(Angle.toDeg(rad));\n    if (deg < 90) {\n      y = -y;\n    } else if (deg < 180) {\n      x = -x;\n      y = -y;\n    } else if (deg < 270) {\n      x = -x;\n    }\n    return new Point(org.x + x, org.y + y);\n  }\n  Point.fromPolar = fromPolar;\n  /**\n   * Converts rectangular to polar coordinates.\n   */\n  function toPolar(point, origin = new Point()) {\n    const p = clone(point);\n    const o = clone(origin);\n    const dx = p.x - o.x;\n    const dy = p.y - o.y;\n    return new Point(Math.sqrt(dx * dx + dy * dy),\n    // r\n    Angle.toRad(o.theta(p)));\n  }\n  Point.toPolar = toPolar;\n  function equals(p1, p2) {\n    if (p1 === p2) {\n      return true;\n    }\n    if (p1 != null && p2 != null) {\n      return p1.x === p2.x && p1.y === p2.y;\n    }\n    return false;\n  }\n  Point.equals = equals;\n  function equalPoints(p1, p2) {\n    if (p1 == null && p2 != null || p1 != null && p2 == null || p1 != null && p2 != null && p1.length !== p2.length) {\n      return false;\n    }\n    if (p1 != null && p2 != null) {\n      for (let i = 0, ii = p1.length; i < ii; i += 1) {\n        if (!equals(p1[i], p2[i])) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  Point.equalPoints = equalPoints;\n  /**\n   * Returns a point with random coordinates that fall within the range\n   * `[x1, x2]` and `[y1, y2]`.\n   */\n  function random(x1, x2, y1, y2) {\n    return new Point(util.random(x1, x2), util.random(y1, y2));\n  }\n  Point.random = random;\n  function rotate(point, angle, center) {\n    const rad = Angle.toRad(Angle.normalize(-angle));\n    const sin = Math.sin(rad);\n    const cos = Math.cos(rad);\n    return rotateEx(point, cos, sin, center);\n  }\n  Point.rotate = rotate;\n  function rotateEx(point, cos, sin, center = new Point()) {\n    const source = clone(point);\n    const origin = clone(center);\n    const dx = source.x - origin.x;\n    const dy = source.y - origin.y;\n    const x1 = dx * cos - dy * sin;\n    const y1 = dy * cos + dx * sin;\n    return new Point(x1 + origin.x, y1 + origin.y);\n  }\n  Point.rotateEx = rotateEx;\n})(Point || (Point = {}));","map":{"version":3,"names":["util","Angle","Geometry","Point","constructor","x","y","Symbol","toStringTag","round","precision","add","p","create","update","translate","dx","dy","t","rotate","degree","center","scale","sx","sy","origin","ref","closest","points","length","ret","min","Infinity","forEach","dist","squaredDistance","distance","Math","sqrt","manhattanDistance","abs","magnitude","theta","rad","atan2","PI","angleBetween","p1","p2","equals","NaN","angle","vectorAngle","zero","toPolar","changeInAngle","clone","adhereToRect","rect","containsPoint","max","width","height","bearing","lat1","toRad","lat2","lon1","lon2","dLon","sin","cos","brng","toDeg","bearings","index","parseInt","cross","a","b","dot","diff","lerp","normalize","move","reflection","snapToGrid","gx","gy","toJSON","serialize","name","isPoint","instance","tag","point","isPointLike","isPointData","Array","isArray","fromPolar","r","org","deg","o","equalPoints","i","ii","random","x1","x2","y1","y2","rotateEx","source"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/geometry/point.ts"],"sourcesContent":["import * as util from './util'\nimport { Angle } from './angle'\nimport { Geometry } from './geometry'\nimport { Rectangle } from './rectangle'\n\nexport class Point extends Geometry implements Point.PointLike {\n  public x: number\n  public y: number\n\n  protected get [Symbol.toStringTag]() {\n    return Point.toStringTag\n  }\n\n  constructor(x?: number, y?: number) {\n    super()\n    this.x = x == null ? 0 : x\n    this.y = y == null ? 0 : y\n  }\n\n  /**\n   * Rounds the point to the given precision.\n   */\n  round(precision = 0) {\n    this.x = util.round(this.x, precision)\n    this.y = util.round(this.y, precision)\n    return this\n  }\n\n  add(x: number, y: number): this\n  add(p: Point.PointLike | Point.PointData): this\n  add(x: number | Point.PointLike | Point.PointData, y?: number): this {\n    const p = Point.create(x, y)\n    this.x += p.x\n    this.y += p.y\n    return this\n  }\n\n  /**\n   * Update the point's `x` and `y` coordinates with new values and return the\n   * point itself. Useful for chaining.\n   */\n  update(x: number, y: number): this\n  update(p: Point.PointLike | Point.PointData): this\n  update(x: number | Point.PointLike | Point.PointData, y?: number): this {\n    const p = Point.create(x, y)\n    this.x = p.x\n    this.y = p.y\n    return this\n  }\n\n  translate(dx: number, dy: number): this\n  translate(p: Point.PointLike | Point.PointData): this\n  translate(dx: number | Point.PointLike | Point.PointData, dy?: number): this {\n    const t = Point.create(dx, dy)\n    this.x += t.x\n    this.y += t.y\n    return this\n  }\n\n  /**\n   * Rotate the point by `degree` around `center`.\n   */\n  rotate(degree: number, center?: Point.PointLike | Point.PointData): this {\n    const p = Point.rotate(this, degree, center)\n    this.x = p.x\n    this.y = p.y\n    return this\n  }\n\n  /**\n   * Scale point by `sx` and `sy` around the given `origin`. If origin is not\n   * specified, the point is scaled around `0,0`.\n   */\n  scale(\n    sx: number,\n    sy: number,\n    origin: Point.PointLike | Point.PointData = new Point(),\n  ) {\n    const ref = Point.create(origin)\n    this.x = ref.x + sx * (this.x - ref.x)\n    this.y = ref.y + sy * (this.y - ref.y)\n    return this\n  }\n\n  /**\n   * Chooses the point closest to this point from among `points`. If `points`\n   * is an empty array, `null` is returned.\n   */\n  closest(points: (Point.PointLike | Point.PointData)[]) {\n    if (points.length === 1) {\n      return Point.create(points[0])\n    }\n\n    let ret: Point.PointLike | Point.PointData | null = null\n    let min = Infinity\n    points.forEach((p) => {\n      const dist = this.squaredDistance(p)\n      if (dist < min) {\n        ret = p\n        min = dist\n      }\n    })\n\n    return ret ? Point.create(ret) : null\n  }\n\n  /**\n   * Returns the distance between the point and another point `p`.\n   */\n  distance(p: Point.PointLike | Point.PointData) {\n    return Math.sqrt(this.squaredDistance(p))\n  }\n\n  /**\n   * Returns the squared distance between the point and another point `p`.\n   *\n   * Useful for distance comparisons in which real distance is not necessary\n   * (saves one `Math.sqrt()` operation).\n   */\n  squaredDistance(p: Point.PointLike | Point.PointData) {\n    const ref = Point.create(p)\n    const dx = this.x - ref.x\n    const dy = this.y - ref.y\n    return dx * dx + dy * dy\n  }\n\n  manhattanDistance(p: Point.PointLike | Point.PointData) {\n    const ref = Point.create(p)\n    return Math.abs(ref.x - this.x) + Math.abs(ref.y - this.y)\n  }\n\n  /**\n   * Returns the magnitude of the point vector.\n   *\n   * @see http://en.wikipedia.org/wiki/Magnitude_(mathematics)\n   */\n  magnitude() {\n    return Math.sqrt(this.x * this.x + this.y * this.y) || 0.01\n  }\n\n  /**\n   * Returns the angle(in degrees) between vector from this point to `p` and\n   * the x-axis.\n   */\n  theta(p: Point.PointLike | Point.PointData = new Point()): number {\n    const ref = Point.create(p)\n    const y = -(ref.y - this.y) // invert the y-axis.\n    const x = ref.x - this.x\n    let rad = Math.atan2(y, x)\n\n    // Correction for III. and IV. quadrant.\n    if (rad < 0) {\n      rad = 2 * Math.PI + rad\n    }\n\n    return (180 * rad) / Math.PI\n  }\n\n  /**\n   * Returns the angle(in degrees) between vector from this point to `p1` and\n   * the vector from this point to `p2`.\n   *\n   * The ordering of points `p1` and `p2` is important.\n   *\n   * The function returns a value between `0` and `180` when the angle (in the\n   * direction from `p1` to `p2`) is clockwise, and a value between `180` and\n   * `360` when the angle is counterclockwise.\n   *\n   * Returns `NaN` if either of the points `p1` and `p2` is equal with this point.\n   */\n  angleBetween(\n    p1: Point.PointLike | Point.PointData,\n    p2: Point.PointLike | Point.PointData,\n  ) {\n    if (this.equals(p1) || this.equals(p2)) {\n      return NaN\n    }\n\n    let angle = this.theta(p2) - this.theta(p1)\n    if (angle < 0) {\n      angle += 360\n    }\n\n    return angle\n  }\n\n  /**\n   * Returns the angle(in degrees) between the line from `(0,0)` and this point\n   * and the line from `(0,0)` to `p`.\n   *\n   * The function returns a value between `0` and `180` when the angle (in the\n   * direction from this point to `p`) is clockwise, and a value between `180`\n   * and `360` when the angle is counterclockwise. Returns `NaN` if called from\n   * point `(0,0)` or if `p` is `(0,0)`.\n   */\n  vectorAngle(p: Point.PointLike | Point.PointData) {\n    const zero = new Point(0, 0)\n    return zero.angleBetween(this, p)\n  }\n\n  /**\n   * Converts rectangular to polar coordinates.\n   */\n  toPolar(origin?: Point.PointLike | Point.PointData) {\n    this.update(Point.toPolar(this, origin))\n    return this\n  }\n\n  /**\n   * Returns the change in angle(in degrees) that is the result of moving the\n   * point from its previous position to its current position.\n   *\n   * More specifically, this function computes the angle between the line from\n   * the ref point to the previous position of this point(i.e. current position\n   * `-dx`, `-dy`) and the line from the `ref` point to the current position of\n   * this point.\n   *\n   * The function returns a positive value between `0` and `180` when the angle\n   * (in the direction from previous position of this point to its current\n   * position) is clockwise, and a negative value between `0` and `-180` when\n   * the angle is counterclockwise.\n   *\n   * The function returns `0` if the previous and current positions of this\n   * point are the same (i.e. both `dx` and `dy` are `0`).\n   */\n  changeInAngle(\n    dx: number,\n    dy: number,\n    ref: Point.PointLike | Point.PointData = new Point(),\n  ) {\n    // Revert the translation and measure the change in angle around x-axis.\n    return this.clone().translate(-dx, -dy).theta(ref) - this.theta(ref)\n  }\n\n  /**\n   * If the point lies outside the rectangle `rect`, adjust the point so that\n   * it becomes the nearest point on the boundary of `rect`.\n   */\n  adhereToRect(rect: Rectangle.RectangleLike) {\n    if (!util.containsPoint(rect, this)) {\n      this.x = Math.min(Math.max(this.x, rect.x), rect.x + rect.width)\n      this.y = Math.min(Math.max(this.y, rect.y), rect.y + rect.height)\n    }\n    return this\n  }\n\n  /**\n   * Returns the bearing(cardinal direction) between me and the given point.\n   *\n   * @see https://en.wikipedia.org/wiki/Cardinal_direction\n   */\n  bearing(p: Point.PointLike | Point.PointData) {\n    const ref = Point.create(p)\n    const lat1 = Angle.toRad(this.y)\n    const lat2 = Angle.toRad(ref.y)\n    const lon1 = this.x\n    const lon2 = ref.x\n    const dLon = Angle.toRad(lon2 - lon1)\n    const y = Math.sin(dLon) * Math.cos(lat2)\n    const x =\n      Math.cos(lat1) * Math.sin(lat2) -\n      Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon)\n\n    const brng = Angle.toDeg(Math.atan2(y, x))\n    const bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N']\n\n    let index = brng - 22.5\n    if (index < 0) {\n      index += 360\n    }\n    index = parseInt((index / 45) as any, 10)\n    return bearings[index] as Point.Bearing\n  }\n\n  /**\n   * Returns the cross product of the vector from me to `p1` and the vector\n   * from me to `p2`.\n   *\n   * The left-hand rule is used because the coordinate system is left-handed.\n   */\n  cross(\n    p1: Point.PointLike | Point.PointData,\n    p2: Point.PointLike | Point.PointData,\n  ) {\n    if (p1 != null && p2 != null) {\n      const a = Point.create(p1)\n      const b = Point.create(p2)\n      return (b.x - this.x) * (a.y - this.y) - (b.y - this.y) * (a.x - this.x)\n    }\n\n    return NaN\n  }\n\n  /**\n   * Returns the dot product of this point with given other point.\n   */\n  dot(p: Point.PointLike | Point.PointData) {\n    const ref = Point.create(p)\n    return this.x * ref.x + this.y * ref.y\n  }\n\n  /**\n   * Returns a point that has coordinates computed as a difference between the\n   * point and another point with coordinates `dx` and `dy`.\n   *\n   * If only `dx` is specified and is a number, `dy` is considered to be zero.\n   * If only `dx` is specified and is an object, it is considered to be another\n   * point or an object in the form `{ x: [number], y: [number] }`\n   */\n  diff(dx: number, dy: number): Point\n  diff(p: Point.PointLike | Point.PointData): Point\n  diff(dx: number | Point.PointLike | Point.PointData, dy?: number): Point {\n    if (typeof dx === 'number') {\n      return new Point(this.x - dx, this.y - dy!)\n    }\n\n    const p = Point.create(dx)\n    return new Point(this.x - p.x, this.y - p.y)\n  }\n\n  /**\n   * Returns an interpolation between me and point `p` for a parametert in\n   * the closed interval `[0, 1]`.\n   */\n  lerp(p: Point.PointLike | Point.PointData, t: number) {\n    const ref = Point.create(p)\n    return new Point((1 - t) * this.x + t * ref.x, (1 - t) * this.y + t * ref.y)\n  }\n\n  /**\n   * Normalize the point vector, scale the line segment between `(0, 0)`\n   * and the point in order for it to have the given length. If length is\n   * not specified, it is considered to be `1`; in that case, a unit vector\n   * is computed.\n   */\n  normalize(length = 1) {\n    const scale = length / this.magnitude()\n    return this.scale(scale, scale)\n  }\n\n  /**\n   * Moves this point along the line starting from `ref` to this point by a\n   * certain `distance`.\n   */\n  move(ref: Point.PointLike | Point.PointData, distance: number) {\n    const p = Point.create(ref)\n    const rad = Angle.toRad(p.theta(this))\n    return this.translate(Math.cos(rad) * distance, -Math.sin(rad) * distance)\n  }\n\n  /**\n   * Returns a point that is the reflection of me with the center of inversion\n   * in `ref` point.\n   */\n  reflection(ref: Point.PointLike | Point.PointData) {\n    return Point.create(ref).move(this, this.distance(ref))\n  }\n\n  /**\n   * Snaps the point(change its x and y coordinates) to a grid of size `gridSize`\n   * (or `gridSize` x `gridSizeY` for non-uniform grid).\n   */\n  snapToGrid(gridSize: number): this\n  snapToGrid(gx: number, gy: number): this\n  snapToGrid(gx: number, gy?: number): this\n  snapToGrid(gx: number, gy?: number): this {\n    this.x = util.snapToGrid(this.x, gx)\n    this.y = util.snapToGrid(this.y, gy == null ? gx : gy)\n    return this\n  }\n\n  equals(p: Point.PointLike | Point.PointData) {\n    const ref = Point.create(p)\n    return ref != null && ref.x === this.x && ref.y === this.y\n  }\n\n  clone() {\n    return Point.clone(this)\n  }\n\n  /**\n   * Returns the point as a simple JSON object. For example: `{ x: 0, y: 0 }`.\n   */\n  toJSON() {\n    return Point.toJSON(this)\n  }\n\n  serialize() {\n    return `${this.x} ${this.y}`\n  }\n}\n\nexport namespace Point {\n  export const toStringTag = `X6.Geometry.${Point.name}`\n\n  export function isPoint(instance: any): instance is Point {\n    if (instance == null) {\n      return false\n    }\n    if (instance instanceof Point) {\n      return true\n    }\n\n    const tag = instance[Symbol.toStringTag]\n    const point = instance as Point\n\n    if (\n      (tag == null || tag === toStringTag) &&\n      typeof point.x === 'number' &&\n      typeof point.y === 'number' &&\n      typeof point.toPolar === 'function'\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n\nexport namespace Point {\n  export interface PointLike {\n    x: number\n    y: number\n  }\n\n  export type PointData = [number, number]\n\n  export type Bearing = 'NE' | 'E' | 'SE' | 'S' | 'SW' | 'W' | 'NW' | 'N'\n\n  export function isPointLike(p: any): p is PointLike {\n    return (\n      p != null &&\n      typeof p === 'object' &&\n      typeof p.x === 'number' &&\n      typeof p.y === 'number'\n    )\n  }\n\n  export function isPointData(p: any): p is PointData {\n    return (\n      p != null &&\n      Array.isArray(p) &&\n      p.length === 2 &&\n      typeof p[0] === 'number' &&\n      typeof p[1] === 'number'\n    )\n  }\n}\n\nexport namespace Point {\n  export function create(\n    x?: number | Point | PointLike | PointData,\n    y?: number,\n  ): Point {\n    if (x == null || typeof x === 'number') {\n      return new Point(x, y)\n    }\n\n    return clone(x)\n  }\n\n  export function clone(p: Point | PointLike | PointData) {\n    if (Point.isPoint(p)) {\n      return new Point(p.x, p.y)\n    }\n\n    if (Array.isArray(p)) {\n      return new Point(p[0], p[1])\n    }\n\n    return new Point(p.x, p.y)\n  }\n\n  export function toJSON(p: Point | PointLike | PointData) {\n    if (Point.isPoint(p)) {\n      return { x: p.x, y: p.y }\n    }\n\n    if (Array.isArray(p)) {\n      return { x: p[0], y: p[1] }\n    }\n\n    return { x: p.x, y: p.y }\n  }\n\n  /**\n   * Returns a new Point object from the given polar coordinates.\n   * @see http://en.wikipedia.org/wiki/Polar_coordinate_system\n   */\n  export function fromPolar(\n    r: number,\n    rad: number,\n    origin: Point | PointLike | PointData = new Point(),\n  ) {\n    let x = Math.abs(r * Math.cos(rad))\n    let y = Math.abs(r * Math.sin(rad))\n    const org = clone(origin)\n    const deg = Angle.normalize(Angle.toDeg(rad))\n\n    if (deg < 90) {\n      y = -y\n    } else if (deg < 180) {\n      x = -x\n      y = -y\n    } else if (deg < 270) {\n      x = -x\n    }\n\n    return new Point(org.x + x, org.y + y)\n  }\n\n  /**\n   * Converts rectangular to polar coordinates.\n   */\n  export function toPolar(\n    point: Point | PointLike | PointData,\n    origin: Point | PointLike | PointData = new Point(),\n  ) {\n    const p = clone(point)\n    const o = clone(origin)\n    const dx = p.x - o.x\n    const dy = p.y - o.y\n    return new Point(\n      Math.sqrt(dx * dx + dy * dy), // r\n      Angle.toRad(o.theta(p)),\n    )\n  }\n\n  export function equals(p1?: Point.PointLike, p2?: Point.PointLike) {\n    if (p1 === p2) {\n      return true\n    }\n\n    if (p1 != null && p2 != null) {\n      return p1.x === p2.x && p1.y === p2.y\n    }\n\n    return false\n  }\n\n  export function equalPoints(p1: Point.PointLike[], p2: Point.PointLike[]) {\n    if (\n      (p1 == null && p2 != null) ||\n      (p1 != null && p2 == null) ||\n      (p1 != null && p2 != null && p1.length !== p2.length)\n    ) {\n      return false\n    }\n\n    if (p1 != null && p2 != null) {\n      for (let i = 0, ii = p1.length; i < ii; i += 1) {\n        if (!equals(p1[i], p2[i])) {\n          return false\n        }\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Returns a point with random coordinates that fall within the range\n   * `[x1, x2]` and `[y1, y2]`.\n   */\n  export function random(x1: number, x2: number, y1: number, y2: number) {\n    return new Point(util.random(x1, x2), util.random(y1, y2))\n  }\n\n  export function rotate(\n    point: Point | PointLike | PointData,\n    angle: number,\n    center?: Point | PointLike | PointData,\n  ) {\n    const rad = Angle.toRad(Angle.normalize(-angle))\n    const sin = Math.sin(rad)\n    const cos = Math.cos(rad)\n\n    return rotateEx(point, cos, sin, center)\n  }\n\n  export function rotateEx(\n    point: Point | PointLike | PointData,\n    cos: number,\n    sin: number,\n    center: Point | PointLike | PointData = new Point(),\n  ) {\n    const source = clone(point)\n    const origin = clone(center)\n    const dx = source.x - origin.x\n    const dy = source.y - origin.y\n    const x1 = dx * cos - dy * sin\n    const y1 = dy * cos + dx * sin\n    return new Point(x1 + origin.x, y1 + origin.y)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}