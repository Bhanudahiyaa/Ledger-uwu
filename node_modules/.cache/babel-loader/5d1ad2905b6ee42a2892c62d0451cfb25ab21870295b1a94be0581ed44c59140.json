{"ast":null,"code":"/* eslint-disable no-control-regex */\nimport { NumberExt } from '../number';\nimport { Text } from '../text';\nimport { attr } from './attr';\nimport { Vector } from '../vector';\nimport { createSvgElement, empty, remove } from './elem';\nimport { Platform } from '../platform';\nfunction createTextPathNode(attrs, elem) {\n  const vel = Vector.create(elem);\n  const textPath = Vector.create('textPath');\n  const d = attrs.d;\n  if (d && attrs['xlink:href'] === undefined) {\n    const path = Vector.create('path').attr('d', d).appendTo(vel.defs());\n    textPath.attr('xlink:href', `#${path.id}`);\n  }\n  if (typeof attrs === 'object') {\n    textPath.attr(attrs);\n  }\n  return textPath.node;\n}\nfunction annotateTextLine(lineNode, lineAnnotations, options) {\n  const eol = options.eol;\n  const baseSize = options.baseSize;\n  const lineHeight = options.lineHeight;\n  let maxFontSize = 0;\n  let tspanNode;\n  const fontMetrics = {};\n  const lastJ = lineAnnotations.length - 1;\n  for (let j = 0; j <= lastJ; j += 1) {\n    let annotation = lineAnnotations[j];\n    let fontSize = null;\n    if (typeof annotation === 'object') {\n      const annotationAttrs = annotation.attrs;\n      const vTSpan = Vector.create('tspan', annotationAttrs);\n      tspanNode = vTSpan.node;\n      let t = annotation.t;\n      if (eol && j === lastJ) {\n        t += eol;\n      }\n      tspanNode.textContent = t;\n      // Per annotation className\n      const annotationClass = annotationAttrs.class;\n      if (annotationClass) {\n        vTSpan.addClass(annotationClass);\n      }\n      // set the list of indices of all the applied annotations\n      // in the `annotations` attribute. This list is a comma\n      // separated list of indices.\n      if (options.includeAnnotationIndices) {\n        vTSpan.attr('annotations', annotation.annotations.join(','));\n      }\n      // Check for max font size\n      fontSize = parseFloat(annotationAttrs['font-size']);\n      if (fontSize === undefined) fontSize = baseSize;\n      if (fontSize && fontSize > maxFontSize) maxFontSize = fontSize;\n    } else {\n      if (eol && j === lastJ) {\n        annotation += eol;\n      }\n      tspanNode = document.createTextNode(annotation || ' ');\n      if (baseSize && baseSize > maxFontSize) {\n        maxFontSize = baseSize;\n      }\n    }\n    lineNode.appendChild(tspanNode);\n  }\n  if (maxFontSize) {\n    fontMetrics.maxFontSize = maxFontSize;\n  }\n  if (lineHeight) {\n    fontMetrics.lineHeight = lineHeight;\n  } else if (maxFontSize) {\n    fontMetrics.lineHeight = maxFontSize * 1.2;\n  }\n  return fontMetrics;\n}\nconst emRegex = /em$/;\nfunction emToPx(em, fontSize) {\n  const numerical = parseFloat(em);\n  if (emRegex.test(em)) {\n    return numerical * fontSize;\n  }\n  return numerical;\n}\nfunction calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {\n  if (!Array.isArray(linesMetrics)) {\n    return 0;\n  }\n  const n = linesMetrics.length;\n  if (!n) return 0;\n  let lineMetrics = linesMetrics[0];\n  const flMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n  let rLineHeights = 0;\n  const lineHeightPx = emToPx(lineHeight, baseSizePx);\n  for (let i = 1; i < n; i += 1) {\n    lineMetrics = linesMetrics[i];\n    const iLineHeight = emToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;\n    rLineHeights += iLineHeight;\n  }\n  const llMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n  let dy;\n  switch (alignment) {\n    case 'middle':\n      dy = flMaxFont / 2 - 0.15 * llMaxFont - rLineHeights / 2;\n      break;\n    case 'bottom':\n      dy = -(0.25 * llMaxFont) - rLineHeights;\n      break;\n    default:\n    case 'top':\n      dy = 0.8 * flMaxFont;\n      break;\n  }\n  return dy;\n}\nexport function text(elem, content, options = {}) {\n  content = Text.sanitize(content); // eslint-disable-line\n  const eol = options.eol;\n  let textPath = options.textPath;\n  const verticalAnchor = options.textVerticalAnchor;\n  const namedVerticalAnchor = verticalAnchor === 'middle' || verticalAnchor === 'bottom' || verticalAnchor === 'top';\n  // Horizontal shift applied to all the lines but the first.\n  let x = options.x;\n  if (x === undefined) {\n    x = elem.getAttribute('x') || 0;\n  }\n  // Annotations\n  const iai = options.includeAnnotationIndices;\n  let annotations = options.annotations;\n  if (annotations && !Array.isArray(annotations)) {\n    annotations = [annotations];\n  }\n  // Shift all the <tspan> but first by one line (`1em`)\n  const defaultLineHeight = options.lineHeight;\n  const autoLineHeight = defaultLineHeight === 'auto';\n  const lineHeight = autoLineHeight ? '1.5em' : defaultLineHeight || '1em';\n  empty(elem);\n  attr(elem, {\n    // Preserve spaces, do not consecutive spaces to get collapsed to one.\n    'xml:space': 'preserve',\n    // An empty text gets rendered into the DOM in webkit-based browsers.\n    // In order to unify this behaviour across all browsers\n    // we rather hide the text element when it's empty.\n    display: content || options.displayEmpty ? null : 'none'\n  });\n  // Set default font-size if none\n  const strFontSize = attr(elem, 'font-size');\n  let fontSize = parseFloat(strFontSize);\n  if (!fontSize) {\n    fontSize = 16;\n    if ((namedVerticalAnchor || annotations) && !strFontSize) {\n      attr(elem, 'font-size', `${fontSize}`);\n    }\n  }\n  let containerNode;\n  if (textPath) {\n    // Now all the `<tspan>`s will be inside the `<textPath>`.\n    if (typeof textPath === 'string') {\n      textPath = {\n        d: textPath\n      };\n    }\n    containerNode = createTextPathNode(textPath, elem);\n  } else {\n    containerNode = document.createDocumentFragment();\n  }\n  let dy;\n  let offset = 0;\n  let annotatedY;\n  const lines = content.split('\\n');\n  const linesMetrics = [];\n  const lastI = lines.length - 1;\n  for (let i = 0; i <= lastI; i += 1) {\n    dy = lineHeight;\n    let lineClassName = 'v-line';\n    const lineNode = createSvgElement('tspan');\n    let lineMetrics;\n    let line = lines[i];\n    if (line) {\n      if (annotations) {\n        // Find the *compacted* annotations for this line.\n        const lineAnnotations = Text.annotate(line, annotations, {\n          offset: -offset,\n          includeAnnotationIndices: iai\n        });\n        lineMetrics = annotateTextLine(lineNode, lineAnnotations, {\n          eol: i !== lastI && eol,\n          baseSize: fontSize,\n          lineHeight: autoLineHeight ? null : lineHeight,\n          includeAnnotationIndices: iai\n        });\n        // Get the line height based on the biggest font size\n        // in the annotations for this line.\n        const iLineHeight = lineMetrics.lineHeight;\n        if (iLineHeight && autoLineHeight && i !== 0) {\n          dy = iLineHeight;\n        }\n        if (i === 0) {\n          annotatedY = lineMetrics.maxFontSize * 0.8;\n        }\n      } else {\n        if (eol && i !== lastI) {\n          line += eol;\n        }\n        lineNode.textContent = line;\n      }\n    } else {\n      // Make sure the textContent is never empty. If it is, add a dummy\n      // character and make it invisible, making the following lines correctly\n      // relatively positioned. `dy=1em` won't work with empty lines otherwise.\n      lineNode.textContent = '-';\n      lineClassName += ' v-empty-line';\n      const lineNodeStyle = lineNode.style;\n      lineNodeStyle.fillOpacity = 0;\n      lineNodeStyle.strokeOpacity = 0;\n      if (annotations) {\n        lineMetrics = {};\n      }\n    }\n    if (lineMetrics) {\n      linesMetrics.push(lineMetrics);\n    }\n    if (i > 0) {\n      lineNode.setAttribute('dy', dy);\n    }\n    // Firefox requires 'x' to be set on the first line\n    if (i > 0 || textPath) {\n      lineNode.setAttribute('x', x);\n    }\n    lineNode.className.baseVal = lineClassName;\n    containerNode.appendChild(lineNode);\n    offset += line.length + 1; // + 1 = newline character.\n  }\n  // Y Alignment calculation\n  if (namedVerticalAnchor) {\n    if (annotations) {\n      dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);\n    } else if (verticalAnchor === 'top') {\n      // A shortcut for top alignment. It does not depend on font-size nor line-height\n      dy = '0.8em';\n    } else {\n      let rh; // remaining height\n      if (lastI > 0) {\n        rh = parseFloat(lineHeight) || 1;\n        rh *= lastI;\n        if (!emRegex.test(lineHeight)) rh /= fontSize;\n      } else {\n        // Single-line text\n        rh = 0;\n      }\n      switch (verticalAnchor) {\n        case 'middle':\n          dy = `${0.3 - rh / 2}em`;\n          break;\n        case 'bottom':\n          dy = `${-rh - 0.3}em`;\n          break;\n        default:\n          break;\n      }\n    }\n  } else if (verticalAnchor === 0) {\n    dy = '0em';\n  } else if (verticalAnchor) {\n    dy = verticalAnchor;\n  } else {\n    // No vertical anchor is defined\n    dy = 0;\n    // Backwards compatibility - we change the `y` attribute instead of `dy`.\n    if (elem.getAttribute('y') == null) {\n      elem.setAttribute('y', `${annotatedY || '0.8em'}`);\n    }\n  }\n  const firstLine = containerNode.firstChild;\n  firstLine.setAttribute('dy', dy);\n  elem.appendChild(containerNode);\n}\nfunction splitText(text, separator, eol, hyphen) {\n  const words = [];\n  const separators = [];\n  if (separator != null) {\n    const parts = text.split(separator);\n    words.push(...parts);\n    if (typeof separator === 'string') {\n      for (let i = 0, l = parts.length - 1; i < l; i += 1) {\n        separators.push(separator);\n      }\n    } else {\n      const seps = text.match(new RegExp(separator, 'g'));\n      for (let i = 0, l = parts.length - 1; i < l; i += 1) {\n        separators.push(seps ? seps[i] : '');\n      }\n    }\n  } else {\n    let word = '';\n    for (let i = 0, l = text.length; i < l; i += 1) {\n      const char = text[i];\n      if (char === ' ') {\n        words.push(word);\n        separators.push(' ');\n        word = '';\n      } else if (char.match(/[^\\x00-\\xff]/)) {\n        // split double byte character\n        if (word.length) {\n          words.push(word);\n          separators.push('');\n        }\n        words.push(char);\n        separators.push('');\n        word = '';\n      } else {\n        word += char;\n      }\n    }\n    if (word.length) {\n      words.push(word);\n    }\n  }\n  // end-of-line\n  for (let i = 0; i < words.length; i += 1) {\n    const word = words[i];\n    if (word.indexOf(eol) >= 0 && word.length > 1) {\n      const parts = word.split(eol);\n      for (let j = 0, k = parts.length - 1; j < k; j += 1) {\n        parts.splice(2 * j + 1, 0, eol);\n      }\n      const valids = parts.filter(part => part !== '');\n      words.splice(i, 1, ...valids);\n      const seps = valids.map(() => '');\n      seps.pop();\n      separators.splice(i, 0, ...seps);\n    }\n  }\n  // hyphen\n  for (let i = 0; i < words.length; i += 1) {\n    const word = words[i];\n    const index = word.search(hyphen);\n    if (index > 0 && index < word.length - 1) {\n      words.splice(i, 1, word.substring(0, index + 1), word.substring(index + 1));\n      separators.splice(i, 0, '');\n    }\n  }\n  return {\n    words,\n    separators\n  };\n}\nexport function breakText(text, size, styles = {}, options = {}) {\n  const width = size.width;\n  const height = size.height;\n  const svgDocument = options.svgDocument || createSvgElement('svg');\n  const telem = createSvgElement('text');\n  const tspan = createSvgElement('tspan');\n  const tnode = document.createTextNode('');\n  attr(telem, styles);\n  telem.appendChild(tspan);\n  // Prevent flickering\n  telem.style.opacity = '0';\n  // Prevent FF from throwing an uncaught exception when `getBBox()`\n  // called on element that is not in the render tree (is not measurable).\n  // <tspan>.getComputedTextLength() returns always 0 in this case.\n  // Note that the `textElement` resp. `textSpan` can become hidden\n  // when it's appended to the DOM and a `display: none` CSS stylesheet\n  // rule gets applied.\n  telem.style.display = 'block';\n  tspan.style.display = 'block';\n  tspan.appendChild(tnode);\n  svgDocument.appendChild(telem);\n  const shouldAppend = svgDocument.parentNode == null;\n  if (shouldAppend) {\n    document.body.appendChild(svgDocument);\n  }\n  const eol = options.eol || '\\n';\n  const separator = options.separator || ' ';\n  const hyphen = options.hyphen ? new RegExp(options.hyphen) : /[^\\w\\d]/;\n  const breakWord = options.breakWord !== false;\n  const full = [];\n  const lineSeprators = {};\n  let lines = [];\n  let partIndex;\n  // let hyphenIndex\n  let lineHeight;\n  let currentSeparator;\n  const {\n    words,\n    separators\n  } = splitText(text, options.separator, eol, hyphen);\n  for (let wordIndex = 0, lineIndex = 0, wordCount = words.length; wordIndex < wordCount; wordIndex += 1) {\n    const word = words[wordIndex];\n    // empty word\n    if (!word) {\n      continue;\n    }\n    // end of line\n    if (word === eol) {\n      full[lineIndex] = true;\n      // start a new line\n      lineIndex += 1;\n      lines[lineIndex] = '';\n      continue;\n    }\n    if (lines[lineIndex] != null) {\n      currentSeparator = separators[wordIndex - 1] || '';\n      tnode.data = `${lines[lineIndex]}${currentSeparator}${word}`;\n    } else {\n      tnode.data = word;\n    }\n    if (tspan.getComputedTextLength() <= width) {\n      // update line\n      lines[lineIndex] = tnode.data;\n      lineSeprators[lineIndex] = separators[wordIndex];\n      // when is partitioning, put rest of the word onto next line\n      if (partIndex) {\n        full[lineIndex] = true;\n        lineIndex += 1;\n        partIndex = 0;\n      }\n    } else {\n      if (breakWord) {\n        // word is too long to put in one line or is partitioning\n        if (!lines[lineIndex] || partIndex) {\n          const isPartition = !!partIndex;\n          const isCharacter = word.length === 1;\n          partIndex = word.length - 1;\n          if (isPartition || isCharacter) {\n            // word has only one character.\n            if (isCharacter) {\n              if (!lines[lineIndex]) {\n                // can't fit this text within our rect\n                lines = [];\n                break;\n              }\n              // partitioning didn't help on the non-empty line\n              // try again, but this time start with a new line\n              // cancel partitions created\n              words.splice(wordIndex, 2, word + words[wordIndex + 1]);\n              separators.splice(wordIndex + 1, 1);\n              full[lineIndex] = true;\n              lineIndex += 1;\n              wordCount -= 1;\n              wordIndex -= 1;\n              continue;\n            }\n            // update the partitioning words\n            words[wordIndex] = word.substring(0, partIndex);\n            words[wordIndex + 1] = word.substring(partIndex) + words[wordIndex + 1];\n          } else {\n            // partitioning the long word into two words\n            words.splice(wordIndex, 1, word.substring(0, partIndex), word.substring(partIndex));\n            separators.splice(wordIndex, 0, '');\n            wordCount += 1;\n            // if the previous line is not full\n            if (lineIndex && !full[lineIndex - 1]) {\n              lineIndex -= 1;\n            }\n          }\n          wordIndex -= 1;\n          continue;\n        }\n      } else if (!lines[lineIndex]) {\n        lines[lineIndex] = word;\n        full[lineIndex] = true;\n        lineIndex += 1;\n        continue;\n      }\n      lineIndex += 1;\n      wordIndex -= 1;\n    }\n    // check whether the height of the entire text exceeds the rect height\n    if (height != null) {\n      // ensure line height\n      if (lineHeight == null) {\n        let heightValue;\n        // use the same defaults as in V.prototype.text\n        if (styles.lineHeight === 'auto') {\n          heightValue = {\n            value: 1.5,\n            unit: 'em'\n          };\n        } else {\n          heightValue = NumberExt.parseCssNumeric(styles.lineHeight, ['em']) || {\n            value: 1,\n            unit: 'em'\n          };\n        }\n        lineHeight = heightValue.value;\n        if (heightValue.unit === 'em') {\n          if (Platform.IS_FIREFOX) {\n            lineHeight *= tspan.getBBox().height;\n          } else {\n            lineHeight *= telem.getBBox().height;\n          }\n        }\n      }\n      if (lineHeight * lines.length > height) {\n        // remove overflowing lines\n        const lastLineIndex = Math.floor(height / lineHeight) - 1;\n        const lastLine = lines[lastLineIndex];\n        const overflowLine = lines[lastLineIndex + 1];\n        lines.splice(lastLineIndex + 1);\n        if (lastLine == null) {\n          break;\n        }\n        // add ellipsis\n        let ellipsis = options.ellipsis;\n        if (!ellipsis) {\n          break;\n        }\n        if (typeof ellipsis !== 'string') {\n          ellipsis = '\\u2026';\n        }\n        let fullLastLine = lastLine;\n        if (overflowLine && breakWord) {\n          fullLastLine += currentSeparator + overflowLine;\n        }\n        let lastCharIndex = fullLastLine.length;\n        let fixedLastLine;\n        let lastChar;\n        do {\n          lastChar = fullLastLine[lastCharIndex];\n          fixedLastLine = fullLastLine.substring(0, lastCharIndex);\n          if (!lastChar) {\n            fixedLastLine += lineSeprators[lastLineIndex];\n          } else if (lastChar.match(separator)) {\n            fixedLastLine += lastChar;\n          }\n          fixedLastLine += ellipsis;\n          tnode.data = fixedLastLine;\n          if (tspan.getComputedTextLength() <= width) {\n            lines[lastLineIndex] = fixedLastLine;\n            break;\n          }\n          lastCharIndex -= 1;\n        } while (lastCharIndex >= 0);\n        break;\n      }\n    }\n  }\n  if (shouldAppend) {\n    remove(svgDocument);\n  } else {\n    remove(telem);\n  }\n  return lines.join(eol);\n}","map":{"version":3,"names":["NumberExt","Text","attr","Vector","createSvgElement","empty","remove","Platform","createTextPathNode","attrs","elem","vel","create","textPath","d","undefined","path","appendTo","defs","id","node","annotateTextLine","lineNode","lineAnnotations","options","eol","baseSize","lineHeight","maxFontSize","tspanNode","fontMetrics","lastJ","length","j","annotation","fontSize","annotationAttrs","vTSpan","t","textContent","annotationClass","class","addClass","includeAnnotationIndices","annotations","join","parseFloat","document","createTextNode","appendChild","emRegex","emToPx","em","numerical","test","calculateDY","alignment","linesMetrics","baseSizePx","Array","isArray","n","lineMetrics","flMaxFont","rLineHeights","lineHeightPx","i","iLineHeight","llMaxFont","dy","text","content","sanitize","verticalAnchor","textVerticalAnchor","namedVerticalAnchor","x","getAttribute","iai","defaultLineHeight","autoLineHeight","display","displayEmpty","strFontSize","containerNode","createDocumentFragment","offset","annotatedY","lines","split","lastI","lineClassName","line","annotate","lineNodeStyle","style","fillOpacity","strokeOpacity","push","setAttribute","className","baseVal","rh","firstLine","firstChild","splitText","separator","hyphen","words","separators","parts","l","seps","match","RegExp","word","char","indexOf","k","splice","valids","filter","part","map","pop","index","search","substring","breakText","size","styles","width","height","svgDocument","telem","tspan","tnode","opacity","shouldAppend","parentNode","body","breakWord","full","lineSeprators","partIndex","currentSeparator","wordIndex","lineIndex","wordCount","data","getComputedTextLength","isPartition","isCharacter","heightValue","value","unit","parseCssNumeric","IS_FIREFOX","getBBox","lastLineIndex","Math","floor","lastLine","overflowLine","ellipsis","fullLastLine","lastCharIndex","fixedLastLine","lastChar"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/util/dom/text.ts"],"sourcesContent":["/* eslint-disable no-control-regex */\n\nimport { Size } from '../../types'\nimport { NumberExt } from '../number'\nimport { Text } from '../text'\nimport { attr } from './attr'\nimport { Vector } from '../vector'\nimport { createSvgElement, empty, remove } from './elem'\nimport { Platform } from '../platform'\n\nfunction createTextPathNode(\n  attrs: { d?: string; 'xlink:href'?: string },\n  elem: SVGElement,\n) {\n  const vel = Vector.create(elem)\n  const textPath = Vector.create('textPath')\n  const d = attrs.d\n  if (d && attrs['xlink:href'] === undefined) {\n    const path = Vector.create('path').attr('d', d).appendTo(vel.defs())\n    textPath.attr('xlink:href', `#${path.id}`)\n  }\n\n  if (typeof attrs === 'object') {\n    textPath.attr(attrs as any)\n  }\n\n  return textPath.node\n}\n\nfunction annotateTextLine(\n  lineNode: SVGTSpanElement,\n  lineAnnotations: (string | Text.AnnotatedItem)[],\n  options: {\n    includeAnnotationIndices?: boolean\n    eol?: boolean | string\n    lineHeight: string | null\n    baseSize: number\n  },\n) {\n  const eol = options.eol\n  const baseSize = options.baseSize\n  const lineHeight = options.lineHeight\n\n  let maxFontSize = 0\n  let tspanNode\n  const fontMetrics: any = {}\n  const lastJ = lineAnnotations.length - 1\n\n  for (let j = 0; j <= lastJ; j += 1) {\n    let annotation = lineAnnotations[j]\n    let fontSize = null\n    if (typeof annotation === 'object') {\n      const annotationAttrs = annotation.attrs\n      const vTSpan = Vector.create('tspan', annotationAttrs)\n      tspanNode = vTSpan.node\n\n      let t = annotation.t\n      if (eol && j === lastJ) {\n        t += eol\n      }\n\n      tspanNode.textContent = t\n      // Per annotation className\n      const annotationClass = annotationAttrs.class as string\n      if (annotationClass) {\n        vTSpan.addClass(annotationClass)\n      }\n\n      // set the list of indices of all the applied annotations\n      // in the `annotations` attribute. This list is a comma\n      // separated list of indices.\n      if (options.includeAnnotationIndices) {\n        vTSpan.attr('annotations', annotation.annotations!.join(','))\n      }\n      // Check for max font size\n      fontSize = parseFloat(annotationAttrs['font-size'] as string)\n      if (fontSize === undefined) fontSize = baseSize\n      if (fontSize && fontSize > maxFontSize) maxFontSize = fontSize\n    } else {\n      if (eol && j === lastJ) {\n        annotation += eol\n      }\n      tspanNode = document.createTextNode(annotation || ' ')\n      if (baseSize && baseSize > maxFontSize) {\n        maxFontSize = baseSize\n      }\n    }\n\n    lineNode.appendChild(tspanNode)\n  }\n\n  if (maxFontSize) {\n    fontMetrics.maxFontSize = maxFontSize\n  }\n\n  if (lineHeight) {\n    fontMetrics.lineHeight = lineHeight\n  } else if (maxFontSize) {\n    fontMetrics.lineHeight = maxFontSize * 1.2\n  }\n\n  return fontMetrics\n}\n\nconst emRegex = /em$/\n\nfunction emToPx(em: string, fontSize: number) {\n  const numerical = parseFloat(em)\n  if (emRegex.test(em)) {\n    return numerical * fontSize\n  }\n\n  return numerical\n}\n\nfunction calculateDY(\n  alignment: string,\n  linesMetrics: any[],\n  baseSizePx: number,\n  lineHeight: string,\n) {\n  if (!Array.isArray(linesMetrics)) {\n    return 0\n  }\n\n  const n = linesMetrics.length\n  if (!n) return 0\n  let lineMetrics = linesMetrics[0]\n  const flMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx\n  let rLineHeights = 0\n  const lineHeightPx = emToPx(lineHeight, baseSizePx)\n  for (let i = 1; i < n; i += 1) {\n    lineMetrics = linesMetrics[i]\n    const iLineHeight =\n      emToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx\n    rLineHeights += iLineHeight\n  }\n  const llMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx\n  let dy\n  switch (alignment) {\n    case 'middle':\n      dy = flMaxFont / 2 - 0.15 * llMaxFont - rLineHeights / 2\n      break\n    case 'bottom':\n      dy = -(0.25 * llMaxFont) - rLineHeights\n      break\n    default:\n    case 'top':\n      dy = 0.8 * flMaxFont\n      break\n  }\n  return dy\n}\n\nexport interface TextOptions {\n  /** Should we allow the text to be selected? */\n  displayEmpty?: boolean\n  /** End of Line character */\n  eol?: string\n  textPath?: string | { d?: string; 'xlink:href'?: string }\n  textVerticalAnchor?: 'middle' | 'bottom' | 'top' | number\n  x?: number | string\n  /** auto, 1.25em */\n  lineHeight?: string\n  includeAnnotationIndices?: boolean\n  annotations?: Text.Annotation | Text.Annotation[]\n}\n\nexport function text(\n  elem: SVGElement,\n  content: string,\n  options: TextOptions = {},\n) {\n  content = Text.sanitize(content) // eslint-disable-line\n  const eol = options.eol\n  let textPath = options.textPath\n  const verticalAnchor = options.textVerticalAnchor\n  const namedVerticalAnchor =\n    verticalAnchor === 'middle' ||\n    verticalAnchor === 'bottom' ||\n    verticalAnchor === 'top'\n\n  // Horizontal shift applied to all the lines but the first.\n  let x = options.x\n  if (x === undefined) {\n    x = elem.getAttribute('x') || 0\n  }\n\n  // Annotations\n  const iai = options.includeAnnotationIndices\n  let annotations = options.annotations\n  if (annotations && !Array.isArray(annotations)) {\n    annotations = [annotations]\n  }\n\n  // Shift all the <tspan> but first by one line (`1em`)\n  const defaultLineHeight = options.lineHeight\n  const autoLineHeight = defaultLineHeight === 'auto'\n  const lineHeight = autoLineHeight ? '1.5em' : defaultLineHeight || '1em'\n\n  empty(elem)\n\n  attr(elem, {\n    // Preserve spaces, do not consecutive spaces to get collapsed to one.\n    'xml:space': 'preserve',\n    // An empty text gets rendered into the DOM in webkit-based browsers.\n    // In order to unify this behaviour across all browsers\n    // we rather hide the text element when it's empty.\n    display: content || options.displayEmpty ? null : 'none',\n  })\n\n  // Set default font-size if none\n  const strFontSize = attr(elem, 'font-size')\n  let fontSize = parseFloat(strFontSize)\n  if (!fontSize) {\n    fontSize = 16\n    if ((namedVerticalAnchor || annotations) && !strFontSize) {\n      attr(elem, 'font-size', `${fontSize}`)\n    }\n  }\n\n  let containerNode\n  if (textPath) {\n    // Now all the `<tspan>`s will be inside the `<textPath>`.\n    if (typeof textPath === 'string') {\n      textPath = { d: textPath }\n    }\n    containerNode = createTextPathNode(textPath as any, elem)\n  } else {\n    containerNode = document.createDocumentFragment()\n  }\n\n  let dy\n  let offset = 0\n  let annotatedY\n  const lines = content.split('\\n')\n  const linesMetrics = []\n  const lastI = lines.length - 1\n\n  for (let i = 0; i <= lastI; i += 1) {\n    dy = lineHeight\n    let lineClassName = 'v-line'\n    const lineNode = createSvgElement('tspan') as SVGTSpanElement\n\n    let lineMetrics\n    let line = lines[i]\n    if (line) {\n      if (annotations) {\n        // Find the *compacted* annotations for this line.\n        const lineAnnotations = Text.annotate(line, annotations, {\n          offset: -offset,\n          includeAnnotationIndices: iai,\n        })\n\n        lineMetrics = annotateTextLine(lineNode, lineAnnotations, {\n          eol: i !== lastI && eol,\n          baseSize: fontSize,\n          lineHeight: autoLineHeight ? null : lineHeight,\n          includeAnnotationIndices: iai,\n        })\n\n        // Get the line height based on the biggest font size\n        // in the annotations for this line.\n        const iLineHeight = lineMetrics.lineHeight\n        if (iLineHeight && autoLineHeight && i !== 0) {\n          dy = iLineHeight\n        }\n\n        if (i === 0) {\n          annotatedY = lineMetrics.maxFontSize * 0.8\n        }\n      } else {\n        if (eol && i !== lastI) {\n          line += eol\n        }\n\n        lineNode.textContent = line\n      }\n    } else {\n      // Make sure the textContent is never empty. If it is, add a dummy\n      // character and make it invisible, making the following lines correctly\n      // relatively positioned. `dy=1em` won't work with empty lines otherwise.\n      lineNode.textContent = '-'\n      lineClassName += ' v-empty-line'\n\n      const lineNodeStyle = lineNode.style as any\n      lineNodeStyle.fillOpacity = 0\n      lineNodeStyle.strokeOpacity = 0\n\n      if (annotations) {\n        lineMetrics = {}\n      }\n    }\n\n    if (lineMetrics) {\n      linesMetrics.push(lineMetrics)\n    }\n\n    if (i > 0) {\n      lineNode.setAttribute('dy', dy)\n    }\n\n    // Firefox requires 'x' to be set on the first line\n    if (i > 0 || textPath) {\n      lineNode.setAttribute('x', x as string)\n    }\n\n    lineNode.className.baseVal = lineClassName\n    containerNode.appendChild(lineNode)\n    offset += line.length + 1 // + 1 = newline character.\n  }\n\n  // Y Alignment calculation\n  if (namedVerticalAnchor) {\n    if (annotations) {\n      dy = calculateDY(\n        verticalAnchor as string,\n        linesMetrics,\n        fontSize,\n        lineHeight,\n      )\n    } else if (verticalAnchor === 'top') {\n      // A shortcut for top alignment. It does not depend on font-size nor line-height\n      dy = '0.8em'\n    } else {\n      let rh // remaining height\n      if (lastI > 0) {\n        rh = parseFloat(lineHeight) || 1\n        rh *= lastI\n        if (!emRegex.test(lineHeight)) rh /= fontSize\n      } else {\n        // Single-line text\n        rh = 0\n      }\n      switch (verticalAnchor) {\n        case 'middle':\n          dy = `${0.3 - rh / 2}em`\n          break\n        case 'bottom':\n          dy = `${-rh - 0.3}em`\n          break\n        default:\n          break\n      }\n    }\n  } else if (verticalAnchor === 0) {\n    dy = '0em'\n  } else if (verticalAnchor) {\n    dy = verticalAnchor\n  } else {\n    // No vertical anchor is defined\n    dy = 0\n    // Backwards compatibility - we change the `y` attribute instead of `dy`.\n    if (elem.getAttribute('y') == null) {\n      elem.setAttribute('y', `${annotatedY || '0.8em'}`)\n    }\n  }\n\n  const firstLine = containerNode.firstChild as SVGElement\n  firstLine.setAttribute('dy', dy)\n  elem.appendChild(containerNode)\n}\n\nfunction splitText(\n  text: string,\n  separator: string | RegExp | undefined | null,\n  eol: string,\n  hyphen: RegExp,\n) {\n  const words: string[] = []\n  const separators: string[] = []\n\n  if (separator != null) {\n    const parts = text.split(separator)\n    words.push(...parts)\n    if (typeof separator === 'string') {\n      for (let i = 0, l = parts.length - 1; i < l; i += 1) {\n        separators.push(separator)\n      }\n    } else {\n      const seps = text.match(new RegExp(separator, 'g'))\n      for (let i = 0, l = parts.length - 1; i < l; i += 1) {\n        separators.push(seps ? seps[i] : '')\n      }\n    }\n  } else {\n    let word = ''\n    for (let i = 0, l = text.length; i < l; i += 1) {\n      const char = text[i]\n\n      if (char === ' ') {\n        words.push(word)\n        separators.push(' ')\n        word = ''\n      } else if (char.match(/[^\\x00-\\xff]/)) {\n        // split double byte character\n        if (word.length) {\n          words.push(word)\n          separators.push('')\n        }\n\n        words.push(char)\n        separators.push('')\n\n        word = ''\n      } else {\n        word += char\n      }\n    }\n\n    if (word.length) {\n      words.push(word)\n    }\n  }\n\n  // end-of-line\n  for (let i = 0; i < words.length; i += 1) {\n    const word = words[i]\n    if (word.indexOf(eol) >= 0 && word.length > 1) {\n      const parts = word.split(eol)\n      for (let j = 0, k = parts.length - 1; j < k; j += 1) {\n        parts.splice(2 * j + 1, 0, eol)\n      }\n\n      const valids = parts.filter((part) => part !== '')\n      words.splice(i, 1, ...valids)\n\n      const seps = valids.map(() => '')\n      seps.pop()\n      separators.splice(i, 0, ...seps)\n    }\n  }\n\n  // hyphen\n  for (let i = 0; i < words.length; i += 1) {\n    const word = words[i]\n    const index = word.search(hyphen)\n    if (index > 0 && index < word.length - 1) {\n      words.splice(\n        i,\n        1,\n        word.substring(0, index + 1),\n        word.substring(index + 1),\n      )\n      separators.splice(i, 0, '')\n    }\n  }\n\n  return { words, separators }\n}\n\nexport function breakText(\n  text: string,\n  size: Size,\n  styles: any = {},\n  options: {\n    ellipsis?: string\n    separator?: string\n    eol?: string\n    hyphen?: string\n    breakWord?: boolean\n    svgDocument?: SVGSVGElement\n  } = {},\n) {\n  const width = size.width\n  const height = size.height\n\n  const svgDocument = options.svgDocument || createSvgElement('svg')\n  const telem = createSvgElement('text') as SVGTextElement\n  const tspan = createSvgElement('tspan') as SVGTSpanElement\n  const tnode = document.createTextNode('')\n\n  attr(telem, styles)\n  telem.appendChild(tspan)\n\n  // Prevent flickering\n  telem.style.opacity = '0'\n  // Prevent FF from throwing an uncaught exception when `getBBox()`\n  // called on element that is not in the render tree (is not measurable).\n  // <tspan>.getComputedTextLength() returns always 0 in this case.\n  // Note that the `textElement` resp. `textSpan` can become hidden\n  // when it's appended to the DOM and a `display: none` CSS stylesheet\n  // rule gets applied.\n  telem.style.display = 'block'\n  tspan.style.display = 'block'\n\n  tspan.appendChild(tnode)\n  svgDocument.appendChild(telem)\n\n  const shouldAppend = svgDocument.parentNode == null\n  if (shouldAppend) {\n    document.body.appendChild(svgDocument)\n  }\n\n  const eol = options.eol || '\\n'\n  const separator = options.separator || ' '\n  const hyphen = options.hyphen ? new RegExp(options.hyphen) : /[^\\w\\d]/\n  const breakWord = options.breakWord !== false\n\n  const full = []\n  const lineSeprators: { [index: number]: string } = {}\n  let lines = []\n  let partIndex\n  // let hyphenIndex\n  let lineHeight\n  let currentSeparator\n\n  const { words, separators } = splitText(text, options.separator, eol, hyphen)\n  for (\n    let wordIndex = 0, lineIndex = 0, wordCount = words.length;\n    wordIndex < wordCount;\n    wordIndex += 1\n  ) {\n    const word = words[wordIndex]\n\n    // empty word\n    if (!word) {\n      continue\n    }\n\n    // end of line\n    if (word === eol) {\n      full[lineIndex] = true\n      // start a new line\n      lineIndex += 1\n      lines[lineIndex] = ''\n      continue\n    }\n\n    if (lines[lineIndex] != null) {\n      currentSeparator = separators[wordIndex - 1] || ''\n      tnode.data = `${lines[lineIndex]}${currentSeparator}${word}`\n    } else {\n      tnode.data = word\n    }\n\n    if (tspan.getComputedTextLength() <= width) {\n      // update line\n      lines[lineIndex] = tnode.data\n      lineSeprators[lineIndex] = separators[wordIndex]\n\n      // when is partitioning, put rest of the word onto next line\n      if (partIndex) {\n        full[lineIndex] = true\n        lineIndex += 1\n        partIndex = 0\n      }\n    } else {\n      if (breakWord) {\n        // word is too long to put in one line or is partitioning\n        if (!lines[lineIndex] || partIndex) {\n          const isPartition = !!partIndex\n          const isCharacter = word.length === 1\n\n          partIndex = word.length - 1\n\n          if (isPartition || isCharacter) {\n            // word has only one character.\n            if (isCharacter) {\n              if (!lines[lineIndex]) {\n                // can't fit this text within our rect\n                lines = []\n                break\n              }\n\n              // partitioning didn't help on the non-empty line\n              // try again, but this time start with a new line\n\n              // cancel partitions created\n              words.splice(wordIndex, 2, word + words[wordIndex + 1])\n              separators.splice(wordIndex + 1, 1)\n              full[lineIndex] = true\n\n              lineIndex += 1\n              wordCount -= 1\n              wordIndex -= 1\n\n              continue\n            }\n\n            // update the partitioning words\n            words[wordIndex] = word.substring(0, partIndex)\n            words[wordIndex + 1] =\n              word.substring(partIndex) + words[wordIndex + 1]\n          } else {\n            // partitioning the long word into two words\n            words.splice(\n              wordIndex,\n              1,\n              word.substring(0, partIndex),\n              word.substring(partIndex),\n            )\n            separators.splice(wordIndex, 0, '')\n            wordCount += 1\n\n            // if the previous line is not full\n            if (lineIndex && !full[lineIndex - 1]) {\n              lineIndex -= 1\n            }\n          }\n\n          wordIndex -= 1\n          continue\n        }\n      } else if (!lines[lineIndex]) {\n        lines[lineIndex] = word\n        full[lineIndex] = true\n        lineIndex += 1\n        continue\n      }\n\n      lineIndex += 1\n      wordIndex -= 1\n    }\n\n    // check whether the height of the entire text exceeds the rect height\n    if (height != null) {\n      // ensure line height\n      if (lineHeight == null) {\n        let heightValue\n\n        // use the same defaults as in V.prototype.text\n        if (styles.lineHeight === 'auto') {\n          heightValue = { value: 1.5, unit: 'em' }\n        } else {\n          heightValue = NumberExt.parseCssNumeric(styles.lineHeight, [\n            'em',\n          ]) || {\n            value: 1,\n            unit: 'em',\n          }\n        }\n\n        lineHeight = heightValue.value\n        if (heightValue.unit === 'em') {\n          if (Platform.IS_FIREFOX) {\n            lineHeight *= tspan.getBBox().height\n          } else {\n            lineHeight *= telem.getBBox().height\n          }\n        }\n      }\n\n      if (lineHeight * lines.length > height) {\n        // remove overflowing lines\n        const lastLineIndex = Math.floor(height / lineHeight) - 1\n        const lastLine = lines[lastLineIndex]\n        const overflowLine = lines[lastLineIndex + 1]\n\n        lines.splice(lastLineIndex + 1)\n\n        if (lastLine == null) {\n          break\n        }\n\n        // add ellipsis\n        let ellipsis = options.ellipsis\n        if (!ellipsis) {\n          break\n        }\n\n        if (typeof ellipsis !== 'string') {\n          ellipsis = '\\u2026'\n        }\n\n        let fullLastLine = lastLine\n        if (overflowLine && breakWord) {\n          fullLastLine += currentSeparator + overflowLine\n        }\n\n        let lastCharIndex = fullLastLine.length\n        let fixedLastLine\n        let lastChar\n\n        do {\n          lastChar = fullLastLine[lastCharIndex]\n          fixedLastLine = fullLastLine.substring(0, lastCharIndex)\n          if (!lastChar) {\n            fixedLastLine += lineSeprators[lastLineIndex]\n          } else if (lastChar.match(separator)) {\n            fixedLastLine += lastChar\n          }\n          fixedLastLine += ellipsis\n          tnode.data = fixedLastLine\n          if (tspan.getComputedTextLength() <= width) {\n            lines[lastLineIndex] = fixedLastLine\n            break\n          }\n          lastCharIndex -= 1\n        } while (lastCharIndex >= 0)\n\n        break\n      }\n    }\n  }\n\n  if (shouldAppend) {\n    remove(svgDocument)\n  } else {\n    remove(telem)\n  }\n\n  return lines.join(eol)\n}\n"],"mappings":"AAAA;AAGA,SAASA,SAAS,QAAQ,WAAW;AACrC,SAASC,IAAI,QAAQ,SAAS;AAC9B,SAASC,IAAI,QAAQ,QAAQ;AAC7B,SAASC,MAAM,QAAQ,WAAW;AAClC,SAASC,gBAAgB,EAAEC,KAAK,EAAEC,MAAM,QAAQ,QAAQ;AACxD,SAASC,QAAQ,QAAQ,aAAa;AAEtC,SAASC,kBAAkBA,CACzBC,KAA4C,EAC5CC,IAAgB;EAEhB,MAAMC,GAAG,GAAGR,MAAM,CAACS,MAAM,CAACF,IAAI,CAAC;EAC/B,MAAMG,QAAQ,GAAGV,MAAM,CAACS,MAAM,CAAC,UAAU,CAAC;EAC1C,MAAME,CAAC,GAAGL,KAAK,CAACK,CAAC;EACjB,IAAIA,CAAC,IAAIL,KAAK,CAAC,YAAY,CAAC,KAAKM,SAAS,EAAE;IAC1C,MAAMC,IAAI,GAAGb,MAAM,CAACS,MAAM,CAAC,MAAM,CAAC,CAACV,IAAI,CAAC,GAAG,EAAEY,CAAC,CAAC,CAACG,QAAQ,CAACN,GAAG,CAACO,IAAI,EAAE,CAAC;IACpEL,QAAQ,CAACX,IAAI,CAAC,YAAY,EAAE,IAAIc,IAAI,CAACG,EAAE,EAAE,CAAC;;EAG5C,IAAI,OAAOV,KAAK,KAAK,QAAQ,EAAE;IAC7BI,QAAQ,CAACX,IAAI,CAACO,KAAY,CAAC;;EAG7B,OAAOI,QAAQ,CAACO,IAAI;AACtB;AAEA,SAASC,gBAAgBA,CACvBC,QAAyB,EACzBC,eAAgD,EAChDC,OAKC;EAED,MAAMC,GAAG,GAAGD,OAAO,CAACC,GAAG;EACvB,MAAMC,QAAQ,GAAGF,OAAO,CAACE,QAAQ;EACjC,MAAMC,UAAU,GAAGH,OAAO,CAACG,UAAU;EAErC,IAAIC,WAAW,GAAG,CAAC;EACnB,IAAIC,SAAS;EACb,MAAMC,WAAW,GAAQ,EAAE;EAC3B,MAAMC,KAAK,GAAGR,eAAe,CAACS,MAAM,GAAG,CAAC;EAExC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIF,KAAK,EAAEE,CAAC,IAAI,CAAC,EAAE;IAClC,IAAIC,UAAU,GAAGX,eAAe,CAACU,CAAC,CAAC;IACnC,IAAIE,QAAQ,GAAG,IAAI;IACnB,IAAI,OAAOD,UAAU,KAAK,QAAQ,EAAE;MAClC,MAAME,eAAe,GAAGF,UAAU,CAACzB,KAAK;MACxC,MAAM4B,MAAM,GAAGlC,MAAM,CAACS,MAAM,CAAC,OAAO,EAAEwB,eAAe,CAAC;MACtDP,SAAS,GAAGQ,MAAM,CAACjB,IAAI;MAEvB,IAAIkB,CAAC,GAAGJ,UAAU,CAACI,CAAC;MACpB,IAAIb,GAAG,IAAIQ,CAAC,KAAKF,KAAK,EAAE;QACtBO,CAAC,IAAIb,GAAG;;MAGVI,SAAS,CAACU,WAAW,GAAGD,CAAC;MACzB;MACA,MAAME,eAAe,GAAGJ,eAAe,CAACK,KAAe;MACvD,IAAID,eAAe,EAAE;QACnBH,MAAM,CAACK,QAAQ,CAACF,eAAe,CAAC;;MAGlC;MACA;MACA;MACA,IAAIhB,OAAO,CAACmB,wBAAwB,EAAE;QACpCN,MAAM,CAACnC,IAAI,CAAC,aAAa,EAAEgC,UAAU,CAACU,WAAY,CAACC,IAAI,CAAC,GAAG,CAAC,CAAC;;MAE/D;MACAV,QAAQ,GAAGW,UAAU,CAACV,eAAe,CAAC,WAAW,CAAW,CAAC;MAC7D,IAAID,QAAQ,KAAKpB,SAAS,EAAEoB,QAAQ,GAAGT,QAAQ;MAC/C,IAAIS,QAAQ,IAAIA,QAAQ,GAAGP,WAAW,EAAEA,WAAW,GAAGO,QAAQ;KAC/D,MAAM;MACL,IAAIV,GAAG,IAAIQ,CAAC,KAAKF,KAAK,EAAE;QACtBG,UAAU,IAAIT,GAAG;;MAEnBI,SAAS,GAAGkB,QAAQ,CAACC,cAAc,CAACd,UAAU,IAAI,GAAG,CAAC;MACtD,IAAIR,QAAQ,IAAIA,QAAQ,GAAGE,WAAW,EAAE;QACtCA,WAAW,GAAGF,QAAQ;;;IAI1BJ,QAAQ,CAAC2B,WAAW,CAACpB,SAAS,CAAC;;EAGjC,IAAID,WAAW,EAAE;IACfE,WAAW,CAACF,WAAW,GAAGA,WAAW;;EAGvC,IAAID,UAAU,EAAE;IACdG,WAAW,CAACH,UAAU,GAAGA,UAAU;GACpC,MAAM,IAAIC,WAAW,EAAE;IACtBE,WAAW,CAACH,UAAU,GAAGC,WAAW,GAAG,GAAG;;EAG5C,OAAOE,WAAW;AACpB;AAEA,MAAMoB,OAAO,GAAG,KAAK;AAErB,SAASC,MAAMA,CAACC,EAAU,EAAEjB,QAAgB;EAC1C,MAAMkB,SAAS,GAAGP,UAAU,CAACM,EAAE,CAAC;EAChC,IAAIF,OAAO,CAACI,IAAI,CAACF,EAAE,CAAC,EAAE;IACpB,OAAOC,SAAS,GAAGlB,QAAQ;;EAG7B,OAAOkB,SAAS;AAClB;AAEA,SAASE,WAAWA,CAClBC,SAAiB,EACjBC,YAAmB,EACnBC,UAAkB,EAClB/B,UAAkB;EAElB,IAAI,CAACgC,KAAK,CAACC,OAAO,CAACH,YAAY,CAAC,EAAE;IAChC,OAAO,CAAC;;EAGV,MAAMI,CAAC,GAAGJ,YAAY,CAACzB,MAAM;EAC7B,IAAI,CAAC6B,CAAC,EAAE,OAAO,CAAC;EAChB,IAAIC,WAAW,GAAGL,YAAY,CAAC,CAAC,CAAC;EACjC,MAAMM,SAAS,GAAGZ,MAAM,CAACW,WAAW,CAAClC,WAAW,EAAE8B,UAAU,CAAC,IAAIA,UAAU;EAC3E,IAAIM,YAAY,GAAG,CAAC;EACpB,MAAMC,YAAY,GAAGd,MAAM,CAACxB,UAAU,EAAE+B,UAAU,CAAC;EACnD,KAAK,IAAIQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,CAAC,EAAEK,CAAC,IAAI,CAAC,EAAE;IAC7BJ,WAAW,GAAGL,YAAY,CAACS,CAAC,CAAC;IAC7B,MAAMC,WAAW,GACfhB,MAAM,CAACW,WAAW,CAACnC,UAAU,EAAE+B,UAAU,CAAC,IAAIO,YAAY;IAC5DD,YAAY,IAAIG,WAAW;;EAE7B,MAAMC,SAAS,GAAGjB,MAAM,CAACW,WAAW,CAAClC,WAAW,EAAE8B,UAAU,CAAC,IAAIA,UAAU;EAC3E,IAAIW,EAAE;EACN,QAAQb,SAAS;IACf,KAAK,QAAQ;MACXa,EAAE,GAAGN,SAAS,GAAG,CAAC,GAAG,IAAI,GAAGK,SAAS,GAAGJ,YAAY,GAAG,CAAC;MACxD;IACF,KAAK,QAAQ;MACXK,EAAE,GAAG,EAAE,IAAI,GAAGD,SAAS,CAAC,GAAGJ,YAAY;MACvC;IACF;IACA,KAAK,KAAK;MACRK,EAAE,GAAG,GAAG,GAAGN,SAAS;MACpB;;EAEJ,OAAOM,EAAE;AACX;AAgBA,OAAM,SAAUC,IAAIA,CAClB5D,IAAgB,EAChB6D,OAAe,EACf/C,OAAA,GAAuB,EAAE;EAEzB+C,OAAO,GAAGtE,IAAI,CAACuE,QAAQ,CAACD,OAAO,CAAC,EAAC;EACjC,MAAM9C,GAAG,GAAGD,OAAO,CAACC,GAAG;EACvB,IAAIZ,QAAQ,GAAGW,OAAO,CAACX,QAAQ;EAC/B,MAAM4D,cAAc,GAAGjD,OAAO,CAACkD,kBAAkB;EACjD,MAAMC,mBAAmB,GACvBF,cAAc,KAAK,QAAQ,IAC3BA,cAAc,KAAK,QAAQ,IAC3BA,cAAc,KAAK,KAAK;EAE1B;EACA,IAAIG,CAAC,GAAGpD,OAAO,CAACoD,CAAC;EACjB,IAAIA,CAAC,KAAK7D,SAAS,EAAE;IACnB6D,CAAC,GAAGlE,IAAI,CAACmE,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC;;EAGjC;EACA,MAAMC,GAAG,GAAGtD,OAAO,CAACmB,wBAAwB;EAC5C,IAAIC,WAAW,GAAGpB,OAAO,CAACoB,WAAW;EACrC,IAAIA,WAAW,IAAI,CAACe,KAAK,CAACC,OAAO,CAAChB,WAAW,CAAC,EAAE;IAC9CA,WAAW,GAAG,CAACA,WAAW,CAAC;;EAG7B;EACA,MAAMmC,iBAAiB,GAAGvD,OAAO,CAACG,UAAU;EAC5C,MAAMqD,cAAc,GAAGD,iBAAiB,KAAK,MAAM;EACnD,MAAMpD,UAAU,GAAGqD,cAAc,GAAG,OAAO,GAAGD,iBAAiB,IAAI,KAAK;EAExE1E,KAAK,CAACK,IAAI,CAAC;EAEXR,IAAI,CAACQ,IAAI,EAAE;IACT;IACA,WAAW,EAAE,UAAU;IACvB;IACA;IACA;IACAuE,OAAO,EAAEV,OAAO,IAAI/C,OAAO,CAAC0D,YAAY,GAAG,IAAI,GAAG;GACnD,CAAC;EAEF;EACA,MAAMC,WAAW,GAAGjF,IAAI,CAACQ,IAAI,EAAE,WAAW,CAAC;EAC3C,IAAIyB,QAAQ,GAAGW,UAAU,CAACqC,WAAW,CAAC;EACtC,IAAI,CAAChD,QAAQ,EAAE;IACbA,QAAQ,GAAG,EAAE;IACb,IAAI,CAACwC,mBAAmB,IAAI/B,WAAW,KAAK,CAACuC,WAAW,EAAE;MACxDjF,IAAI,CAACQ,IAAI,EAAE,WAAW,EAAE,GAAGyB,QAAQ,EAAE,CAAC;;;EAI1C,IAAIiD,aAAa;EACjB,IAAIvE,QAAQ,EAAE;IACZ;IACA,IAAI,OAAOA,QAAQ,KAAK,QAAQ,EAAE;MAChCA,QAAQ,GAAG;QAAEC,CAAC,EAAED;MAAQ,CAAE;;IAE5BuE,aAAa,GAAG5E,kBAAkB,CAACK,QAAe,EAAEH,IAAI,CAAC;GAC1D,MAAM;IACL0E,aAAa,GAAGrC,QAAQ,CAACsC,sBAAsB,EAAE;;EAGnD,IAAIhB,EAAE;EACN,IAAIiB,MAAM,GAAG,CAAC;EACd,IAAIC,UAAU;EACd,MAAMC,KAAK,GAAGjB,OAAO,CAACkB,KAAK,CAAC,IAAI,CAAC;EACjC,MAAMhC,YAAY,GAAG,EAAE;EACvB,MAAMiC,KAAK,GAAGF,KAAK,CAACxD,MAAM,GAAG,CAAC;EAE9B,KAAK,IAAIkC,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIwB,KAAK,EAAExB,CAAC,IAAI,CAAC,EAAE;IAClCG,EAAE,GAAG1C,UAAU;IACf,IAAIgE,aAAa,GAAG,QAAQ;IAC5B,MAAMrE,QAAQ,GAAGlB,gBAAgB,CAAC,OAAO,CAAoB;IAE7D,IAAI0D,WAAW;IACf,IAAI8B,IAAI,GAAGJ,KAAK,CAACtB,CAAC,CAAC;IACnB,IAAI0B,IAAI,EAAE;MACR,IAAIhD,WAAW,EAAE;QACf;QACA,MAAMrB,eAAe,GAAGtB,IAAI,CAAC4F,QAAQ,CAACD,IAAI,EAAEhD,WAAW,EAAE;UACvD0C,MAAM,EAAE,CAACA,MAAM;UACf3C,wBAAwB,EAAEmC;SAC3B,CAAC;QAEFhB,WAAW,GAAGzC,gBAAgB,CAACC,QAAQ,EAAEC,eAAe,EAAE;UACxDE,GAAG,EAAEyC,CAAC,KAAKwB,KAAK,IAAIjE,GAAG;UACvBC,QAAQ,EAAES,QAAQ;UAClBR,UAAU,EAAEqD,cAAc,GAAG,IAAI,GAAGrD,UAAU;UAC9CgB,wBAAwB,EAAEmC;SAC3B,CAAC;QAEF;QACA;QACA,MAAMX,WAAW,GAAGL,WAAW,CAACnC,UAAU;QAC1C,IAAIwC,WAAW,IAAIa,cAAc,IAAId,CAAC,KAAK,CAAC,EAAE;UAC5CG,EAAE,GAAGF,WAAW;;QAGlB,IAAID,CAAC,KAAK,CAAC,EAAE;UACXqB,UAAU,GAAGzB,WAAW,CAAClC,WAAW,GAAG,GAAG;;OAE7C,MAAM;QACL,IAAIH,GAAG,IAAIyC,CAAC,KAAKwB,KAAK,EAAE;UACtBE,IAAI,IAAInE,GAAG;;QAGbH,QAAQ,CAACiB,WAAW,GAAGqD,IAAI;;KAE9B,MAAM;MACL;MACA;MACA;MACAtE,QAAQ,CAACiB,WAAW,GAAG,GAAG;MAC1BoD,aAAa,IAAI,eAAe;MAEhC,MAAMG,aAAa,GAAGxE,QAAQ,CAACyE,KAAY;MAC3CD,aAAa,CAACE,WAAW,GAAG,CAAC;MAC7BF,aAAa,CAACG,aAAa,GAAG,CAAC;MAE/B,IAAIrD,WAAW,EAAE;QACfkB,WAAW,GAAG,EAAE;;;IAIpB,IAAIA,WAAW,EAAE;MACfL,YAAY,CAACyC,IAAI,CAACpC,WAAW,CAAC;;IAGhC,IAAII,CAAC,GAAG,CAAC,EAAE;MACT5C,QAAQ,CAAC6E,YAAY,CAAC,IAAI,EAAE9B,EAAE,CAAC;;IAGjC;IACA,IAAIH,CAAC,GAAG,CAAC,IAAIrD,QAAQ,EAAE;MACrBS,QAAQ,CAAC6E,YAAY,CAAC,GAAG,EAAEvB,CAAW,CAAC;;IAGzCtD,QAAQ,CAAC8E,SAAS,CAACC,OAAO,GAAGV,aAAa;IAC1CP,aAAa,CAACnC,WAAW,CAAC3B,QAAQ,CAAC;IACnCgE,MAAM,IAAIM,IAAI,CAAC5D,MAAM,GAAG,CAAC,EAAC;;EAG5B;EACA,IAAI2C,mBAAmB,EAAE;IACvB,IAAI/B,WAAW,EAAE;MACfyB,EAAE,GAAGd,WAAW,CACdkB,cAAwB,EACxBhB,YAAY,EACZtB,QAAQ,EACRR,UAAU,CACX;KACF,MAAM,IAAI8C,cAAc,KAAK,KAAK,EAAE;MACnC;MACAJ,EAAE,GAAG,OAAO;KACb,MAAM;MACL,IAAIiC,EAAE,EAAC;MACP,IAAIZ,KAAK,GAAG,CAAC,EAAE;QACbY,EAAE,GAAGxD,UAAU,CAACnB,UAAU,CAAC,IAAI,CAAC;QAChC2E,EAAE,IAAIZ,KAAK;QACX,IAAI,CAACxC,OAAO,CAACI,IAAI,CAAC3B,UAAU,CAAC,EAAE2E,EAAE,IAAInE,QAAQ;OAC9C,MAAM;QACL;QACAmE,EAAE,GAAG,CAAC;;MAER,QAAQ7B,cAAc;QACpB,KAAK,QAAQ;UACXJ,EAAE,GAAG,GAAG,GAAG,GAAGiC,EAAE,GAAG,CAAC,IAAI;UACxB;QACF,KAAK,QAAQ;UACXjC,EAAE,GAAG,GAAG,CAACiC,EAAE,GAAG,GAAG,IAAI;UACrB;QACF;UACE;;;GAGP,MAAM,IAAI7B,cAAc,KAAK,CAAC,EAAE;IAC/BJ,EAAE,GAAG,KAAK;GACX,MAAM,IAAII,cAAc,EAAE;IACzBJ,EAAE,GAAGI,cAAc;GACpB,MAAM;IACL;IACAJ,EAAE,GAAG,CAAC;IACN;IACA,IAAI3D,IAAI,CAACmE,YAAY,CAAC,GAAG,CAAC,IAAI,IAAI,EAAE;MAClCnE,IAAI,CAACyF,YAAY,CAAC,GAAG,EAAE,GAAGZ,UAAU,IAAI,OAAO,EAAE,CAAC;;;EAItD,MAAMgB,SAAS,GAAGnB,aAAa,CAACoB,UAAwB;EACxDD,SAAS,CAACJ,YAAY,CAAC,IAAI,EAAE9B,EAAE,CAAC;EAChC3D,IAAI,CAACuC,WAAW,CAACmC,aAAa,CAAC;AACjC;AAEA,SAASqB,SAASA,CAChBnC,IAAY,EACZoC,SAA6C,EAC7CjF,GAAW,EACXkF,MAAc;EAEd,MAAMC,KAAK,GAAa,EAAE;EAC1B,MAAMC,UAAU,GAAa,EAAE;EAE/B,IAAIH,SAAS,IAAI,IAAI,EAAE;IACrB,MAAMI,KAAK,GAAGxC,IAAI,CAACmB,KAAK,CAACiB,SAAS,CAAC;IACnCE,KAAK,CAACV,IAAI,CAAC,GAAGY,KAAK,CAAC;IACpB,IAAI,OAAOJ,SAAS,KAAK,QAAQ,EAAE;MACjC,KAAK,IAAIxC,CAAC,GAAG,CAAC,EAAE6C,CAAC,GAAGD,KAAK,CAAC9E,MAAM,GAAG,CAAC,EAAEkC,CAAC,GAAG6C,CAAC,EAAE7C,CAAC,IAAI,CAAC,EAAE;QACnD2C,UAAU,CAACX,IAAI,CAACQ,SAAS,CAAC;;KAE7B,MAAM;MACL,MAAMM,IAAI,GAAG1C,IAAI,CAAC2C,KAAK,CAAC,IAAIC,MAAM,CAACR,SAAS,EAAE,GAAG,CAAC,CAAC;MACnD,KAAK,IAAIxC,CAAC,GAAG,CAAC,EAAE6C,CAAC,GAAGD,KAAK,CAAC9E,MAAM,GAAG,CAAC,EAAEkC,CAAC,GAAG6C,CAAC,EAAE7C,CAAC,IAAI,CAAC,EAAE;QACnD2C,UAAU,CAACX,IAAI,CAACc,IAAI,GAAGA,IAAI,CAAC9C,CAAC,CAAC,GAAG,EAAE,CAAC;;;GAGzC,MAAM;IACL,IAAIiD,IAAI,GAAG,EAAE;IACb,KAAK,IAAIjD,CAAC,GAAG,CAAC,EAAE6C,CAAC,GAAGzC,IAAI,CAACtC,MAAM,EAAEkC,CAAC,GAAG6C,CAAC,EAAE7C,CAAC,IAAI,CAAC,EAAE;MAC9C,MAAMkD,IAAI,GAAG9C,IAAI,CAACJ,CAAC,CAAC;MAEpB,IAAIkD,IAAI,KAAK,GAAG,EAAE;QAChBR,KAAK,CAACV,IAAI,CAACiB,IAAI,CAAC;QAChBN,UAAU,CAACX,IAAI,CAAC,GAAG,CAAC;QACpBiB,IAAI,GAAG,EAAE;OACV,MAAM,IAAIC,IAAI,CAACH,KAAK,CAAC,cAAc,CAAC,EAAE;QACrC;QACA,IAAIE,IAAI,CAACnF,MAAM,EAAE;UACf4E,KAAK,CAACV,IAAI,CAACiB,IAAI,CAAC;UAChBN,UAAU,CAACX,IAAI,CAAC,EAAE,CAAC;;QAGrBU,KAAK,CAACV,IAAI,CAACkB,IAAI,CAAC;QAChBP,UAAU,CAACX,IAAI,CAAC,EAAE,CAAC;QAEnBiB,IAAI,GAAG,EAAE;OACV,MAAM;QACLA,IAAI,IAAIC,IAAI;;;IAIhB,IAAID,IAAI,CAACnF,MAAM,EAAE;MACf4E,KAAK,CAACV,IAAI,CAACiB,IAAI,CAAC;;;EAIpB;EACA,KAAK,IAAIjD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0C,KAAK,CAAC5E,MAAM,EAAEkC,CAAC,IAAI,CAAC,EAAE;IACxC,MAAMiD,IAAI,GAAGP,KAAK,CAAC1C,CAAC,CAAC;IACrB,IAAIiD,IAAI,CAACE,OAAO,CAAC5F,GAAG,CAAC,IAAI,CAAC,IAAI0F,IAAI,CAACnF,MAAM,GAAG,CAAC,EAAE;MAC7C,MAAM8E,KAAK,GAAGK,IAAI,CAAC1B,KAAK,CAAChE,GAAG,CAAC;MAC7B,KAAK,IAAIQ,CAAC,GAAG,CAAC,EAAEqF,CAAC,GAAGR,KAAK,CAAC9E,MAAM,GAAG,CAAC,EAAEC,CAAC,GAAGqF,CAAC,EAAErF,CAAC,IAAI,CAAC,EAAE;QACnD6E,KAAK,CAACS,MAAM,CAAC,CAAC,GAAGtF,CAAC,GAAG,CAAC,EAAE,CAAC,EAAER,GAAG,CAAC;;MAGjC,MAAM+F,MAAM,GAAGV,KAAK,CAACW,MAAM,CAAEC,IAAI,IAAKA,IAAI,KAAK,EAAE,CAAC;MAClDd,KAAK,CAACW,MAAM,CAACrD,CAAC,EAAE,CAAC,EAAE,GAAGsD,MAAM,CAAC;MAE7B,MAAMR,IAAI,GAAGQ,MAAM,CAACG,GAAG,CAAC,MAAM,EAAE,CAAC;MACjCX,IAAI,CAACY,GAAG,EAAE;MACVf,UAAU,CAACU,MAAM,CAACrD,CAAC,EAAE,CAAC,EAAE,GAAG8C,IAAI,CAAC;;;EAIpC;EACA,KAAK,IAAI9C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0C,KAAK,CAAC5E,MAAM,EAAEkC,CAAC,IAAI,CAAC,EAAE;IACxC,MAAMiD,IAAI,GAAGP,KAAK,CAAC1C,CAAC,CAAC;IACrB,MAAM2D,KAAK,GAAGV,IAAI,CAACW,MAAM,CAACnB,MAAM,CAAC;IACjC,IAAIkB,KAAK,GAAG,CAAC,IAAIA,KAAK,GAAGV,IAAI,CAACnF,MAAM,GAAG,CAAC,EAAE;MACxC4E,KAAK,CAACW,MAAM,CACVrD,CAAC,EACD,CAAC,EACDiD,IAAI,CAACY,SAAS,CAAC,CAAC,EAAEF,KAAK,GAAG,CAAC,CAAC,EAC5BV,IAAI,CAACY,SAAS,CAACF,KAAK,GAAG,CAAC,CAAC,CAC1B;MACDhB,UAAU,CAACU,MAAM,CAACrD,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;;;EAI/B,OAAO;IAAE0C,KAAK;IAAEC;EAAU,CAAE;AAC9B;AAEA,OAAM,SAAUmB,SAASA,CACvB1D,IAAY,EACZ2D,IAAU,EACVC,MAAA,GAAc,EAAE,EAChB1G,OAAA,GAOI,EAAE;EAEN,MAAM2G,KAAK,GAAGF,IAAI,CAACE,KAAK;EACxB,MAAMC,MAAM,GAAGH,IAAI,CAACG,MAAM;EAE1B,MAAMC,WAAW,GAAG7G,OAAO,CAAC6G,WAAW,IAAIjI,gBAAgB,CAAC,KAAK,CAAC;EAClE,MAAMkI,KAAK,GAAGlI,gBAAgB,CAAC,MAAM,CAAmB;EACxD,MAAMmI,KAAK,GAAGnI,gBAAgB,CAAC,OAAO,CAAoB;EAC1D,MAAMoI,KAAK,GAAGzF,QAAQ,CAACC,cAAc,CAAC,EAAE,CAAC;EAEzC9C,IAAI,CAACoI,KAAK,EAAEJ,MAAM,CAAC;EACnBI,KAAK,CAACrF,WAAW,CAACsF,KAAK,CAAC;EAExB;EACAD,KAAK,CAACvC,KAAK,CAAC0C,OAAO,GAAG,GAAG;EACzB;EACA;EACA;EACA;EACA;EACA;EACAH,KAAK,CAACvC,KAAK,CAACd,OAAO,GAAG,OAAO;EAC7BsD,KAAK,CAACxC,KAAK,CAACd,OAAO,GAAG,OAAO;EAE7BsD,KAAK,CAACtF,WAAW,CAACuF,KAAK,CAAC;EACxBH,WAAW,CAACpF,WAAW,CAACqF,KAAK,CAAC;EAE9B,MAAMI,YAAY,GAAGL,WAAW,CAACM,UAAU,IAAI,IAAI;EACnD,IAAID,YAAY,EAAE;IAChB3F,QAAQ,CAAC6F,IAAI,CAAC3F,WAAW,CAACoF,WAAW,CAAC;;EAGxC,MAAM5G,GAAG,GAAGD,OAAO,CAACC,GAAG,IAAI,IAAI;EAC/B,MAAMiF,SAAS,GAAGlF,OAAO,CAACkF,SAAS,IAAI,GAAG;EAC1C,MAAMC,MAAM,GAAGnF,OAAO,CAACmF,MAAM,GAAG,IAAIO,MAAM,CAAC1F,OAAO,CAACmF,MAAM,CAAC,GAAG,SAAS;EACtE,MAAMkC,SAAS,GAAGrH,OAAO,CAACqH,SAAS,KAAK,KAAK;EAE7C,MAAMC,IAAI,GAAG,EAAE;EACf,MAAMC,aAAa,GAAgC,EAAE;EACrD,IAAIvD,KAAK,GAAG,EAAE;EACd,IAAIwD,SAAS;EACb;EACA,IAAIrH,UAAU;EACd,IAAIsH,gBAAgB;EAEpB,MAAM;IAAErC,KAAK;IAAEC;EAAU,CAAE,GAAGJ,SAAS,CAACnC,IAAI,EAAE9C,OAAO,CAACkF,SAAS,EAAEjF,GAAG,EAAEkF,MAAM,CAAC;EAC7E,KACE,IAAIuC,SAAS,GAAG,CAAC,EAAEC,SAAS,GAAG,CAAC,EAAEC,SAAS,GAAGxC,KAAK,CAAC5E,MAAM,EAC1DkH,SAAS,GAAGE,SAAS,EACrBF,SAAS,IAAI,CAAC,EACd;IACA,MAAM/B,IAAI,GAAGP,KAAK,CAACsC,SAAS,CAAC;IAE7B;IACA,IAAI,CAAC/B,IAAI,EAAE;MACT;;IAGF;IACA,IAAIA,IAAI,KAAK1F,GAAG,EAAE;MAChBqH,IAAI,CAACK,SAAS,CAAC,GAAG,IAAI;MACtB;MACAA,SAAS,IAAI,CAAC;MACd3D,KAAK,CAAC2D,SAAS,CAAC,GAAG,EAAE;MACrB;;IAGF,IAAI3D,KAAK,CAAC2D,SAAS,CAAC,IAAI,IAAI,EAAE;MAC5BF,gBAAgB,GAAGpC,UAAU,CAACqC,SAAS,GAAG,CAAC,CAAC,IAAI,EAAE;MAClDV,KAAK,CAACa,IAAI,GAAG,GAAG7D,KAAK,CAAC2D,SAAS,CAAC,GAAGF,gBAAgB,GAAG9B,IAAI,EAAE;KAC7D,MAAM;MACLqB,KAAK,CAACa,IAAI,GAAGlC,IAAI;;IAGnB,IAAIoB,KAAK,CAACe,qBAAqB,EAAE,IAAInB,KAAK,EAAE;MAC1C;MACA3C,KAAK,CAAC2D,SAAS,CAAC,GAAGX,KAAK,CAACa,IAAI;MAC7BN,aAAa,CAACI,SAAS,CAAC,GAAGtC,UAAU,CAACqC,SAAS,CAAC;MAEhD;MACA,IAAIF,SAAS,EAAE;QACbF,IAAI,CAACK,SAAS,CAAC,GAAG,IAAI;QACtBA,SAAS,IAAI,CAAC;QACdH,SAAS,GAAG,CAAC;;KAEhB,MAAM;MACL,IAAIH,SAAS,EAAE;QACb;QACA,IAAI,CAACrD,KAAK,CAAC2D,SAAS,CAAC,IAAIH,SAAS,EAAE;UAClC,MAAMO,WAAW,GAAG,CAAC,CAACP,SAAS;UAC/B,MAAMQ,WAAW,GAAGrC,IAAI,CAACnF,MAAM,KAAK,CAAC;UAErCgH,SAAS,GAAG7B,IAAI,CAACnF,MAAM,GAAG,CAAC;UAE3B,IAAIuH,WAAW,IAAIC,WAAW,EAAE;YAC9B;YACA,IAAIA,WAAW,EAAE;cACf,IAAI,CAAChE,KAAK,CAAC2D,SAAS,CAAC,EAAE;gBACrB;gBACA3D,KAAK,GAAG,EAAE;gBACV;;cAGF;cACA;cAEA;cACAoB,KAAK,CAACW,MAAM,CAAC2B,SAAS,EAAE,CAAC,EAAE/B,IAAI,GAAGP,KAAK,CAACsC,SAAS,GAAG,CAAC,CAAC,CAAC;cACvDrC,UAAU,CAACU,MAAM,CAAC2B,SAAS,GAAG,CAAC,EAAE,CAAC,CAAC;cACnCJ,IAAI,CAACK,SAAS,CAAC,GAAG,IAAI;cAEtBA,SAAS,IAAI,CAAC;cACdC,SAAS,IAAI,CAAC;cACdF,SAAS,IAAI,CAAC;cAEd;;YAGF;YACAtC,KAAK,CAACsC,SAAS,CAAC,GAAG/B,IAAI,CAACY,SAAS,CAAC,CAAC,EAAEiB,SAAS,CAAC;YAC/CpC,KAAK,CAACsC,SAAS,GAAG,CAAC,CAAC,GAClB/B,IAAI,CAACY,SAAS,CAACiB,SAAS,CAAC,GAAGpC,KAAK,CAACsC,SAAS,GAAG,CAAC,CAAC;WACnD,MAAM;YACL;YACAtC,KAAK,CAACW,MAAM,CACV2B,SAAS,EACT,CAAC,EACD/B,IAAI,CAACY,SAAS,CAAC,CAAC,EAAEiB,SAAS,CAAC,EAC5B7B,IAAI,CAACY,SAAS,CAACiB,SAAS,CAAC,CAC1B;YACDnC,UAAU,CAACU,MAAM,CAAC2B,SAAS,EAAE,CAAC,EAAE,EAAE,CAAC;YACnCE,SAAS,IAAI,CAAC;YAEd;YACA,IAAID,SAAS,IAAI,CAACL,IAAI,CAACK,SAAS,GAAG,CAAC,CAAC,EAAE;cACrCA,SAAS,IAAI,CAAC;;;UAIlBD,SAAS,IAAI,CAAC;UACd;;OAEH,MAAM,IAAI,CAAC1D,KAAK,CAAC2D,SAAS,CAAC,EAAE;QAC5B3D,KAAK,CAAC2D,SAAS,CAAC,GAAGhC,IAAI;QACvB2B,IAAI,CAACK,SAAS,CAAC,GAAG,IAAI;QACtBA,SAAS,IAAI,CAAC;QACd;;MAGFA,SAAS,IAAI,CAAC;MACdD,SAAS,IAAI,CAAC;;IAGhB;IACA,IAAId,MAAM,IAAI,IAAI,EAAE;MAClB;MACA,IAAIzG,UAAU,IAAI,IAAI,EAAE;QACtB,IAAI8H,WAAW;QAEf;QACA,IAAIvB,MAAM,CAACvG,UAAU,KAAK,MAAM,EAAE;UAChC8H,WAAW,GAAG;YAAEC,KAAK,EAAE,GAAG;YAAEC,IAAI,EAAE;UAAI,CAAE;SACzC,MAAM;UACLF,WAAW,GAAGzJ,SAAS,CAAC4J,eAAe,CAAC1B,MAAM,CAACvG,UAAU,EAAE,CACzD,IAAI,CACL,CAAC,IAAI;YACJ+H,KAAK,EAAE,CAAC;YACRC,IAAI,EAAE;WACP;;QAGHhI,UAAU,GAAG8H,WAAW,CAACC,KAAK;QAC9B,IAAID,WAAW,CAACE,IAAI,KAAK,IAAI,EAAE;UAC7B,IAAIpJ,QAAQ,CAACsJ,UAAU,EAAE;YACvBlI,UAAU,IAAI4G,KAAK,CAACuB,OAAO,EAAE,CAAC1B,MAAM;WACrC,MAAM;YACLzG,UAAU,IAAI2G,KAAK,CAACwB,OAAO,EAAE,CAAC1B,MAAM;;;;MAK1C,IAAIzG,UAAU,GAAG6D,KAAK,CAACxD,MAAM,GAAGoG,MAAM,EAAE;QACtC;QACA,MAAM2B,aAAa,GAAGC,IAAI,CAACC,KAAK,CAAC7B,MAAM,GAAGzG,UAAU,CAAC,GAAG,CAAC;QACzD,MAAMuI,QAAQ,GAAG1E,KAAK,CAACuE,aAAa,CAAC;QACrC,MAAMI,YAAY,GAAG3E,KAAK,CAACuE,aAAa,GAAG,CAAC,CAAC;QAE7CvE,KAAK,CAAC+B,MAAM,CAACwC,aAAa,GAAG,CAAC,CAAC;QAE/B,IAAIG,QAAQ,IAAI,IAAI,EAAE;UACpB;;QAGF;QACA,IAAIE,QAAQ,GAAG5I,OAAO,CAAC4I,QAAQ;QAC/B,IAAI,CAACA,QAAQ,EAAE;UACb;;QAGF,IAAI,OAAOA,QAAQ,KAAK,QAAQ,EAAE;UAChCA,QAAQ,GAAG,QAAQ;;QAGrB,IAAIC,YAAY,GAAGH,QAAQ;QAC3B,IAAIC,YAAY,IAAItB,SAAS,EAAE;UAC7BwB,YAAY,IAAIpB,gBAAgB,GAAGkB,YAAY;;QAGjD,IAAIG,aAAa,GAAGD,YAAY,CAACrI,MAAM;QACvC,IAAIuI,aAAa;QACjB,IAAIC,QAAQ;QAEZ,GAAG;UACDA,QAAQ,GAAGH,YAAY,CAACC,aAAa,CAAC;UACtCC,aAAa,GAAGF,YAAY,CAACtC,SAAS,CAAC,CAAC,EAAEuC,aAAa,CAAC;UACxD,IAAI,CAACE,QAAQ,EAAE;YACbD,aAAa,IAAIxB,aAAa,CAACgB,aAAa,CAAC;WAC9C,MAAM,IAAIS,QAAQ,CAACvD,KAAK,CAACP,SAAS,CAAC,EAAE;YACpC6D,aAAa,IAAIC,QAAQ;;UAE3BD,aAAa,IAAIH,QAAQ;UACzB5B,KAAK,CAACa,IAAI,GAAGkB,aAAa;UAC1B,IAAIhC,KAAK,CAACe,qBAAqB,EAAE,IAAInB,KAAK,EAAE;YAC1C3C,KAAK,CAACuE,aAAa,CAAC,GAAGQ,aAAa;YACpC;;UAEFD,aAAa,IAAI,CAAC;SACnB,QAAQA,aAAa,IAAI,CAAC;QAE3B;;;;EAKN,IAAI5B,YAAY,EAAE;IAChBpI,MAAM,CAAC+H,WAAW,CAAC;GACpB,MAAM;IACL/H,MAAM,CAACgI,KAAK,CAAC;;EAGf,OAAO9C,KAAK,CAAC3C,IAAI,CAACpB,GAAG,CAAC;AACxB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}