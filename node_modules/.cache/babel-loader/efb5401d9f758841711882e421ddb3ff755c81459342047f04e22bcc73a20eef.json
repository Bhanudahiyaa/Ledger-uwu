{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { rgb2arr } from '@antv/l7-utils';\nimport BaseModel from \"../../core/BaseModel\";\nimport { LinearDir, TextureBlend } from \"../../core/interface\";\nimport { LineTriangulation } from \"../../core/triangulation\";\n/* babel-plugin-inline-import '../shaders/line/line_frag.glsl' */\nconst line_frag = \"// #extension GL_OES_standard_derivatives : enable\\n#define Animate 0.0\\n#define LineTexture 1.0\\n\\nuniform sampler2D u_texture;\\nlayout(std140) uniform commonUniorm {\\n  vec4 u_animate: [ 1., 2., 1.0, 0.2 ];\\n  vec4 u_dash_array;\\n  vec4 u_blur;\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  vec2 u_textSize;\\n  float u_icon_step: 100;\\n  float u_heightfixed: 0.0;\\n  float u_vertexScale: 1.0;\\n  float u_raisingHeight: 0.0;\\n  float u_strokeWidth: 0.0;\\n  float u_textureBlend;\\n  float u_line_texture;\\n  float u_linearDir: 1.0;\\n  float u_linearColor: 0;\\n  float u_time;\\n};\\n\\nin vec4 v_color;\\nin vec4 v_stroke;\\n// dash\\nin vec4 v_dash_array;\\nin float v_d_distance_ratio;\\nin vec2 v_iconMapUV;\\nin vec4 v_texture_data;\\n\\nout vec4 outputColor;\\n#pragma include \\\"picking\\\"\\n\\n// [animate, duration, interval, trailLength],\\nvoid main() {\\n  if(u_dash_array!=vec4(0.0)){\\n    float dashLength = mod(v_d_distance_ratio, v_dash_array.x + v_dash_array.y + v_dash_array.z + v_dash_array.w);\\n    if(!(dashLength < v_dash_array.x || (dashLength > (v_dash_array.x + v_dash_array.y) && dashLength <  v_dash_array.x + v_dash_array.y + v_dash_array.z))) {\\n      // \\u865A\\u7EBF\\u90E8\\u5206\\n      discard;\\n    };\\n  }\\n  float animateSpeed = 0.0; // \\u8FD0\\u52A8\\u901F\\u5EA6\\n  float d_distance_ratio = v_texture_data.r; // \\u5F53\\u524D\\u70B9\\u4F4D\\u8DDD\\u79BB\\u5360\\u7EBF\\u603B\\u957F\\u7684\\u6BD4\\u4F8B\\n  if(u_linearDir < 1.0) {\\n    d_distance_ratio = v_texture_data.a;\\n  }\\n  if(u_linearColor == 1.0) { // \\u4F7F\\u7528\\u6E10\\u53D8\\u989C\\u8272\\n    outputColor = mix(u_sourceColor, u_targetColor, d_distance_ratio);\\n    outputColor.a *= v_color.a;\\n  } else { // \\u4F7F\\u7528 color \\u65B9\\u6CD5\\u4F20\\u5165\\u7684\\u989C\\u8272\\n     outputColor = v_color;\\n  }\\n  // anti-alias\\n  // float blur = 1.0 - smoothstep(u_blur, 1., length(v_normal.xy));\\n  if(u_animate.x == Animate) {\\n      animateSpeed = u_time / u_animate.y;\\n       float alpha =1.0 - fract( mod(1.0- d_distance_ratio, u_animate.z)* (1.0/ u_animate.z) + animateSpeed);\\n      alpha = (alpha + u_animate.w -1.0) / u_animate.w;\\n      alpha = smoothstep(0., 1., alpha);\\n      outputColor.a *= alpha;\\n  }\\n\\n  if(u_line_texture == LineTexture) { // while load texture\\n    float aDistance = v_texture_data.g;      // \\u5F53\\u524D\\u9876\\u70B9\\u7684\\u8DDD\\u79BB\\n    float d_texPixelLen = v_texture_data.b;  // \\u8D34\\u56FE\\u7684\\u50CF\\u7D20\\u957F\\u5EA6\\uFF0C\\u6839\\u636E\\u5730\\u56FE\\u5C42\\u7EA7\\u7F29\\u653E\\n    float u = fract(mod(aDistance, d_texPixelLen)/d_texPixelLen - animateSpeed);\\n    float v = v_texture_data.a;  // \\u7EBF\\u56FE\\u5C42\\u8D34\\u56FE\\u90E8\\u5206\\u7684 v \\u5750\\u6807\\u503C\\n\\n    // v = max(smoothstep(0.95, 1.0, v), v);\\n    vec2 uv= v_iconMapUV / u_textSize + vec2(u, v) / u_textSize * 64.;\\n     vec4 pattern = texture(SAMPLER_2D(u_texture), uv);\\n\\n    if(u_textureBlend == 0.0) { // normal\\n      pattern.a = 0.0;\\n      outputColor += pattern;\\n    } else { // replace\\n        pattern.a *= v_color.a;\\n        if(outputColor.a <= 0.0) {\\n          pattern.a = 0.0;\\n        }\\n        outputColor = pattern;\\n    }\\n  } \\n\\n  float v = v_texture_data.a;\\n  float strokeWidth = min(0.5, u_strokeWidth);\\n  // \\u7ED8\\u5236 border\\n  if(strokeWidth > 0.01) {\\n    float borderOuterWidth = strokeWidth / 2.0;\\n\\n\\n    if(v >= 1.0 - strokeWidth || v <= strokeWidth) {\\n      if(v > strokeWidth) { // \\u5916\\u4FA7\\n        float linear = smoothstep(0.0, 1.0, (v - (1.0 - strokeWidth))/strokeWidth);\\n        //  float linear = step(0.0, (v - (1.0 - borderWidth))/borderWidth);\\n        outputColor.rgb = mix(outputColor.rgb, v_stroke.rgb, linear);\\n      } else if(v <= strokeWidth) {\\n        float linear = smoothstep(0.0, 1.0, v/strokeWidth);\\n        outputColor.rgb = mix(v_stroke.rgb, outputColor.rgb, linear);\\n      }\\n    }\\n\\n    if(v < borderOuterWidth) {\\n      outputColor.a = mix(0.0, outputColor.a, v/borderOuterWidth);\\n    } else if(v > 1.0 - borderOuterWidth) {\\n      outputColor.a = mix(outputColor.a, 0.0, (v - (1.0 - borderOuterWidth))/borderOuterWidth);\\n    }\\n  }\\n\\n  // blur\\n  float blurV = v_texture_data.a;\\n  if(blurV < 0.5) {\\n    outputColor.a *= mix(u_blur.r, u_blur.g, blurV/0.5);\\n  } else {\\n    outputColor.a *= mix(u_blur.g, u_blur.b, (blurV - 0.5)/0.5);\\n  }\\n  \\n  outputColor = filterColor(outputColor);\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/line/line_vert.glsl' */\nconst line_vert = \"#define Animate (0.0)\\n\\nlayout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in vec2 a_Size;\\nlayout(location = ATTRIBUTE_LOCATION_DISTANCE_INDEX) in vec3 a_DistanceAndIndexAndMiter;\\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec4 a_Normal_Total_Distance;\\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_iconMapUV;\\n\\nlayout(std140) uniform commonUniorm {\\n  vec4 u_animate: [ 1., 2., 1.0, 0.2 ];\\n  vec4 u_dash_array;\\n  vec4 u_blur;\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  vec2 u_textSize;\\n  float u_icon_step: 100;\\n  float u_heightfixed: 0.0;\\n  float u_vertexScale: 1.0;\\n  float u_raisingHeight: 0.0;\\n  float u_strokeWidth: 0.0;\\n  float u_textureBlend;\\n  float u_line_texture;\\n  float u_linearDir: 1.0;\\n  float u_linearColor: 0;\\n  float u_time;\\n};\\n\\nout vec4 v_color;\\nout vec4 v_stroke;\\n//dash\\nout vec4 v_dash_array;\\nout float v_d_distance_ratio;\\n// texV \\u7EBF\\u56FE\\u5C42 - \\u8D34\\u56FE\\u90E8\\u5206\\u7684 v \\u5750\\u6807\\uFF08\\u7EBF\\u7684\\u5BBD\\u5EA6\\u65B9\\u5411\\uFF09\\nout vec2 v_iconMapUV;\\nout vec4 v_texture_data;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  vec2 a_DistanceAndIndex = a_DistanceAndIndexAndMiter.xy;\\n  float a_Miter = a_DistanceAndIndexAndMiter.z;\\n  vec3 a_Normal = a_Normal_Total_Distance.xyz;\\n  float a_Total_Distance = a_Normal_Total_Distance.w;\\n  //dash\\u8F93\\u51FA\\n  v_dash_array = pow(2.0, 20.0 - u_Zoom) * u_dash_array / a_Total_Distance;\\n  v_d_distance_ratio = a_DistanceAndIndex.x / a_Total_Distance;\\n\\n  // cal style mapping - \\u6570\\u636E\\u7EB9\\u7406\\u6620\\u5C04\\u90E8\\u5206\\u7684\\u8BA1\\u7B97\\n  float d_texPixelLen; // \\u8D34\\u56FE\\u7684\\u50CF\\u7D20\\u957F\\u5EA6\\uFF0C\\u6839\\u636E\\u5730\\u56FE\\u5C42\\u7EA7\\u7F29\\u653E\\n  v_iconMapUV = a_iconMapUV;\\n  d_texPixelLen = project_float_pixel(u_icon_step);\\n\\n  v_color = a_Color;\\n  v_color.a *= opacity;\\n  v_stroke = stroke;\\n\\n  vec3 size = a_Miter * setPickingSize(a_Size.x) * a_Normal;\\n\\n  vec2 offset = project_pixel(size.xy);\\n\\n  float lineDistance = a_DistanceAndIndex.x;\\n  float currentLinePointRatio = lineDistance / a_Total_Distance;\\n\\n  float lineOffsetWidth = length(offset + offset * sign(a_Miter)); // \\u7EBF\\u6A2A\\u5411\\u504F\\u79FB\\u7684\\u8DDD\\u79BB\\uFF08\\u5411\\u4E24\\u4FA7\\u504F\\u79FB\\u7684\\u548C\\uFF09\\n  float linePixelSize = project_pixel(a_Size.x) * 2.0; // \\u5B9A\\u70B9\\u4F4D\\u7F6E\\u504F\\u79FB\\uFF0C\\u6309\\u5730\\u56FE\\u7B49\\u7EA7\\u7F29\\u653E\\u540E\\u7684\\u8DDD\\u79BB \\u5355\\u4FA7 * 2\\n  float texV = lineOffsetWidth / linePixelSize; // \\u7EBF\\u56FE\\u5C42\\u8D34\\u56FE\\u90E8\\u5206\\u7684 v \\u5750\\u6807\\u503C\\n\\n  v_texture_data = vec4(currentLinePointRatio, lineDistance, d_texPixelLen, texV);\\n  // \\u8BBE\\u7F6E\\u6570\\u636E\\u96C6\\u7684\\u53C2\\u6570\\n\\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0, 1.0), a_Position64Low);\\n\\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, a_Size.y, 1.0));\\n\\n  float h = float(a_Position.z) * u_vertexScale; // \\u7EBF\\u9876\\u70B9\\u7684\\u9AD8\\u5EA6 - \\u517C\\u5BB9\\u4E0D\\u5B58\\u5728\\u7B2C\\u4E09\\u4E2A\\u6570\\u503C\\u7684\\u60C5\\u51B5 vertex height\\n  float lineHeight = a_Size.y; // size \\u7B2C\\u4E8C\\u4E2A\\u53C2\\u6570\\u4EE3\\u8868\\u7684\\u9AD8\\u5EA6 [linewidth, lineheight]\\n\\n  // \\u517C\\u5BB9 mapbox \\u5728\\u7EBF\\u9AD8\\u5EA6\\u4E0A\\u7684\\u6548\\u679C\\u8868\\u73B0\\u57FA\\u672C\\u4E00\\u81F4\\n  if (\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\\n  ) {\\n    // mapbox\\n    // \\u4FDD\\u6301\\u9AD8\\u5EA6\\u76F8\\u5BF9\\u4E0D\\u53D8\\n    float mapboxZoomScale = 4.0 / pow(2.0, 21.0 - u_Zoom);\\n    h *= mapboxZoomScale;\\n    h += u_raisingHeight * mapboxZoomScale;\\n    if (u_heightfixed > 0.0) {\\n      lineHeight *= mapboxZoomScale;\\n    }\\n  }\\n\\n  gl_Position = project_common_position_to_clipspace(\\n    vec4(project_pos.xy + offset, lineHeight + h, 1.0)\\n  );\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\nexport default class LineModel extends BaseModel {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"textureEventFlag\", false);\n    _defineProperty(this, \"texture\", this.createTexture2D({\n      data: new Uint8Array([0, 0, 0, 0]),\n      width: 1,\n      height: 1\n    }));\n    _defineProperty(this, \"updateTexture\", () => {\n      const {\n        createTexture2D\n      } = this.rendererService;\n      if (this.textures.length === 0) {\n        this.textures = [this.texture];\n      }\n      if (this.texture) {\n        this.texture.update({\n          data: this.iconService.getCanvas()\n        });\n        this.layer.render();\n        return;\n      }\n      this.texture = createTexture2D({\n        data: this.iconService.getCanvas(),\n        mag: gl.NEAREST,\n        min: gl.NEAREST,\n        premultiplyAlpha: false,\n        width: 1024,\n        height: this.iconService.canvasHeight || 128\n      });\n    });\n  }\n  get attributeLocation() {\n    return Object.assign(super.attributeLocation, {\n      MAX: super.attributeLocation.MAX,\n      SIZE: 9,\n      DISTANCE_INDEX: 10,\n      NORMAL: 11,\n      UV: 12\n    });\n  }\n  getCommonUniformsInfo() {\n    const {\n      sourceColor,\n      targetColor,\n      textureBlend = 'normal',\n      lineType = 'solid',\n      dashArray = [10, 5, 0, 0],\n      lineTexture = false,\n      iconStep = 100,\n      vertexHeightScale = 20.0,\n      strokeWidth = 0.0,\n      raisingHeight = 0,\n      heightfixed = false,\n      linearDir = LinearDir.VERTICAL,\n      // 默认纵向\n      blur = [1, 1, 1, 0]\n    } = this.layer.getLayerConfig();\n    let u_dash_array = dashArray;\n    if (lineType !== 'dash') {\n      u_dash_array = [0, 0, 0, 0];\n    }\n    if (u_dash_array.length === 2) {\n      u_dash_array.push(0, 0);\n    }\n    if (this.rendererService.getDirty() && this.texture) {\n      var _this$texture;\n      (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.bind();\n    }\n    const {\n      animateOption\n    } = this.layer.getLayerConfig();\n    // 转化渐变色\n    let useLinearColor = 0; // 默认不生效\n    let sourceColorArr = [0, 0, 0, 0];\n    let targetColorArr = [0, 0, 0, 0];\n    if (sourceColor && targetColor) {\n      sourceColorArr = rgb2arr(sourceColor);\n      targetColorArr = rgb2arr(targetColor);\n      useLinearColor = 1;\n    }\n    const commonOptions = {\n      u_animate: this.animateOption2Array(animateOption),\n      u_dash_array,\n      u_blur: blur,\n      u_sourceColor: sourceColorArr,\n      u_targetColor: targetColorArr,\n      u_textSize: [1024, this.iconService.canvasHeight || 128],\n      u_icon_step: iconStep,\n      // 是否固定高度\n      u_heightfixed: Number(heightfixed),\n      // 顶点高度 scale\n      u_vertexScale: vertexHeightScale,\n      u_raisingHeight: Number(raisingHeight),\n      // line border 参数\n      u_strokeWidth: strokeWidth,\n      u_textureBlend: textureBlend === TextureBlend.NORMAL ? 0.0 : 1.0,\n      u_line_texture: lineTexture ? 1.0 : 0.0,\n      // 传入线的标识\n      u_linearDir: linearDir === LinearDir.VERTICAL ? 1.0 : 0.0,\n      u_linearColor: useLinearColor,\n      u_time: this.layer.getLayerAnimateTime() || 0\n    };\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  // public getAnimateUniforms(): IModelUniform {\n  //   const { animateOption } = this.layer.getLayerConfig() as ILayerConfig;\n  //   return {\n  //     u_animate: this.animateOption2Array(animateOption as IAnimateOption),\n  //     u_time: this.layer.getLayerAnimateTime(),\n  //   };\n  // }\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.initUniformsBuffer();\n      // this.updateTexture();\n      // this.iconService.on('imageUpdate', this.updateTexture);\n      if (!_this.textureEventFlag) {\n        _this.textureEventFlag = true;\n        _this.updateTexture();\n        _this.iconService.on('imageUpdate', _this.updateTexture);\n      }\n      return _this.buildModels();\n    })();\n  }\n  clearModels() {\n    var _this$texture2;\n    (_this$texture2 = this.texture) === null || _this$texture2 === void 0 || _this$texture2.destroy();\n    this.iconService.off('imageUpdate', this.updateTexture);\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        depth = false\n      } = _this2.layer.getLayerConfig();\n      const {\n        frag,\n        vert,\n        type\n      } = _this2.getShaders();\n      _this2.layer.triangulation = LineTriangulation;\n      const model = yield _this2.layer.buildLayerModel({\n        moduleName: 'line' + type,\n        vertexShader: vert,\n        fragmentShader: frag,\n        triangulation: LineTriangulation,\n        defines: _this2.getDefines(),\n        inject: _this2.getInject(),\n        depth: {\n          enable: depth\n        }\n      });\n      return [model];\n    })();\n  }\n\n  /**\n   * 根据参数获取不同的 shader 代码\n   * @returns\n   */\n  getShaders() {\n    return {\n      frag: line_frag,\n      vert: line_vert,\n      type: ''\n    };\n  }\n  registerBuiltinAttributes() {\n    // 注册 Position 属性 64 位地位部分，经纬度数据开启双精度，避免大于 20层级以上出现数据偏移\n    this.registerPosition64LowAttribute();\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'distanceAndIndex',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_DistanceAndIndexAndMiter',\n        shaderLocation: this.attributeLocation.DISTANCE_INDEX,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.STATIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        update: (feature, featureIdx, vertex, attributeIdx, normal, vertexIndex) => {\n          return vertexIndex === undefined ? [vertex[3], 10, vertex[4]] : [vertex[3], vertexIndex, vertex[4]];\n        }\n      }\n    });\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Size',\n        shaderLocation: this.attributeLocation.SIZE,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 2,\n        update: feature => {\n          const {\n            size = 1\n          } = feature;\n          return Array.isArray(size) ? [size[0], size[1]] : [size, 0];\n        }\n      }\n    });\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'normal_total_distance',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Normal_Total_Distance',\n        shaderLocation: this.attributeLocation.NORMAL,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.STATIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 4,\n        update: (feature, featureIdx, vertex, attributeIdx, normal) => {\n          return [...normal, vertex[5]];\n        }\n      }\n    });\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'uv',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_iconMapUV',\n        shaderLocation: this.attributeLocation.UV,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 2,\n        update: feature => {\n          const iconMap = this.iconService.getIconMap();\n          const {\n            texture\n          } = feature;\n          const {\n            x,\n            y\n          } = iconMap[texture] || {\n            x: 0,\n            y: 0\n          };\n          return [x, y];\n        }\n      }\n    });\n  }\n}","map":{"version":3,"names":["_asyncToGenerator","_defineProperty","AttributeType","gl","rgb2arr","BaseModel","LinearDir","TextureBlend","LineTriangulation","line_frag","line_vert","LineModel","constructor","args","createTexture2D","data","Uint8Array","width","height","rendererService","textures","length","texture","update","iconService","getCanvas","layer","render","mag","NEAREST","min","premultiplyAlpha","canvasHeight","attributeLocation","Object","assign","MAX","SIZE","DISTANCE_INDEX","NORMAL","UV","getCommonUniformsInfo","sourceColor","targetColor","textureBlend","lineType","dashArray","lineTexture","iconStep","vertexHeightScale","strokeWidth","raisingHeight","heightfixed","linearDir","VERTICAL","blur","getLayerConfig","u_dash_array","push","getDirty","_this$texture","bind","animateOption","useLinearColor","sourceColorArr","targetColorArr","commonOptions","u_animate","animateOption2Array","u_blur","u_sourceColor","u_targetColor","u_textSize","u_icon_step","u_heightfixed","Number","u_vertexScale","u_raisingHeight","u_strokeWidth","u_textureBlend","u_line_texture","u_linearDir","u_linearColor","u_time","getLayerAnimateTime","commonBufferInfo","getUniformsBufferInfo","initModels","_this","initUniformsBuffer","textureEventFlag","updateTexture","on","buildModels","clearModels","_this$texture2","destroy","off","_this2","depth","frag","vert","type","getShaders","triangulation","model","buildLayerModel","moduleName","vertexShader","fragmentShader","defines","getDefines","inject","getInject","enable","registerBuiltinAttributes","registerPosition64LowAttribute","styleAttributeService","registerStyleAttribute","name","Attribute","descriptor","shaderLocation","buffer","usage","STATIC_DRAW","FLOAT","size","feature","featureIdx","vertex","attributeIdx","normal","vertexIndex","undefined","DYNAMIC_DRAW","Array","isArray","iconMap","getIconMap","x","y"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/l7-layers/es/line/models/line.js"],"sourcesContent":["import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { rgb2arr } from '@antv/l7-utils';\nimport BaseModel from \"../../core/BaseModel\";\nimport { LinearDir, TextureBlend } from \"../../core/interface\";\nimport { LineTriangulation } from \"../../core/triangulation\";\n/* babel-plugin-inline-import '../shaders/line/line_frag.glsl' */\nconst line_frag = \"// #extension GL_OES_standard_derivatives : enable\\n#define Animate 0.0\\n#define LineTexture 1.0\\n\\nuniform sampler2D u_texture;\\nlayout(std140) uniform commonUniorm {\\n  vec4 u_animate: [ 1., 2., 1.0, 0.2 ];\\n  vec4 u_dash_array;\\n  vec4 u_blur;\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  vec2 u_textSize;\\n  float u_icon_step: 100;\\n  float u_heightfixed: 0.0;\\n  float u_vertexScale: 1.0;\\n  float u_raisingHeight: 0.0;\\n  float u_strokeWidth: 0.0;\\n  float u_textureBlend;\\n  float u_line_texture;\\n  float u_linearDir: 1.0;\\n  float u_linearColor: 0;\\n  float u_time;\\n};\\n\\nin vec4 v_color;\\nin vec4 v_stroke;\\n// dash\\nin vec4 v_dash_array;\\nin float v_d_distance_ratio;\\nin vec2 v_iconMapUV;\\nin vec4 v_texture_data;\\n\\nout vec4 outputColor;\\n#pragma include \\\"picking\\\"\\n\\n// [animate, duration, interval, trailLength],\\nvoid main() {\\n  if(u_dash_array!=vec4(0.0)){\\n    float dashLength = mod(v_d_distance_ratio, v_dash_array.x + v_dash_array.y + v_dash_array.z + v_dash_array.w);\\n    if(!(dashLength < v_dash_array.x || (dashLength > (v_dash_array.x + v_dash_array.y) && dashLength <  v_dash_array.x + v_dash_array.y + v_dash_array.z))) {\\n      // \\u865A\\u7EBF\\u90E8\\u5206\\n      discard;\\n    };\\n  }\\n  float animateSpeed = 0.0; // \\u8FD0\\u52A8\\u901F\\u5EA6\\n  float d_distance_ratio = v_texture_data.r; // \\u5F53\\u524D\\u70B9\\u4F4D\\u8DDD\\u79BB\\u5360\\u7EBF\\u603B\\u957F\\u7684\\u6BD4\\u4F8B\\n  if(u_linearDir < 1.0) {\\n    d_distance_ratio = v_texture_data.a;\\n  }\\n  if(u_linearColor == 1.0) { // \\u4F7F\\u7528\\u6E10\\u53D8\\u989C\\u8272\\n    outputColor = mix(u_sourceColor, u_targetColor, d_distance_ratio);\\n    outputColor.a *= v_color.a;\\n  } else { // \\u4F7F\\u7528 color \\u65B9\\u6CD5\\u4F20\\u5165\\u7684\\u989C\\u8272\\n     outputColor = v_color;\\n  }\\n  // anti-alias\\n  // float blur = 1.0 - smoothstep(u_blur, 1., length(v_normal.xy));\\n  if(u_animate.x == Animate) {\\n      animateSpeed = u_time / u_animate.y;\\n       float alpha =1.0 - fract( mod(1.0- d_distance_ratio, u_animate.z)* (1.0/ u_animate.z) + animateSpeed);\\n      alpha = (alpha + u_animate.w -1.0) / u_animate.w;\\n      alpha = smoothstep(0., 1., alpha);\\n      outputColor.a *= alpha;\\n  }\\n\\n  if(u_line_texture == LineTexture) { // while load texture\\n    float aDistance = v_texture_data.g;      // \\u5F53\\u524D\\u9876\\u70B9\\u7684\\u8DDD\\u79BB\\n    float d_texPixelLen = v_texture_data.b;  // \\u8D34\\u56FE\\u7684\\u50CF\\u7D20\\u957F\\u5EA6\\uFF0C\\u6839\\u636E\\u5730\\u56FE\\u5C42\\u7EA7\\u7F29\\u653E\\n    float u = fract(mod(aDistance, d_texPixelLen)/d_texPixelLen - animateSpeed);\\n    float v = v_texture_data.a;  // \\u7EBF\\u56FE\\u5C42\\u8D34\\u56FE\\u90E8\\u5206\\u7684 v \\u5750\\u6807\\u503C\\n\\n    // v = max(smoothstep(0.95, 1.0, v), v);\\n    vec2 uv= v_iconMapUV / u_textSize + vec2(u, v) / u_textSize * 64.;\\n     vec4 pattern = texture(SAMPLER_2D(u_texture), uv);\\n\\n    if(u_textureBlend == 0.0) { // normal\\n      pattern.a = 0.0;\\n      outputColor += pattern;\\n    } else { // replace\\n        pattern.a *= v_color.a;\\n        if(outputColor.a <= 0.0) {\\n          pattern.a = 0.0;\\n        }\\n        outputColor = pattern;\\n    }\\n  } \\n\\n  float v = v_texture_data.a;\\n  float strokeWidth = min(0.5, u_strokeWidth);\\n  // \\u7ED8\\u5236 border\\n  if(strokeWidth > 0.01) {\\n    float borderOuterWidth = strokeWidth / 2.0;\\n\\n\\n    if(v >= 1.0 - strokeWidth || v <= strokeWidth) {\\n      if(v > strokeWidth) { // \\u5916\\u4FA7\\n        float linear = smoothstep(0.0, 1.0, (v - (1.0 - strokeWidth))/strokeWidth);\\n        //  float linear = step(0.0, (v - (1.0 - borderWidth))/borderWidth);\\n        outputColor.rgb = mix(outputColor.rgb, v_stroke.rgb, linear);\\n      } else if(v <= strokeWidth) {\\n        float linear = smoothstep(0.0, 1.0, v/strokeWidth);\\n        outputColor.rgb = mix(v_stroke.rgb, outputColor.rgb, linear);\\n      }\\n    }\\n\\n    if(v < borderOuterWidth) {\\n      outputColor.a = mix(0.0, outputColor.a, v/borderOuterWidth);\\n    } else if(v > 1.0 - borderOuterWidth) {\\n      outputColor.a = mix(outputColor.a, 0.0, (v - (1.0 - borderOuterWidth))/borderOuterWidth);\\n    }\\n  }\\n\\n  // blur\\n  float blurV = v_texture_data.a;\\n  if(blurV < 0.5) {\\n    outputColor.a *= mix(u_blur.r, u_blur.g, blurV/0.5);\\n  } else {\\n    outputColor.a *= mix(u_blur.g, u_blur.b, (blurV - 0.5)/0.5);\\n  }\\n  \\n  outputColor = filterColor(outputColor);\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/line/line_vert.glsl' */\nconst line_vert = \"#define Animate (0.0)\\n\\nlayout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in vec2 a_Size;\\nlayout(location = ATTRIBUTE_LOCATION_DISTANCE_INDEX) in vec3 a_DistanceAndIndexAndMiter;\\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec4 a_Normal_Total_Distance;\\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_iconMapUV;\\n\\nlayout(std140) uniform commonUniorm {\\n  vec4 u_animate: [ 1., 2., 1.0, 0.2 ];\\n  vec4 u_dash_array;\\n  vec4 u_blur;\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  vec2 u_textSize;\\n  float u_icon_step: 100;\\n  float u_heightfixed: 0.0;\\n  float u_vertexScale: 1.0;\\n  float u_raisingHeight: 0.0;\\n  float u_strokeWidth: 0.0;\\n  float u_textureBlend;\\n  float u_line_texture;\\n  float u_linearDir: 1.0;\\n  float u_linearColor: 0;\\n  float u_time;\\n};\\n\\nout vec4 v_color;\\nout vec4 v_stroke;\\n//dash\\nout vec4 v_dash_array;\\nout float v_d_distance_ratio;\\n// texV \\u7EBF\\u56FE\\u5C42 - \\u8D34\\u56FE\\u90E8\\u5206\\u7684 v \\u5750\\u6807\\uFF08\\u7EBF\\u7684\\u5BBD\\u5EA6\\u65B9\\u5411\\uFF09\\nout vec2 v_iconMapUV;\\nout vec4 v_texture_data;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  vec2 a_DistanceAndIndex = a_DistanceAndIndexAndMiter.xy;\\n  float a_Miter = a_DistanceAndIndexAndMiter.z;\\n  vec3 a_Normal = a_Normal_Total_Distance.xyz;\\n  float a_Total_Distance = a_Normal_Total_Distance.w;\\n  //dash\\u8F93\\u51FA\\n  v_dash_array = pow(2.0, 20.0 - u_Zoom) * u_dash_array / a_Total_Distance;\\n  v_d_distance_ratio = a_DistanceAndIndex.x / a_Total_Distance;\\n\\n  // cal style mapping - \\u6570\\u636E\\u7EB9\\u7406\\u6620\\u5C04\\u90E8\\u5206\\u7684\\u8BA1\\u7B97\\n  float d_texPixelLen; // \\u8D34\\u56FE\\u7684\\u50CF\\u7D20\\u957F\\u5EA6\\uFF0C\\u6839\\u636E\\u5730\\u56FE\\u5C42\\u7EA7\\u7F29\\u653E\\n  v_iconMapUV = a_iconMapUV;\\n  d_texPixelLen = project_float_pixel(u_icon_step);\\n\\n  v_color = a_Color;\\n  v_color.a *= opacity;\\n  v_stroke = stroke;\\n\\n  vec3 size = a_Miter * setPickingSize(a_Size.x) * a_Normal;\\n\\n  vec2 offset = project_pixel(size.xy);\\n\\n  float lineDistance = a_DistanceAndIndex.x;\\n  float currentLinePointRatio = lineDistance / a_Total_Distance;\\n\\n  float lineOffsetWidth = length(offset + offset * sign(a_Miter)); // \\u7EBF\\u6A2A\\u5411\\u504F\\u79FB\\u7684\\u8DDD\\u79BB\\uFF08\\u5411\\u4E24\\u4FA7\\u504F\\u79FB\\u7684\\u548C\\uFF09\\n  float linePixelSize = project_pixel(a_Size.x) * 2.0; // \\u5B9A\\u70B9\\u4F4D\\u7F6E\\u504F\\u79FB\\uFF0C\\u6309\\u5730\\u56FE\\u7B49\\u7EA7\\u7F29\\u653E\\u540E\\u7684\\u8DDD\\u79BB \\u5355\\u4FA7 * 2\\n  float texV = lineOffsetWidth / linePixelSize; // \\u7EBF\\u56FE\\u5C42\\u8D34\\u56FE\\u90E8\\u5206\\u7684 v \\u5750\\u6807\\u503C\\n\\n  v_texture_data = vec4(currentLinePointRatio, lineDistance, d_texPixelLen, texV);\\n  // \\u8BBE\\u7F6E\\u6570\\u636E\\u96C6\\u7684\\u53C2\\u6570\\n\\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0, 1.0), a_Position64Low);\\n\\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, a_Size.y, 1.0));\\n\\n  float h = float(a_Position.z) * u_vertexScale; // \\u7EBF\\u9876\\u70B9\\u7684\\u9AD8\\u5EA6 - \\u517C\\u5BB9\\u4E0D\\u5B58\\u5728\\u7B2C\\u4E09\\u4E2A\\u6570\\u503C\\u7684\\u60C5\\u51B5 vertex height\\n  float lineHeight = a_Size.y; // size \\u7B2C\\u4E8C\\u4E2A\\u53C2\\u6570\\u4EE3\\u8868\\u7684\\u9AD8\\u5EA6 [linewidth, lineheight]\\n\\n  // \\u517C\\u5BB9 mapbox \\u5728\\u7EBF\\u9AD8\\u5EA6\\u4E0A\\u7684\\u6548\\u679C\\u8868\\u73B0\\u57FA\\u672C\\u4E00\\u81F4\\n  if (\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\\n  ) {\\n    // mapbox\\n    // \\u4FDD\\u6301\\u9AD8\\u5EA6\\u76F8\\u5BF9\\u4E0D\\u53D8\\n    float mapboxZoomScale = 4.0 / pow(2.0, 21.0 - u_Zoom);\\n    h *= mapboxZoomScale;\\n    h += u_raisingHeight * mapboxZoomScale;\\n    if (u_heightfixed > 0.0) {\\n      lineHeight *= mapboxZoomScale;\\n    }\\n  }\\n\\n  gl_Position = project_common_position_to_clipspace(\\n    vec4(project_pos.xy + offset, lineHeight + h, 1.0)\\n  );\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\nexport default class LineModel extends BaseModel {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"textureEventFlag\", false);\n    _defineProperty(this, \"texture\", this.createTexture2D({\n      data: new Uint8Array([0, 0, 0, 0]),\n      width: 1,\n      height: 1\n    }));\n    _defineProperty(this, \"updateTexture\", () => {\n      const {\n        createTexture2D\n      } = this.rendererService;\n      if (this.textures.length === 0) {\n        this.textures = [this.texture];\n      }\n      if (this.texture) {\n        this.texture.update({\n          data: this.iconService.getCanvas()\n        });\n        this.layer.render();\n        return;\n      }\n      this.texture = createTexture2D({\n        data: this.iconService.getCanvas(),\n        mag: gl.NEAREST,\n        min: gl.NEAREST,\n        premultiplyAlpha: false,\n        width: 1024,\n        height: this.iconService.canvasHeight || 128\n      });\n    });\n  }\n  get attributeLocation() {\n    return Object.assign(super.attributeLocation, {\n      MAX: super.attributeLocation.MAX,\n      SIZE: 9,\n      DISTANCE_INDEX: 10,\n      NORMAL: 11,\n      UV: 12\n    });\n  }\n  getCommonUniformsInfo() {\n    const {\n      sourceColor,\n      targetColor,\n      textureBlend = 'normal',\n      lineType = 'solid',\n      dashArray = [10, 5, 0, 0],\n      lineTexture = false,\n      iconStep = 100,\n      vertexHeightScale = 20.0,\n      strokeWidth = 0.0,\n      raisingHeight = 0,\n      heightfixed = false,\n      linearDir = LinearDir.VERTICAL,\n      // 默认纵向\n      blur = [1, 1, 1, 0]\n    } = this.layer.getLayerConfig();\n    let u_dash_array = dashArray;\n    if (lineType !== 'dash') {\n      u_dash_array = [0, 0, 0, 0];\n    }\n    if (u_dash_array.length === 2) {\n      u_dash_array.push(0, 0);\n    }\n    if (this.rendererService.getDirty() && this.texture) {\n      var _this$texture;\n      (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.bind();\n    }\n    const {\n      animateOption\n    } = this.layer.getLayerConfig();\n    // 转化渐变色\n    let useLinearColor = 0; // 默认不生效\n    let sourceColorArr = [0, 0, 0, 0];\n    let targetColorArr = [0, 0, 0, 0];\n    if (sourceColor && targetColor) {\n      sourceColorArr = rgb2arr(sourceColor);\n      targetColorArr = rgb2arr(targetColor);\n      useLinearColor = 1;\n    }\n    const commonOptions = {\n      u_animate: this.animateOption2Array(animateOption),\n      u_dash_array,\n      u_blur: blur,\n      u_sourceColor: sourceColorArr,\n      u_targetColor: targetColorArr,\n      u_textSize: [1024, this.iconService.canvasHeight || 128],\n      u_icon_step: iconStep,\n      // 是否固定高度\n      u_heightfixed: Number(heightfixed),\n      // 顶点高度 scale\n      u_vertexScale: vertexHeightScale,\n      u_raisingHeight: Number(raisingHeight),\n      // line border 参数\n      u_strokeWidth: strokeWidth,\n      u_textureBlend: textureBlend === TextureBlend.NORMAL ? 0.0 : 1.0,\n      u_line_texture: lineTexture ? 1.0 : 0.0,\n      // 传入线的标识\n      u_linearDir: linearDir === LinearDir.VERTICAL ? 1.0 : 0.0,\n      u_linearColor: useLinearColor,\n      u_time: this.layer.getLayerAnimateTime() || 0\n    };\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  // public getAnimateUniforms(): IModelUniform {\n  //   const { animateOption } = this.layer.getLayerConfig() as ILayerConfig;\n  //   return {\n  //     u_animate: this.animateOption2Array(animateOption as IAnimateOption),\n  //     u_time: this.layer.getLayerAnimateTime(),\n  //   };\n  // }\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.initUniformsBuffer();\n      // this.updateTexture();\n      // this.iconService.on('imageUpdate', this.updateTexture);\n      if (!_this.textureEventFlag) {\n        _this.textureEventFlag = true;\n        _this.updateTexture();\n        _this.iconService.on('imageUpdate', _this.updateTexture);\n      }\n      return _this.buildModels();\n    })();\n  }\n  clearModels() {\n    var _this$texture2;\n    (_this$texture2 = this.texture) === null || _this$texture2 === void 0 || _this$texture2.destroy();\n    this.iconService.off('imageUpdate', this.updateTexture);\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        depth = false\n      } = _this2.layer.getLayerConfig();\n      const {\n        frag,\n        vert,\n        type\n      } = _this2.getShaders();\n      _this2.layer.triangulation = LineTriangulation;\n      const model = yield _this2.layer.buildLayerModel({\n        moduleName: 'line' + type,\n        vertexShader: vert,\n        fragmentShader: frag,\n        triangulation: LineTriangulation,\n        defines: _this2.getDefines(),\n        inject: _this2.getInject(),\n        depth: {\n          enable: depth\n        }\n      });\n      return [model];\n    })();\n  }\n\n  /**\n   * 根据参数获取不同的 shader 代码\n   * @returns\n   */\n  getShaders() {\n    return {\n      frag: line_frag,\n      vert: line_vert,\n      type: ''\n    };\n  }\n  registerBuiltinAttributes() {\n    // 注册 Position 属性 64 位地位部分，经纬度数据开启双精度，避免大于 20层级以上出现数据偏移\n    this.registerPosition64LowAttribute();\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'distanceAndIndex',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_DistanceAndIndexAndMiter',\n        shaderLocation: this.attributeLocation.DISTANCE_INDEX,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.STATIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        update: (feature, featureIdx, vertex, attributeIdx, normal, vertexIndex) => {\n          return vertexIndex === undefined ? [vertex[3], 10, vertex[4]] : [vertex[3], vertexIndex, vertex[4]];\n        }\n      }\n    });\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Size',\n        shaderLocation: this.attributeLocation.SIZE,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 2,\n        update: feature => {\n          const {\n            size = 1\n          } = feature;\n          return Array.isArray(size) ? [size[0], size[1]] : [size, 0];\n        }\n      }\n    });\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'normal_total_distance',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Normal_Total_Distance',\n        shaderLocation: this.attributeLocation.NORMAL,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.STATIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 4,\n        update: (feature, featureIdx, vertex, attributeIdx, normal) => {\n          return [...normal, vertex[5]];\n        }\n      }\n    });\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'uv',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_iconMapUV',\n        shaderLocation: this.attributeLocation.UV,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 2,\n        update: feature => {\n          const iconMap = this.iconService.getIconMap();\n          const {\n            texture\n          } = feature;\n          const {\n            x,\n            y\n          } = iconMap[texture] || {\n            x: 0,\n            y: 0\n          };\n          return [x, y];\n        }\n      }\n    });\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}