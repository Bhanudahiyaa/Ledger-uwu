{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { lodashUtil } from '@antv/l7-utils';\nimport { extractUniforms } from \"../../utils/shader-module\";\nconst {\n  uniq\n} = lodashUtil;\n/* babel-plugin-inline-import '../../shaders/common.glsl' */\nconst common = \"#define PI 3.14159265359\";\n/* babel-plugin-inline-import '../../shaders/common_light.glsl' */\nconst light = \"#define ambientRatio 0.5\\n#define diffuseRatio 0.3\\n#define specularRatio 0.2\\n\\n\\nfloat calc_lighting(vec4 pos) {\\n\\n    vec3 worldPos = vec3(pos * u_ModelMatrix);\\n\\n    vec3 worldNormal = a_Normal;\\n      // //cal light weight\\n    vec3 viewDir = normalize(u_CameraPosition - worldPos);\\n\\n    vec3 lightDir = normalize(vec3(1, -10.5, 12));\\n\\n    vec3 halfDir = normalize(viewDir+lightDir);\\n      // //lambert\\n    float lambert = dot(worldNormal, lightDir);\\n        //specular\\n    float specular = pow(max(0.0, dot(worldNormal, halfDir)), 32.0);\\n        //sum to light weight\\n    float lightWeight = ambientRatio + diffuseRatio * lambert + specularRatio * specular;\\n\\n    return lightWeight;\\n}\\n\";\n/* babel-plugin-inline-import '../../shaders/decode.glsl' */\nconst decode = \"#define SHIFT_RIGHT17 1.0 / 131072.0\\n#define SHIFT_RIGHT18 1.0 / 262144.0\\n#define SHIFT_RIGHT19 1.0 / 524288.0\\n#define SHIFT_RIGHT20 1.0 / 1048576.0\\n#define SHIFT_RIGHT21 1.0 / 2097152.0\\n#define SHIFT_RIGHT22 1.0 / 4194304.0\\n#define SHIFT_RIGHT23 1.0 / 8388608.0\\n#define SHIFT_RIGHT24 1.0 / 16777216.0\\n\\n#define SHIFT_LEFT17 131072.0\\n#define SHIFT_LEFT18 262144.0\\n#define SHIFT_LEFT19 524288.0\\n#define SHIFT_LEFT20 1048576.0\\n#define SHIFT_LEFT21 2097152.0\\n#define SHIFT_LEFT22 4194304.0\\n#define SHIFT_LEFT23 8388608.0\\n#define SHIFT_LEFT24 16777216.0\\n\\nvec2 unpack_float(float packedValue) {\\n  int packedIntValue = int(packedValue);\\n  int v0 = packedIntValue / 256;\\n  return vec2(v0, packedIntValue - v0 * 256);\\n}\\n\\nvec4 decode_color(vec2 encodedColor) {\\n  return vec4(\\n    unpack_float(encodedColor[0]) / 255.0,\\n    unpack_float(encodedColor[1]) / 255.0\\n  );\\n}\\n\";\n/* babel-plugin-inline-import '../../shaders/lighting.glsl' */\nconst lighting = \"// Blinn-Phong model\\n// apply lighting in vertex shader instead of fragment shader\\n// @see https://learnopengl.com/Advanced-Lighting/Advanced-Lighting\\nuniform float u_Ambient : 1.0;\\nuniform float u_Diffuse : 1.0;\\nuniform float u_Specular : 1.0;\\nuniform int u_NumOfDirectionalLights : 1;\\nuniform int u_NumOfSpotLights : 0;\\n\\n#define SHININESS 32.0\\n#define MAX_NUM_OF_DIRECTIONAL_LIGHTS 3\\n#define MAX_NUM_OF_SPOT_LIGHTS 3\\n\\nstruct DirectionalLight {\\n  vec3 direction;\\n  vec3 ambient;\\n  vec3 diffuse;\\n  vec3 specular;\\n};\\n\\nstruct SpotLight {\\n  vec3 position;\\n  vec3 direction;\\n  vec3 ambient;\\n  vec3 diffuse;\\n  vec3 specular;\\n  float constant;\\n  float linear;\\n  float quadratic;\\n  float angle;\\n  float blur;\\n  float exponent;\\n};\\n\\nuniform DirectionalLight u_DirectionalLights[MAX_NUM_OF_DIRECTIONAL_LIGHTS];\\nuniform SpotLight u_SpotLights[MAX_NUM_OF_SPOT_LIGHTS];\\n\\nvec3 calc_directional_light(DirectionalLight light, vec3 normal, vec3 viewDir) {\\n  vec3 lightDir = normalize(light.direction);\\n  // diffuse shading\\n  float diff = max(dot(normal, lightDir), 0.0);\\n  // Blinn-Phong specular shading\\n  vec3 halfwayDir = normalize(lightDir + viewDir);\\n  float spec = pow(max(dot(normal, halfwayDir), 0.0), SHININESS);\\n\\n  vec3 ambient = light.ambient * u_Ambient;\\n  vec3 diffuse = light.diffuse * diff * u_Diffuse;\\n  vec3 specular = light.specular * spec * u_Specular;\\n\\n  return ambient + diffuse + specular;\\n}\\n\\n\\nvec3 calc_lighting(vec3 position, vec3 normal, vec3 viewDir) {\\n  vec3 weight = vec3(0.0);\\n  for (int i = 0; i < MAX_NUM_OF_DIRECTIONAL_LIGHTS; i++) {\\n    if (i >= u_NumOfDirectionalLights) {\\n      break;\\n    }\\n    weight += calc_directional_light(u_DirectionalLights[i], normal, viewDir);\\n  }\\n  return weight;\\n}\\n\";\n/* babel-plugin-inline-import '../../shaders/picking.frag.glsl' */\nconst pickingFrag = \"\\nin vec4 v_PickingResult;\\n\\n#pragma include \\\"picking_uniforms\\\"\\n\\n#define PICKING_NONE 0.0\\n#define PICKING_ENCODE 1.0\\n#define PICKING_HIGHLIGHT 2.0\\n#define COLOR_SCALE 1. / 255.\\n\\n#define HIGHLIGHT 1.0\\n#define SELECT 2.0\\n\\n/*\\n * Returns highlight color if this item is selected.\\n */\\nvec4 filterHighlightColor(vec4 color, float weight) {\\n  float activeType = v_PickingResult.a;\\n  if(activeType > 0.0) {\\n    vec4 highLightColor =  activeType > 1.5 ? u_SelectColor : u_HighlightColor;\\n    highLightColor = highLightColor * COLOR_SCALE;\\n    float highLightAlpha = highLightColor.a;\\n    float highLightRatio = highLightAlpha / (highLightAlpha + color.a * (1.0 - highLightAlpha));\\n    vec3 resultRGB = mix(color.rgb, highLightColor.rgb, highLightRatio);\\n    return vec4(mix(resultRGB * weight, color.rgb, u_activeMix), color.a);\\n  }\\n  else {\\n    return color;\\n  }\\n\\n  \\n}\\n\\n/*\\n * Returns picking color if picking enabled else unmodified argument.\\n */\\nvec4 filterPickingColor(vec4 color) {\\n  vec3 pickingColor = v_PickingResult.rgb;\\n  if (u_PickingStage == PICKING_ENCODE && length(pickingColor) < 0.001) {\\n    discard;\\n  }\\n  return u_PickingStage == PICKING_ENCODE ? vec4(pickingColor, step(0.001,color.a)): color;\\n}\\n\\n/*\\n * Returns picking color if picking is enabled if not\\n * highlight color if this item is selected, otherwise unmodified argument.\\n */\\nvec4 filterColor(vec4 color) {\\n  // \\u8FC7\\u6EE4\\u591A\\u4F59\\u7684 shader \\u8BA1\\u7B97\\n  // return color;\\n  if(u_shaderPick < 0.5) {\\n    return color; // \\u6682\\u65F6\\u53BB\\u9664 \\u76F4\\u63A5\\u53D6\\u6D88\\u8BA1\\u7B97\\u5728\\u9009\\u4E2D\\u65F6\\u62D6\\u62FD\\u5730\\u56FE\\u4F1A\\u6709\\u95EE\\u9898\\n  } else {\\n    return filterPickingColor(filterHighlightColor(color, 1.0));\\n  }\\n  \\n}\\n\\nvec4 filterColorAlpha(vec4 color, float alpha) {\\n  // \\u8FC7\\u6EE4\\u591A\\u4F59\\u7684 shader \\u8BA1\\u7B97\\n  // return color;\\n  if(u_shaderPick < 0.5) {\\n    return color; // \\u6682\\u65F6\\u53BB\\u9664 \\u76F4\\u63A5\\u53D6\\u6D88\\u8BA1\\u7B97\\u5728\\u9009\\u4E2D\\u65F6\\u62D6\\u62FD\\u5730\\u56FE\\u4F1A\\u6709\\u95EE\\u9898\\n  } else {\\n    return filterPickingColor(filterHighlightColor(color, alpha));\\n  }\\n}\\n\\n\";\n/* babel-plugin-inline-import '../../shaders/picking.vert.glsl' */\nconst pickingVert = \"layout(location = ATTRIBUTE_LOCATION_PICKING_COLOR) in vec3 a_PickingColor;\\nout vec4 v_PickingResult;\\n\\n#pragma include \\\"picking_uniforms\\\"\\n\\n#define PICKING_NONE 0.0\\n#define PICKING_ENCODE 1.0\\n#define PICKING_HIGHLIGHT 2.0\\n#define COLOR_SCALE 1. / 255.\\n\\n#define NORMAL 0.0\\n#define HIGHLIGHT 1.0\\n#define SELECT 2.0\\n\\nbool isVertexPicked(vec3 vertexColor) {\\n  return distance(vertexColor,u_PickingColor.rgb) < 0.01;\\n}\\n\\n// \\u5224\\u65AD\\u5F53\\u524D\\u70B9\\u662F\\u5426\\u5DF2\\u7ECF\\u88AB select \\u9009\\u4E2D\\nbool isVertexSelected(vec3 vertexColor) {\\n  return distance(vertexColor,u_CurrentSelectedId.rgb) < 0.01;\\n}\\n\\nvoid setPickingColor(vec3 pickingColor) {\\n  if(u_shaderPick < 0.5) {\\n    return;\\n  }\\n  // compares only in highlight stage\\n\\n  if(u_PickingStage == PICKING_HIGHLIGHT) {\\n    if(isVertexPicked(pickingColor)) {\\n       v_PickingResult = vec4(pickingColor.rgb * COLOR_SCALE,HIGHLIGHT);\\n       return;\\n    }\\n    if(isVertexSelected(pickingColor)) {\\n     v_PickingResult = vec4(u_CurrentSelectedId.rgb * COLOR_SCALE,SELECT);\\n      return;\\n    }\\n\\n  } else {\\n      v_PickingResult= vec4(pickingColor.rgb * COLOR_SCALE,NORMAL);\\n      return;\\n  }\\n\\n  // // v_PickingResult.a = float((u_PickingStage == PICKING_HIGHLIGHT) && (isVertexPicked(pickingColor) || isVertexPicked(u_CurrentSelectedId)));\\n\\n  // // Stores the picking color so that the fragment shader can render it during picking\\n  // v_PickingResult.rgb = pickingColor * COLOR_SCALE;\\n}\\n\\nfloat setPickingSize(float x) {\\n   return u_PickingStage == PICKING_ENCODE ? x + u_PickingBuffer : x;\\n}\\n\\nfloat setPickingOrder(float z) {\\n   bool selected = bool(v_PickingResult.a);\\n   return selected ? z + 1. : 0.;\\n}\\n\";\n/* babel-plugin-inline-import '../../shaders/picking_uniforms.glsl' */\nconst picking_uniforms = \"layout(std140) uniform PickingUniforms {\\n  vec4 u_HighlightColor;\\n  vec4 u_SelectColor;\\n  vec3 u_PickingColor;\\n  float u_PickingStage;\\n  vec3 u_CurrentSelectedId;\\n  float u_PickingThreshold;\\n  float u_PickingBuffer;\\n  float u_shaderPick;\\n  float u_activeMix;\\n};\";\n/* babel-plugin-inline-import '../../shaders/project.glsl' */\nconst project = \"\\n#define E 2.718281828459045\\nvec2 ProjectFlat(vec2 lnglat){\\n  float maxs=85.0511287798;\\n  float lat=max(min(maxs,lnglat.y),-maxs);\\n  float scale= 268435456.;\\n  float d=PI/180.;\\n  float x=lnglat.x*d;\\n  float y=lat*d;\\n  y=log(tan((PI/4.)+(y/2.)));\\n\\n  float a=.5/PI,\\n  b=.5,\\n  c=-.5/PI;\\n  d=.5;\\n  x=scale*(a*x+b);\\n  y=scale*(c*y+d);\\n  return vec2(x,y);\\n}\\n\\nvec2 unProjectFlat(vec2 px){\\n  float a=.5/PI;\\n  float b=.5;\\n  float c=-.5/PI;\\n  float d=.5;\\n  float scale = 268435456.;\\n  float x=(px.x/scale-b)/a;\\n  float y=(px.y/scale-d)/c;\\n  y=(atan(pow(E,y))-(PI/4.))*2.;\\n  d=PI/180.;\\n  float lat=y/d;\\n  float lng=x/d;\\n  return vec2(lng,lat);\\n}\\n\\nfloat pixelDistance(vec2 from, vec2 to) {\\n vec2 a1 = ProjectFlat(from);\\n vec2 b1 = ProjectFlat(to);\\n return distance(a1, b1);\\n}\\n\\n// gaode2.0\\nvec2 customProject(vec2 lnglat) { // \\u7ECF\\u7EAC\\u5EA6 => \\u5E73\\u9762\\u5750\\u6807\\n  float t = lnglat.x;\\n  float e = lnglat.y;\\n  float Sm = 180.0 / PI;\\n  float Tm = 6378137.0;\\n  float Rm = PI / 180.0;\\n  float r = 85.0511287798;\\n  e = max(min(r, e), -r);\\n  t *= Rm;\\n  e *= Rm;\\n  e = log(tan(PI / 4.0 + e / 2.0));\\n  return vec2(t * Tm, e * Tm);\\n}\\n\\nvec2 unProjCustomCoord(vec2 point) { // \\u5E73\\u9762\\u5750\\u6807 => \\u7ECF\\u7EAC\\u5EA6\\n  float Sm = 57.29577951308232; //180 / Math.PI\\n  float Tm = 6378137.0;\\n  float t = point.x;\\n  float e = point.y;\\n  return vec2(t / Tm * Sm, (2.0 * atan(exp(e / Tm)) - PI / 2.0) * Sm);\\n}\\n\\n\\nfloat customPixelDistance(vec2 from, vec2 to) {\\n vec2 a1 = ProjectFlat(from);\\n vec2 b1 = ProjectFlat(to);\\n return distance(a1, b1);\\n}\";\n/* babel-plugin-inline-import '../../shaders/projection.glsl' */\nconst projection = \"#define TILE_SIZE (512.0)\\n#define PI (3.1415926536)\\n#define WORLD_SCALE (TILE_SIZE / (PI * 2.0))\\n#define EARTH_CIRCUMFERENCE (40.03e6)\\n\\n#define COORDINATE_SYSTEM_LNGLAT (1.0) // mapbox\\n#define COORDINATE_SYSTEM_LNGLAT_OFFSET (2.0) // mapbox offset\\n#define COORDINATE_SYSTEM_VECTOR_TILE (3.0)\\n#define COORDINATE_SYSTEM_IDENTITY (4.0)\\n#define COORDINATE_SYSTEM_METER_OFFSET (5.0)\\n\\n#pragma include \\\"scene_uniforms\\\"\\n\\nconst vec2 ZERO_64_XY_LOW = vec2(0.0, 0.0);\\n\\n// web mercator coords -> world coords\\nvec2 project_mercator(vec2 lnglat) {\\n  float x = lnglat.x;\\n  return vec2(radians(x) + PI, PI - log(tan(PI * 0.25 + radians(lnglat.y) * 0.5)));\\n}\\n\\nfloat project_scale(float meters) {\\n  return meters * u_PixelsPerMeter.z;\\n}\\n\\n// offset coords -> world coords\\nvec4 project_offset(vec4 offset) {\\n  float dy = offset.y;\\n  dy = clamp(dy, -1.0, 1.0);\\n  vec3 pixels_per_unit = u_PixelsPerDegree + u_PixelsPerDegree2 * dy;\\n  return vec4(offset.xyz * pixels_per_unit, offset.w);\\n}\\n\\nvec3 project_normal(vec3 normal) {\\n  vec4 normal_modelspace = u_ModelMatrix * vec4(normal, 0.0);\\n  return normalize(normal_modelspace.xyz * u_PixelsPerMeter);\\n}\\n\\nvec3 project_offset_normal(vec3 vector) {\\n  if (\\n    u_CoordinateSystem < COORDINATE_SYSTEM_LNGLAT + 0.01 &&\\n      u_CoordinateSystem > COORDINATE_SYSTEM_LNGLAT - 0.01 ||\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\\n  ) {\\n    // normals generated by the polygon tesselator are in lnglat offsets instead of meters\\n    return normalize(vector * u_PixelsPerDegree);\\n  }\\n  return project_normal(vector);\\n}\\n\\nvec4 project_position(vec4 position, vec2 position64xyLow) {\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\\n    float X = position.x - u_ViewportCenter.x;\\n    float Y = position.y - u_ViewportCenter.y;\\n    return project_offset(\\n      vec4(X + position64xyLow.x, Y + position64xyLow.y, position.z, position.w)\\n    );\\n  }\\n  if (\\n    u_CoordinateSystem < COORDINATE_SYSTEM_LNGLAT + 0.01 &&\\n    u_CoordinateSystem > COORDINATE_SYSTEM_LNGLAT - 0.01\\n  ) {\\n    return vec4(\\n      project_mercator(position.xy) * WORLD_SCALE * u_ZoomScale,\\n      project_scale(position.z),\\n      position.w\\n    );\\n  }\\n\\n  return position;\\n}\\n\\nvec4 project_position(vec4 position) {\\n  return project_position(position, ZERO_64_XY_LOW);\\n}\\n\\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\\n  vec2 offset = pixels / u_ViewportSize * u_DevicePixelRatio * 2.0;\\n  return offset * u_FocalDistance;\\n}\\n\\n// \\u9002\\u914D\\u7EB9\\u7406\\u8D34\\u56FE\\u7684\\u7B49\\u50CF\\u7D20\\u5927\\u5C0F\\nfloat project_pixel_texture(float pixel) {\\n  // mapbox zoom > 12\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\\n    return pixel * pow(0.5, u_Zoom) * u_FocalDistance;\\n  }\\n\\n  return pixel * 2.0 * u_FocalDistance;\\n}\\n\\n// \\u5728\\u4E0D\\u8BBA\\u4EC0\\u4E48\\u5E95\\u56FE\\u4E0B\\u9700\\u8981\\u7EDF\\u4E00\\u5904\\u7406\\u7684\\u65F6\\u5019\\u4F7F\\u7528\\nfloat project_float_pixel(float pixel) {\\n  if (\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\\n  ) {\\n    // mapbox \\u5750\\u6807\\u7CFB\\u4E0B\\uFF0C\\u4E3A\\u4E86\\u548C Web \\u58A8\\u5361\\u6258\\u5750\\u6807\\u7CFB\\u7EDF\\u4E00\\uFF0Czoom \\u9ED8\\u8BA4\\u51CF1\\n    return pixel * pow(2.0, 19.0 - u_Zoom) * u_FocalDistance;\\n  }\\n\\n  return pixel * u_FocalDistance;\\n}\\n\\n// Project meter into the unit of pixel which used in the camera world space\\nfloat project_float_meter(float meter) {\\n  if (\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\\n  ) {\\n    // Since the zoom level uniform is updated by mapservice and it's alread been subtracted by 1\\n    // Not sure if we are supposed to do that again\\n    return meter;\\n  } else {\\n    return project_float_pixel(meter);\\n  }\\n\\n  // TODO: change the following code to make adaptations for amap\\n  // return u_FocalDistance * TILE_SIZE * pow(2.0, u_Zoom) * meter / EARTH_CIRCUMFERENCE;\\n\\n}\\n\\nfloat project_pixel(float pixel) {\\n  return pixel * u_FocalDistance;\\n}\\n\\nvec2 project_pixel(vec2 pixel) {\\n  return pixel * -1.0 * u_FocalDistance;\\n}\\n\\nvec3 project_pixel(vec3 pixel) {\\n  return pixel * -1.0 * u_FocalDistance;\\n}\\n\\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\\n  if (\\n    u_CoordinateSystem == COORDINATE_SYSTEM_METER_OFFSET ||\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\\n  ) {\\n    // Needs to be divided with project_uCommonUnitsPerMeter\\n    position.w *= u_PixelsPerMeter.z;\\n  }\\n\\n  return viewProjectionMatrix * position + center;\\n}\\n\\n// Projects from common space coordinates to clip space\\nvec4 project_common_position_to_clipspace(vec4 position) {\\n  return project_common_position_to_clipspace(\\n    position,\\n    u_ViewProjectionMatrix,\\n    u_ViewportCenterProjection\\n  );\\n}\\n\\nvec4 unproject_clipspace_to_position(vec4 clipspacePos, mat4 u_InverseViewProjectionMatrix) {\\n  vec4 pos = u_InverseViewProjectionMatrix * (clipspacePos - u_ViewportCenterProjection);\\n\\n  if (\\n    u_CoordinateSystem == COORDINATE_SYSTEM_METER_OFFSET ||\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\\n  ) {\\n    // Needs to be divided with project_uCommonUnitsPerMeter\\n    pos.w = pos.w / u_PixelsPerMeter.z;\\n  }\\n  return pos;\\n}\\n\\nbool isEqual(float a, float b) {\\n  return a < b + 0.001 && a > b - 0.001;\\n}\\n\\n\";\n/* babel-plugin-inline-import '../../shaders/rotation_2d.glsl' */\nconst rotation_2d = \"vec2 rotate_matrix(vec2 v, float a) {\\n    float b = a / 180.0 * 3.1415926535897932384626433832795;\\n    float s = sin(b);\\n    float c = cos(b);\\n    mat2 m = mat2(c, s, -s, c);\\n    return m * v;\\n}\";\n/* babel-plugin-inline-import '../../shaders/scene_uniforms.glsl' */\nconst scene_uniforms = \"layout(std140) uniform SceneUniforms {\\n  mat4 u_ViewMatrix;\\n  mat4 u_ProjectionMatrix;\\n  mat4 u_ViewProjectionMatrix;\\n  mat4 u_ModelMatrix;\\n  vec4 u_ViewportCenterProjection;\\n  vec3 u_PixelsPerDegree;\\n  float u_Zoom;\\n  vec3 u_PixelsPerDegree2;\\n  float u_ZoomScale;\\n  vec3 u_PixelsPerMeter;\\n  float u_CoordinateSystem;\\n  vec3 u_CameraPosition;\\n  float u_DevicePixelRatio;\\n  vec2 u_ViewportCenter;\\n  vec2 u_ViewportSize;\\n  float u_FocalDistance;\\n};\\n\";\n/* babel-plugin-inline-import '../../shaders/sdf_2d.glsl' */\nconst sdf2d = \"/**\\n * 2D signed distance field functions\\n * @see http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\\n */\\n\\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\\n\\nfloat sdCircle(vec2 p, float r) {\\n  return length(p) - r;\\n}\\n\\nfloat sdEquilateralTriangle(vec2 p) {\\n  float k = sqrt(3.0);\\n  p.x = abs(p.x) - 1.0;\\n  p.y = p.y + 1.0/k;\\n  if( p.x + k*p.y > 0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\\n  p.x -= clamp( p.x, -2.0, 0.0 );\\n  return -length(p)*sign(p.y);\\n}\\n\\nfloat sdBox(vec2 p, vec2 b) {\\n  vec2 d = abs(p)-b;\\n  return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\\n}\\n\\nfloat sdPentagon(vec2 p, float r) {\\n  vec3 k = vec3(0.809016994,0.587785252,0.726542528);\\n  p.x = abs(p.x);\\n  p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\\n  p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\\n  p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdHexagon(vec2 p, float r) {\\n  vec3 k = vec3(-0.866025404,0.5,0.577350269);\\n  p = abs(p);\\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdOctogon(vec2 p, float r) {\\n  vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\\n  p = abs(p);\\n  p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\\n  p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdHexagram(vec2 p, float r) {\\n  vec4 k=vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\\n  p = abs(p);\\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\\n  p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\\n  p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdRhombus(vec2 p, vec2 b) {\\n  vec2 q = abs(p);\\n  float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\\n  float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\\n  return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\\n}\\n\\nfloat sdVesica(vec2 p, float r, float d) {\\n  p = abs(p);\\n  float b = sqrt(r*r-d*d); // can delay this sqrt\\n  return ((p.y-b)*d>p.x*b)\\n          ? length(p-vec2(0.0,b))\\n          : length(p-vec2(-d,0.0))-r;\\n}\\n\";\nconst precisionRegExp = /precision\\s+(high|low|medium)p\\s+float/;\nconst globalDefaultprecision = '#ifdef GL_FRAGMENT_PRECISION_HIGH\\n precision highp float;\\n #else\\n precision mediump float;\\n#endif\\n';\nconst includeRegExp = /#pragma include ([\"^+\"]?[\"[a-zA-Z_0-9](.*)\"]*?)/g;\nconst REGEX_START_OF_MAIN = /void\\s+main\\s*\\([^)]*\\)\\s*\\{\\n?/; // Beginning of main\n\nexport default class ShaderModuleService {\n  constructor() {\n    _defineProperty(this, \"moduleCache\", {});\n    _defineProperty(this, \"rawContentCache\", {});\n  }\n  registerBuiltinModules() {\n    this.destroy();\n    this.registerModule('common', {\n      vs: common,\n      fs: common\n    });\n    this.registerModule('decode', {\n      vs: decode,\n      fs: ''\n    });\n    this.registerModule('scene_uniforms', {\n      vs: scene_uniforms,\n      fs: scene_uniforms\n    });\n    this.registerModule('picking_uniforms', {\n      vs: picking_uniforms,\n      fs: picking_uniforms\n    });\n    this.registerModule('projection', {\n      vs: projection,\n      fs: projection\n    });\n    this.registerModule('project', {\n      vs: project,\n      fs: ''\n    });\n    this.registerModule('sdf_2d', {\n      vs: '',\n      fs: sdf2d\n    });\n    this.registerModule('lighting', {\n      vs: lighting,\n      fs: ''\n    });\n    this.registerModule('light', {\n      vs: light,\n      fs: ''\n    });\n    this.registerModule('picking', {\n      vs: pickingVert,\n      fs: pickingFrag\n    });\n    this.registerModule('rotation_2d', {\n      vs: rotation_2d,\n      fs: ''\n    });\n  }\n  registerModule(moduleName, moduleParams) {\n    // prevent registering the same module multiple times\n    // if (this.rawContentCache[moduleName]) {\n    //   return;\n    // }\n\n    moduleParams.vs = moduleParams.vs.replace(/\\r\\n/g, '\\n'); // 将所有的\\r\\n替换为\\n\n    moduleParams.fs = moduleParams.fs.replace(/\\r\\n/g, '\\n'); // 将所有的\\r\\n替换为\\n\n    const {\n      vs,\n      fs,\n      uniforms: declaredUniforms,\n      defines,\n      inject\n    } = moduleParams;\n    const {\n      content: extractedVS,\n      uniforms: vsUniforms\n    } = extractUniforms(vs);\n    const {\n      content: extractedFS,\n      uniforms: fsUniforms\n    } = extractUniforms(fs);\n    this.rawContentCache[moduleName] = {\n      fs: extractedFS,\n      defines,\n      inject,\n      uniforms: _objectSpread(_objectSpread(_objectSpread({}, vsUniforms), fsUniforms), declaredUniforms),\n      vs: extractedVS\n    };\n  }\n  getModule(moduleName) {\n    // TODO: cache module\n    // if (this.moduleCache[moduleName]) {\n    //   return this.moduleCache[moduleName];\n    // }\n\n    let rawVS = this.rawContentCache[moduleName].vs;\n    let rawFS = this.rawContentCache[moduleName].fs;\n    const {\n      defines = {},\n      inject = {}\n    } = this.rawContentCache[moduleName];\n    let declaredUniforms = {};\n\n    // vs 头部注入\n    if (inject['vs:#decl']) {\n      rawVS = inject['vs:#decl'] + rawVS;\n      declaredUniforms = extractUniforms(inject['vs:#decl']).uniforms;\n    }\n\n    // vs main\n    if (inject['vs:#main-start']) {\n      rawVS = rawVS.replace(REGEX_START_OF_MAIN, match => {\n        return match + inject['vs:#main-start'];\n      });\n    }\n\n    // fs 头部注入\n    if (inject['fs:#decl']) {\n      rawFS = inject['fs:#decl'] + rawFS;\n    }\n    const injectDefines = getInjectDefines(defines);\n\n    // 注入定义的宏\n    rawVS = injectDefines + rawVS;\n    const {\n      content: vs,\n      includeList: vsIncludeList\n    } = this.processModule(rawVS, [], 'vs');\n    const {\n      content: fs,\n      includeList: fsIncludeList\n    } = this.processModule(rawFS, [], 'fs');\n\n    // TODO: extract uniforms and their default values from GLSL\n    const uniforms = uniq(vsIncludeList.concat(fsIncludeList).concat(moduleName)).reduce((prev, cur) => {\n      return _objectSpread(_objectSpread({}, prev), this.rawContentCache[cur].uniforms);\n    }, _objectSpread({}, declaredUniforms));\n\n    /**\n     * set default precision for fragment shader\n     * https://stackoverflow.com/questions/28540290/why-it-is-necessary-to-set-precision-for-the-fragment-shader\n     */\n    const compiledVs = (precisionRegExp.test(fs) ? '' : globalDefaultprecision) + vs;\n    const compiledFs = (precisionRegExp.test(fs) ? '' : globalDefaultprecision) + fs;\n    this.moduleCache[moduleName] = {\n      vs: compiledVs.trim(),\n      fs: compiledFs.trim(),\n      uniforms\n    };\n    return this.moduleCache[moduleName];\n  }\n  destroy() {\n    this.moduleCache = {};\n    this.rawContentCache = {};\n  }\n\n  /**\n   *\n   * 解析定义的内联模块\n   * like: #pragma include \"projection\"\n   */\n  processModule(rawContent, includeList, type) {\n    const compiled = rawContent.replace(includeRegExp, (_, strMatch) => {\n      const includeOpt = strMatch.split(' ');\n      const includeName = includeOpt[0].replace(/\"/g, '');\n      if (includeList.indexOf(includeName) > -1) {\n        return '';\n      }\n      const txt = this.rawContentCache[includeName][type];\n      includeList.push(includeName);\n      const {\n        content\n      } = this.processModule(txt, includeList, type);\n      return content;\n    });\n    return {\n      content: compiled,\n      includeList\n    };\n  }\n}\n\n/** Generates defines from an object of key value pairs */\nfunction getInjectDefines(defines) {\n  const defineStr = Object.keys(defines).reduce((prev, cur) => {\n    return prev + `#define ${cur.toUpperCase()} ${defines[cur]}\\n`;\n  }, '\\n');\n  return defineStr;\n}","map":{"version":3,"names":["_objectSpread","_defineProperty","lodashUtil","extractUniforms","uniq","common","light","decode","lighting","pickingFrag","pickingVert","picking_uniforms","project","projection","rotation_2d","scene_uniforms","sdf2d","precisionRegExp","globalDefaultprecision","includeRegExp","REGEX_START_OF_MAIN","ShaderModuleService","constructor","registerBuiltinModules","destroy","registerModule","vs","fs","moduleName","moduleParams","replace","uniforms","declaredUniforms","defines","inject","content","extractedVS","vsUniforms","extractedFS","fsUniforms","rawContentCache","getModule","rawVS","rawFS","match","injectDefines","getInjectDefines","includeList","vsIncludeList","processModule","fsIncludeList","concat","reduce","prev","cur","compiledVs","test","compiledFs","moduleCache","trim","rawContent","type","compiled","_","strMatch","includeOpt","split","includeName","indexOf","txt","push","defineStr","Object","keys","toUpperCase"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/l7-core/es/services/shader/ShaderModuleService.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { lodashUtil } from '@antv/l7-utils';\nimport { extractUniforms } from \"../../utils/shader-module\";\nconst {\n  uniq\n} = lodashUtil;\n/* babel-plugin-inline-import '../../shaders/common.glsl' */\nconst common = \"#define PI 3.14159265359\";\n/* babel-plugin-inline-import '../../shaders/common_light.glsl' */\nconst light = \"#define ambientRatio 0.5\\n#define diffuseRatio 0.3\\n#define specularRatio 0.2\\n\\n\\nfloat calc_lighting(vec4 pos) {\\n\\n    vec3 worldPos = vec3(pos * u_ModelMatrix);\\n\\n    vec3 worldNormal = a_Normal;\\n      // //cal light weight\\n    vec3 viewDir = normalize(u_CameraPosition - worldPos);\\n\\n    vec3 lightDir = normalize(vec3(1, -10.5, 12));\\n\\n    vec3 halfDir = normalize(viewDir+lightDir);\\n      // //lambert\\n    float lambert = dot(worldNormal, lightDir);\\n        //specular\\n    float specular = pow(max(0.0, dot(worldNormal, halfDir)), 32.0);\\n        //sum to light weight\\n    float lightWeight = ambientRatio + diffuseRatio * lambert + specularRatio * specular;\\n\\n    return lightWeight;\\n}\\n\";\n/* babel-plugin-inline-import '../../shaders/decode.glsl' */\nconst decode = \"#define SHIFT_RIGHT17 1.0 / 131072.0\\n#define SHIFT_RIGHT18 1.0 / 262144.0\\n#define SHIFT_RIGHT19 1.0 / 524288.0\\n#define SHIFT_RIGHT20 1.0 / 1048576.0\\n#define SHIFT_RIGHT21 1.0 / 2097152.0\\n#define SHIFT_RIGHT22 1.0 / 4194304.0\\n#define SHIFT_RIGHT23 1.0 / 8388608.0\\n#define SHIFT_RIGHT24 1.0 / 16777216.0\\n\\n#define SHIFT_LEFT17 131072.0\\n#define SHIFT_LEFT18 262144.0\\n#define SHIFT_LEFT19 524288.0\\n#define SHIFT_LEFT20 1048576.0\\n#define SHIFT_LEFT21 2097152.0\\n#define SHIFT_LEFT22 4194304.0\\n#define SHIFT_LEFT23 8388608.0\\n#define SHIFT_LEFT24 16777216.0\\n\\nvec2 unpack_float(float packedValue) {\\n  int packedIntValue = int(packedValue);\\n  int v0 = packedIntValue / 256;\\n  return vec2(v0, packedIntValue - v0 * 256);\\n}\\n\\nvec4 decode_color(vec2 encodedColor) {\\n  return vec4(\\n    unpack_float(encodedColor[0]) / 255.0,\\n    unpack_float(encodedColor[1]) / 255.0\\n  );\\n}\\n\";\n/* babel-plugin-inline-import '../../shaders/lighting.glsl' */\nconst lighting = \"// Blinn-Phong model\\n// apply lighting in vertex shader instead of fragment shader\\n// @see https://learnopengl.com/Advanced-Lighting/Advanced-Lighting\\nuniform float u_Ambient : 1.0;\\nuniform float u_Diffuse : 1.0;\\nuniform float u_Specular : 1.0;\\nuniform int u_NumOfDirectionalLights : 1;\\nuniform int u_NumOfSpotLights : 0;\\n\\n#define SHININESS 32.0\\n#define MAX_NUM_OF_DIRECTIONAL_LIGHTS 3\\n#define MAX_NUM_OF_SPOT_LIGHTS 3\\n\\nstruct DirectionalLight {\\n  vec3 direction;\\n  vec3 ambient;\\n  vec3 diffuse;\\n  vec3 specular;\\n};\\n\\nstruct SpotLight {\\n  vec3 position;\\n  vec3 direction;\\n  vec3 ambient;\\n  vec3 diffuse;\\n  vec3 specular;\\n  float constant;\\n  float linear;\\n  float quadratic;\\n  float angle;\\n  float blur;\\n  float exponent;\\n};\\n\\nuniform DirectionalLight u_DirectionalLights[MAX_NUM_OF_DIRECTIONAL_LIGHTS];\\nuniform SpotLight u_SpotLights[MAX_NUM_OF_SPOT_LIGHTS];\\n\\nvec3 calc_directional_light(DirectionalLight light, vec3 normal, vec3 viewDir) {\\n  vec3 lightDir = normalize(light.direction);\\n  // diffuse shading\\n  float diff = max(dot(normal, lightDir), 0.0);\\n  // Blinn-Phong specular shading\\n  vec3 halfwayDir = normalize(lightDir + viewDir);\\n  float spec = pow(max(dot(normal, halfwayDir), 0.0), SHININESS);\\n\\n  vec3 ambient = light.ambient * u_Ambient;\\n  vec3 diffuse = light.diffuse * diff * u_Diffuse;\\n  vec3 specular = light.specular * spec * u_Specular;\\n\\n  return ambient + diffuse + specular;\\n}\\n\\n\\nvec3 calc_lighting(vec3 position, vec3 normal, vec3 viewDir) {\\n  vec3 weight = vec3(0.0);\\n  for (int i = 0; i < MAX_NUM_OF_DIRECTIONAL_LIGHTS; i++) {\\n    if (i >= u_NumOfDirectionalLights) {\\n      break;\\n    }\\n    weight += calc_directional_light(u_DirectionalLights[i], normal, viewDir);\\n  }\\n  return weight;\\n}\\n\";\n/* babel-plugin-inline-import '../../shaders/picking.frag.glsl' */\nconst pickingFrag = \"\\nin vec4 v_PickingResult;\\n\\n#pragma include \\\"picking_uniforms\\\"\\n\\n#define PICKING_NONE 0.0\\n#define PICKING_ENCODE 1.0\\n#define PICKING_HIGHLIGHT 2.0\\n#define COLOR_SCALE 1. / 255.\\n\\n#define HIGHLIGHT 1.0\\n#define SELECT 2.0\\n\\n/*\\n * Returns highlight color if this item is selected.\\n */\\nvec4 filterHighlightColor(vec4 color, float weight) {\\n  float activeType = v_PickingResult.a;\\n  if(activeType > 0.0) {\\n    vec4 highLightColor =  activeType > 1.5 ? u_SelectColor : u_HighlightColor;\\n    highLightColor = highLightColor * COLOR_SCALE;\\n    float highLightAlpha = highLightColor.a;\\n    float highLightRatio = highLightAlpha / (highLightAlpha + color.a * (1.0 - highLightAlpha));\\n    vec3 resultRGB = mix(color.rgb, highLightColor.rgb, highLightRatio);\\n    return vec4(mix(resultRGB * weight, color.rgb, u_activeMix), color.a);\\n  }\\n  else {\\n    return color;\\n  }\\n\\n  \\n}\\n\\n/*\\n * Returns picking color if picking enabled else unmodified argument.\\n */\\nvec4 filterPickingColor(vec4 color) {\\n  vec3 pickingColor = v_PickingResult.rgb;\\n  if (u_PickingStage == PICKING_ENCODE && length(pickingColor) < 0.001) {\\n    discard;\\n  }\\n  return u_PickingStage == PICKING_ENCODE ? vec4(pickingColor, step(0.001,color.a)): color;\\n}\\n\\n/*\\n * Returns picking color if picking is enabled if not\\n * highlight color if this item is selected, otherwise unmodified argument.\\n */\\nvec4 filterColor(vec4 color) {\\n  // \\u8FC7\\u6EE4\\u591A\\u4F59\\u7684 shader \\u8BA1\\u7B97\\n  // return color;\\n  if(u_shaderPick < 0.5) {\\n    return color; // \\u6682\\u65F6\\u53BB\\u9664 \\u76F4\\u63A5\\u53D6\\u6D88\\u8BA1\\u7B97\\u5728\\u9009\\u4E2D\\u65F6\\u62D6\\u62FD\\u5730\\u56FE\\u4F1A\\u6709\\u95EE\\u9898\\n  } else {\\n    return filterPickingColor(filterHighlightColor(color, 1.0));\\n  }\\n  \\n}\\n\\nvec4 filterColorAlpha(vec4 color, float alpha) {\\n  // \\u8FC7\\u6EE4\\u591A\\u4F59\\u7684 shader \\u8BA1\\u7B97\\n  // return color;\\n  if(u_shaderPick < 0.5) {\\n    return color; // \\u6682\\u65F6\\u53BB\\u9664 \\u76F4\\u63A5\\u53D6\\u6D88\\u8BA1\\u7B97\\u5728\\u9009\\u4E2D\\u65F6\\u62D6\\u62FD\\u5730\\u56FE\\u4F1A\\u6709\\u95EE\\u9898\\n  } else {\\n    return filterPickingColor(filterHighlightColor(color, alpha));\\n  }\\n}\\n\\n\";\n/* babel-plugin-inline-import '../../shaders/picking.vert.glsl' */\nconst pickingVert = \"layout(location = ATTRIBUTE_LOCATION_PICKING_COLOR) in vec3 a_PickingColor;\\nout vec4 v_PickingResult;\\n\\n#pragma include \\\"picking_uniforms\\\"\\n\\n#define PICKING_NONE 0.0\\n#define PICKING_ENCODE 1.0\\n#define PICKING_HIGHLIGHT 2.0\\n#define COLOR_SCALE 1. / 255.\\n\\n#define NORMAL 0.0\\n#define HIGHLIGHT 1.0\\n#define SELECT 2.0\\n\\nbool isVertexPicked(vec3 vertexColor) {\\n  return distance(vertexColor,u_PickingColor.rgb) < 0.01;\\n}\\n\\n// \\u5224\\u65AD\\u5F53\\u524D\\u70B9\\u662F\\u5426\\u5DF2\\u7ECF\\u88AB select \\u9009\\u4E2D\\nbool isVertexSelected(vec3 vertexColor) {\\n  return distance(vertexColor,u_CurrentSelectedId.rgb) < 0.01;\\n}\\n\\nvoid setPickingColor(vec3 pickingColor) {\\n  if(u_shaderPick < 0.5) {\\n    return;\\n  }\\n  // compares only in highlight stage\\n\\n  if(u_PickingStage == PICKING_HIGHLIGHT) {\\n    if(isVertexPicked(pickingColor)) {\\n       v_PickingResult = vec4(pickingColor.rgb * COLOR_SCALE,HIGHLIGHT);\\n       return;\\n    }\\n    if(isVertexSelected(pickingColor)) {\\n     v_PickingResult = vec4(u_CurrentSelectedId.rgb * COLOR_SCALE,SELECT);\\n      return;\\n    }\\n\\n  } else {\\n      v_PickingResult= vec4(pickingColor.rgb * COLOR_SCALE,NORMAL);\\n      return;\\n  }\\n\\n  // // v_PickingResult.a = float((u_PickingStage == PICKING_HIGHLIGHT) && (isVertexPicked(pickingColor) || isVertexPicked(u_CurrentSelectedId)));\\n\\n  // // Stores the picking color so that the fragment shader can render it during picking\\n  // v_PickingResult.rgb = pickingColor * COLOR_SCALE;\\n}\\n\\nfloat setPickingSize(float x) {\\n   return u_PickingStage == PICKING_ENCODE ? x + u_PickingBuffer : x;\\n}\\n\\nfloat setPickingOrder(float z) {\\n   bool selected = bool(v_PickingResult.a);\\n   return selected ? z + 1. : 0.;\\n}\\n\";\n/* babel-plugin-inline-import '../../shaders/picking_uniforms.glsl' */\nconst picking_uniforms = \"layout(std140) uniform PickingUniforms {\\n  vec4 u_HighlightColor;\\n  vec4 u_SelectColor;\\n  vec3 u_PickingColor;\\n  float u_PickingStage;\\n  vec3 u_CurrentSelectedId;\\n  float u_PickingThreshold;\\n  float u_PickingBuffer;\\n  float u_shaderPick;\\n  float u_activeMix;\\n};\";\n/* babel-plugin-inline-import '../../shaders/project.glsl' */\nconst project = \"\\n#define E 2.718281828459045\\nvec2 ProjectFlat(vec2 lnglat){\\n  float maxs=85.0511287798;\\n  float lat=max(min(maxs,lnglat.y),-maxs);\\n  float scale= 268435456.;\\n  float d=PI/180.;\\n  float x=lnglat.x*d;\\n  float y=lat*d;\\n  y=log(tan((PI/4.)+(y/2.)));\\n\\n  float a=.5/PI,\\n  b=.5,\\n  c=-.5/PI;\\n  d=.5;\\n  x=scale*(a*x+b);\\n  y=scale*(c*y+d);\\n  return vec2(x,y);\\n}\\n\\nvec2 unProjectFlat(vec2 px){\\n  float a=.5/PI;\\n  float b=.5;\\n  float c=-.5/PI;\\n  float d=.5;\\n  float scale = 268435456.;\\n  float x=(px.x/scale-b)/a;\\n  float y=(px.y/scale-d)/c;\\n  y=(atan(pow(E,y))-(PI/4.))*2.;\\n  d=PI/180.;\\n  float lat=y/d;\\n  float lng=x/d;\\n  return vec2(lng,lat);\\n}\\n\\nfloat pixelDistance(vec2 from, vec2 to) {\\n vec2 a1 = ProjectFlat(from);\\n vec2 b1 = ProjectFlat(to);\\n return distance(a1, b1);\\n}\\n\\n// gaode2.0\\nvec2 customProject(vec2 lnglat) { // \\u7ECF\\u7EAC\\u5EA6 => \\u5E73\\u9762\\u5750\\u6807\\n  float t = lnglat.x;\\n  float e = lnglat.y;\\n  float Sm = 180.0 / PI;\\n  float Tm = 6378137.0;\\n  float Rm = PI / 180.0;\\n  float r = 85.0511287798;\\n  e = max(min(r, e), -r);\\n  t *= Rm;\\n  e *= Rm;\\n  e = log(tan(PI / 4.0 + e / 2.0));\\n  return vec2(t * Tm, e * Tm);\\n}\\n\\nvec2 unProjCustomCoord(vec2 point) { // \\u5E73\\u9762\\u5750\\u6807 => \\u7ECF\\u7EAC\\u5EA6\\n  float Sm = 57.29577951308232; //180 / Math.PI\\n  float Tm = 6378137.0;\\n  float t = point.x;\\n  float e = point.y;\\n  return vec2(t / Tm * Sm, (2.0 * atan(exp(e / Tm)) - PI / 2.0) * Sm);\\n}\\n\\n\\nfloat customPixelDistance(vec2 from, vec2 to) {\\n vec2 a1 = ProjectFlat(from);\\n vec2 b1 = ProjectFlat(to);\\n return distance(a1, b1);\\n}\";\n/* babel-plugin-inline-import '../../shaders/projection.glsl' */\nconst projection = \"#define TILE_SIZE (512.0)\\n#define PI (3.1415926536)\\n#define WORLD_SCALE (TILE_SIZE / (PI * 2.0))\\n#define EARTH_CIRCUMFERENCE (40.03e6)\\n\\n#define COORDINATE_SYSTEM_LNGLAT (1.0) // mapbox\\n#define COORDINATE_SYSTEM_LNGLAT_OFFSET (2.0) // mapbox offset\\n#define COORDINATE_SYSTEM_VECTOR_TILE (3.0)\\n#define COORDINATE_SYSTEM_IDENTITY (4.0)\\n#define COORDINATE_SYSTEM_METER_OFFSET (5.0)\\n\\n#pragma include \\\"scene_uniforms\\\"\\n\\nconst vec2 ZERO_64_XY_LOW = vec2(0.0, 0.0);\\n\\n// web mercator coords -> world coords\\nvec2 project_mercator(vec2 lnglat) {\\n  float x = lnglat.x;\\n  return vec2(radians(x) + PI, PI - log(tan(PI * 0.25 + radians(lnglat.y) * 0.5)));\\n}\\n\\nfloat project_scale(float meters) {\\n  return meters * u_PixelsPerMeter.z;\\n}\\n\\n// offset coords -> world coords\\nvec4 project_offset(vec4 offset) {\\n  float dy = offset.y;\\n  dy = clamp(dy, -1.0, 1.0);\\n  vec3 pixels_per_unit = u_PixelsPerDegree + u_PixelsPerDegree2 * dy;\\n  return vec4(offset.xyz * pixels_per_unit, offset.w);\\n}\\n\\nvec3 project_normal(vec3 normal) {\\n  vec4 normal_modelspace = u_ModelMatrix * vec4(normal, 0.0);\\n  return normalize(normal_modelspace.xyz * u_PixelsPerMeter);\\n}\\n\\nvec3 project_offset_normal(vec3 vector) {\\n  if (\\n    u_CoordinateSystem < COORDINATE_SYSTEM_LNGLAT + 0.01 &&\\n      u_CoordinateSystem > COORDINATE_SYSTEM_LNGLAT - 0.01 ||\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\\n  ) {\\n    // normals generated by the polygon tesselator are in lnglat offsets instead of meters\\n    return normalize(vector * u_PixelsPerDegree);\\n  }\\n  return project_normal(vector);\\n}\\n\\nvec4 project_position(vec4 position, vec2 position64xyLow) {\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\\n    float X = position.x - u_ViewportCenter.x;\\n    float Y = position.y - u_ViewportCenter.y;\\n    return project_offset(\\n      vec4(X + position64xyLow.x, Y + position64xyLow.y, position.z, position.w)\\n    );\\n  }\\n  if (\\n    u_CoordinateSystem < COORDINATE_SYSTEM_LNGLAT + 0.01 &&\\n    u_CoordinateSystem > COORDINATE_SYSTEM_LNGLAT - 0.01\\n  ) {\\n    return vec4(\\n      project_mercator(position.xy) * WORLD_SCALE * u_ZoomScale,\\n      project_scale(position.z),\\n      position.w\\n    );\\n  }\\n\\n  return position;\\n}\\n\\nvec4 project_position(vec4 position) {\\n  return project_position(position, ZERO_64_XY_LOW);\\n}\\n\\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\\n  vec2 offset = pixels / u_ViewportSize * u_DevicePixelRatio * 2.0;\\n  return offset * u_FocalDistance;\\n}\\n\\n// \\u9002\\u914D\\u7EB9\\u7406\\u8D34\\u56FE\\u7684\\u7B49\\u50CF\\u7D20\\u5927\\u5C0F\\nfloat project_pixel_texture(float pixel) {\\n  // mapbox zoom > 12\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\\n    return pixel * pow(0.5, u_Zoom) * u_FocalDistance;\\n  }\\n\\n  return pixel * 2.0 * u_FocalDistance;\\n}\\n\\n// \\u5728\\u4E0D\\u8BBA\\u4EC0\\u4E48\\u5E95\\u56FE\\u4E0B\\u9700\\u8981\\u7EDF\\u4E00\\u5904\\u7406\\u7684\\u65F6\\u5019\\u4F7F\\u7528\\nfloat project_float_pixel(float pixel) {\\n  if (\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\\n  ) {\\n    // mapbox \\u5750\\u6807\\u7CFB\\u4E0B\\uFF0C\\u4E3A\\u4E86\\u548C Web \\u58A8\\u5361\\u6258\\u5750\\u6807\\u7CFB\\u7EDF\\u4E00\\uFF0Czoom \\u9ED8\\u8BA4\\u51CF1\\n    return pixel * pow(2.0, 19.0 - u_Zoom) * u_FocalDistance;\\n  }\\n\\n  return pixel * u_FocalDistance;\\n}\\n\\n// Project meter into the unit of pixel which used in the camera world space\\nfloat project_float_meter(float meter) {\\n  if (\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\\n  ) {\\n    // Since the zoom level uniform is updated by mapservice and it's alread been subtracted by 1\\n    // Not sure if we are supposed to do that again\\n    return meter;\\n  } else {\\n    return project_float_pixel(meter);\\n  }\\n\\n  // TODO: change the following code to make adaptations for amap\\n  // return u_FocalDistance * TILE_SIZE * pow(2.0, u_Zoom) * meter / EARTH_CIRCUMFERENCE;\\n\\n}\\n\\nfloat project_pixel(float pixel) {\\n  return pixel * u_FocalDistance;\\n}\\n\\nvec2 project_pixel(vec2 pixel) {\\n  return pixel * -1.0 * u_FocalDistance;\\n}\\n\\nvec3 project_pixel(vec3 pixel) {\\n  return pixel * -1.0 * u_FocalDistance;\\n}\\n\\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\\n  if (\\n    u_CoordinateSystem == COORDINATE_SYSTEM_METER_OFFSET ||\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\\n  ) {\\n    // Needs to be divided with project_uCommonUnitsPerMeter\\n    position.w *= u_PixelsPerMeter.z;\\n  }\\n\\n  return viewProjectionMatrix * position + center;\\n}\\n\\n// Projects from common space coordinates to clip space\\nvec4 project_common_position_to_clipspace(vec4 position) {\\n  return project_common_position_to_clipspace(\\n    position,\\n    u_ViewProjectionMatrix,\\n    u_ViewportCenterProjection\\n  );\\n}\\n\\nvec4 unproject_clipspace_to_position(vec4 clipspacePos, mat4 u_InverseViewProjectionMatrix) {\\n  vec4 pos = u_InverseViewProjectionMatrix * (clipspacePos - u_ViewportCenterProjection);\\n\\n  if (\\n    u_CoordinateSystem == COORDINATE_SYSTEM_METER_OFFSET ||\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\\n  ) {\\n    // Needs to be divided with project_uCommonUnitsPerMeter\\n    pos.w = pos.w / u_PixelsPerMeter.z;\\n  }\\n  return pos;\\n}\\n\\nbool isEqual(float a, float b) {\\n  return a < b + 0.001 && a > b - 0.001;\\n}\\n\\n\";\n/* babel-plugin-inline-import '../../shaders/rotation_2d.glsl' */\nconst rotation_2d = \"vec2 rotate_matrix(vec2 v, float a) {\\n    float b = a / 180.0 * 3.1415926535897932384626433832795;\\n    float s = sin(b);\\n    float c = cos(b);\\n    mat2 m = mat2(c, s, -s, c);\\n    return m * v;\\n}\";\n/* babel-plugin-inline-import '../../shaders/scene_uniforms.glsl' */\nconst scene_uniforms = \"layout(std140) uniform SceneUniforms {\\n  mat4 u_ViewMatrix;\\n  mat4 u_ProjectionMatrix;\\n  mat4 u_ViewProjectionMatrix;\\n  mat4 u_ModelMatrix;\\n  vec4 u_ViewportCenterProjection;\\n  vec3 u_PixelsPerDegree;\\n  float u_Zoom;\\n  vec3 u_PixelsPerDegree2;\\n  float u_ZoomScale;\\n  vec3 u_PixelsPerMeter;\\n  float u_CoordinateSystem;\\n  vec3 u_CameraPosition;\\n  float u_DevicePixelRatio;\\n  vec2 u_ViewportCenter;\\n  vec2 u_ViewportSize;\\n  float u_FocalDistance;\\n};\\n\";\n/* babel-plugin-inline-import '../../shaders/sdf_2d.glsl' */\nconst sdf2d = \"/**\\n * 2D signed distance field functions\\n * @see http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\\n */\\n\\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\\n\\nfloat sdCircle(vec2 p, float r) {\\n  return length(p) - r;\\n}\\n\\nfloat sdEquilateralTriangle(vec2 p) {\\n  float k = sqrt(3.0);\\n  p.x = abs(p.x) - 1.0;\\n  p.y = p.y + 1.0/k;\\n  if( p.x + k*p.y > 0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\\n  p.x -= clamp( p.x, -2.0, 0.0 );\\n  return -length(p)*sign(p.y);\\n}\\n\\nfloat sdBox(vec2 p, vec2 b) {\\n  vec2 d = abs(p)-b;\\n  return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\\n}\\n\\nfloat sdPentagon(vec2 p, float r) {\\n  vec3 k = vec3(0.809016994,0.587785252,0.726542528);\\n  p.x = abs(p.x);\\n  p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\\n  p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\\n  p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdHexagon(vec2 p, float r) {\\n  vec3 k = vec3(-0.866025404,0.5,0.577350269);\\n  p = abs(p);\\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdOctogon(vec2 p, float r) {\\n  vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\\n  p = abs(p);\\n  p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\\n  p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdHexagram(vec2 p, float r) {\\n  vec4 k=vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\\n  p = abs(p);\\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\\n  p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\\n  p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdRhombus(vec2 p, vec2 b) {\\n  vec2 q = abs(p);\\n  float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\\n  float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\\n  return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\\n}\\n\\nfloat sdVesica(vec2 p, float r, float d) {\\n  p = abs(p);\\n  float b = sqrt(r*r-d*d); // can delay this sqrt\\n  return ((p.y-b)*d>p.x*b)\\n          ? length(p-vec2(0.0,b))\\n          : length(p-vec2(-d,0.0))-r;\\n}\\n\";\nconst precisionRegExp = /precision\\s+(high|low|medium)p\\s+float/;\nconst globalDefaultprecision = '#ifdef GL_FRAGMENT_PRECISION_HIGH\\n precision highp float;\\n #else\\n precision mediump float;\\n#endif\\n';\nconst includeRegExp = /#pragma include ([\"^+\"]?[\"[a-zA-Z_0-9](.*)\"]*?)/g;\nconst REGEX_START_OF_MAIN = /void\\s+main\\s*\\([^)]*\\)\\s*\\{\\n?/; // Beginning of main\n\nexport default class ShaderModuleService {\n  constructor() {\n    _defineProperty(this, \"moduleCache\", {});\n    _defineProperty(this, \"rawContentCache\", {});\n  }\n  registerBuiltinModules() {\n    this.destroy();\n    this.registerModule('common', {\n      vs: common,\n      fs: common\n    });\n    this.registerModule('decode', {\n      vs: decode,\n      fs: ''\n    });\n    this.registerModule('scene_uniforms', {\n      vs: scene_uniforms,\n      fs: scene_uniforms\n    });\n    this.registerModule('picking_uniforms', {\n      vs: picking_uniforms,\n      fs: picking_uniforms\n    });\n    this.registerModule('projection', {\n      vs: projection,\n      fs: projection\n    });\n    this.registerModule('project', {\n      vs: project,\n      fs: ''\n    });\n    this.registerModule('sdf_2d', {\n      vs: '',\n      fs: sdf2d\n    });\n    this.registerModule('lighting', {\n      vs: lighting,\n      fs: ''\n    });\n    this.registerModule('light', {\n      vs: light,\n      fs: ''\n    });\n    this.registerModule('picking', {\n      vs: pickingVert,\n      fs: pickingFrag\n    });\n    this.registerModule('rotation_2d', {\n      vs: rotation_2d,\n      fs: ''\n    });\n  }\n  registerModule(moduleName, moduleParams) {\n    // prevent registering the same module multiple times\n    // if (this.rawContentCache[moduleName]) {\n    //   return;\n    // }\n\n    moduleParams.vs = moduleParams.vs.replace(/\\r\\n/g, '\\n'); // 将所有的\\r\\n替换为\\n\n    moduleParams.fs = moduleParams.fs.replace(/\\r\\n/g, '\\n'); // 将所有的\\r\\n替换为\\n\n    const {\n      vs,\n      fs,\n      uniforms: declaredUniforms,\n      defines,\n      inject\n    } = moduleParams;\n    const {\n      content: extractedVS,\n      uniforms: vsUniforms\n    } = extractUniforms(vs);\n    const {\n      content: extractedFS,\n      uniforms: fsUniforms\n    } = extractUniforms(fs);\n    this.rawContentCache[moduleName] = {\n      fs: extractedFS,\n      defines,\n      inject,\n      uniforms: _objectSpread(_objectSpread(_objectSpread({}, vsUniforms), fsUniforms), declaredUniforms),\n      vs: extractedVS\n    };\n  }\n  getModule(moduleName) {\n    // TODO: cache module\n    // if (this.moduleCache[moduleName]) {\n    //   return this.moduleCache[moduleName];\n    // }\n\n    let rawVS = this.rawContentCache[moduleName].vs;\n    let rawFS = this.rawContentCache[moduleName].fs;\n    const {\n      defines = {},\n      inject = {}\n    } = this.rawContentCache[moduleName];\n    let declaredUniforms = {};\n\n    // vs 头部注入\n    if (inject['vs:#decl']) {\n      rawVS = inject['vs:#decl'] + rawVS;\n      declaredUniforms = extractUniforms(inject['vs:#decl']).uniforms;\n    }\n\n    // vs main\n    if (inject['vs:#main-start']) {\n      rawVS = rawVS.replace(REGEX_START_OF_MAIN, match => {\n        return match + inject['vs:#main-start'];\n      });\n    }\n\n    // fs 头部注入\n    if (inject['fs:#decl']) {\n      rawFS = inject['fs:#decl'] + rawFS;\n    }\n    const injectDefines = getInjectDefines(defines);\n\n    // 注入定义的宏\n    rawVS = injectDefines + rawVS;\n    const {\n      content: vs,\n      includeList: vsIncludeList\n    } = this.processModule(rawVS, [], 'vs');\n    const {\n      content: fs,\n      includeList: fsIncludeList\n    } = this.processModule(rawFS, [], 'fs');\n\n    // TODO: extract uniforms and their default values from GLSL\n    const uniforms = uniq(vsIncludeList.concat(fsIncludeList).concat(moduleName)).reduce((prev, cur) => {\n      return _objectSpread(_objectSpread({}, prev), this.rawContentCache[cur].uniforms);\n    }, _objectSpread({}, declaredUniforms));\n\n    /**\n     * set default precision for fragment shader\n     * https://stackoverflow.com/questions/28540290/why-it-is-necessary-to-set-precision-for-the-fragment-shader\n     */\n    const compiledVs = (precisionRegExp.test(fs) ? '' : globalDefaultprecision) + vs;\n    const compiledFs = (precisionRegExp.test(fs) ? '' : globalDefaultprecision) + fs;\n    this.moduleCache[moduleName] = {\n      vs: compiledVs.trim(),\n      fs: compiledFs.trim(),\n      uniforms\n    };\n    return this.moduleCache[moduleName];\n  }\n  destroy() {\n    this.moduleCache = {};\n    this.rawContentCache = {};\n  }\n\n  /**\n   *\n   * 解析定义的内联模块\n   * like: #pragma include \"projection\"\n   */\n  processModule(rawContent, includeList, type) {\n    const compiled = rawContent.replace(includeRegExp, (_, strMatch) => {\n      const includeOpt = strMatch.split(' ');\n      const includeName = includeOpt[0].replace(/\"/g, '');\n      if (includeList.indexOf(includeName) > -1) {\n        return '';\n      }\n      const txt = this.rawContentCache[includeName][type];\n      includeList.push(includeName);\n      const {\n        content\n      } = this.processModule(txt, includeList, type);\n      return content;\n    });\n    return {\n      content: compiled,\n      includeList\n    };\n  }\n}\n\n/** Generates defines from an object of key value pairs */\nfunction getInjectDefines(defines) {\n  const defineStr = Object.keys(defines).reduce((prev, cur) => {\n    return prev + `#define ${cur.toUpperCase()} ${defines[cur]}\\n`;\n  }, '\\n');\n  return defineStr;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}