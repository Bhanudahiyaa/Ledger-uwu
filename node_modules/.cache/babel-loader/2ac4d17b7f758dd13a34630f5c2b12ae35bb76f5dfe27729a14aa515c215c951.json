{"ast":null,"code":"// src/lineAtOffset/arc.ts\nfunction arcLineAtOffset(source, target, offset, thetaOffset, segmentNumber = 30, autoFit) {\n  let pointOffset = offset;\n  if (autoFit) {\n    pointOffset = Math.round(offset * (segmentNumber - 1)) / (segmentNumber - 1);\n  }\n  if (!thetaOffset) {\n    return interpolate(source, target, pointOffset, 0.314);\n  } else {\n    return interpolate(source, target, pointOffset, thetaOffset);\n  }\n}\nfunction bezier3(arr, t) {\n  const ut = 1 - t;\n  return (arr[0] * ut + arr[1] * t) * ut + (arr[1] * ut + arr[2] * t) * t;\n}\nfunction calDistance(p1, p2) {\n  return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n}\nfunction midPoint(source, target, thetaOffset) {\n  const center = [target[0] - source[0], target[1] - source[1]];\n  const r = calDistance(center, [0, 0]);\n  const theta = Math.atan2(center[1], center[0]);\n  const r2 = r / 2 / Math.cos(thetaOffset);\n  const theta2 = theta + thetaOffset;\n  const mid = [r2 * Math.cos(theta2) + source[0], r2 * Math.sin(theta2) + source[1]];\n  return mid;\n}\nfunction interpolate(source, target, offset, thetaOffset) {\n  const mid = midPoint(source, target, thetaOffset);\n  const x = [source[0], mid[0], target[0]];\n  const y = [source[1], mid[1], target[1]];\n  return [bezier3(x, offset), bezier3(y, offset), 0];\n}\nexport { arcLineAtOffset };","map":{"version":3,"names":["arcLineAtOffset","source","target","offset","thetaOffset","segmentNumber","autoFit","pointOffset","Math","round","interpolate","bezier3","arr","t","ut","calDistance","p1","p2","sqrt","pow","midPoint","center","r","theta","atan2","r2","cos","theta2","mid","sin","x","y"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/l7-utils/es/lineAtOffset/arc.js"],"sourcesContent":["// src/lineAtOffset/arc.ts\nfunction arcLineAtOffset(source, target, offset, thetaOffset, segmentNumber = 30, autoFit) {\n  let pointOffset = offset;\n  if (autoFit) {\n    pointOffset = Math.round(offset * (segmentNumber - 1)) / (segmentNumber - 1);\n  }\n  if (!thetaOffset) {\n    return interpolate(source, target, pointOffset, 0.314);\n  } else {\n    return interpolate(source, target, pointOffset, thetaOffset);\n  }\n}\nfunction bezier3(arr, t) {\n  const ut = 1 - t;\n  return (arr[0] * ut + arr[1] * t) * ut + (arr[1] * ut + arr[2] * t) * t;\n}\nfunction calDistance(p1, p2) {\n  return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n}\nfunction midPoint(source, target, thetaOffset) {\n  const center = [target[0] - source[0], target[1] - source[1]];\n  const r = calDistance(center, [0, 0]);\n  const theta = Math.atan2(center[1], center[0]);\n  const r2 = r / 2 / Math.cos(thetaOffset);\n  const theta2 = theta + thetaOffset;\n  const mid = [r2 * Math.cos(theta2) + source[0], r2 * Math.sin(theta2) + source[1]];\n  return mid;\n}\nfunction interpolate(source, target, offset, thetaOffset) {\n  const mid = midPoint(source, target, thetaOffset);\n  const x = [source[0], mid[0], target[0]];\n  const y = [source[1], mid[1], target[1]];\n  return [bezier3(x, offset), bezier3(y, offset), 0];\n}\nexport {\n  arcLineAtOffset\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}