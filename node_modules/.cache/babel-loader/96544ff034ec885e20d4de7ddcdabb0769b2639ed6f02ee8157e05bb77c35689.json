{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport { AST_TOKEN_TYPES, createEntity, STORAGE_CLASS } from '@antv/g-webgpu-core';\nimport { isTypedArray } from '../utils/is-typedarray';\n\n/* babel-plugin-inline-import './shaders/quad.vert.glsl' */\nvar quadVert = \"attribute vec3 a_Position;\\nattribute vec2 a_TexCoord;\\n\\nvarying vec2 v_TexCoord;\\n\\nvoid main() {\\n  gl_Position = vec4(a_Position, 1.0);\\n  v_TexCoord = a_TexCoord;\\n}\";\nvar textureId = 0;\nvar debug = false;\n/**\n * adaptor for regl.DrawCommand\n */\n\nvar ReglComputeModel = /*#__PURE__*/function () {\n  function ReglComputeModel(reGl, context) {\n    var _this = this;\n    _classCallCheck(this, ReglComputeModel);\n    this.reGl = reGl;\n    this.context = context;\n    this.entity = createEntity();\n    this.texFBO = void 0;\n    this.computeCommand = void 0;\n    this.textureCache = {};\n    this.outputTextureName = void 0;\n    this.swapOutputTextureName = void 0;\n    this.compiledPingpong = void 0;\n    this.dynamicPingpong = void 0;\n    var uniforms = {};\n    this.context.uniforms.forEach(function (uniform) {\n      var name = uniform.name,\n        type = uniform.type,\n        data = uniform.data,\n        isReferer = uniform.isReferer,\n        storageClass = uniform.storageClass; // store data with a 2D texture\n\n      if (storageClass === STORAGE_CLASS.StorageBuffer) {\n        if (!isReferer) {\n          _this.textureCache[name] = _this.calcDataTexture(name, type, data);\n          var _this$textureCache$na = _this.textureCache[name],\n            width = _this$textureCache$na.textureWidth,\n            isOutput = _this$textureCache$na.isOutput;\n          uniforms[\"\".concat(name, \"Size\")] = [width, width];\n          if (isOutput) {\n            _this.outputTextureName = name;\n            if (_this.context.needPingpong) {\n              _this.outputTextureName = \"\".concat(name, \"Output\");\n              _this.textureCache[_this.outputTextureName] = _this.calcDataTexture(name, type, data);\n            }\n          }\n        } else {\n          // @ts-ignore\n          _this.textureCache[name] = {\n            data: undefined\n          }; // refer to another kernel's output,\n          // the referred kernel may not have been initialized, so we use dynamic way here\n\n          uniforms[\"\".concat(name, \"Size\")] = function () {\n            return (\n              // @ts-ignore\n              data.compiledBundle.context.output.textureSize\n            );\n          };\n        }\n        uniforms[name] = function () {\n          if (debug) {\n            console.log(\"[\".concat(_this.entity, \"]: \").concat(name, \" \").concat(_this.textureCache[name].id));\n          }\n          return _this.textureCache[name].texture;\n        };\n      } else if (storageClass === STORAGE_CLASS.Uniform) {\n        if (data && (Array.isArray(data) || isTypedArray(data)) && data.length > 16) {\n          // up to mat4 which includes 16 elements\n          throw new Error(\"invalid data type \".concat(type));\n        } // get uniform dynamically\n\n        uniforms[name] = function () {\n          return uniform.data;\n        };\n      }\n    });\n    var _this$getOuputDataTex = this.getOuputDataTexture(),\n      textureWidth = _this$getOuputDataTex.textureWidth,\n      texelCount = _this$getOuputDataTex.texelCount; // 传入 output 纹理尺寸和数据长度，便于多余的 texel 提前退出\n\n    uniforms.u_OutputTextureSize = [textureWidth, textureWidth];\n    uniforms.u_OutputTexelCount = texelCount; // 保存在 Kernel 的上下文中，供其他 Kernel 引用\n\n    this.context.output.textureSize = [textureWidth, textureWidth];\n    var drawParams = {\n      attributes: {\n        a_Position: [[-1, 1, 0], [-1, -1, 0], [1, 1, 0], [1, -1, 0]],\n        a_TexCoord: [[0, 1], [0, 0], [1, 1], [1, 0]]\n      },\n      frag: \"#ifdef GL_FRAGMENT_PRECISION_HIGH\\n  precision highp float;\\n#else\\n  precision mediump float;\\n#endif\\n\".concat(this.context.shader),\n      uniforms: uniforms,\n      vert: quadVert,\n      // TODO: use a fullscreen triangle instead.\n      primitive: 'triangle strip',\n      count: 4\n    };\n    this.computeCommand = this.reGl(drawParams);\n  }\n  _createClass(ReglComputeModel, [{\n    key: \"run\",\n    value: function run() {\n      var _this2 = this;\n      if (this.context.maxIteration > 1 && this.context.needPingpong) {\n        this.compiledPingpong = true;\n      } // need pingpong when (@in@out and execute(10)) or use `setBinding('out', self)`\n      // this.needPingpong =\n      //   !!(this.context.maxIteration > 1 && this.context.needPingpong);\n      // if (this.relativeOutputTextureNames.length) {\n      //   const { id, texture } = this.getOuputDataTexture();\n      //   this.relativeOutputTextureNames.forEach((name) => {\n      //     this.textureCache[name].id = id;\n      //     this.textureCache[name].texture = texture;\n      //   });\n      //   this.swap();\n      // }\n\n      if (this.compiledPingpong || this.dynamicPingpong) {\n        this.swap();\n      }\n      this.texFBO = this.reGl.framebuffer({\n        color: this.getOuputDataTexture().texture\n      });\n      this.texFBO.use(function () {\n        _this2.computeCommand();\n      });\n      if (debug) {\n        console.log(\"[\".concat(this.entity, \"]: output \").concat(this.getOuputDataTexture().id));\n      }\n    }\n  }, {\n    key: \"readData\",\n    value: function () {\n      var _readData = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this3 = this;\n        var pixels, _this$getOuputDataTex2, originalDataLength, elementsPerTexel, _this$getOuputDataTex3, typedArrayConstructor, formattedPixels, i;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.reGl({\n                  framebuffer: this.texFBO\n                })(function () {\n                  pixels = _this3.reGl.read();\n                }); // @ts-ignore\n\n                if (!pixels) {\n                  _context.next = 6;\n                  break;\n                }\n                _this$getOuputDataTex2 = this.getOuputDataTexture(), originalDataLength = _this$getOuputDataTex2.originalDataLength, elementsPerTexel = _this$getOuputDataTex2.elementsPerTexel, _this$getOuputDataTex3 = _this$getOuputDataTex2.typedArrayConstructor, typedArrayConstructor = _this$getOuputDataTex3 === void 0 ? Float32Array : _this$getOuputDataTex3;\n                formattedPixels = [];\n                if (elementsPerTexel !== 4) {\n                  for (i = 0; i < pixels.length; i += 4) {\n                    if (elementsPerTexel === 1) {\n                      formattedPixels.push(pixels[i]);\n                    } else if (elementsPerTexel === 2) {\n                      formattedPixels.push(pixels[i], pixels[i + 1]);\n                    } else {\n                      formattedPixels.push(pixels[i], pixels[i + 1], pixels[i + 2]);\n                    }\n                  }\n                } else {\n                  // @ts-ignore\n                  formattedPixels = pixels;\n                } // 截取多余的部分\n                // @ts-ignore\n\n                return _context.abrupt(\"return\", new typedArrayConstructor(formattedPixels.slice(0, originalDataLength)));\n              case 6:\n                return _context.abrupt(\"return\", new Float32Array());\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function readData() {\n        return _readData.apply(this, arguments);\n      }\n      return readData;\n    }()\n  }, {\n    key: \"confirmInput\",\n    value: function confirmInput(model, inputName) {\n      var inputModel; // refer to self, same as pingpong\n\n      if (this.entity === model.entity) {\n        this.dynamicPingpong = true;\n        inputModel = this;\n      } else {\n        inputModel = model;\n      }\n      this.textureCache[inputName].id = inputModel.getOuputDataTexture().id;\n      this.textureCache[inputName].texture = inputModel.getOuputDataTexture().texture;\n      if (debug) {\n        console.log(\"[\".concat(this.entity, \"]: confirm input \").concat(inputName, \" from model \").concat(inputModel.entity, \", \").concat(inputModel.getOuputDataTexture().id));\n      }\n    }\n  }, {\n    key: \"updateUniform\",\n    value: function updateUniform() {// already get uniform's data dynamically when created, do nothing here\n    }\n  }, {\n    key: \"updateBuffer\",\n    value: function updateBuffer(bufferName, data) {\n      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      // regenerate data texture\n      var buffer = this.context.uniforms.find(function (_ref) {\n        var name = _ref.name;\n        return name === bufferName;\n      });\n      if (buffer) {\n        var _this$calcDataTexture = this.calcDataTexture(bufferName, buffer.type, data),\n          texture = _this$calcDataTexture.texture,\n          paddingData = _this$calcDataTexture.data; // TODO: destroy outdated texture\n\n        this.textureCache[bufferName].data = paddingData;\n        this.textureCache[bufferName].texture = texture;\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {// regl will destroy all resources\n    }\n  }, {\n    key: \"swap\",\n    value: function swap() {\n      if (!this.swapOutputTextureName) {\n        this.createSwapOutputDataTexture();\n      }\n      if (this.compiledPingpong) {\n        var outputTextureUniformName = this.context.output.name;\n        this.textureCache[outputTextureUniformName].id = this.getOuputDataTexture().id;\n        this.textureCache[outputTextureUniformName].texture = this.getOuputDataTexture().texture;\n      }\n      var tmp = this.outputTextureName;\n      this.outputTextureName = this.swapOutputTextureName;\n      this.swapOutputTextureName = tmp;\n      if (debug) {\n        console.log(\"[\".concat(this.entity, \"]: after swap, output \").concat(this.getOuputDataTexture().id));\n      }\n    }\n  }, {\n    key: \"getOuputDataTexture\",\n    value: function getOuputDataTexture() {\n      return this.textureCache[this.outputTextureName];\n    }\n  }, {\n    key: \"createSwapOutputDataTexture\",\n    value: function createSwapOutputDataTexture() {\n      var texture = this.cloneDataTexture(this.getOuputDataTexture());\n      this.swapOutputTextureName = \"\".concat(this.entity, \"-swap\");\n      this.textureCache[this.swapOutputTextureName] = texture;\n    }\n  }, {\n    key: \"cloneDataTexture\",\n    value: function cloneDataTexture(texture) {\n      var data = texture.data,\n        textureWidth = texture.textureWidth;\n      return _objectSpread(_objectSpread({}, texture), {}, {\n        id: textureId++,\n        // @ts-ignore\n        texture: this.reGl.texture({\n          width: textureWidth,\n          height: textureWidth,\n          data: data,\n          type: 'float'\n        })\n      });\n    }\n  }, {\n    key: \"calcDataTexture\",\n    value: function calcDataTexture(name, type, data) {\n      var elementsPerTexel = 1;\n      if (type === AST_TOKEN_TYPES.Vector4FloatArray) {\n        elementsPerTexel = 4;\n      } // 用 0 补全不足 vec4 的部分\n\n      var paddingData = [];\n      for (var i = 0; i < data.length; i += elementsPerTexel) {\n        if (elementsPerTexel === 1) {\n          paddingData.push(data[i], 0, 0, 0);\n        } else if (elementsPerTexel === 2) {\n          paddingData.push(data[i], data[i + 1], 0, 0);\n        } else if (elementsPerTexel === 3) {\n          paddingData.push(data[i], data[i + 1], data[i + 2], 0);\n        } else if (elementsPerTexel === 4) {\n          paddingData.push(data[i], data[i + 1], data[i + 2], data[i + 3]);\n        }\n      } // 使用纹理存储，例如 Array(8) 使用 3 * 3 纹理，末尾空白使用 0 填充\n\n      var originalDataLength = data.length;\n      var texelCount = Math.ceil(originalDataLength / elementsPerTexel);\n      var width = Math.ceil(Math.sqrt(texelCount));\n      var paddingTexelCount = width * width;\n      if (texelCount < paddingTexelCount) {\n        paddingData.push.apply(paddingData, _toConsumableArray(new Array((paddingTexelCount - texelCount) * 4).fill(0)));\n      }\n      var texture = this.reGl.texture({\n        width: width,\n        height: width,\n        data: paddingData,\n        type: 'float'\n      });\n      return {\n        id: textureId++,\n        data: paddingData,\n        originalDataLength: originalDataLength,\n        typedArrayConstructor: isTypedArray(data) ? data.constructor : undefined,\n        textureWidth: width,\n        texture: texture,\n        texelCount: texelCount,\n        elementsPerTexel: elementsPerTexel,\n        isOutput: name === this.context.output.name\n      };\n    }\n  }]);\n  return ReglComputeModel;\n}();\nexport { ReglComputeModel as default };","map":{"version":3,"names":["AST_TOKEN_TYPES","createEntity","STORAGE_CLASS","isTypedArray","textureId","debug","ReglComputeModel","reGl","context","_this","_classCallCheck","entity","texFBO","computeCommand","textureCache","outputTextureName","swapOutputTextureName","compiledPingpong","dynamicPingpong","uniforms","forEach","uniform","name","type","data","isReferer","storageClass","StorageBuffer","calcDataTexture","_this$textureCache$na","width","textureWidth","isOutput","concat","needPingpong","undefined","compiledBundle","output","textureSize","console","log","id","texture","Uniform","Array","isArray","length","Error","_this$getOuputDataTex","getOuputDataTexture","texelCount","u_OutputTextureSize","u_OutputTexelCount","drawParams","attributes","a_Position","a_TexCoord","frag","shader","vert","quadVert","primitive","count","_this2","maxIteration","swap","framebuffer","color","use","pixels","_this3","read","originalDataLength","elementsPerTexel","typedArrayConstructor","Float32Array","formattedPixels","i","push","slice","model","inputName","inputModel","bufferName","offset","arguments","buffer","find","_ref","_this$calcDataTexture","paddingData","createSwapOutputDataTexture","outputTextureUniformName","tmp","cloneDataTexture","_objectSpread","height","Vector4FloatArray","Math","ceil","sqrt","paddingTexelCount","apply","_toConsumableArray","fill","constructor"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/g-webgpu-engine/src/webgl/ReglComputeModel.ts"],"sourcesContent":["import {\n  AST_TOKEN_TYPES,\n  createEntity,\n  DataType,\n  GLSLContext,\n  IComputeModel,\n  STORAGE_CLASS,\n} from '@antv/g-webgpu-core';\nimport regl from 'regl';\nimport { isTypedArray } from '../utils/is-typedarray';\nimport quadVert from './shaders/quad.vert.glsl';\n\ninterface DataTextureDescriptor {\n  id: number;\n  data:\n    | number\n    | number[]\n    | Float32Array\n    | Uint8Array\n    | Uint16Array\n    | Uint32Array\n    | Int8Array\n    | Int16Array\n    | Int32Array\n    | undefined;\n  textureWidth: number;\n  texture: regl.Texture2D;\n  texelCount: number;\n  originalDataLength: number;\n  elementsPerTexel: number;\n  typedArrayConstructor?: Function;\n  isOutput: boolean;\n}\n\nlet textureId = 0;\nconst debug = false;\n\n/**\n * adaptor for regl.DrawCommand\n */\nexport default class ReglComputeModel implements IComputeModel {\n  private entity = createEntity();\n  private texFBO: regl.Framebuffer2D;\n  private computeCommand: regl.DrawCommand;\n  private textureCache: {\n    [textureName: string]: DataTextureDescriptor;\n  } = {};\n  private outputTextureName: string;\n  private swapOutputTextureName: string;\n  private compiledPingpong: boolean;\n  private dynamicPingpong: boolean;\n\n  constructor(private reGl: regl.Regl, private context: GLSLContext) {\n    const uniforms: Record<string, any> = {};\n    this.context.uniforms.forEach((uniform) => {\n      const { name, type, data, isReferer, storageClass } = uniform;\n      // store data with a 2D texture\n      if (storageClass === STORAGE_CLASS.StorageBuffer) {\n        if (!isReferer) {\n          this.textureCache[name] = this.calcDataTexture(name, type, data!);\n          const { textureWidth: width, isOutput } = this.textureCache[name];\n          uniforms[`${name}Size`] = [width, width];\n\n          if (isOutput) {\n            this.outputTextureName = name;\n            if (this.context.needPingpong) {\n              this.outputTextureName = `${name}Output`;\n              this.textureCache[this.outputTextureName] = this.calcDataTexture(\n                name,\n                type,\n                data!,\n              );\n            }\n          }\n        } else {\n          // @ts-ignore\n          this.textureCache[name] = {\n            data: undefined,\n          };\n          // refer to another kernel's output,\n          // the referred kernel may not have been initialized, so we use dynamic way here\n          uniforms[`${name}Size`] = () =>\n            // @ts-ignore\n            data.compiledBundle.context.output.textureSize;\n        }\n\n        uniforms[name] = () => {\n          if (debug) {\n            console.log(\n              `[${this.entity}]: ${name} ${this.textureCache[name].id}`,\n            );\n          }\n          return this.textureCache[name].texture;\n        };\n      } else if (storageClass === STORAGE_CLASS.Uniform) {\n        if (\n          data &&\n          (Array.isArray(data) || isTypedArray(data)) &&\n          (data as ArrayLike<number>).length > 16\n        ) {\n          // up to mat4 which includes 16 elements\n          throw new Error(`invalid data type ${type}`);\n        }\n        // get uniform dynamically\n        uniforms[name] = () => uniform.data;\n      }\n    });\n\n    const { textureWidth, texelCount } = this.getOuputDataTexture();\n\n    // 传入 output 纹理尺寸和数据长度，便于多余的 texel 提前退出\n    uniforms.u_OutputTextureSize = [textureWidth, textureWidth];\n    uniforms.u_OutputTexelCount = texelCount;\n\n    // 保存在 Kernel 的上下文中，供其他 Kernel 引用\n    this.context.output.textureSize = [textureWidth!, textureWidth!];\n\n    const drawParams: regl.DrawConfig = {\n      attributes: {\n        a_Position: [\n          [-1, 1, 0],\n          [-1, -1, 0],\n          [1, 1, 0],\n          [1, -1, 0],\n        ],\n        a_TexCoord: [\n          [0, 1],\n          [0, 0],\n          [1, 1],\n          [1, 0],\n        ],\n      },\n      frag: `#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n${this.context.shader}`,\n      uniforms,\n      vert: quadVert,\n      // TODO: use a fullscreen triangle instead.\n      primitive: 'triangle strip',\n      count: 4,\n    };\n\n    this.computeCommand = this.reGl(drawParams);\n  }\n\n  public run() {\n    if (this.context.maxIteration > 1 && this.context.needPingpong) {\n      this.compiledPingpong = true;\n    }\n    // need pingpong when (@in@out and execute(10)) or use `setBinding('out', self)`\n    // this.needPingpong =\n    //   !!(this.context.maxIteration > 1 && this.context.needPingpong);\n\n    // if (this.relativeOutputTextureNames.length) {\n    //   const { id, texture } = this.getOuputDataTexture();\n    //   this.relativeOutputTextureNames.forEach((name) => {\n    //     this.textureCache[name].id = id;\n    //     this.textureCache[name].texture = texture;\n    //   });\n    //   this.swap();\n    // }\n\n    if (this.compiledPingpong || this.dynamicPingpong) {\n      this.swap();\n    }\n\n    this.texFBO = this.reGl.framebuffer({\n      color: this.getOuputDataTexture().texture,\n    });\n    this.texFBO.use(() => {\n      this.computeCommand();\n    });\n    if (debug) {\n      console.log(`[${this.entity}]: output ${this.getOuputDataTexture().id}`);\n    }\n  }\n\n  public async readData() {\n    let pixels: Uint8Array | Float32Array;\n    this.reGl({\n      framebuffer: this.texFBO,\n    })(() => {\n      pixels = this.reGl.read();\n    });\n\n    // @ts-ignore\n    if (pixels) {\n      const {\n        originalDataLength,\n        elementsPerTexel,\n        typedArrayConstructor = Float32Array,\n      } = this.getOuputDataTexture();\n\n      let formattedPixels = [];\n      if (elementsPerTexel !== 4) {\n        for (let i = 0; i < pixels.length; i += 4) {\n          if (elementsPerTexel === 1) {\n            formattedPixels.push(pixels[i]);\n          } else if (elementsPerTexel === 2) {\n            formattedPixels.push(pixels[i], pixels[i + 1]);\n          } else {\n            formattedPixels.push(pixels[i], pixels[i + 1], pixels[i + 2]);\n          }\n        }\n      } else {\n        // @ts-ignore\n        formattedPixels = pixels;\n      }\n\n      // 截取多余的部分\n      // @ts-ignore\n      return new typedArrayConstructor(\n        formattedPixels.slice(0, originalDataLength),\n      );\n    }\n\n    return new Float32Array();\n  }\n\n  public confirmInput(model: IComputeModel, inputName: string) {\n    let inputModel: ReglComputeModel;\n    // refer to self, same as pingpong\n    if (this.entity === (model as ReglComputeModel).entity) {\n      this.dynamicPingpong = true;\n      inputModel = this;\n    } else {\n      inputModel = model as ReglComputeModel;\n    }\n\n    this.textureCache[inputName].id = inputModel.getOuputDataTexture().id;\n    this.textureCache[\n      inputName\n    ].texture = inputModel.getOuputDataTexture().texture;\n\n    if (debug) {\n      console.log(\n        `[${this.entity}]: confirm input ${inputName} from model ${\n          inputModel.entity\n        }, ${(inputModel as ReglComputeModel).getOuputDataTexture().id}`,\n      );\n    }\n  }\n\n  public updateUniform() {\n    // already get uniform's data dynamically when created, do nothing here\n  }\n\n  public updateBuffer(\n    bufferName: string,\n    data:\n      | number[]\n      | Float32Array\n      | Uint8Array\n      | Uint16Array\n      | Uint32Array\n      | Int8Array\n      | Int16Array\n      | Int32Array,\n    offset: number = 0,\n  ) {\n    // regenerate data texture\n    const buffer = this.context.uniforms.find(\n      ({ name }) => name === bufferName,\n    );\n    if (buffer) {\n      const { texture, data: paddingData } = this.calcDataTexture(\n        bufferName,\n        buffer.type,\n        data,\n      );\n\n      // TODO: destroy outdated texture\n      this.textureCache[bufferName].data = paddingData;\n      this.textureCache[bufferName].texture = texture;\n    }\n  }\n\n  public destroy() {\n    // regl will destroy all resources\n  }\n\n  private swap() {\n    if (!this.swapOutputTextureName) {\n      this.createSwapOutputDataTexture();\n    }\n\n    if (this.compiledPingpong) {\n      const outputTextureUniformName = this.context.output.name;\n      this.textureCache[\n        outputTextureUniformName\n      ].id = this.getOuputDataTexture().id;\n      this.textureCache[\n        outputTextureUniformName\n      ].texture = this.getOuputDataTexture().texture;\n    }\n\n    const tmp = this.outputTextureName;\n    this.outputTextureName = this.swapOutputTextureName;\n    this.swapOutputTextureName = tmp;\n\n    if (debug) {\n      console.log(\n        `[${this.entity}]: after swap, output ${this.getOuputDataTexture().id}`,\n      );\n    }\n  }\n\n  private getOuputDataTexture() {\n    return this.textureCache[this.outputTextureName];\n  }\n\n  private createSwapOutputDataTexture() {\n    const texture = this.cloneDataTexture(this.getOuputDataTexture());\n    this.swapOutputTextureName = `${this.entity}-swap`;\n    this.textureCache[this.swapOutputTextureName] = texture;\n  }\n\n  private cloneDataTexture(texture: DataTextureDescriptor) {\n    const { data, textureWidth } = texture;\n    return {\n      ...texture,\n      id: textureId++,\n      // @ts-ignore\n      texture: this.reGl.texture({\n        width: textureWidth,\n        height: textureWidth,\n        data,\n        type: 'float',\n      }),\n    };\n  }\n\n  private calcDataTexture(\n    name: string,\n    type: DataType,\n    data:\n      | number\n      | number[]\n      | Float32Array\n      | Uint8Array\n      | Uint16Array\n      | Uint32Array\n      | Int8Array\n      | Int16Array\n      | Int32Array,\n  ) {\n    let elementsPerTexel = 1;\n    if (type === AST_TOKEN_TYPES.Vector4FloatArray) {\n      elementsPerTexel = 4;\n    }\n\n    // 用 0 补全不足 vec4 的部分\n    const paddingData: number[] = [];\n    for (let i = 0; i < (data as number[]).length; i += elementsPerTexel) {\n      if (elementsPerTexel === 1) {\n        paddingData.push((data as number[])[i], 0, 0, 0);\n      } else if (elementsPerTexel === 2) {\n        paddingData.push(\n          (data as number[])[i],\n          (data as number[])[i + 1],\n          0,\n          0,\n        );\n      } else if (elementsPerTexel === 3) {\n        paddingData.push(\n          (data as number[])[i],\n          (data as number[])[i + 1],\n          (data as number[])[i + 2],\n          0,\n        );\n      } else if (elementsPerTexel === 4) {\n        paddingData.push(\n          (data as number[])[i],\n          (data as number[])[i + 1],\n          (data as number[])[i + 2],\n          (data as number[])[i + 3],\n        );\n      }\n    }\n\n    // 使用纹理存储，例如 Array(8) 使用 3 * 3 纹理，末尾空白使用 0 填充\n    const originalDataLength = (data as ArrayLike<number>).length;\n    const texelCount = Math.ceil(originalDataLength / elementsPerTexel);\n    const width = Math.ceil(Math.sqrt(texelCount));\n    const paddingTexelCount = width * width;\n    if (texelCount < paddingTexelCount) {\n      paddingData.push(\n        ...new Array((paddingTexelCount - texelCount) * 4).fill(0),\n      );\n    }\n\n    const texture = this.reGl.texture({\n      width,\n      height: width,\n      data: paddingData,\n      type: 'float',\n    });\n\n    return {\n      id: textureId++,\n      data: paddingData,\n      originalDataLength,\n      typedArrayConstructor: isTypedArray(data) ? data!.constructor : undefined,\n      textureWidth: width,\n      texture,\n      texelCount,\n      elementsPerTexel,\n      isOutput: name === this.context.output.name,\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}