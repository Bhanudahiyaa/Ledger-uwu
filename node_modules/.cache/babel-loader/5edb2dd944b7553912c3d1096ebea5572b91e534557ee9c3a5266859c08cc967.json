{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _dec, _class;\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nimport { generateAABBFromVertices } from '@antv/g-webgpu-core';\nimport { vec3 } from 'gl-matrix';\nimport { injectable } from 'inversify';\nimport { Geometry } from '.';\nvar primitiveUv1Padding = 4.0 / 64;\nvar primitiveUv1PaddingScale = 1.0 - primitiveUv1Padding * 2;\nexport var\n/**\n * borrow from playcanvas:\n * Creates a procedural box-shaped mesh\n */\nBox = (_dec = injectable(), _dec(_class = /*#__PURE__*/function (_Geometry) {\n  _inherits(Box, _Geometry);\n  var _super = _createSuper(Box);\n  function Box() {\n    _classCallCheck(this, Box);\n    return _super.apply(this, arguments);\n  }\n  _createClass(Box, [{\n    key: \"onEntityCreated\",\n    value: function onEntityCreated() {\n      var _this$config = this.config,\n        _this$config$widthSeg = _this$config.widthSegments,\n        widthSegments = _this$config$widthSeg === void 0 ? 1 : _this$config$widthSeg,\n        _this$config$heightSe = _this$config.heightSegments,\n        heightSegments = _this$config$heightSe === void 0 ? 1 : _this$config$heightSe,\n        _this$config$depthSeg = _this$config.depthSegments,\n        depthSegments = _this$config$depthSeg === void 0 ? 1 : _this$config$depthSeg,\n        _this$config$halfExte = _this$config.halfExtents,\n        halfExtents = _this$config$halfExte === void 0 ? vec3.fromValues(0.5, 0.5, 0.5) : _this$config$halfExte;\n      var ws = widthSegments;\n      var hs = heightSegments;\n      var ds = depthSegments;\n      var _halfExtents = _slicedToArray(halfExtents, 3),\n        hex = _halfExtents[0],\n        hey = _halfExtents[1],\n        hez = _halfExtents[2];\n      var corners = [vec3.fromValues(-hex, -hey, hez), vec3.fromValues(hex, -hey, hez), vec3.fromValues(hex, hey, hez), vec3.fromValues(-hex, hey, hez), vec3.fromValues(hex, -hey, -hez), vec3.fromValues(-hex, -hey, -hez), vec3.fromValues(-hex, hey, -hez), vec3.fromValues(hex, hey, -hez)];\n      var faceAxes = [[0, 1, 3],\n      // FRONT\n      [4, 5, 7],\n      // BACK\n      [3, 2, 6],\n      // TOP\n      [1, 0, 4],\n      // BOTTOM\n      [1, 4, 2],\n      // RIGHT\n      [5, 0, 6] // LEFT\n      ];\n      var faceNormals = [[0, 0, 1],\n      // FRONT\n      [0, 0, -1],\n      // BACK\n      [0, 1, 0],\n      // TOP\n      [0, -1, 0],\n      // BOTTOM\n      [1, 0, 0],\n      // RIGHT\n      [-1, 0, 0] // LEFT\n      ];\n      var sides = {\n        FRONT: 0,\n        BACK: 1,\n        TOP: 2,\n        BOTTOM: 3,\n        RIGHT: 4,\n        LEFT: 5\n      };\n      var positions = [];\n      var normals = [];\n      var uvs = [];\n      var uvs1 = [];\n      var indices = [];\n      var vcounter = 0;\n      var generateFace = function generateFace(side, uSegments, vSegments) {\n        var u;\n        var v;\n        var i;\n        var j;\n        for (i = 0; i <= uSegments; i++) {\n          for (j = 0; j <= vSegments; j++) {\n            var temp1 = vec3.create();\n            var temp2 = vec3.create();\n            var temp3 = vec3.create();\n            var r = vec3.create();\n            vec3.lerp(temp1, corners[faceAxes[side][0]], corners[faceAxes[side][1]], i / uSegments);\n            vec3.lerp(temp2, corners[faceAxes[side][0]], corners[faceAxes[side][2]], j / vSegments);\n            vec3.sub(temp3, temp2, corners[faceAxes[side][0]]);\n            vec3.add(r, temp1, temp3);\n            u = i / uSegments;\n            v = j / vSegments;\n            positions.push(r[0], r[1], r[2]);\n            normals.push(faceNormals[side][0], faceNormals[side][1], faceNormals[side][2]);\n            uvs.push(u, v); // pack as 3x2\n            // 1/3 will be empty, but it's either that or stretched pixels\n            // TODO: generate non-rectangular lightMaps, so we could use space without stretching\n\n            u /= 3;\n            v /= 3;\n            u = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n            v = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n            u += side % 3 / 3;\n            v += Math.floor(side / 3) / 3;\n            uvs1.push(u, v);\n            if (i < uSegments && j < vSegments) {\n              indices.push(vcounter + vSegments + 1, vcounter + 1, vcounter);\n              indices.push(vcounter + vSegments + 1, vcounter + vSegments + 2, vcounter + 1);\n            }\n            vcounter++;\n          }\n        }\n      };\n      generateFace(sides.FRONT, ws, hs);\n      generateFace(sides.BACK, ws, hs);\n      generateFace(sides.TOP, ws, ds);\n      generateFace(sides.BOTTOM, ws, ds);\n      generateFace(sides.RIGHT, ds, hs);\n      generateFace(sides.LEFT, ds, hs); // generate AABB\n\n      var aabb = generateAABBFromVertices(positions);\n      var component = this.getComponent();\n      component.indices = Uint32Array.from(indices);\n      component.aabb = aabb;\n      component.vertexCount = vcounter;\n      component.attributes = [{\n        dirty: true,\n        name: 'position',\n        data: Float32Array.from(positions),\n        arrayStride: 4 * 3,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 0,\n          offset: 0,\n          format: 'float3'\n        }]\n      }, {\n        dirty: true,\n        name: 'normal',\n        data: Float32Array.from(normals),\n        arrayStride: 4 * 3,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 1,\n          offset: 0,\n          format: 'float3'\n        }]\n      }, {\n        dirty: true,\n        name: 'uv',\n        data: Float32Array.from(uvs),\n        arrayStride: 4 * 2,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 2,\n          offset: 0,\n          format: 'float2'\n        }]\n      }]; // TODO: barycentric & tangent\n    }\n  }]);\n  return Box;\n}(Geometry)) || _class);","map":{"version":3,"names":["generateAABBFromVertices","vec3","injectable","Geometry","primitiveUv1Padding","primitiveUv1PaddingScale","Box","_dec","_class","_Geometry","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","key","value","onEntityCreated","_this$config","config","_this$config$widthSeg","widthSegments","_this$config$heightSe","heightSegments","_this$config$depthSeg","depthSegments","_this$config$halfExte","halfExtents","fromValues","ws","hs","ds","_halfExtents","_slicedToArray","hex","hey","hez","corners","faceAxes","faceNormals","sides","FRONT","BACK","TOP","BOTTOM","RIGHT","LEFT","positions","normals","uvs","uvs1","indices","vcounter","generateFace","side","uSegments","vSegments","u","v","i","j","temp1","create","temp2","temp3","r","lerp","sub","add","push","Math","floor","aabb","component","getComponent","Uint32Array","from","vertexCount","attributes","dirty","name","data","Float32Array","arrayStride","stepMode","shaderLocation","offset","format"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/g-webgpu/src/geometry/Box.ts"],"sourcesContent":["import { generateAABBFromVertices } from '@antv/g-webgpu-core';\nimport { vec3 } from 'gl-matrix';\nimport { inject, injectable } from 'inversify';\nimport { Geometry } from '.';\n\nexport interface IBoxGeometryParams {\n  halfExtents: vec3;\n  widthSegments: number;\n  heightSegments: number;\n  depthSegments: number;\n}\n\nconst primitiveUv1Padding = 4.0 / 64;\nconst primitiveUv1PaddingScale = 1.0 - primitiveUv1Padding * 2;\n\n@injectable()\n/**\n * borrow from playcanvas:\n * Creates a procedural box-shaped mesh\n */\nexport class Box extends Geometry<Partial<IBoxGeometryParams>> {\n  protected onEntityCreated() {\n    const {\n      widthSegments = 1,\n      heightSegments = 1,\n      depthSegments = 1,\n      halfExtents = vec3.fromValues(0.5, 0.5, 0.5),\n    } = this.config;\n    const ws = widthSegments;\n    const hs = heightSegments;\n    const ds = depthSegments;\n    const [hex, hey, hez] = halfExtents;\n\n    const corners = [\n      vec3.fromValues(-hex, -hey, hez),\n      vec3.fromValues(hex, -hey, hez),\n      vec3.fromValues(hex, hey, hez),\n      vec3.fromValues(-hex, hey, hez),\n      vec3.fromValues(hex, -hey, -hez),\n      vec3.fromValues(-hex, -hey, -hez),\n      vec3.fromValues(-hex, hey, -hez),\n      vec3.fromValues(hex, hey, -hez),\n    ];\n\n    const faceAxes = [\n      [0, 1, 3], // FRONT\n      [4, 5, 7], // BACK\n      [3, 2, 6], // TOP\n      [1, 0, 4], // BOTTOM\n      [1, 4, 2], // RIGHT\n      [5, 0, 6], // LEFT\n    ];\n\n    const faceNormals = [\n      [0, 0, 1], // FRONT\n      [0, 0, -1], // BACK\n      [0, 1, 0], // TOP\n      [0, -1, 0], // BOTTOM\n      [1, 0, 0], // RIGHT\n      [-1, 0, 0], // LEFT\n    ];\n\n    const sides = {\n      FRONT: 0,\n      BACK: 1,\n      TOP: 2,\n      BOTTOM: 3,\n      RIGHT: 4,\n      LEFT: 5,\n    };\n\n    const positions: number[] = [];\n    const normals: number[] = [];\n    const uvs: number[] = [];\n    const uvs1: number[] = [];\n    const indices: number[] = [];\n    let vcounter = 0;\n\n    const generateFace = (\n      side: number,\n      uSegments: number,\n      vSegments: number,\n    ) => {\n      let u;\n      let v;\n      let i;\n      let j;\n\n      for (i = 0; i <= uSegments; i++) {\n        for (j = 0; j <= vSegments; j++) {\n          const temp1 = vec3.create();\n          const temp2 = vec3.create();\n          const temp3 = vec3.create();\n          const r = vec3.create();\n          vec3.lerp(\n            temp1,\n            corners[faceAxes[side][0]],\n            corners[faceAxes[side][1]],\n            i / uSegments,\n          );\n          vec3.lerp(\n            temp2,\n            corners[faceAxes[side][0]],\n            corners[faceAxes[side][2]],\n            j / vSegments,\n          );\n          vec3.sub(temp3, temp2, corners[faceAxes[side][0]]);\n          vec3.add(r, temp1, temp3);\n          u = i / uSegments;\n          v = j / vSegments;\n\n          positions.push(r[0], r[1], r[2]);\n          normals.push(\n            faceNormals[side][0],\n            faceNormals[side][1],\n            faceNormals[side][2],\n          );\n          uvs.push(u, v);\n          // pack as 3x2\n          // 1/3 will be empty, but it's either that or stretched pixels\n          // TODO: generate non-rectangular lightMaps, so we could use space without stretching\n          u /= 3;\n          v /= 3;\n          u = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n          v = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n          u += (side % 3) / 3;\n          v += Math.floor(side / 3) / 3;\n          uvs1.push(u, v);\n\n          if (i < uSegments && j < vSegments) {\n            indices.push(vcounter + vSegments + 1, vcounter + 1, vcounter);\n            indices.push(\n              vcounter + vSegments + 1,\n              vcounter + vSegments + 2,\n              vcounter + 1,\n            );\n          }\n\n          vcounter++;\n        }\n      }\n    };\n\n    generateFace(sides.FRONT, ws, hs);\n    generateFace(sides.BACK, ws, hs);\n    generateFace(sides.TOP, ws, ds);\n    generateFace(sides.BOTTOM, ws, ds);\n    generateFace(sides.RIGHT, ds, hs);\n    generateFace(sides.LEFT, ds, hs);\n\n    // generate AABB\n    const aabb = generateAABBFromVertices(positions);\n\n    const component = this.getComponent();\n    component.indices = Uint32Array.from(indices);\n    component.aabb = aabb;\n    component.vertexCount = vcounter;\n    component.attributes = [\n      {\n        dirty: true,\n        name: 'position',\n        data: Float32Array.from(positions),\n        arrayStride: 4 * 3,\n        stepMode: 'vertex',\n        attributes: [\n          {\n            shaderLocation: 0,\n            offset: 0,\n            format: 'float3',\n          },\n        ],\n      },\n      {\n        dirty: true,\n        name: 'normal',\n        data: Float32Array.from(normals),\n        arrayStride: 4 * 3,\n        stepMode: 'vertex',\n        attributes: [\n          {\n            shaderLocation: 1,\n            offset: 0,\n            format: 'float3',\n          },\n        ],\n      },\n      {\n        dirty: true,\n        name: 'uv',\n        data: Float32Array.from(uvs),\n        arrayStride: 4 * 2,\n        stepMode: 'vertex',\n        attributes: [\n          {\n            shaderLocation: 2,\n            offset: 0,\n            format: 'float2',\n          },\n        ],\n      },\n    ];\n\n    // TODO: barycentric & tangent\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}