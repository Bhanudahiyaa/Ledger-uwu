{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { rgb2arr } from '@antv/l7-utils';\nimport BaseModel from \"../../core/BaseModel\";\nimport { LineTriangulation } from \"../../core/triangulation\";\n/* babel-plugin-inline-import '../shaders/wall/wall_frag.glsl' */\nconst line_frag = \"#define Animate 0.0\\n#define LineTexture 1.0\\n\\n// line texture\\n\\nuniform sampler2D u_texture;\\nlayout(std140) uniform commonUniorm {\\n  vec4 u_animate: [ 1., 2., 1.0, 0.2 ];\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  vec2 u_textSize;\\n  float u_icon_step: 100;\\n  float u_heightfixed;\\n  float u_linearColor: 0;\\n  float u_line_texture;\\n  float u_textureBlend;\\n  float u_iconStepCount;\\n  float u_time;\\n};\\n\\n\\nin vec2 v_iconMapUV;\\nin vec4 v_color;\\nin float v_blur;\\nin vec4 v_dataset;\\n\\nout vec4 outputColor;\\n\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  float animateSpeed = 0.0; // \\u8FD0\\u52A8\\u901F\\u5EA6\\n  float d_distance_ratio = v_dataset.r; // \\u5F53\\u524D\\u70B9\\u4F4D\\u8DDD\\u79BB\\u5360\\u7EBF\\u603B\\u957F\\u7684\\u6BD4\\u4F8B\\n  float v = v_dataset.a;\\n\\n  if(u_linearColor == 1.0) { // \\u4F7F\\u7528\\u6E10\\u53D8\\u989C\\u8272\\n    outputColor = mix(u_sourceColor, u_targetColor, v);\\n  } else { // \\u4F7F\\u7528 color \\u65B9\\u6CD5\\u4F20\\u5165\\u7684\\u989C\\u8272\\n     outputColor = v_color;\\n  }\\n\\n  outputColor.a *= v_color.a; // \\u5168\\u5C40\\u900F\\u660E\\u5EA6\\n  if(u_animate.x == Animate) {\\n      animateSpeed = u_time / u_animate.y;\\n       float alpha =1.0 - fract( mod(1.0- d_distance_ratio, u_animate.z)* (1.0/ u_animate.z) + animateSpeed);\\n      alpha = (alpha + u_animate.w -1.0) / u_animate.w;\\n      alpha = smoothstep(0., 1., alpha);\\n      outputColor.a *= alpha;\\n  }\\n\\n  if(u_line_texture == LineTexture) { // while load texture\\n    float aDistance = v_dataset.g;      // \\u5F53\\u524D\\u9876\\u70B9\\u7684\\u8DDD\\u79BB\\n    float d_texPixelLen = v_dataset.b;  // \\u8D34\\u56FE\\u7684\\u50CF\\u7D20\\u957F\\u5EA6\\uFF0C\\u6839\\u636E\\u5730\\u56FE\\u5C42\\u7EA7\\u7F29\\u653E\\n    float u = fract(mod(aDistance, d_texPixelLen)/d_texPixelLen - animateSpeed);\\n    float v = v_dataset.a;  // \\u7EBF\\u56FE\\u5C42\\u8D34\\u56FE\\u90E8\\u5206\\u7684 v \\u5750\\u6807\\u503C\\n\\n    // \\u8BA1\\u7B97\\u7EB9\\u7406\\u95F4\\u9694 start\\n    float flag = 0.0;\\n    if(u > 1.0/u_iconStepCount) {\\n      flag = 1.0;\\n    }\\n    u = fract(u*u_iconStepCount);\\n    // \\u8BA1\\u7B97\\u7EB9\\u7406\\u95F4\\u9694 end\\n\\n    vec2 uv= v_iconMapUV / u_textSize + vec2(u, v) / u_textSize * 64.;\\n    vec4 pattern = texture(SAMPLER_2D(u_texture), uv);\\n\\n    // Tip: \\u5224\\u65AD\\u7EB9\\u7406\\u95F4\\u9694\\n    if(flag > 0.0) {\\n      pattern = vec4(0.0);\\n    }\\n\\n    if(u_textureBlend == 0.0) { // normal\\n      pattern.a = 0.0;\\n      outputColor = filterColor(outputColor + pattern);\\n    } else { // replace\\n        pattern.a *= v_color.a;\\n        if(outputColor.a <= 0.0) {\\n          pattern.a = 0.0;\\n        }\\n        outputColor = filterColor(pattern);\\n    }\\n  }\\n\\n\\n  // blur - AA\\n  if(v < v_blur) {\\n    outputColor.a = mix(0.0, outputColor.a, v/v_blur);\\n  } else if(v > 1.0 - v_blur) {\\n    outputColor.a = mix(outputColor.a, 0.0, (v - (1.0 - v_blur))/v_blur);\\n  }\\n\\n  outputColor = filterColor(outputColor);\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/wall/wall_vert.glsl' */\nconst line_vert = \"#define Animate 0.0\\nlayout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in vec2 a_Size;\\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_iconMapUV;\\nlayout(location = ATTRIBUTE_LOCATION_DISTANCE_MITER_TOTAL) in vec3 a_Distance_Total_Miter;\\n\\nlayout(std140) uniform commonUniorm {\\n  vec4 u_animate: [ 1., 2., 1.0, 0.2 ];\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  vec2 u_textSize;\\n  float u_icon_step: 100;\\n  float u_heightfixed;\\n  float u_linearColor: 0;\\n  float u_line_texture;\\n  float u_textureBlend;\\n  float u_iconStepCount;\\n  float u_time;\\n};\\n\\n// texV \\u7EBF\\u56FE\\u5C42 - \\u8D34\\u56FE\\u90E8\\u5206\\u7684 v \\u5750\\u6807\\uFF08\\u7EBF\\u7684\\u5BBD\\u5EA6\\u65B9\\u5411\\uFF09\\nout vec2 v_iconMapUV;\\nout vec4 v_color;\\nout float v_blur;\\nout vec4 v_dataset;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"light\\\"\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  float a_Distance = a_Distance_Total_Miter.x;\\n  float a_Miter = a_Distance_Total_Miter.y;\\n  float a_Total_Distance = a_Distance_Total_Miter.z;\\n\\n  float d_distance_ratio; // \\u5F53\\u524D\\u70B9\\u4F4D\\u8DDD\\u79BB\\u5360\\u7EBF\\u603B\\u957F\\u7684\\u6BD4\\u4F8B\\n  float d_texPixelLen; // \\u8D34\\u56FE\\u7684\\u50CF\\u7D20\\u957F\\u5EA6\\uFF0C\\u6839\\u636E\\u5730\\u56FE\\u5C42\\u7EA7\\u7F29\\u653E\\n\\n  v_iconMapUV = a_iconMapUV;\\n  if (u_heightfixed < 1.0) {\\n    // \\u9AD8\\u5EA6\\u968F zoom \\u8C03\\u6574\\n    d_texPixelLen = project_pixel(u_icon_step);\\n  } else {\\n    d_texPixelLen = u_icon_step;\\n  }\\n\\n  if (u_animate.x == Animate || u_linearColor == 1.0) {\\n    d_distance_ratio = a_Distance / a_Total_Distance;\\n  }\\n\\n  float miter = (a_Miter + 1.0) / 2.0;\\n  // \\u8BBE\\u7F6E\\u6570\\u636E\\u96C6\\u7684\\u53C2\\u6570\\n  v_dataset[0] = d_distance_ratio; // \\u5F53\\u524D\\u70B9\\u4F4D\\u8DDD\\u79BB\\u5360\\u7EBF\\u603B\\u957F\\u7684\\u6BD4\\u4F8B\\n  v_dataset[1] = a_Distance; // \\u5F53\\u524D\\u9876\\u70B9\\u7684\\u8DDD\\u79BB\\n  v_dataset[2] = d_texPixelLen; // \\u8D34\\u56FE\\u7684\\u50CF\\u7D20\\u957F\\u5EA6\\uFF0C\\u6839\\u636E\\u5730\\u56FE\\u5C42\\u7EA7\\u7F29\\u653E\\n  v_dataset[3] = miter; // \\u7EBF\\u56FE\\u5C42\\u8D34\\u56FE\\u90E8\\u5206\\u7684 v \\u5750\\u6807\\u503C 0 - 1\\n\\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0, 1.0), a_Position64Low);\\n\\n  float originSize = a_Size.x; // \\u56FA\\u5B9A\\u9AD8\\u5EA6\\n  if (u_heightfixed < 1.0) {\\n    originSize = project_float_meter(a_Size.x); // \\u9AD8\\u5EA6\\u968F zoom \\u8C03\\u6574\\n  }\\n\\n  float wallHeight = originSize * miter;\\n  float lightWeight = calc_lighting(vec4(project_pos.xy, wallHeight, 1.0));\\n\\n  v_blur = min(project_float_pixel(2.0) / originSize, 0.05);\\n  v_color = vec4(a_Color.rgb * lightWeight, a_Color.w * opacity);\\n\\n  // \\u517C\\u5BB9 mapbox \\u5728\\u7EBF\\u9AD8\\u5EA6\\u4E0A\\u7684\\u6548\\u679C\\u8868\\u73B0\\u57FA\\u672C\\u4E00\\u81F4\\n  if (\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\\n  ) {\\n    // mapbox\\n    // \\u4FDD\\u6301\\u9AD8\\u5EA6\\u76F8\\u5BF9\\u4E0D\\u53D8\\n    float mapboxZoomScale = 4.0 / pow(2.0, 21.0 - u_Zoom);\\n    if (u_heightfixed > 0.0) {\\n      wallHeight *= mapboxZoomScale;\\n    }\\n  }\\n\\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, wallHeight, 1.0));\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\nexport default class LineWallModel extends BaseModel {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"texture\", void 0);\n    _defineProperty(this, \"updateTexture\", () => {\n      const {\n        createTexture2D\n      } = this.rendererService;\n      if (this.texture) {\n        this.texture.update({\n          data: this.iconService.getCanvas()\n        });\n        this.layer.render();\n        return;\n      }\n      this.texture = createTexture2D({\n        data: this.iconService.getCanvas(),\n        mag: gl.NEAREST,\n        min: gl.NEAREST,\n        premultiplyAlpha: false,\n        width: 1024,\n        height: this.iconService.canvasHeight || 128\n      });\n      this.textures = [this.texture];\n    });\n  }\n  get attributeLocation() {\n    return Object.assign(super.attributeLocation, {\n      MAX: super.attributeLocation.MAX,\n      SIZE: 9,\n      NORMAL: 12,\n      UV: 13,\n      DISTANCE_MITER_TOTAL: 15\n    });\n  }\n  getCommonUniformsInfo() {\n    const {\n      sourceColor,\n      targetColor,\n      textureBlend = 'normal',\n      heightfixed = false,\n      lineTexture = false,\n      iconStep = 100,\n      iconStepCount = 1\n    } = this.layer.getLayerConfig();\n    const {\n      animateOption\n    } = this.layer.getLayerConfig();\n    if (this.rendererService.getDirty()) {\n      var _this$texture;\n      (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.bind();\n    }\n\n    // 转化渐变色\n    let useLinearColor = 0; // 默认不生效\n    let sourceColorArr = [0, 0, 0, 0];\n    let targetColorArr = [0, 0, 0, 0];\n    if (sourceColor && targetColor) {\n      sourceColorArr = rgb2arr(sourceColor);\n      targetColorArr = rgb2arr(targetColor);\n      useLinearColor = 1;\n    }\n    const commonOptions = {\n      u_animate: this.animateOption2Array(animateOption),\n      u_sourceColor: sourceColorArr,\n      u_targetColor: targetColorArr,\n      u_textSize: [1024, this.iconService.canvasHeight || 128],\n      u_icon_step: iconStep,\n      u_heightfixed: Number(heightfixed),\n      // 渐变色支持参数\n      u_linearColor: useLinearColor,\n      u_line_texture: lineTexture ? 1.0 : 0.0,\n      // 传入线的标识\n      u_textureBlend: textureBlend === 'normal' ? 0.0 : 1.0,\n      u_iconStepCount: iconStepCount,\n      u_time: this.layer.getLayerAnimateTime() || 0\n    };\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  // public getAnimateUniforms(): IModelUniform {\n  //   const { animateOption } = this.layer.getLayerConfig() as ILayerConfig;\n  //   return {\n  //     u_animate: this.animateOption2Array(animateOption as IAnimateOption),\n  //     u_time: this.layer.getLayerAnimateTime(),\n  //   };\n  // }\n\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.initUniformsBuffer();\n      _this.updateTexture();\n      _this.iconService.on('imageUpdate', _this.updateTexture);\n      return _this.buildModels();\n    })();\n  }\n  clearModels() {\n    var _this$texture2;\n    (_this$texture2 = this.texture) === null || _this$texture2 === void 0 || _this$texture2.destroy();\n    this.iconService.off('imageUpdate', this.updateTexture);\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const model = yield _this2.layer.buildLayerModel({\n        moduleName: 'lineWall',\n        vertexShader: line_vert,\n        fragmentShader: line_frag,\n        triangulation: LineTriangulation,\n        defines: _this2.getDefines(),\n        inject: _this2.getInject(),\n        depth: {\n          enable: false\n        },\n        blend: _this2.getBlend()\n      });\n      return [model];\n    })();\n  }\n  registerBuiltinAttributes() {\n    // 注册 Position 属性 64 位地位部分，经纬度数据开启双精度，避免大于 20层级以上出现数据偏移\n    this.registerPosition64LowAttribute();\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Size',\n        shaderLocation: this.attributeLocation.SIZE,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 2,\n        update: feature => {\n          const {\n            size = 1\n          } = feature;\n          return Array.isArray(size) ? [size[0], size[1]] : [size, 0];\n        }\n      }\n    });\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'normal',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Normal',\n        shaderLocation: this.attributeLocation.NORMAL,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.STATIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        // @ts-ignore\n        update: (feature, featureIdx, vertex, attributeIdx, normal) => {\n          return normal;\n        }\n      }\n    });\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'distanceAndTotalAndMiter',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Distance_Total_Miter',\n        shaderLocation: this.attributeLocation.DISTANCE_MITER_TOTAL,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.STATIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        update: (feature, featureIdx, vertex) => {\n          // [distance, miter, total_distance]\n          return [vertex[3], vertex[4], vertex[5]];\n        }\n      }\n    });\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'uv',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_iconMapUV',\n        shaderLocation: this.attributeLocation.UV,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 2,\n        update: feature => {\n          const iconMap = this.iconService.getIconMap();\n          const {\n            texture\n          } = feature;\n          const {\n            x,\n            y\n          } = iconMap[texture] || {\n            x: 0,\n            y: 0\n          };\n          return [x, y];\n        }\n      }\n    });\n  }\n}","map":{"version":3,"names":["_asyncToGenerator","_defineProperty","AttributeType","gl","rgb2arr","BaseModel","LineTriangulation","line_frag","line_vert","LineWallModel","constructor","args","createTexture2D","rendererService","texture","update","data","iconService","getCanvas","layer","render","mag","NEAREST","min","premultiplyAlpha","width","height","canvasHeight","textures","attributeLocation","Object","assign","MAX","SIZE","NORMAL","UV","DISTANCE_MITER_TOTAL","getCommonUniformsInfo","sourceColor","targetColor","textureBlend","heightfixed","lineTexture","iconStep","iconStepCount","getLayerConfig","animateOption","getDirty","_this$texture","bind","useLinearColor","sourceColorArr","targetColorArr","commonOptions","u_animate","animateOption2Array","u_sourceColor","u_targetColor","u_textSize","u_icon_step","u_heightfixed","Number","u_linearColor","u_line_texture","u_textureBlend","u_iconStepCount","u_time","getLayerAnimateTime","commonBufferInfo","getUniformsBufferInfo","initModels","_this","initUniformsBuffer","updateTexture","on","buildModels","clearModels","_this$texture2","destroy","off","_this2","model","buildLayerModel","moduleName","vertexShader","fragmentShader","triangulation","defines","getDefines","inject","getInject","depth","enable","blend","getBlend","registerBuiltinAttributes","registerPosition64LowAttribute","styleAttributeService","registerStyleAttribute","name","type","Attribute","descriptor","shaderLocation","buffer","usage","DYNAMIC_DRAW","FLOAT","size","feature","Array","isArray","STATIC_DRAW","featureIdx","vertex","attributeIdx","normal","iconMap","getIconMap","x","y"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/l7-layers/es/line/models/wall.js"],"sourcesContent":["import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { rgb2arr } from '@antv/l7-utils';\nimport BaseModel from \"../../core/BaseModel\";\nimport { LineTriangulation } from \"../../core/triangulation\";\n/* babel-plugin-inline-import '../shaders/wall/wall_frag.glsl' */\nconst line_frag = \"#define Animate 0.0\\n#define LineTexture 1.0\\n\\n// line texture\\n\\nuniform sampler2D u_texture;\\nlayout(std140) uniform commonUniorm {\\n  vec4 u_animate: [ 1., 2., 1.0, 0.2 ];\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  vec2 u_textSize;\\n  float u_icon_step: 100;\\n  float u_heightfixed;\\n  float u_linearColor: 0;\\n  float u_line_texture;\\n  float u_textureBlend;\\n  float u_iconStepCount;\\n  float u_time;\\n};\\n\\n\\nin vec2 v_iconMapUV;\\nin vec4 v_color;\\nin float v_blur;\\nin vec4 v_dataset;\\n\\nout vec4 outputColor;\\n\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  float animateSpeed = 0.0; // \\u8FD0\\u52A8\\u901F\\u5EA6\\n  float d_distance_ratio = v_dataset.r; // \\u5F53\\u524D\\u70B9\\u4F4D\\u8DDD\\u79BB\\u5360\\u7EBF\\u603B\\u957F\\u7684\\u6BD4\\u4F8B\\n  float v = v_dataset.a;\\n\\n  if(u_linearColor == 1.0) { // \\u4F7F\\u7528\\u6E10\\u53D8\\u989C\\u8272\\n    outputColor = mix(u_sourceColor, u_targetColor, v);\\n  } else { // \\u4F7F\\u7528 color \\u65B9\\u6CD5\\u4F20\\u5165\\u7684\\u989C\\u8272\\n     outputColor = v_color;\\n  }\\n\\n  outputColor.a *= v_color.a; // \\u5168\\u5C40\\u900F\\u660E\\u5EA6\\n  if(u_animate.x == Animate) {\\n      animateSpeed = u_time / u_animate.y;\\n       float alpha =1.0 - fract( mod(1.0- d_distance_ratio, u_animate.z)* (1.0/ u_animate.z) + animateSpeed);\\n      alpha = (alpha + u_animate.w -1.0) / u_animate.w;\\n      alpha = smoothstep(0., 1., alpha);\\n      outputColor.a *= alpha;\\n  }\\n\\n  if(u_line_texture == LineTexture) { // while load texture\\n    float aDistance = v_dataset.g;      // \\u5F53\\u524D\\u9876\\u70B9\\u7684\\u8DDD\\u79BB\\n    float d_texPixelLen = v_dataset.b;  // \\u8D34\\u56FE\\u7684\\u50CF\\u7D20\\u957F\\u5EA6\\uFF0C\\u6839\\u636E\\u5730\\u56FE\\u5C42\\u7EA7\\u7F29\\u653E\\n    float u = fract(mod(aDistance, d_texPixelLen)/d_texPixelLen - animateSpeed);\\n    float v = v_dataset.a;  // \\u7EBF\\u56FE\\u5C42\\u8D34\\u56FE\\u90E8\\u5206\\u7684 v \\u5750\\u6807\\u503C\\n\\n    // \\u8BA1\\u7B97\\u7EB9\\u7406\\u95F4\\u9694 start\\n    float flag = 0.0;\\n    if(u > 1.0/u_iconStepCount) {\\n      flag = 1.0;\\n    }\\n    u = fract(u*u_iconStepCount);\\n    // \\u8BA1\\u7B97\\u7EB9\\u7406\\u95F4\\u9694 end\\n\\n    vec2 uv= v_iconMapUV / u_textSize + vec2(u, v) / u_textSize * 64.;\\n    vec4 pattern = texture(SAMPLER_2D(u_texture), uv);\\n\\n    // Tip: \\u5224\\u65AD\\u7EB9\\u7406\\u95F4\\u9694\\n    if(flag > 0.0) {\\n      pattern = vec4(0.0);\\n    }\\n\\n    if(u_textureBlend == 0.0) { // normal\\n      pattern.a = 0.0;\\n      outputColor = filterColor(outputColor + pattern);\\n    } else { // replace\\n        pattern.a *= v_color.a;\\n        if(outputColor.a <= 0.0) {\\n          pattern.a = 0.0;\\n        }\\n        outputColor = filterColor(pattern);\\n    }\\n  }\\n\\n\\n  // blur - AA\\n  if(v < v_blur) {\\n    outputColor.a = mix(0.0, outputColor.a, v/v_blur);\\n  } else if(v > 1.0 - v_blur) {\\n    outputColor.a = mix(outputColor.a, 0.0, (v - (1.0 - v_blur))/v_blur);\\n  }\\n\\n  outputColor = filterColor(outputColor);\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/wall/wall_vert.glsl' */\nconst line_vert = \"#define Animate 0.0\\nlayout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in vec2 a_Size;\\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_iconMapUV;\\nlayout(location = ATTRIBUTE_LOCATION_DISTANCE_MITER_TOTAL) in vec3 a_Distance_Total_Miter;\\n\\nlayout(std140) uniform commonUniorm {\\n  vec4 u_animate: [ 1., 2., 1.0, 0.2 ];\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  vec2 u_textSize;\\n  float u_icon_step: 100;\\n  float u_heightfixed;\\n  float u_linearColor: 0;\\n  float u_line_texture;\\n  float u_textureBlend;\\n  float u_iconStepCount;\\n  float u_time;\\n};\\n\\n// texV \\u7EBF\\u56FE\\u5C42 - \\u8D34\\u56FE\\u90E8\\u5206\\u7684 v \\u5750\\u6807\\uFF08\\u7EBF\\u7684\\u5BBD\\u5EA6\\u65B9\\u5411\\uFF09\\nout vec2 v_iconMapUV;\\nout vec4 v_color;\\nout float v_blur;\\nout vec4 v_dataset;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"light\\\"\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  float a_Distance = a_Distance_Total_Miter.x;\\n  float a_Miter = a_Distance_Total_Miter.y;\\n  float a_Total_Distance = a_Distance_Total_Miter.z;\\n\\n  float d_distance_ratio; // \\u5F53\\u524D\\u70B9\\u4F4D\\u8DDD\\u79BB\\u5360\\u7EBF\\u603B\\u957F\\u7684\\u6BD4\\u4F8B\\n  float d_texPixelLen; // \\u8D34\\u56FE\\u7684\\u50CF\\u7D20\\u957F\\u5EA6\\uFF0C\\u6839\\u636E\\u5730\\u56FE\\u5C42\\u7EA7\\u7F29\\u653E\\n\\n  v_iconMapUV = a_iconMapUV;\\n  if (u_heightfixed < 1.0) {\\n    // \\u9AD8\\u5EA6\\u968F zoom \\u8C03\\u6574\\n    d_texPixelLen = project_pixel(u_icon_step);\\n  } else {\\n    d_texPixelLen = u_icon_step;\\n  }\\n\\n  if (u_animate.x == Animate || u_linearColor == 1.0) {\\n    d_distance_ratio = a_Distance / a_Total_Distance;\\n  }\\n\\n  float miter = (a_Miter + 1.0) / 2.0;\\n  // \\u8BBE\\u7F6E\\u6570\\u636E\\u96C6\\u7684\\u53C2\\u6570\\n  v_dataset[0] = d_distance_ratio; // \\u5F53\\u524D\\u70B9\\u4F4D\\u8DDD\\u79BB\\u5360\\u7EBF\\u603B\\u957F\\u7684\\u6BD4\\u4F8B\\n  v_dataset[1] = a_Distance; // \\u5F53\\u524D\\u9876\\u70B9\\u7684\\u8DDD\\u79BB\\n  v_dataset[2] = d_texPixelLen; // \\u8D34\\u56FE\\u7684\\u50CF\\u7D20\\u957F\\u5EA6\\uFF0C\\u6839\\u636E\\u5730\\u56FE\\u5C42\\u7EA7\\u7F29\\u653E\\n  v_dataset[3] = miter; // \\u7EBF\\u56FE\\u5C42\\u8D34\\u56FE\\u90E8\\u5206\\u7684 v \\u5750\\u6807\\u503C 0 - 1\\n\\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0, 1.0), a_Position64Low);\\n\\n  float originSize = a_Size.x; // \\u56FA\\u5B9A\\u9AD8\\u5EA6\\n  if (u_heightfixed < 1.0) {\\n    originSize = project_float_meter(a_Size.x); // \\u9AD8\\u5EA6\\u968F zoom \\u8C03\\u6574\\n  }\\n\\n  float wallHeight = originSize * miter;\\n  float lightWeight = calc_lighting(vec4(project_pos.xy, wallHeight, 1.0));\\n\\n  v_blur = min(project_float_pixel(2.0) / originSize, 0.05);\\n  v_color = vec4(a_Color.rgb * lightWeight, a_Color.w * opacity);\\n\\n  // \\u517C\\u5BB9 mapbox \\u5728\\u7EBF\\u9AD8\\u5EA6\\u4E0A\\u7684\\u6548\\u679C\\u8868\\u73B0\\u57FA\\u672C\\u4E00\\u81F4\\n  if (\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\\n  ) {\\n    // mapbox\\n    // \\u4FDD\\u6301\\u9AD8\\u5EA6\\u76F8\\u5BF9\\u4E0D\\u53D8\\n    float mapboxZoomScale = 4.0 / pow(2.0, 21.0 - u_Zoom);\\n    if (u_heightfixed > 0.0) {\\n      wallHeight *= mapboxZoomScale;\\n    }\\n  }\\n\\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, wallHeight, 1.0));\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\nexport default class LineWallModel extends BaseModel {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"texture\", void 0);\n    _defineProperty(this, \"updateTexture\", () => {\n      const {\n        createTexture2D\n      } = this.rendererService;\n      if (this.texture) {\n        this.texture.update({\n          data: this.iconService.getCanvas()\n        });\n        this.layer.render();\n        return;\n      }\n      this.texture = createTexture2D({\n        data: this.iconService.getCanvas(),\n        mag: gl.NEAREST,\n        min: gl.NEAREST,\n        premultiplyAlpha: false,\n        width: 1024,\n        height: this.iconService.canvasHeight || 128\n      });\n      this.textures = [this.texture];\n    });\n  }\n  get attributeLocation() {\n    return Object.assign(super.attributeLocation, {\n      MAX: super.attributeLocation.MAX,\n      SIZE: 9,\n      NORMAL: 12,\n      UV: 13,\n      DISTANCE_MITER_TOTAL: 15\n    });\n  }\n  getCommonUniformsInfo() {\n    const {\n      sourceColor,\n      targetColor,\n      textureBlend = 'normal',\n      heightfixed = false,\n      lineTexture = false,\n      iconStep = 100,\n      iconStepCount = 1\n    } = this.layer.getLayerConfig();\n    const {\n      animateOption\n    } = this.layer.getLayerConfig();\n    if (this.rendererService.getDirty()) {\n      var _this$texture;\n      (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.bind();\n    }\n\n    // 转化渐变色\n    let useLinearColor = 0; // 默认不生效\n    let sourceColorArr = [0, 0, 0, 0];\n    let targetColorArr = [0, 0, 0, 0];\n    if (sourceColor && targetColor) {\n      sourceColorArr = rgb2arr(sourceColor);\n      targetColorArr = rgb2arr(targetColor);\n      useLinearColor = 1;\n    }\n    const commonOptions = {\n      u_animate: this.animateOption2Array(animateOption),\n      u_sourceColor: sourceColorArr,\n      u_targetColor: targetColorArr,\n      u_textSize: [1024, this.iconService.canvasHeight || 128],\n      u_icon_step: iconStep,\n      u_heightfixed: Number(heightfixed),\n      // 渐变色支持参数\n      u_linearColor: useLinearColor,\n      u_line_texture: lineTexture ? 1.0 : 0.0,\n      // 传入线的标识\n      u_textureBlend: textureBlend === 'normal' ? 0.0 : 1.0,\n      u_iconStepCount: iconStepCount,\n      u_time: this.layer.getLayerAnimateTime() || 0\n    };\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  // public getAnimateUniforms(): IModelUniform {\n  //   const { animateOption } = this.layer.getLayerConfig() as ILayerConfig;\n  //   return {\n  //     u_animate: this.animateOption2Array(animateOption as IAnimateOption),\n  //     u_time: this.layer.getLayerAnimateTime(),\n  //   };\n  // }\n\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.initUniformsBuffer();\n      _this.updateTexture();\n      _this.iconService.on('imageUpdate', _this.updateTexture);\n      return _this.buildModels();\n    })();\n  }\n  clearModels() {\n    var _this$texture2;\n    (_this$texture2 = this.texture) === null || _this$texture2 === void 0 || _this$texture2.destroy();\n    this.iconService.off('imageUpdate', this.updateTexture);\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const model = yield _this2.layer.buildLayerModel({\n        moduleName: 'lineWall',\n        vertexShader: line_vert,\n        fragmentShader: line_frag,\n        triangulation: LineTriangulation,\n        defines: _this2.getDefines(),\n        inject: _this2.getInject(),\n        depth: {\n          enable: false\n        },\n        blend: _this2.getBlend()\n      });\n      return [model];\n    })();\n  }\n  registerBuiltinAttributes() {\n    // 注册 Position 属性 64 位地位部分，经纬度数据开启双精度，避免大于 20层级以上出现数据偏移\n    this.registerPosition64LowAttribute();\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Size',\n        shaderLocation: this.attributeLocation.SIZE,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 2,\n        update: feature => {\n          const {\n            size = 1\n          } = feature;\n          return Array.isArray(size) ? [size[0], size[1]] : [size, 0];\n        }\n      }\n    });\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'normal',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Normal',\n        shaderLocation: this.attributeLocation.NORMAL,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.STATIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        // @ts-ignore\n        update: (feature, featureIdx, vertex, attributeIdx, normal) => {\n          return normal;\n        }\n      }\n    });\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'distanceAndTotalAndMiter',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Distance_Total_Miter',\n        shaderLocation: this.attributeLocation.DISTANCE_MITER_TOTAL,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.STATIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        update: (feature, featureIdx, vertex) => {\n          // [distance, miter, total_distance]\n          return [vertex[3], vertex[4], vertex[5]];\n        }\n      }\n    });\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'uv',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_iconMapUV',\n        shaderLocation: this.attributeLocation.UV,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 2,\n        update: feature => {\n          const iconMap = this.iconService.getIconMap();\n          const {\n            texture\n          } = feature;\n          const {\n            x,\n            y\n          } = iconMap[texture] || {\n            x: 0,\n            y: 0\n          };\n          return [x, y];\n        }\n      }\n    });\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}