{"ast":null,"code":"import { ObjectExt, Dom, Vector } from '../../util';\nimport { Util } from '../../global';\nconst defaultOptions = {\n  padding: 3,\n  rx: 0,\n  ry: 0,\n  attrs: {\n    'stroke-width': 3,\n    stroke: '#FEB663'\n  }\n};\nexport const stroke = {\n  highlight(cellView, magnet, options) {\n    const id = Private.getHighlighterId(magnet, options);\n    if (Private.hasCache(id)) {\n      return;\n    }\n    // eslint-disable-next-line\n    options = ObjectExt.defaultsDeep({}, options, defaultOptions);\n    const magnetVel = Vector.create(magnet);\n    let pathData;\n    let magnetBBox;\n    try {\n      pathData = magnetVel.toPathData();\n    } catch (error) {\n      // Failed to get path data from magnet element.\n      // Draw a rectangle around the entire cell view instead.\n      magnetBBox = magnetVel.bbox(true /* without transforms */);\n      pathData = Dom.rectToPathData(Object.assign(Object.assign({}, options), magnetBBox));\n    }\n    const path = Dom.createSvgElement('path');\n    Dom.attr(path, Object.assign({\n      d: pathData,\n      'pointer-events': 'none',\n      'vector-effect': 'non-scaling-stroke',\n      fill: 'none'\n    }, options.attrs ? Dom.kebablizeAttrs(options.attrs) : null));\n    // const highlightVel = v.create('path').attr()\n    if (cellView.isEdgeElement(magnet)) {\n      Dom.attr(path, 'd', cellView.getConnectionPathData());\n    } else {\n      let highlightMatrix = magnetVel.getTransformToElement(cellView.container);\n      // Add padding to the highlight element.\n      const padding = options.padding;\n      if (padding) {\n        if (magnetBBox == null) {\n          magnetBBox = magnetVel.bbox(true);\n        }\n        const cx = magnetBBox.x + magnetBBox.width / 2;\n        const cy = magnetBBox.y + magnetBBox.height / 2;\n        magnetBBox = Dom.transformRectangle(magnetBBox, highlightMatrix);\n        const width = Math.max(magnetBBox.width, 1);\n        const height = Math.max(magnetBBox.height, 1);\n        const sx = (width + padding) / width;\n        const sy = (height + padding) / height;\n        const paddingMatrix = Dom.createSVGMatrix({\n          a: sx,\n          b: 0,\n          c: 0,\n          d: sy,\n          e: cx - sx * cx,\n          f: cy - sy * cy\n        });\n        highlightMatrix = highlightMatrix.multiply(paddingMatrix);\n      }\n      Dom.transform(path, highlightMatrix);\n    }\n    Dom.addClass(path, Util.prefix('highlight-stroke'));\n    const cell = cellView.cell;\n    const removeHandler = () => Private.removeHighlighter(id);\n    cell.on('removed', removeHandler);\n    if (cell.model) {\n      cell.model.on('reseted', removeHandler);\n    }\n    cellView.container.appendChild(path);\n    Private.setCache(id, path);\n  },\n  unhighlight(cellView, magnet, opt) {\n    Private.removeHighlighter(Private.getHighlighterId(magnet, opt));\n  }\n};\nvar Private;\n(function (Private) {\n  function getHighlighterId(magnet, options) {\n    Dom.ensureId(magnet);\n    return magnet.id + JSON.stringify(options);\n  }\n  Private.getHighlighterId = getHighlighterId;\n  const cache = {};\n  function setCache(id, elem) {\n    cache[id] = elem;\n  }\n  Private.setCache = setCache;\n  function hasCache(id) {\n    return cache[id] != null;\n  }\n  Private.hasCache = hasCache;\n  function removeHighlighter(id) {\n    const elem = cache[id];\n    if (elem) {\n      Dom.remove(elem);\n      delete cache[id];\n    }\n  }\n  Private.removeHighlighter = removeHighlighter;\n})(Private || (Private = {}));","map":{"version":3,"names":["ObjectExt","Dom","Vector","Util","defaultOptions","padding","rx","ry","attrs","stroke","highlight","cellView","magnet","options","id","Private","getHighlighterId","hasCache","defaultsDeep","magnetVel","create","pathData","magnetBBox","toPathData","error","bbox","rectToPathData","Object","assign","path","createSvgElement","attr","d","fill","kebablizeAttrs","isEdgeElement","getConnectionPathData","highlightMatrix","getTransformToElement","container","cx","x","width","cy","y","height","transformRectangle","Math","max","sx","sy","paddingMatrix","createSVGMatrix","a","b","c","e","f","multiply","transform","addClass","prefix","cell","removeHandler","removeHighlighter","on","model","appendChild","setCache","unhighlight","opt","ensureId","JSON","stringify","cache","elem","remove"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/registry/highlighter/stroke.ts"],"sourcesContent":["import { Attr } from '../attr'\nimport { ObjectExt, Dom, Vector } from '../../util'\nimport { Util } from '../../global'\nimport { EdgeView } from '../../view'\nimport { Highlighter } from './index'\n\nexport interface StrokeHighlighterOptions {\n  padding?: number\n  rx?: number\n  ry?: number\n  attrs?: Attr.SimpleAttrs\n}\n\nconst defaultOptions: StrokeHighlighterOptions = {\n  padding: 3,\n  rx: 0,\n  ry: 0,\n  attrs: {\n    'stroke-width': 3,\n    stroke: '#FEB663',\n  },\n}\n\nexport const stroke: Highlighter.Definition<StrokeHighlighterOptions> = {\n  highlight(cellView, magnet, options) {\n    const id = Private.getHighlighterId(magnet, options)\n    if (Private.hasCache(id)) {\n      return\n    }\n\n    // eslint-disable-next-line\n    options = ObjectExt.defaultsDeep({}, options, defaultOptions)\n\n    const magnetVel = Vector.create(magnet as SVGElement)\n    let pathData\n    let magnetBBox\n\n    try {\n      pathData = magnetVel.toPathData()\n    } catch (error) {\n      // Failed to get path data from magnet element.\n      // Draw a rectangle around the entire cell view instead.\n      magnetBBox = magnetVel.bbox(true /* without transforms */)\n      pathData = Dom.rectToPathData({ ...options, ...magnetBBox })\n    }\n\n    const path = Dom.createSvgElement('path')\n    Dom.attr(path, {\n      d: pathData,\n      'pointer-events': 'none',\n      'vector-effect': 'non-scaling-stroke',\n      fill: 'none',\n      ...(options.attrs ? Dom.kebablizeAttrs(options.attrs) : null),\n    })\n\n    // const highlightVel = v.create('path').attr()\n\n    if (cellView.isEdgeElement(magnet)) {\n      Dom.attr(path, 'd', (cellView as EdgeView).getConnectionPathData())\n    } else {\n      let highlightMatrix = magnetVel.getTransformToElement(\n        cellView.container as SVGElement,\n      )\n\n      // Add padding to the highlight element.\n      const padding = options.padding\n      if (padding) {\n        if (magnetBBox == null) {\n          magnetBBox = magnetVel.bbox(true)\n        }\n\n        const cx = magnetBBox.x + magnetBBox.width / 2\n        const cy = magnetBBox.y + magnetBBox.height / 2\n\n        magnetBBox = Dom.transformRectangle(magnetBBox, highlightMatrix)\n\n        const width = Math.max(magnetBBox.width, 1)\n        const height = Math.max(magnetBBox.height, 1)\n        const sx = (width + padding) / width\n        const sy = (height + padding) / height\n\n        const paddingMatrix = Dom.createSVGMatrix({\n          a: sx,\n          b: 0,\n          c: 0,\n          d: sy,\n          e: cx - sx * cx,\n          f: cy - sy * cy,\n        })\n\n        highlightMatrix = highlightMatrix.multiply(paddingMatrix)\n      }\n\n      Dom.transform(path, highlightMatrix)\n    }\n\n    Dom.addClass(path, Util.prefix('highlight-stroke'))\n\n    const cell = cellView.cell\n    const removeHandler = () => Private.removeHighlighter(id)\n\n    cell.on('removed', removeHandler)\n    if (cell.model) {\n      cell.model.on('reseted', removeHandler)\n    }\n\n    cellView.container.appendChild(path)\n    Private.setCache(id, path)\n  },\n\n  unhighlight(cellView, magnet, opt) {\n    Private.removeHighlighter(Private.getHighlighterId(magnet, opt))\n  },\n}\n\nnamespace Private {\n  export function getHighlighterId(\n    magnet: Element,\n    options: StrokeHighlighterOptions,\n  ) {\n    Dom.ensureId(magnet)\n    return magnet.id + JSON.stringify(options)\n  }\n\n  const cache: { [id: string]: Element } = {}\n\n  export function setCache(id: string, elem: Element) {\n    cache[id] = elem\n  }\n\n  export function hasCache(id: string) {\n    return cache[id] != null\n  }\n\n  export function removeHighlighter(id: string) {\n    const elem = cache[id]\n    if (elem) {\n      Dom.remove(elem)\n      delete cache[id]\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}