{"ast":null,"code":"import { Point } from './point';\nimport { Rectangle } from './rectangle';\nimport { Geometry } from './geometry';\nexport class Ellipse extends Geometry {\n  constructor(x, y, a, b) {\n    super();\n    this.x = x == null ? 0 : x;\n    this.y = y == null ? 0 : y;\n    this.a = a == null ? 0 : a;\n    this.b = b == null ? 0 : b;\n  }\n  get [Symbol.toStringTag]() {\n    return Ellipse.toStringTag;\n  }\n  get center() {\n    return new Point(this.x, this.y);\n  }\n  /**\n   * Returns a rectangle that is the bounding box of the ellipse.\n   */\n  bbox() {\n    return Rectangle.fromEllipse(this);\n  }\n  /**\n   * Returns a point that is the center of the ellipse.\n   */\n  getCenter() {\n    return this.center;\n  }\n  inflate(dx, dy) {\n    const w = dx;\n    const h = dy != null ? dy : dx;\n    this.a += 2 * w;\n    this.b += 2 * h;\n    return this;\n  }\n  normalizedDistance(x, y) {\n    const ref = Point.create(x, y);\n    const dx = ref.x - this.x;\n    const dy = ref.y - this.y;\n    const a = this.a;\n    const b = this.b;\n    return dx * dx / (a * a) + dy * dy / (b * b);\n  }\n  containsPoint(x, y) {\n    return this.normalizedDistance(x, y) <= 1;\n  }\n  /**\n   * Returns an array of the intersection points of the ellipse and the line.\n   * Returns `null` if no intersection exists.\n   */\n  intersectsWithLine(line) {\n    const intersections = [];\n    const rx = this.a;\n    const ry = this.b;\n    const a1 = line.start;\n    const a2 = line.end;\n    const dir = line.vector();\n    const diff = a1.diff(new Point(this.x, this.y));\n    const mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry));\n    const mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry));\n    const a = dir.dot(mDir);\n    const b = dir.dot(mDiff);\n    const c = diff.dot(mDiff) - 1.0;\n    const d = b * b - a * c;\n    if (d < 0) {\n      return null;\n    }\n    if (d > 0) {\n      const root = Math.sqrt(d);\n      const ta = (-b - root) / a;\n      const tb = (-b + root) / a;\n      if ((ta < 0 || ta > 1) && (tb < 0 || tb > 1)) {\n        // outside\n        return null;\n      }\n      if (ta >= 0 && ta <= 1) {\n        intersections.push(a1.lerp(a2, ta));\n      }\n      if (tb >= 0 && tb <= 1) {\n        intersections.push(a1.lerp(a2, tb));\n      }\n    } else {\n      const t = -b / a;\n      if (t >= 0 && t <= 1) {\n        intersections.push(a1.lerp(a2, t));\n      } else {\n        // outside\n        return null;\n      }\n    }\n    return intersections;\n  }\n  /**\n   * Returns the point on the boundary of the ellipse that is the\n   * intersection of the ellipse with a line starting in the center\n   * of the ellipse ending in the point `p`.\n   *\n   * If angle is specified, the intersection will take into account\n   * the rotation of the ellipse by angle degrees around its center.\n   */\n  intersectsWithLineFromCenterToPoint(p, angle = 0) {\n    const ref = Point.clone(p);\n    if (angle) {\n      ref.rotate(angle, this.getCenter());\n    }\n    const dx = ref.x - this.x;\n    const dy = ref.y - this.y;\n    let result;\n    if (dx === 0) {\n      result = this.bbox().getNearestPointToPoint(ref);\n      if (angle) {\n        return result.rotate(-angle, this.getCenter());\n      }\n      return result;\n    }\n    const m = dy / dx;\n    const mSquared = m * m;\n    const aSquared = this.a * this.a;\n    const bSquared = this.b * this.b;\n    let x = Math.sqrt(1 / (1 / aSquared + mSquared / bSquared));\n    x = dx < 0 ? -x : x;\n    const y = m * x;\n    result = new Point(this.x + x, this.y + y);\n    if (angle) {\n      return result.rotate(-angle, this.getCenter());\n    }\n    return result;\n  }\n  /**\n   * Returns the angle between the x-axis and the tangent from a point. It is\n   * valid for points lying on the ellipse boundary only.\n   */\n  tangentTheta(p) {\n    const ref = Point.clone(p);\n    const x0 = ref.x;\n    const y0 = ref.y;\n    const a = this.a;\n    const b = this.b;\n    const center = this.bbox().center;\n    const cx = center.x;\n    const cy = center.y;\n    const refPointDelta = 30;\n    const q1 = x0 > center.x + a / 2;\n    const q3 = x0 < center.x - a / 2;\n    let x;\n    let y;\n    if (q1 || q3) {\n      y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;\n      x = a * a / (x0 - cx) - a * a * (y0 - cy) * (y - cy) / (b * b * (x0 - cx)) + cx;\n    } else {\n      x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;\n      y = b * b / (y0 - cy) - b * b * (x0 - cx) * (x - cx) / (a * a * (y0 - cy)) + cy;\n    }\n    return new Point(x, y).theta(ref);\n  }\n  scale(sx, sy) {\n    this.a *= sx;\n    this.b *= sy;\n    return this;\n  }\n  rotate(angle, origin) {\n    const rect = Rectangle.fromEllipse(this);\n    rect.rotate(angle, origin);\n    const ellipse = Ellipse.fromRect(rect);\n    this.a = ellipse.a;\n    this.b = ellipse.b;\n    this.x = ellipse.x;\n    this.y = ellipse.y;\n    return this;\n  }\n  translate(dx, dy) {\n    const p = Point.create(dx, dy);\n    this.x += p.x;\n    this.y += p.y;\n    return this;\n  }\n  equals(ellipse) {\n    return ellipse != null && ellipse.x === this.x && ellipse.y === this.y && ellipse.a === this.a && ellipse.b === this.b;\n  }\n  clone() {\n    return new Ellipse(this.x, this.y, this.a, this.b);\n  }\n  toJSON() {\n    return {\n      x: this.x,\n      y: this.y,\n      a: this.a,\n      b: this.b\n    };\n  }\n  serialize() {\n    return `${this.x} ${this.y} ${this.a} ${this.b}`;\n  }\n}\n(function (Ellipse) {\n  Ellipse.toStringTag = `X6.Geometry.${Ellipse.name}`;\n  function isEllipse(instance) {\n    if (instance == null) {\n      return false;\n    }\n    if (instance instanceof Ellipse) {\n      return true;\n    }\n    const tag = instance[Symbol.toStringTag];\n    const ellipse = instance;\n    if ((tag == null || tag === Ellipse.toStringTag) && typeof ellipse.x === 'number' && typeof ellipse.y === 'number' && typeof ellipse.a === 'number' && typeof ellipse.b === 'number' && typeof ellipse.inflate === 'function' && typeof ellipse.normalizedDistance === 'function') {\n      return true;\n    }\n    return false;\n  }\n  Ellipse.isEllipse = isEllipse;\n})(Ellipse || (Ellipse = {}));\n(function (Ellipse) {\n  function create(x, y, a, b) {\n    if (x == null || typeof x === 'number') {\n      return new Ellipse(x, y, a, b);\n    }\n    return parse(x);\n  }\n  Ellipse.create = create;\n  function parse(e) {\n    if (Ellipse.isEllipse(e)) {\n      return e.clone();\n    }\n    if (Array.isArray(e)) {\n      return new Ellipse(e[0], e[1], e[2], e[3]);\n    }\n    return new Ellipse(e.x, e.y, e.a, e.b);\n  }\n  Ellipse.parse = parse;\n  function fromRect(rect) {\n    const center = rect.center;\n    return new Ellipse(center.x, center.y, rect.width / 2, rect.height / 2);\n  }\n  Ellipse.fromRect = fromRect;\n})(Ellipse || (Ellipse = {}));","map":{"version":3,"names":["Point","Rectangle","Geometry","Ellipse","constructor","x","y","a","b","Symbol","toStringTag","center","bbox","fromEllipse","getCenter","inflate","dx","dy","w","h","normalizedDistance","ref","create","containsPoint","intersectsWithLine","line","intersections","rx","ry","a1","start","a2","end","dir","vector","diff","mDir","mDiff","dot","c","d","root","Math","sqrt","ta","tb","push","lerp","t","intersectsWithLineFromCenterToPoint","p","angle","clone","rotate","result","getNearestPointToPoint","m","mSquared","aSquared","bSquared","tangentTheta","x0","y0","cx","cy","refPointDelta","q1","q3","theta","scale","sx","sy","origin","rect","ellipse","fromRect","translate","equals","toJSON","serialize","name","isEllipse","instance","tag","parse","e","Array","isArray","width","height"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/geometry/ellipse.ts"],"sourcesContent":["import { Point } from './point'\nimport { Line } from './line'\nimport { Rectangle } from './rectangle'\nimport { Geometry } from './geometry'\n\nexport class Ellipse extends Geometry implements Ellipse.EllipseLike {\n  public x: number\n  public y: number\n  public a: number\n  public b: number\n\n  protected get [Symbol.toStringTag]() {\n    return Ellipse.toStringTag\n  }\n\n  get center() {\n    return new Point(this.x, this.y)\n  }\n\n  constructor(x?: number, y?: number, a?: number, b?: number) {\n    super()\n    this.x = x == null ? 0 : x\n    this.y = y == null ? 0 : y\n    this.a = a == null ? 0 : a\n    this.b = b == null ? 0 : b\n  }\n\n  /**\n   * Returns a rectangle that is the bounding box of the ellipse.\n   */\n  bbox() {\n    return Rectangle.fromEllipse(this)\n  }\n\n  /**\n   * Returns a point that is the center of the ellipse.\n   */\n  getCenter() {\n    return this.center\n  }\n\n  /**\n   * Returns ellipse inflated in axis-x by `2 * amount` and in axis-y by\n   * `2 * amount`.\n   */\n  inflate(amount: number): this\n  /**\n   * Returns ellipse inflated in axis-x by `2 * dx` and in axis-y by `2 * dy`.\n   */\n  inflate(dx: number, dy: number): this\n  inflate(dx: number, dy?: number): this {\n    const w = dx\n    const h = dy != null ? dy : dx\n    this.a += 2 * w\n    this.b += 2 * h\n\n    return this\n  }\n\n  /**\n   * Returns a normalized distance from the ellipse center to point `p`.\n   * Returns `n < 1` for points inside the ellipse, `n = 1` for points\n   * lying on the ellipse boundary and `n > 1` for points outside the ellipse.\n   */\n  normalizedDistance(x: number, y: number): number\n  normalizedDistance(p: Point.PointLike | Point.PointData): number\n  normalizedDistance(\n    x: number | Point.PointLike | Point.PointData,\n    y?: number,\n  ) {\n    const ref = Point.create(x, y)\n    const dx = ref.x - this.x\n    const dy = ref.y - this.y\n    const a = this.a\n    const b = this.b\n\n    return (dx * dx) / (a * a) + (dy * dy) / (b * b)\n  }\n\n  /**\n   * Returns `true` if the point `p` is inside the ellipse (inclusive).\n   * Returns `false` otherwise.\n   */\n  containsPoint(x: number, y: number): boolean\n  containsPoint(p: Point.PointLike | Point.PointData): boolean\n  containsPoint(x: number | Point.PointLike | Point.PointData, y?: number) {\n    return this.normalizedDistance(x as number, y as number) <= 1\n  }\n\n  /**\n   * Returns an array of the intersection points of the ellipse and the line.\n   * Returns `null` if no intersection exists.\n   */\n  intersectsWithLine(line: Line) {\n    const intersections = []\n    const rx = this.a\n    const ry = this.b\n    const a1 = line.start\n    const a2 = line.end\n    const dir = line.vector()\n    const diff = a1.diff(new Point(this.x, this.y))\n    const mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry))\n    const mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry))\n\n    const a = dir.dot(mDir)\n    const b = dir.dot(mDiff)\n    const c = diff.dot(mDiff) - 1.0\n    const d = b * b - a * c\n\n    if (d < 0) {\n      return null\n    }\n\n    if (d > 0) {\n      const root = Math.sqrt(d)\n      const ta = (-b - root) / a\n      const tb = (-b + root) / a\n\n      if ((ta < 0 || ta > 1) && (tb < 0 || tb > 1)) {\n        // outside\n        return null\n      }\n\n      if (ta >= 0 && ta <= 1) {\n        intersections.push(a1.lerp(a2, ta))\n      }\n\n      if (tb >= 0 && tb <= 1) {\n        intersections.push(a1.lerp(a2, tb))\n      }\n    } else {\n      const t = -b / a\n      if (t >= 0 && t <= 1) {\n        intersections.push(a1.lerp(a2, t))\n      } else {\n        // outside\n        return null\n      }\n    }\n\n    return intersections\n  }\n\n  /**\n   * Returns the point on the boundary of the ellipse that is the\n   * intersection of the ellipse with a line starting in the center\n   * of the ellipse ending in the point `p`.\n   *\n   * If angle is specified, the intersection will take into account\n   * the rotation of the ellipse by angle degrees around its center.\n   */\n  intersectsWithLineFromCenterToPoint(\n    p: Point.PointLike | Point.PointData,\n    angle = 0,\n  ) {\n    const ref = Point.clone(p)\n    if (angle) {\n      ref.rotate(angle, this.getCenter())\n    }\n\n    const dx = ref.x - this.x\n    const dy = ref.y - this.y\n    let result\n\n    if (dx === 0) {\n      result = this.bbox().getNearestPointToPoint(ref)\n      if (angle) {\n        return result.rotate(-angle, this.getCenter())\n      }\n      return result\n    }\n\n    const m = dy / dx\n    const mSquared = m * m\n    const aSquared = this.a * this.a\n    const bSquared = this.b * this.b\n\n    let x = Math.sqrt(1 / (1 / aSquared + mSquared / bSquared))\n    x = dx < 0 ? -x : x\n\n    const y = m * x\n    result = new Point(this.x + x, this.y + y)\n\n    if (angle) {\n      return result.rotate(-angle, this.getCenter())\n    }\n\n    return result\n  }\n\n  /**\n   * Returns the angle between the x-axis and the tangent from a point. It is\n   * valid for points lying on the ellipse boundary only.\n   */\n  tangentTheta(p: Point.PointLike | Point.PointData) {\n    const ref = Point.clone(p)\n    const x0 = ref.x\n    const y0 = ref.y\n    const a = this.a\n    const b = this.b\n    const center = this.bbox().center\n    const cx = center.x\n    const cy = center.y\n    const refPointDelta = 30\n\n    const q1 = x0 > center.x + a / 2\n    const q3 = x0 < center.x - a / 2\n\n    let x\n    let y\n\n    if (q1 || q3) {\n      y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta\n      x =\n        (a * a) / (x0 - cx) -\n        (a * a * (y0 - cy) * (y - cy)) / (b * b * (x0 - cx)) +\n        cx\n    } else {\n      x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta\n      y =\n        (b * b) / (y0 - cy) -\n        (b * b * (x0 - cx) * (x - cx)) / (a * a * (y0 - cy)) +\n        cy\n    }\n\n    return new Point(x, y).theta(ref)\n  }\n\n  scale(sx: number, sy: number) {\n    this.a *= sx\n    this.b *= sy\n    return this\n  }\n\n  rotate(angle: number, origin?: Point.PointLike | Point.PointData) {\n    const rect = Rectangle.fromEllipse(this)\n    rect.rotate(angle, origin)\n    const ellipse = Ellipse.fromRect(rect)\n    this.a = ellipse.a\n    this.b = ellipse.b\n    this.x = ellipse.x\n    this.y = ellipse.y\n    return this\n  }\n\n  translate(dx: number, dy: number): this\n  translate(p: Point.PointLike | Point.PointData): this\n  translate(dx: number | Point.PointLike | Point.PointData, dy?: number): this {\n    const p = Point.create(dx, dy)\n    this.x += p.x\n    this.y += p.y\n    return this\n  }\n\n  equals(ellipse: Ellipse) {\n    return (\n      ellipse != null &&\n      ellipse.x === this.x &&\n      ellipse.y === this.y &&\n      ellipse.a === this.a &&\n      ellipse.b === this.b\n    )\n  }\n\n  clone() {\n    return new Ellipse(this.x, this.y, this.a, this.b)\n  }\n\n  toJSON() {\n    return { x: this.x, y: this.y, a: this.a, b: this.b }\n  }\n\n  serialize() {\n    return `${this.x} ${this.y} ${this.a} ${this.b}`\n  }\n}\n\nexport namespace Ellipse {\n  export const toStringTag = `X6.Geometry.${Ellipse.name}`\n\n  export function isEllipse(instance: any): instance is Ellipse {\n    if (instance == null) {\n      return false\n    }\n\n    if (instance instanceof Ellipse) {\n      return true\n    }\n\n    const tag = instance[Symbol.toStringTag]\n    const ellipse = instance as Ellipse\n\n    if (\n      (tag == null || tag === toStringTag) &&\n      typeof ellipse.x === 'number' &&\n      typeof ellipse.y === 'number' &&\n      typeof ellipse.a === 'number' &&\n      typeof ellipse.b === 'number' &&\n      typeof ellipse.inflate === 'function' &&\n      typeof ellipse.normalizedDistance === 'function'\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n\nexport namespace Ellipse {\n  export interface EllipseLike extends Point.PointLike {\n    x: number\n    y: number\n    a: number\n    b: number\n  }\n\n  export type EllipseData = [number, number, number, number]\n}\n\nexport namespace Ellipse {\n  export function create(\n    x?: number | Ellipse | EllipseLike | EllipseData,\n    y?: number,\n    a?: number,\n    b?: number,\n  ): Ellipse {\n    if (x == null || typeof x === 'number') {\n      return new Ellipse(x, y, a, b)\n    }\n\n    return parse(x)\n  }\n\n  export function parse(e: Ellipse | EllipseLike | EllipseData) {\n    if (Ellipse.isEllipse(e)) {\n      return e.clone()\n    }\n\n    if (Array.isArray(e)) {\n      return new Ellipse(e[0], e[1], e[2], e[3])\n    }\n\n    return new Ellipse(e.x, e.y, e.a, e.b)\n  }\n\n  export function fromRect(rect: Rectangle) {\n    const center = rect.center\n    return new Ellipse(center.x, center.y, rect.width / 2, rect.height / 2)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}