{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Dom, FunctionExt } from '../util';\nimport { Rectangle } from '../geometry';\nimport { Cell } from '../model';\nimport { View, CellView } from '../view';\nimport { Base } from './base';\nexport class Renderer extends Base {\n  init() {\n    this.resetUpdates();\n    this.startListening();\n    // Renders existing cells in the model.\n    this.resetViews(this.model.getCells());\n    // Starts rendering loop.\n    if (!this.isFrozen() && this.isAsync()) {\n      this.updateViewsAsync();\n    }\n  }\n  startListening() {\n    this.model.on('sorted', this.onSortModel, this);\n    this.model.on('reseted', this.onModelReseted, this);\n    this.model.on('batch:stop', this.onBatchStop, this);\n    this.model.on('cell:added', this.onCellAdded, this);\n    this.model.on('cell:removed', this.onCellRemoved, this);\n    this.model.on('cell:change:zIndex', this.onCellZIndexChanged, this);\n    this.model.on('cell:change:visible', this.onCellVisibleChanged, this);\n  }\n  stopListening() {\n    this.model.off('sorted', this.onSortModel, this);\n    this.model.off('reseted', this.onModelReseted, this);\n    this.model.off('batch:stop', this.onBatchStop, this);\n    this.model.off('cell:added', this.onCellAdded, this);\n    this.model.off('cell:removed', this.onCellRemoved, this);\n    this.model.off('cell:change:zIndex', this.onCellZIndexChanged, this);\n    this.model.off('cell:change:visible', this.onCellVisibleChanged, this);\n  }\n  resetUpdates() {\n    this.updates = {\n      priorities: [{}, {}, {}],\n      mounted: {},\n      mountedCids: [],\n      unmounted: {},\n      unmountedCids: [],\n      count: 0,\n      sort: false,\n      frozen: false,\n      freezeKey: null,\n      animationId: null\n    };\n  }\n  onSortModel() {\n    if (this.model.hasActiveBatch(Renderer.SORT_DELAYING_BATCHES)) {\n      return;\n    }\n    this.sortViews();\n  }\n  onModelReseted({\n    options\n  }) {\n    this.removeZPivots();\n    this.resetViews(this.model.getCells(), options);\n  }\n  onBatchStop({\n    name,\n    data\n  }) {\n    if (this.isFrozen()) {\n      return;\n    }\n    const model = this.model;\n    if (!this.isAsync()) {\n      const updateDelayingBatches = Renderer.UPDATE_DELAYING_BATCHES;\n      if (updateDelayingBatches.includes(name) && !model.hasActiveBatch(updateDelayingBatches)) {\n        this.updateViews(data);\n      }\n    }\n    const sortDelayingBatches = Renderer.SORT_DELAYING_BATCHES;\n    if (sortDelayingBatches.includes(name) && !model.hasActiveBatch(sortDelayingBatches)) {\n      this.sortViews();\n    }\n  }\n  onCellAdded({\n    cell,\n    options\n  }) {\n    const position = options.position;\n    if (this.isAsync() || typeof position !== 'number') {\n      this.renderView(cell, options);\n    } else {\n      if (options.maxPosition === position) {\n        this.freeze({\n          key: 'addCells'\n        });\n      }\n      this.renderView(cell, options);\n      if (position === 0) {\n        this.unfreeze({\n          key: 'addCells'\n        });\n      }\n    }\n  }\n  onCellRemoved({\n    cell,\n    options\n  }) {\n    const view = this.findViewByCell(cell);\n    if (view) {\n      this.requestViewUpdate(view, Renderer.FLAG_REMOVE, view.priority, options);\n    }\n  }\n  onCellZIndexChanged({\n    cell,\n    options\n  }) {\n    if (this.options.sorting === 'approx') {\n      const view = this.findViewByCell(cell);\n      if (view) {\n        this.requestViewUpdate(view, Renderer.FLAG_INSERT, view.priority, options);\n      }\n    }\n  }\n  onCellVisibleChanged({\n    cell,\n    current: visible,\n    options\n  }) {\n    // Hide connected edges before cell\n    if (!visible) {\n      this.processEdgeOnTerminalVisibleChanged(cell, false);\n    }\n    const view = this.findViewByCell(cell);\n    if (!visible && view) {\n      this.removeView(cell);\n    } else if (visible && view == null) {\n      this.renderView(cell, options);\n    }\n    // Show connected edges after cell rendered\n    if (visible) {\n      this.processEdgeOnTerminalVisibleChanged(cell, true);\n    }\n    // this.sortViews()\n  }\n  processEdgeOnTerminalVisibleChanged(node, visible) {\n    const getOpposite = (edge, currentTerminal) => {\n      const sourceId = edge.getSourceCellId();\n      if (sourceId !== currentTerminal.id) {\n        return edge.getSourceCell();\n      }\n      const targetId = edge.getTargetCellId();\n      if (targetId !== currentTerminal.id) {\n        return edge.getTargetCell();\n      }\n      return null;\n    };\n    this.model.getConnectedEdges(node).forEach(edge => {\n      const opposite = getOpposite(edge, node);\n      if (opposite == null || opposite.isVisible()) {\n        visible ? edge.show() : edge.hide();\n      }\n    });\n  }\n  isEdgeTerminalVisible(edge, terminal) {\n    const cellId = terminal === 'source' ? edge.getSourceCellId() : edge.getTargetCellId();\n    const cell = cellId ? this.model.getCell(cellId) : null;\n    if (cell && !cell.isVisible()) {\n      return false;\n    }\n    return true;\n  }\n  requestConnectedEdgesUpdate(view, options = {}) {\n    if (CellView.isCellView(view)) {\n      const cell = view.cell;\n      const edges = this.model.getConnectedEdges(cell);\n      for (let j = 0, n = edges.length; j < n; j += 1) {\n        const edge = edges[j];\n        const edgeView = this.findViewByCell(edge);\n        if (!edgeView) {\n          continue;\n        }\n        const flagLabels = ['update'];\n        if (edge.getTargetCell() === cell) {\n          flagLabels.push('target');\n        }\n        if (edge.getSourceCell() === cell) {\n          flagLabels.push('source');\n        }\n        this.scheduleViewUpdate(edgeView, edgeView.getFlag(flagLabels), edgeView.priority, options);\n      }\n    }\n  }\n  forcePostponedViewUpdate(view, flag) {\n    if (!view || !CellView.isCellView(view)) {\n      return false;\n    }\n    const cell = view.cell;\n    if (cell.isNode()) {\n      return false;\n    }\n    const edgeView = view;\n    if (cell.isEdge() && (flag & view.getFlag(['source', 'target'])) === 0) {\n      // EdgeView is waiting for the source/target cellView to be rendered.\n      // This can happen when the cells are not in the viewport.\n      let sourceFlag = 0;\n      const sourceView = this.findViewByCell(cell.getSourceCell());\n      if (sourceView && !this.isViewMounted(sourceView)) {\n        sourceFlag = this.dumpView(sourceView);\n        edgeView.updateTerminalMagnet('source');\n      }\n      let targetFlag = 0;\n      const targetView = this.findViewByCell(cell.getTargetCell());\n      if (targetView && !this.isViewMounted(targetView)) {\n        targetFlag = this.dumpView(targetView);\n        edgeView.updateTerminalMagnet('target');\n      }\n      if (sourceFlag === 0 && targetFlag === 0) {\n        // If leftover flag is 0, all view updates were done.\n        return !this.dumpView(edgeView);\n      }\n    }\n    return false;\n  }\n  scheduleViewUpdate(view, flag, priority, options = {}) {\n    const cid = view.cid;\n    const updates = this.updates;\n    let cache = updates.priorities[priority];\n    if (!cache) {\n      cache = updates.priorities[priority] = {};\n    }\n    const currentFlag = cache[cid] || 0;\n    if ((currentFlag & flag) === flag) {\n      return;\n    }\n    if (!currentFlag) {\n      updates.count += 1;\n    }\n    if (flag & Renderer.FLAG_REMOVE && currentFlag & Renderer.FLAG_INSERT) {\n      // When a view is removed we need to remove the\n      // insert flag as this is a reinsert.\n      cache[cid] ^= Renderer.FLAG_INSERT;\n    } else if (flag & Renderer.FLAG_INSERT && currentFlag & Renderer.FLAG_REMOVE) {\n      // When a view is added we need to remove the remove\n      // flag as this is view was previously removed.\n      cache[cid] ^= Renderer.FLAG_REMOVE;\n    }\n    cache[cid] |= flag;\n    this.graph.hook.onViewUpdated(view, flag, options);\n  }\n  requestViewUpdate(view, flag, priority, options = {}) {\n    this.scheduleViewUpdate(view, flag, priority, options);\n    const isAsync = this.isAsync();\n    if (this.isFrozen() || isAsync && options.async !== false || this.model.hasActiveBatch(Renderer.UPDATE_DELAYING_BATCHES)) {\n      return;\n    }\n    const stats = this.updateViews(options);\n    if (isAsync) {\n      this.graph.trigger('render:done', {\n        stats,\n        options\n      });\n    }\n  }\n  /**\n   * Adds view into the DOM and update it.\n   */\n  dumpView(view, options = {}) {\n    if (view == null) {\n      return 0;\n    }\n    const cid = view.cid;\n    const updates = this.updates;\n    const cache = updates.priorities[view.priority];\n    const flag = this.registerMountedView(view) | cache[cid];\n    delete cache[cid];\n    if (!flag) {\n      return 0;\n    }\n    return this.updateView(view, flag, options);\n  }\n  /**\n   * Adds all views into the DOM and update them.\n   */\n  dumpViews(options = {}) {\n    this.checkView(options);\n    this.updateViews(options);\n  }\n  /**\n   * Ensure the view associated with the cell is attached\n   * to the DOM and updated.\n   */\n  requireView(cell, options = {}) {\n    const view = this.findViewByCell(cell);\n    if (view == null) {\n      return null;\n    }\n    this.dumpView(view, options);\n    return view;\n  }\n  updateView(view, flag, options = {}) {\n    if (view == null) {\n      return 0;\n    }\n    if (CellView.isCellView(view)) {\n      if (flag & Renderer.FLAG_REMOVE) {\n        this.removeView(view.cell);\n        return 0;\n      }\n      if (flag & Renderer.FLAG_INSERT) {\n        this.insertView(view);\n        flag ^= Renderer.FLAG_INSERT; // eslint-disable-line\n      }\n    }\n    if (!flag) {\n      return 0;\n    }\n    return view.confirmUpdate(flag, options);\n  }\n  updateViews(options = {}) {\n    let result;\n    let batchCount = 0;\n    let updatedCount = 0;\n    let priority = Renderer.MIN_PRIORITY;\n    do {\n      result = this.updateViewsBatch(options);\n      batchCount += 1;\n      updatedCount += result.updatedCount;\n      priority = Math.min(result.priority, priority);\n    } while (!result.empty);\n    return {\n      priority,\n      batchCount,\n      updatedCount\n    };\n  }\n  updateViewsBatch(options = {}) {\n    const updates = this.updates;\n    const priorities = updates.priorities;\n    const batchSize = options.batchSize || Renderer.UPDATE_BATCH_SIZE;\n    let empty = true;\n    let priority = Renderer.MIN_PRIORITY;\n    let mountedCount = 0;\n    let unmountedCount = 0;\n    let updatedCount = 0;\n    let postponedCount = 0;\n    let checkView = options.checkView || this.options.checkView;\n    if (typeof checkView !== 'function') {\n      checkView = null;\n    }\n    // eslint-disable-next-line\n    main: for (let p = 0, n = priorities.length; p < n; p += 1) {\n      const cache = priorities[p];\n      // eslint-disable-next-line\n      for (const cid in cache) {\n        if (updatedCount >= batchSize) {\n          empty = false; // goto next batch\n          break main; // eslint-disable-line no-labels\n        }\n        const view = View.views[cid];\n        if (!view) {\n          delete cache[cid];\n          continue;\n        }\n        let currentFlag = cache[cid];\n        // Do not check a view for viewport if we are about to remove the view.\n        if ((currentFlag & Renderer.FLAG_REMOVE) === 0) {\n          const isUnmounted = cid in updates.unmounted;\n          if (checkView && !FunctionExt.call(checkView, this.graph, {\n            view: view,\n            unmounted: isUnmounted\n          })) {\n            // Unmount view\n            if (!isUnmounted) {\n              this.registerUnmountedView(view);\n              view.unmount();\n            }\n            updates.unmounted[cid] |= currentFlag;\n            delete cache[cid];\n            unmountedCount += 1;\n            continue;\n          }\n          // Mount view\n          if (isUnmounted) {\n            currentFlag |= Renderer.FLAG_INSERT;\n            mountedCount += 1;\n          }\n          currentFlag |= this.registerMountedView(view);\n        }\n        const cellView = view;\n        let leftoverFlag = this.updateView(view, currentFlag, options);\n        if (leftoverFlag > 0) {\n          const cell = cellView.cell;\n          if (cell && cell.isEdge()) {\n            // remove edge view when source cell is invisible\n            if (cellView.hasAction(leftoverFlag, 'source') && !this.isEdgeTerminalVisible(cell, 'source')) {\n              leftoverFlag = cellView.removeAction(leftoverFlag, 'source');\n              leftoverFlag |= Renderer.FLAG_REMOVE;\n            }\n            // remove edge view when target cell is invisible\n            if (cellView.hasAction(leftoverFlag, 'target') && !this.isEdgeTerminalVisible(cell, 'target')) {\n              leftoverFlag = cellView.removeAction(leftoverFlag, 'target');\n              leftoverFlag |= Renderer.FLAG_REMOVE;\n            }\n          }\n        }\n        if (leftoverFlag > 0) {\n          // update has not finished\n          cache[cid] = leftoverFlag;\n          if (!this.graph.hook.onViewPostponed(cellView, leftoverFlag, options) || cache[cid]) {\n            postponedCount += 1;\n            empty = false;\n            continue;\n          }\n        }\n        if (priority > p) {\n          priority = p;\n        }\n        updatedCount += 1;\n        delete cache[cid];\n      }\n    }\n    return {\n      empty,\n      priority,\n      mountedCount,\n      unmountedCount,\n      updatedCount,\n      postponedCount\n    };\n  }\n  updateViewsAsync(options = {}, data = {\n    processed: 0,\n    priority: Renderer.MIN_PRIORITY\n  }) {\n    const updates = this.updates;\n    const animationId = updates.animationId;\n    if (animationId) {\n      Dom.cancelAnimationFrame(animationId);\n      if (data.processed === 0) {\n        const beforeFn = options.before;\n        if (typeof beforeFn === 'function') {\n          FunctionExt.call(beforeFn, this.graph, this.graph);\n        }\n      }\n      const stats = this.updateViewsBatch(options);\n      const checkout = this.checkViewImpl({\n        checkView: options.checkView,\n        mountedBatchSize: Renderer.MOUNT_BATCH_SIZE - stats.mountedCount,\n        unmountedBatchSize: Renderer.MOUNT_BATCH_SIZE - stats.unmountedCount\n      });\n      let processed = data.processed;\n      const total = updates.count;\n      const mountedCount = checkout.mountedCount;\n      const unmountedCount = checkout.unmountedCount;\n      if (stats.updatedCount > 0) {\n        // Some updates have been just processed\n        processed += stats.updatedCount + stats.unmountedCount;\n        data.priority = Math.min(stats.priority, data.priority);\n        if (stats.empty && mountedCount === 0) {\n          stats.priority = data.priority;\n          stats.mountedCount += mountedCount;\n          stats.unmountedCount += unmountedCount;\n          this.graph.trigger('render:done', {\n            stats,\n            options\n          });\n          data.processed = 0;\n          updates.count = 0;\n        } else {\n          data.processed = processed;\n        }\n      }\n      // Progress callback\n      const progressFn = options.progress;\n      if (total && typeof progressFn === 'function') {\n        FunctionExt.call(progressFn, this.graph, {\n          total,\n          done: stats.empty,\n          current: processed\n        });\n      }\n      // The current frame could have been canceled in a callback\n      if (updates.animationId !== animationId) {\n        return;\n      }\n    }\n    updates.animationId = Dom.requestAnimationFrame(() => {\n      this.updateViewsAsync(options, data);\n    });\n  }\n  registerMountedView(view) {\n    const cid = view.cid;\n    const updates = this.updates;\n    if (cid in updates.mounted) {\n      return 0;\n    }\n    updates.mounted[cid] = true;\n    updates.mountedCids.push(cid);\n    const flag = updates.unmounted[cid] || 0;\n    delete updates.unmounted[cid];\n    return flag;\n  }\n  registerUnmountedView(view) {\n    const cid = view.cid;\n    const updates = this.updates;\n    if (cid in updates.unmounted) {\n      return 0;\n    }\n    updates.unmounted[cid] |= Renderer.FLAG_INSERT;\n    const flag = updates.unmounted[cid];\n    updates.unmountedCids.push(cid);\n    delete updates.mounted[cid];\n    return flag;\n  }\n  isViewMounted(view) {\n    if (view == null) {\n      return false;\n    }\n    const cid = view.cid;\n    return cid in this.updates.mounted;\n  }\n  getMountedViews() {\n    return Object.keys(this.updates.mounted).map(cid => CellView.views[cid]);\n  }\n  getUnmountedViews() {\n    return Object.keys(this.updates.unmounted).map(cid => CellView.views[cid]);\n  }\n  checkMountedViews(viewportFn, batchSize) {\n    let unmountCount = 0;\n    if (typeof viewportFn !== 'function') {\n      return unmountCount;\n    }\n    const updates = this.updates;\n    const mounted = updates.mounted;\n    const mountedCids = updates.mountedCids;\n    const size = batchSize == null ? mountedCids.length : Math.min(mountedCids.length, batchSize);\n    for (let i = 0; i < size; i += 1) {\n      const cid = mountedCids[i];\n      if (!(cid in mounted)) {\n        continue;\n      }\n      const view = CellView.views[cid];\n      if (view == null) {\n        continue;\n      }\n      const shouldMount = FunctionExt.call(viewportFn, this.graph, {\n        view: view,\n        unmounted: true\n      });\n      if (shouldMount) {\n        // Push at the end of all mounted ids\n        mountedCids.push(cid);\n        continue;\n      }\n      unmountCount += 1;\n      const flag = this.registerUnmountedView(view);\n      if (flag) {\n        view.unmount();\n      }\n    }\n    // Get rid of views, that have been unmounted\n    mountedCids.splice(0, size);\n    return unmountCount;\n  }\n  checkUnmountedViews(checkView, batchSize) {\n    let mountCount = 0;\n    if (typeof checkView !== 'function') {\n      checkView = null; // eslint-disable-line\n    }\n    const updates = this.updates;\n    const unmounted = updates.unmounted;\n    const unmountedCids = updates.unmountedCids;\n    const size = batchSize == null ? unmountedCids.length : Math.min(unmountedCids.length, batchSize);\n    for (let i = 0; i < size; i += 1) {\n      const cid = unmountedCids[i];\n      if (!(cid in unmounted)) {\n        continue;\n      }\n      const view = CellView.views[cid];\n      if (view == null) {\n        continue;\n      }\n      if (checkView && !FunctionExt.call(checkView, this.graph, {\n        view,\n        unmounted: false\n      })) {\n        unmountedCids.push(cid);\n        continue;\n      }\n      mountCount += 1;\n      const flag = this.registerMountedView(view);\n      if (flag) {\n        this.scheduleViewUpdate(view, flag, view.priority, {\n          mounting: true\n        });\n      }\n    }\n    // Get rid of views, that have been mounted\n    unmountedCids.splice(0, size);\n    return mountCount;\n  }\n  checkViewImpl(options = {\n    mountedBatchSize: Number.MAX_SAFE_INTEGER,\n    unmountedBatchSize: Number.MAX_SAFE_INTEGER\n  }) {\n    const checkView = options.checkView || this.options.checkView;\n    const unmountedCount = this.checkMountedViews(checkView, options.unmountedBatchSize);\n    const mountedCount = this.checkUnmountedViews(checkView,\n    // Do not check views, that have been just unmounted\n    // and pushed at the end of the cids array\n    unmountedCount > 0 ? Math.min(this.updates.unmountedCids.length - unmountedCount, options.mountedBatchSize) : options.mountedBatchSize);\n    return {\n      mountedCount,\n      unmountedCount\n    };\n  }\n  /**\n   * Determine every view in the graph should be attached/detached.\n   */\n  checkView(options = {}) {\n    return this.checkViewImpl(options);\n  }\n  isFrozen() {\n    return !!this.options.frozen;\n  }\n  /**\n   * Freeze the graph then the graph does not automatically re-render upon\n   * changes in the graph. This is useful when adding large numbers of cells.\n   */\n  freeze(options = {}) {\n    const key = options.key;\n    const updates = this.updates;\n    const frozen = this.options.frozen;\n    const freezeKey = updates.freezeKey;\n    if (key && key !== freezeKey) {\n      if (frozen && freezeKey) {\n        // key passed, but the graph is already freezed with another key\n        return;\n      }\n      updates.frozen = frozen;\n      updates.freezeKey = key;\n    }\n    this.options.frozen = true;\n    const animationId = updates.animationId;\n    updates.animationId = null;\n    if (this.isAsync() && animationId != null) {\n      Dom.cancelAnimationFrame(animationId);\n    }\n    this.graph.trigger('freeze', {\n      key\n    });\n  }\n  unfreeze(options = {}) {\n    const key = options.key;\n    const updates = this.updates;\n    const freezeKey = updates.freezeKey;\n    // key passed, but the graph is already freezed with another key\n    if (key && freezeKey && key !== freezeKey) {\n      return;\n    }\n    updates.freezeKey = null;\n    // key passed, but the graph is already freezed\n    if (key && key === freezeKey && updates.frozen) {\n      return;\n    }\n    const callback = () => {\n      this.options.frozen = updates.frozen = false;\n      if (updates.sort) {\n        this.sortViews();\n        updates.sort = false;\n      }\n      const afterFn = options.after;\n      if (afterFn) {\n        FunctionExt.call(afterFn, this.graph, this.graph);\n      }\n      this.graph.trigger('unfreeze', {\n        key\n      });\n    };\n    if (this.isAsync()) {\n      this.freeze();\n      const onProgress = options.progress;\n      this.updateViewsAsync(Object.assign(Object.assign({}, options), {\n        progress: ({\n          done,\n          current,\n          total\n        }) => {\n          if (onProgress) {\n            FunctionExt.call(onProgress, this.graph, {\n              done,\n              current,\n              total\n            });\n          }\n          // sort views after async render\n          if (done) {\n            callback();\n          }\n        }\n      }));\n    } else {\n      this.updateViews(options);\n      callback();\n    }\n  }\n  isAsync() {\n    return !!this.options.async;\n  }\n  setAsync(async) {\n    this.options.async = async;\n  }\n  onRemove() {\n    this.freeze();\n    this.removeViews();\n  }\n  resetViews(cells = [], options = {}) {\n    this.resetUpdates();\n    this.removeViews();\n    this.freeze({\n      key: 'reset'\n    });\n    for (let i = 0, n = cells.length; i < n; i += 1) {\n      this.renderView(cells[i], options);\n    }\n    this.unfreeze({\n      key: 'reset'\n    });\n    this.sortViews();\n  }\n  removeView(cell) {\n    const view = this.views[cell.id];\n    if (view) {\n      const cid = view.cid;\n      const updates = this.updates;\n      const mounted = updates.mounted;\n      const unmounted = updates.unmounted;\n      view.remove();\n      delete this.views[cell.id];\n      delete mounted[cid];\n      delete unmounted[cid];\n    }\n    return view;\n  }\n  removeViews() {\n    if (this.views) {\n      Object.keys(this.views).forEach(id => {\n        const view = this.views[id];\n        if (view) {\n          this.removeView(view.cell);\n        }\n      });\n    }\n    this.views = {};\n  }\n  renderView(cell, options = {}) {\n    const id = cell.id;\n    const views = this.views;\n    let flag = 0;\n    let view = views[id];\n    if (!cell.isVisible()) {\n      return;\n    }\n    if (cell.isEdge()) {\n      if (!this.isEdgeTerminalVisible(cell, 'source') || !this.isEdgeTerminalVisible(cell, 'target')) {\n        return;\n      }\n    }\n    if (view) {\n      flag = Renderer.FLAG_INSERT;\n    } else {\n      const tmp = this.graph.hook.createCellView(cell);\n      if (tmp) {\n        view = views[cell.id] = tmp;\n        view.graph = this.graph;\n        flag = this.registerUnmountedView(view) | view.getBootstrapFlag();\n      }\n    }\n    if (view) {\n      this.requestViewUpdate(view, flag, view.priority, options);\n    }\n  }\n  isExactSorting() {\n    return this.options.sorting === 'exact';\n  }\n  sortViews() {\n    if (!this.isExactSorting()) {\n      return;\n    }\n    if (this.isFrozen()) {\n      // sort views once unfrozen\n      this.updates.sort = true;\n      return;\n    }\n    this.sortViewsExact();\n  }\n  sortElements(elems, comparator) {\n    // Highly inspired by the jquery.sortElements plugin by Padolsey.\n    // See http://james.padolsey.com/javascript/sorting-elements-with-jquery/.\n    const placements = elems.map(elem => {\n      const parentNode = elem.parentNode;\n      // Since the element itself will change position, we have\n      // to have some way of storing it's original position in\n      // the DOM. The easiest way is to have a 'flag' node:\n      const nextSibling = parentNode.insertBefore(document.createTextNode(''), elem.nextSibling);\n      return targetNode => {\n        if (parentNode === targetNode) {\n          throw new Error(\"You can't sort elements if any one is a descendant of another.\");\n        }\n        // Insert before flag\n        parentNode.insertBefore(targetNode, nextSibling);\n        // Remove flag\n        parentNode.removeChild(nextSibling);\n      };\n    });\n    elems.sort(comparator).forEach((elem, index) => placements[index](elem));\n  }\n  sortViewsExact() {\n    // const elems = this.view.stage.querySelectorAll('[data-cell-id]')\n    // const length = elems.length\n    // const cells = []\n    // for (let i = 0; i < length; i++) {\n    //   const cell = this.model.getCell(elems[i].getAttribute('data-cell-id') || '')\n    //   cells.push({\n    //     id: cell.id,\n    //     zIndex: cell.getZIndex() || 0,\n    //     elem: elems[i],\n    //   })\n    // }\n    // const sortedCells = [...cells].sort((cell1, cell2) => cell1.zIndex - cell2.zIndex)\n    // const moves = ArrayExt.diff(cells, sortedCells, 'zIndex').moves\n    // if (moves && moves.length) {\n    //   moves.forEach((move) => {\n    //     if (move.type) {\n    //       const elem = move.item.elem as Element\n    //       const parentNode = elem.parentNode\n    //       const index = move.index\n    //       if (parentNode) {\n    //         if (index === length - 1) {\n    //           parentNode.appendChild(elem)\n    //         } else if (index < length - 1) {\n    //           parentNode.insertBefore(elem, elems[index + 1])\n    //         }\n    //       }\n    //     }\n    //   })\n    // }\n    // Run insertion sort algorithm in order to efficiently sort DOM\n    // elements according to their associated cell `zIndex` attribute.\n    const elems = this.view.$(this.view.stage).children('[data-cell-id]').toArray();\n    const model = this.model;\n    this.sortElements(elems, (a, b) => {\n      const cellA = model.getCell(a.getAttribute('data-cell-id') || '');\n      const cellB = model.getCell(b.getAttribute('data-cell-id') || '');\n      const z1 = cellA.getZIndex() || 0;\n      const z2 = cellB.getZIndex() || 0;\n      return z1 === z2 ? 0 : z1 < z2 ? -1 : 1;\n    });\n  }\n  addZPivot(zIndex = 0) {\n    if (this.zPivots == null) {\n      this.zPivots = {};\n    }\n    const pivots = this.zPivots;\n    let pivot = pivots[zIndex];\n    if (pivot) {\n      return pivot;\n    }\n    pivot = pivots[zIndex] = document.createComment(`z-index:${zIndex + 1}`);\n    let neighborZ = -Infinity;\n    // eslint-disable-next-line\n    for (const key in pivots) {\n      const currentZ = +key;\n      if (currentZ < zIndex && currentZ > neighborZ) {\n        neighborZ = currentZ;\n        if (neighborZ === zIndex - 1) {\n          continue;\n        }\n      }\n    }\n    const layer = this.view.stage;\n    if (neighborZ !== -Infinity) {\n      const neighborPivot = pivots[neighborZ];\n      layer.insertBefore(pivot, neighborPivot.nextSibling);\n    } else {\n      layer.insertBefore(pivot, layer.firstChild);\n    }\n    return pivot;\n  }\n  removeZPivots() {\n    if (this.zPivots) {\n      Object.keys(this.zPivots).forEach(z => {\n        const elem = this.zPivots[z];\n        if (elem && elem.parentNode) {\n          elem.parentNode.removeChild(elem);\n        }\n      });\n    }\n    this.zPivots = {};\n  }\n  insertView(view) {\n    const stage = this.view.stage;\n    switch (this.options.sorting) {\n      case 'approx':\n        {\n          const zIndex = view.cell.getZIndex();\n          const pivot = this.addZPivot(zIndex);\n          stage.insertBefore(view.container, pivot);\n          break;\n        }\n      case 'exact':\n      default:\n        stage.appendChild(view.container);\n        break;\n    }\n  }\n  findViewByCell(cell) {\n    if (cell == null) {\n      return null;\n    }\n    const id = Cell.isCell(cell) ? cell.id : cell;\n    return this.views[id];\n  }\n  findViewByElem(elem) {\n    if (elem == null) {\n      return null;\n    }\n    const target = typeof elem === 'string' ? this.view.stage.querySelector(elem) : elem instanceof Element ? elem : elem[0];\n    if (target) {\n      const id = this.view.findAttr('data-cell-id', target);\n      if (id) {\n        return this.views[id];\n      }\n    }\n    return null;\n  }\n  findViewsFromPoint(p) {\n    const ref = {\n      x: p.x,\n      y: p.y\n    };\n    return this.model.getCells().map(cell => this.findViewByCell(cell)).filter(view => {\n      if (view != null) {\n        return Dom.getBBox(view.container, {\n          target: this.view.stage\n        }).containsPoint(ref);\n      }\n      return false;\n    });\n  }\n  findEdgeViewsInArea(rect, options = {}) {\n    const area = Rectangle.create(rect);\n    return this.model.getEdges().map(edge => this.findViewByCell(edge)).filter(view => {\n      if (view) {\n        const bbox = Dom.getBBox(view.container, {\n          target: this.view.stage\n        });\n        if (bbox.width === 0) {\n          bbox.inflate(1, 0);\n        } else if (bbox.height === 0) {\n          bbox.inflate(0, 1);\n        }\n        return options.strict ? area.containsRect(bbox) : area.isIntersectWithRect(bbox);\n      }\n      return false;\n    });\n  }\n  findViewsInArea(rect, options = {}) {\n    const area = Rectangle.create(rect);\n    return this.model.getNodes().map(node => this.findViewByCell(node)).filter(view => {\n      if (view) {\n        const bbox = Dom.getBBox(view.container, {\n          target: this.view.stage\n        });\n        return options.strict ? area.containsRect(bbox) : area.isIntersectWithRect(bbox);\n      }\n      return false;\n    });\n  }\n  dispose() {\n    this.resetUpdates();\n    this.stopListening();\n  }\n}\n__decorate([Base.dispose()], Renderer.prototype, \"dispose\", null);\n(function (Renderer) {\n  Renderer.FLAG_INSERT = 1 << 30;\n  Renderer.FLAG_REMOVE = 1 << 29;\n  Renderer.MOUNT_BATCH_SIZE = 1000;\n  Renderer.UPDATE_BATCH_SIZE = 1000;\n  Renderer.MIN_PRIORITY = 2;\n  Renderer.SORT_DELAYING_BATCHES = ['add', 'to-front', 'to-back'];\n  Renderer.UPDATE_DELAYING_BATCHES = ['translate'];\n})(Renderer || (Renderer = {}));","map":{"version":3,"names":["Dom","FunctionExt","Rectangle","Cell","View","CellView","Base","Renderer","init","resetUpdates","startListening","resetViews","model","getCells","isFrozen","isAsync","updateViewsAsync","on","onSortModel","onModelReseted","onBatchStop","onCellAdded","onCellRemoved","onCellZIndexChanged","onCellVisibleChanged","stopListening","off","updates","priorities","mounted","mountedCids","unmounted","unmountedCids","count","sort","frozen","freezeKey","animationId","hasActiveBatch","SORT_DELAYING_BATCHES","sortViews","options","removeZPivots","name","data","updateDelayingBatches","UPDATE_DELAYING_BATCHES","includes","updateViews","sortDelayingBatches","cell","position","renderView","maxPosition","freeze","key","unfreeze","view","findViewByCell","requestViewUpdate","FLAG_REMOVE","priority","sorting","FLAG_INSERT","current","visible","processEdgeOnTerminalVisibleChanged","removeView","node","getOpposite","edge","currentTerminal","sourceId","getSourceCellId","id","getSourceCell","targetId","getTargetCellId","getTargetCell","getConnectedEdges","forEach","opposite","isVisible","show","hide","isEdgeTerminalVisible","terminal","cellId","getCell","requestConnectedEdgesUpdate","isCellView","edges","j","n","length","edgeView","flagLabels","push","scheduleViewUpdate","getFlag","forcePostponedViewUpdate","flag","isNode","isEdge","sourceFlag","sourceView","isViewMounted","dumpView","updateTerminalMagnet","targetFlag","targetView","cid","cache","currentFlag","graph","hook","onViewUpdated","async","stats","trigger","registerMountedView","updateView","dumpViews","checkView","requireView","insertView","confirmUpdate","result","batchCount","updatedCount","MIN_PRIORITY","updateViewsBatch","Math","min","empty","batchSize","UPDATE_BATCH_SIZE","mountedCount","unmountedCount","postponedCount","main","p","views","isUnmounted","call","registerUnmountedView","unmount","cellView","leftoverFlag","hasAction","removeAction","onViewPostponed","processed","cancelAnimationFrame","beforeFn","before","checkout","checkViewImpl","mountedBatchSize","MOUNT_BATCH_SIZE","unmountedBatchSize","total","progressFn","progress","done","requestAnimationFrame","getMountedViews","Object","keys","map","getUnmountedViews","checkMountedViews","viewportFn","unmountCount","size","i","shouldMount","splice","checkUnmountedViews","mountCount","mounting","Number","MAX_SAFE_INTEGER","callback","afterFn","after","onProgress","assign","setAsync","onRemove","removeViews","cells","remove","tmp","createCellView","getBootstrapFlag","isExactSorting","sortViewsExact","sortElements","elems","comparator","placements","elem","parentNode","nextSibling","insertBefore","document","createTextNode","targetNode","Error","removeChild","index","$","stage","children","toArray","a","b","cellA","getAttribute","cellB","z1","getZIndex","z2","addZPivot","zIndex","zPivots","pivots","pivot","createComment","neighborZ","Infinity","currentZ","layer","neighborPivot","firstChild","z","container","appendChild","isCell","findViewByElem","target","querySelector","Element","findAttr","findViewsFromPoint","ref","x","y","filter","getBBox","containsPoint","findEdgeViewsInArea","rect","area","create","getEdges","bbox","width","inflate","height","strict","containsRect","isIntersectWithRect","findViewsInArea","getNodes","dispose","__decorate"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/x6/src/graph/renderer.ts"],"sourcesContent":["import { KeyValue } from '../types'\nimport { Dom, FunctionExt } from '../util'\nimport { Point, Rectangle } from '../geometry'\nimport { Cell, Edge, Model } from '../model'\nimport { View, CellView, EdgeView } from '../view'\nimport { FlagManager } from '../view/flag'\nimport { Graph } from './graph'\nimport { Base } from './base'\n\nexport class Renderer extends Base {\n  protected views: KeyValue<CellView>\n  protected zPivots: KeyValue<Comment>\n  protected updates: Renderer.Updates\n\n  protected init() {\n    this.resetUpdates()\n    this.startListening()\n\n    // Renders existing cells in the model.\n    this.resetViews(this.model.getCells())\n\n    // Starts rendering loop.\n    if (!this.isFrozen() && this.isAsync()) {\n      this.updateViewsAsync()\n    }\n  }\n\n  protected startListening() {\n    this.model.on('sorted', this.onSortModel, this)\n    this.model.on('reseted', this.onModelReseted, this)\n    this.model.on('batch:stop', this.onBatchStop, this)\n    this.model.on('cell:added', this.onCellAdded, this)\n    this.model.on('cell:removed', this.onCellRemoved, this)\n    this.model.on('cell:change:zIndex', this.onCellZIndexChanged, this)\n    this.model.on('cell:change:visible', this.onCellVisibleChanged, this)\n  }\n\n  protected stopListening() {\n    this.model.off('sorted', this.onSortModel, this)\n    this.model.off('reseted', this.onModelReseted, this)\n    this.model.off('batch:stop', this.onBatchStop, this)\n    this.model.off('cell:added', this.onCellAdded, this)\n    this.model.off('cell:removed', this.onCellRemoved, this)\n    this.model.off('cell:change:zIndex', this.onCellZIndexChanged, this)\n    this.model.off('cell:change:visible', this.onCellVisibleChanged, this)\n  }\n\n  protected resetUpdates() {\n    this.updates = {\n      priorities: [{}, {}, {}],\n\n      mounted: {},\n      mountedCids: [],\n\n      unmounted: {},\n      unmountedCids: [],\n\n      count: 0,\n      sort: false,\n      frozen: false,\n      freezeKey: null,\n\n      animationId: null,\n    }\n  }\n\n  protected onSortModel() {\n    if (this.model.hasActiveBatch(Renderer.SORT_DELAYING_BATCHES)) {\n      return\n    }\n\n    this.sortViews()\n  }\n\n  protected onModelReseted({ options }: Model.EventArgs['reseted']) {\n    this.removeZPivots()\n    this.resetViews(this.model.getCells(), options)\n  }\n\n  protected onBatchStop({ name, data }: Model.EventArgs['batch:stop']) {\n    if (this.isFrozen()) {\n      return\n    }\n\n    const model = this.model\n    if (!this.isAsync()) {\n      const updateDelayingBatches = Renderer.UPDATE_DELAYING_BATCHES\n      if (\n        updateDelayingBatches.includes(name as Model.BatchName) &&\n        !model.hasActiveBatch(updateDelayingBatches)\n      ) {\n        this.updateViews(data)\n      }\n    }\n\n    const sortDelayingBatches = Renderer.SORT_DELAYING_BATCHES\n    if (\n      sortDelayingBatches.includes(name as Model.BatchName) &&\n      !model.hasActiveBatch(sortDelayingBatches)\n    ) {\n      this.sortViews()\n    }\n  }\n\n  protected onCellAdded({ cell, options }: Model.EventArgs['cell:added']) {\n    const position = options.position\n    if (this.isAsync() || typeof position !== 'number') {\n      this.renderView(cell, options)\n    } else {\n      if (options.maxPosition === position) {\n        this.freeze({ key: 'addCells' })\n      }\n      this.renderView(cell, options)\n      if (position === 0) {\n        this.unfreeze({ key: 'addCells' })\n      }\n    }\n  }\n\n  protected onCellRemoved({ cell, options }: Model.EventArgs['cell:removed']) {\n    const view = this.findViewByCell(cell)\n    if (view) {\n      this.requestViewUpdate(view, Renderer.FLAG_REMOVE, view.priority, options)\n    }\n  }\n\n  protected onCellZIndexChanged({\n    cell,\n    options,\n  }: Model.EventArgs['cell:change:zIndex']) {\n    if (this.options.sorting === 'approx') {\n      const view = this.findViewByCell(cell)\n      if (view) {\n        this.requestViewUpdate(\n          view,\n          Renderer.FLAG_INSERT,\n          view.priority,\n          options,\n        )\n      }\n    }\n  }\n\n  protected onCellVisibleChanged({\n    cell,\n    current: visible,\n    options,\n  }: Model.EventArgs['cell:change:visible']) {\n    // Hide connected edges before cell\n    if (!visible) {\n      this.processEdgeOnTerminalVisibleChanged(cell, false)\n    }\n\n    const view = this.findViewByCell(cell)\n    if (!visible && view) {\n      this.removeView(cell)\n    } else if (visible && view == null) {\n      this.renderView(cell, options)\n    }\n\n    // Show connected edges after cell rendered\n    if (visible) {\n      this.processEdgeOnTerminalVisibleChanged(cell, true)\n    }\n\n    // this.sortViews()\n  }\n\n  protected processEdgeOnTerminalVisibleChanged(node: Cell, visible: boolean) {\n    const getOpposite = (edge: Edge, currentTerminal: Cell) => {\n      const sourceId = edge.getSourceCellId()\n      if (sourceId !== currentTerminal.id) {\n        return edge.getSourceCell()\n      }\n\n      const targetId = edge.getTargetCellId()\n      if (targetId !== currentTerminal.id) {\n        return edge.getTargetCell()\n      }\n\n      return null\n    }\n\n    this.model.getConnectedEdges(node).forEach((edge) => {\n      const opposite = getOpposite(edge, node)\n      if (opposite == null || opposite.isVisible()) {\n        visible ? edge.show() : edge.hide()\n      }\n    })\n  }\n\n  protected isEdgeTerminalVisible(edge: Edge, terminal: Edge.TerminalType) {\n    const cellId =\n      terminal === 'source' ? edge.getSourceCellId() : edge.getTargetCellId()\n    const cell = cellId ? this.model.getCell(cellId) : null\n    if (cell && !cell.isVisible()) {\n      return false\n    }\n    return true\n  }\n\n  requestConnectedEdgesUpdate(\n    view: CellView,\n    options: Renderer.RequestViewUpdateOptions = {},\n  ) {\n    if (CellView.isCellView(view)) {\n      const cell = view.cell\n      const edges = this.model.getConnectedEdges(cell)\n      for (let j = 0, n = edges.length; j < n; j += 1) {\n        const edge = edges[j]\n        const edgeView = this.findViewByCell(edge)\n        if (!edgeView) {\n          continue\n        }\n\n        const flagLabels: FlagManager.Action[] = ['update']\n        if (edge.getTargetCell() === cell) {\n          flagLabels.push('target')\n        }\n        if (edge.getSourceCell() === cell) {\n          flagLabels.push('source')\n        }\n\n        this.scheduleViewUpdate(\n          edgeView,\n          edgeView.getFlag(flagLabels),\n          edgeView.priority,\n          options,\n        )\n      }\n    }\n  }\n\n  forcePostponedViewUpdate(view: CellView, flag: number) {\n    if (!view || !CellView.isCellView(view)) {\n      return false\n    }\n\n    const cell = view.cell\n    if (cell.isNode()) {\n      return false\n    }\n\n    const edgeView = view as EdgeView\n\n    if (cell.isEdge() && (flag & view.getFlag(['source', 'target'])) === 0) {\n      // EdgeView is waiting for the source/target cellView to be rendered.\n      // This can happen when the cells are not in the viewport.\n      let sourceFlag = 0\n      const sourceView = this.findViewByCell(cell.getSourceCell())\n      if (sourceView && !this.isViewMounted(sourceView)) {\n        sourceFlag = this.dumpView(sourceView)\n        edgeView.updateTerminalMagnet('source')\n      }\n      let targetFlag = 0\n      const targetView = this.findViewByCell(cell.getTargetCell())\n      if (targetView && !this.isViewMounted(targetView)) {\n        targetFlag = this.dumpView(targetView)\n        edgeView.updateTerminalMagnet('target')\n      }\n\n      if (sourceFlag === 0 && targetFlag === 0) {\n        // If leftover flag is 0, all view updates were done.\n        return !this.dumpView(edgeView)\n      }\n    }\n\n    return false\n  }\n\n  scheduleViewUpdate(\n    view: View,\n    flag: number,\n    priority: number,\n    options: Renderer.RequestViewUpdateOptions = {},\n  ) {\n    const cid = view.cid\n    const updates = this.updates\n    let cache = updates.priorities[priority]\n    if (!cache) {\n      cache = updates.priorities[priority] = {}\n    }\n\n    const currentFlag = cache[cid] || 0\n    if ((currentFlag & flag) === flag) {\n      return\n    }\n\n    if (!currentFlag) {\n      updates.count += 1\n    }\n\n    if (flag & Renderer.FLAG_REMOVE && currentFlag & Renderer.FLAG_INSERT) {\n      // When a view is removed we need to remove the\n      // insert flag as this is a reinsert.\n      cache[cid] ^= Renderer.FLAG_INSERT\n    } else if (\n      flag & Renderer.FLAG_INSERT &&\n      currentFlag & Renderer.FLAG_REMOVE\n    ) {\n      // When a view is added we need to remove the remove\n      // flag as this is view was previously removed.\n      cache[cid] ^= Renderer.FLAG_REMOVE\n    }\n\n    cache[cid] |= flag\n\n    this.graph.hook.onViewUpdated(view as CellView, flag, options)\n  }\n\n  requestViewUpdate(\n    view: CellView,\n    flag: number,\n    priority: number,\n    options: Renderer.RequestViewUpdateOptions = {},\n  ) {\n    this.scheduleViewUpdate(view, flag, priority, options)\n\n    const isAsync = this.isAsync()\n    if (\n      this.isFrozen() ||\n      (isAsync && options.async !== false) ||\n      this.model.hasActiveBatch(Renderer.UPDATE_DELAYING_BATCHES)\n    ) {\n      return\n    }\n\n    const stats = this.updateViews(options)\n    if (isAsync) {\n      this.graph.trigger('render:done', { stats, options })\n    }\n  }\n\n  /**\n   * Adds view into the DOM and update it.\n   */\n  dumpView(view: CellView, options: any = {}) {\n    if (view == null) {\n      return 0\n    }\n\n    const cid = view.cid\n    const updates = this.updates\n    const cache = updates.priorities[view.priority]\n    const flag = this.registerMountedView(view) | cache[cid]\n    delete cache[cid]\n\n    if (!flag) {\n      return 0\n    }\n\n    return this.updateView(view, flag, options)\n  }\n\n  /**\n   * Adds all views into the DOM and update them.\n   */\n  dumpViews(options: Renderer.UpdateViewOptions = {}) {\n    this.checkView(options)\n    this.updateViews(options)\n  }\n\n  /**\n   * Ensure the view associated with the cell is attached\n   * to the DOM and updated.\n   */\n  requireView(cell: Cell, options: any = {}) {\n    const view = this.findViewByCell(cell)\n    if (view == null) {\n      return null\n    }\n    this.dumpView(view, options)\n    return view\n  }\n\n  updateView(view: View, flag: number, options: any = {}) {\n    if (view == null) {\n      return 0\n    }\n\n    if (CellView.isCellView(view)) {\n      if (flag & Renderer.FLAG_REMOVE) {\n        this.removeView(view.cell as any)\n        return 0\n      }\n\n      if (flag & Renderer.FLAG_INSERT) {\n        this.insertView(view)\n        flag ^= Renderer.FLAG_INSERT // eslint-disable-line\n      }\n    }\n\n    if (!flag) {\n      return 0\n    }\n\n    return view.confirmUpdate(flag, options)\n  }\n\n  updateViews(options: Renderer.UpdateViewOptions = {}) {\n    let result: ReturnType<typeof Renderer.prototype.updateViewsBatch>\n    let batchCount = 0\n    let updatedCount = 0\n    let priority = Renderer.MIN_PRIORITY\n\n    do {\n      result = this.updateViewsBatch(options)\n      batchCount += 1\n      updatedCount += result.updatedCount\n      priority = Math.min(result.priority, priority)\n    } while (!result.empty)\n\n    return {\n      priority,\n      batchCount,\n      updatedCount,\n    }\n  }\n\n  protected updateViewsBatch(options: Renderer.UpdateViewOptions = {}) {\n    const updates = this.updates\n    const priorities = updates.priorities\n    const batchSize = options.batchSize || Renderer.UPDATE_BATCH_SIZE\n\n    let empty = true\n    let priority = Renderer.MIN_PRIORITY\n    let mountedCount = 0\n    let unmountedCount = 0\n    let updatedCount = 0\n    let postponedCount = 0\n\n    let checkView = options.checkView || this.options.checkView\n    if (typeof checkView !== 'function') {\n      checkView = null\n    }\n\n    // eslint-disable-next-line\n    main: for (let p = 0, n = priorities.length; p < n; p += 1) {\n      const cache = priorities[p]\n\n      // eslint-disable-next-line\n      for (const cid in cache) {\n        if (updatedCount >= batchSize) {\n          empty = false // goto next batch\n          break main // eslint-disable-line no-labels\n        }\n\n        const view = View.views[cid]\n        if (!view) {\n          delete cache[cid]\n          continue\n        }\n\n        let currentFlag = cache[cid]\n        // Do not check a view for viewport if we are about to remove the view.\n        if ((currentFlag & Renderer.FLAG_REMOVE) === 0) {\n          const isUnmounted = cid in updates.unmounted\n          if (\n            checkView &&\n            !FunctionExt.call(checkView, this.graph, {\n              view: view as CellView,\n              unmounted: isUnmounted,\n            })\n          ) {\n            // Unmount view\n            if (!isUnmounted) {\n              this.registerUnmountedView(view)\n              view.unmount()\n            }\n\n            updates.unmounted[cid] |= currentFlag\n            delete cache[cid]\n            unmountedCount += 1\n            continue\n          }\n\n          // Mount view\n          if (isUnmounted) {\n            currentFlag |= Renderer.FLAG_INSERT\n            mountedCount += 1\n          }\n          currentFlag |= this.registerMountedView(view)\n        }\n\n        const cellView = view as CellView\n        let leftoverFlag = this.updateView(view, currentFlag, options)\n        if (leftoverFlag > 0) {\n          const cell = cellView.cell\n          if (cell && cell.isEdge()) {\n            // remove edge view when source cell is invisible\n            if (\n              cellView.hasAction(leftoverFlag, 'source') &&\n              !this.isEdgeTerminalVisible(cell, 'source')\n            ) {\n              leftoverFlag = cellView.removeAction(leftoverFlag, 'source')\n              leftoverFlag |= Renderer.FLAG_REMOVE\n            }\n\n            // remove edge view when target cell is invisible\n            if (\n              cellView.hasAction(leftoverFlag, 'target') &&\n              !this.isEdgeTerminalVisible(cell, 'target')\n            ) {\n              leftoverFlag = cellView.removeAction(leftoverFlag, 'target')\n              leftoverFlag |= Renderer.FLAG_REMOVE\n            }\n          }\n        }\n\n        if (leftoverFlag > 0) {\n          // update has not finished\n          cache[cid] = leftoverFlag\n          if (\n            !this.graph.hook.onViewPostponed(cellView, leftoverFlag, options) ||\n            cache[cid]\n          ) {\n            postponedCount += 1\n            empty = false\n            continue\n          }\n        }\n\n        if (priority > p) {\n          priority = p\n        }\n\n        updatedCount += 1\n        delete cache[cid]\n      }\n    }\n\n    return {\n      empty,\n      priority,\n      mountedCount,\n      unmountedCount,\n      updatedCount,\n      postponedCount,\n    }\n  }\n\n  protected updateViewsAsync(\n    options: Renderer.UpdateViewsAsyncOptions = {},\n    data: {\n      processed: number\n      priority: number\n    } = {\n      processed: 0,\n      priority: Renderer.MIN_PRIORITY,\n    },\n  ) {\n    const updates = this.updates\n    const animationId = updates.animationId\n    if (animationId) {\n      Dom.cancelAnimationFrame(animationId)\n      if (data.processed === 0) {\n        const beforeFn = options.before\n        if (typeof beforeFn === 'function') {\n          FunctionExt.call(beforeFn, this.graph, this.graph)\n        }\n      }\n\n      const stats = this.updateViewsBatch(options)\n      const checkout = this.checkViewImpl({\n        checkView: options.checkView,\n        mountedBatchSize: Renderer.MOUNT_BATCH_SIZE - stats.mountedCount,\n        unmountedBatchSize: Renderer.MOUNT_BATCH_SIZE - stats.unmountedCount,\n      })\n\n      let processed = data.processed\n      const total = updates.count\n      const mountedCount = checkout.mountedCount\n      const unmountedCount = checkout.unmountedCount\n\n      if (stats.updatedCount > 0) {\n        // Some updates have been just processed\n        processed += stats.updatedCount + stats.unmountedCount\n        data.priority = Math.min(stats.priority, data.priority)\n        if (stats.empty && mountedCount === 0) {\n          stats.priority = data.priority\n          stats.mountedCount += mountedCount\n          stats.unmountedCount += unmountedCount\n          this.graph.trigger('render:done', { stats, options })\n          data.processed = 0\n          updates.count = 0\n        } else {\n          data.processed = processed\n        }\n      }\n\n      // Progress callback\n      const progressFn = options.progress\n      if (total && typeof progressFn === 'function') {\n        FunctionExt.call(progressFn, this.graph, {\n          total,\n          done: stats.empty,\n          current: processed,\n        })\n      }\n\n      // The current frame could have been canceled in a callback\n      if (updates.animationId !== animationId) {\n        return\n      }\n    }\n\n    updates.animationId = Dom.requestAnimationFrame(() => {\n      this.updateViewsAsync(options, data)\n    })\n  }\n\n  protected registerMountedView(view: View) {\n    const cid = view.cid\n    const updates = this.updates\n\n    if (cid in updates.mounted) {\n      return 0\n    }\n\n    updates.mounted[cid] = true\n    updates.mountedCids.push(cid)\n    const flag = updates.unmounted[cid] || 0\n    delete updates.unmounted[cid]\n    return flag\n  }\n\n  protected registerUnmountedView(view: View) {\n    const cid = view.cid\n    const updates = this.updates\n\n    if (cid in updates.unmounted) {\n      return 0\n    }\n\n    updates.unmounted[cid] |= Renderer.FLAG_INSERT\n\n    const flag = updates.unmounted[cid]\n    updates.unmountedCids.push(cid)\n    delete updates.mounted[cid]\n    return flag\n  }\n\n  isViewMounted(view: CellView) {\n    if (view == null) {\n      return false\n    }\n\n    const cid = view.cid\n    return cid in this.updates.mounted\n  }\n\n  getMountedViews() {\n    return Object.keys(this.updates.mounted).map((cid) => CellView.views[cid])\n  }\n\n  getUnmountedViews() {\n    return Object.keys(this.updates.unmounted).map((cid) => CellView.views[cid])\n  }\n\n  protected checkMountedViews(\n    viewportFn?: Renderer.CheckViewFn | null,\n    batchSize?: number,\n  ) {\n    let unmountCount = 0\n    if (typeof viewportFn !== 'function') {\n      return unmountCount\n    }\n\n    const updates = this.updates\n    const mounted = updates.mounted\n    const mountedCids = updates.mountedCids\n    const size =\n      batchSize == null\n        ? mountedCids.length\n        : Math.min(mountedCids.length, batchSize)\n\n    for (let i = 0; i < size; i += 1) {\n      const cid = mountedCids[i]\n      if (!(cid in mounted)) {\n        continue\n      }\n\n      const view = CellView.views[cid]\n      if (view == null) {\n        continue\n      }\n\n      const shouldMount = FunctionExt.call(viewportFn, this.graph, {\n        view: view as CellView,\n        unmounted: true,\n      })\n\n      if (shouldMount) {\n        // Push at the end of all mounted ids\n        mountedCids.push(cid)\n        continue\n      }\n\n      unmountCount += 1\n      const flag = this.registerUnmountedView(view)\n      if (flag) {\n        view.unmount()\n      }\n    }\n\n    // Get rid of views, that have been unmounted\n    mountedCids.splice(0, size)\n    return unmountCount\n  }\n\n  protected checkUnmountedViews(\n    checkView?: Renderer.CheckViewFn | null,\n    batchSize?: number,\n  ) {\n    let mountCount = 0\n    if (typeof checkView !== 'function') {\n      checkView = null // eslint-disable-line\n    }\n\n    const updates = this.updates\n    const unmounted = updates.unmounted\n    const unmountedCids = updates.unmountedCids\n    const size =\n      batchSize == null\n        ? unmountedCids.length\n        : Math.min(unmountedCids.length, batchSize)\n\n    for (let i = 0; i < size; i += 1) {\n      const cid = unmountedCids[i]\n      if (!(cid in unmounted)) {\n        continue\n      }\n\n      const view = CellView.views[cid] as CellView\n      if (view == null) {\n        continue\n      }\n\n      if (\n        checkView &&\n        !FunctionExt.call(checkView, this.graph, { view, unmounted: false })\n      ) {\n        unmountedCids.push(cid)\n        continue\n      }\n\n      mountCount += 1\n      const flag = this.registerMountedView(view)\n      if (flag) {\n        this.scheduleViewUpdate(view, flag, view.priority, {\n          mounting: true,\n        })\n      }\n    }\n\n    // Get rid of views, that have been mounted\n    unmountedCids.splice(0, size)\n\n    return mountCount\n  }\n\n  protected checkViewImpl(\n    options: Renderer.CheckViewOptions & {\n      mountedBatchSize?: number\n      unmountedBatchSize?: number\n    } = {\n      mountedBatchSize: Number.MAX_SAFE_INTEGER,\n      unmountedBatchSize: Number.MAX_SAFE_INTEGER,\n    },\n  ) {\n    const checkView = options.checkView || this.options.checkView\n    const unmountedCount = this.checkMountedViews(\n      checkView,\n      options.unmountedBatchSize,\n    )\n\n    const mountedCount = this.checkUnmountedViews(\n      checkView,\n      // Do not check views, that have been just unmounted\n      // and pushed at the end of the cids array\n      unmountedCount > 0\n        ? Math.min(\n            this.updates.unmountedCids.length - unmountedCount,\n            options.mountedBatchSize as number,\n          )\n        : options.mountedBatchSize,\n    )\n\n    return { mountedCount, unmountedCount }\n  }\n\n  /**\n   * Determine every view in the graph should be attached/detached.\n   */\n  protected checkView(options: Renderer.CheckViewOptions = {}) {\n    return this.checkViewImpl(options)\n  }\n\n  isFrozen() {\n    return !!this.options.frozen\n  }\n\n  /**\n   * Freeze the graph then the graph does not automatically re-render upon\n   * changes in the graph. This is useful when adding large numbers of cells.\n   */\n  freeze(options: Renderer.FreezeOptions = {}) {\n    const key = options.key\n    const updates = this.updates\n    const frozen = this.options.frozen\n    const freezeKey = updates.freezeKey\n\n    if (key && key !== freezeKey) {\n      if (frozen && freezeKey) {\n        // key passed, but the graph is already freezed with another key\n        return\n      }\n      updates.frozen = frozen\n      updates.freezeKey = key\n    }\n\n    this.options.frozen = true\n\n    const animationId = updates.animationId\n    updates.animationId = null\n    if (this.isAsync() && animationId != null) {\n      Dom.cancelAnimationFrame(animationId)\n    }\n    this.graph.trigger('freeze', { key })\n  }\n\n  unfreeze(options: Renderer.UnfreezeOptions = {}) {\n    const key = options.key\n    const updates = this.updates\n    const freezeKey = updates.freezeKey\n    // key passed, but the graph is already freezed with another key\n    if (key && freezeKey && key !== freezeKey) {\n      return\n    }\n\n    updates.freezeKey = null\n    // key passed, but the graph is already freezed\n    if (key && key === freezeKey && updates.frozen) {\n      return\n    }\n\n    const callback = () => {\n      this.options.frozen = updates.frozen = false\n\n      if (updates.sort) {\n        this.sortViews()\n        updates.sort = false\n      }\n\n      const afterFn = options.after\n      if (afterFn) {\n        FunctionExt.call(afterFn, this.graph, this.graph)\n      }\n\n      this.graph.trigger('unfreeze', { key })\n    }\n\n    if (this.isAsync()) {\n      this.freeze()\n      const onProgress = options.progress\n      this.updateViewsAsync({\n        ...options,\n        progress: ({ done, current, total }) => {\n          if (onProgress) {\n            FunctionExt.call(onProgress, this.graph, { done, current, total })\n          }\n\n          // sort views after async render\n          if (done) {\n            callback()\n          }\n        },\n      })\n    } else {\n      this.updateViews(options)\n      callback()\n    }\n  }\n\n  isAsync() {\n    return !!this.options.async\n  }\n\n  setAsync(async: boolean) {\n    this.options.async = async\n  }\n\n  protected onRemove() {\n    this.freeze()\n    this.removeViews()\n  }\n\n  protected resetViews(cells: Cell[] = [], options: any = {}) {\n    this.resetUpdates()\n    this.removeViews()\n    this.freeze({ key: 'reset' })\n    for (let i = 0, n = cells.length; i < n; i += 1) {\n      this.renderView(cells[i], options)\n    }\n    this.unfreeze({ key: 'reset' })\n    this.sortViews()\n  }\n\n  protected removeView(cell: Cell) {\n    const view = this.views[cell.id]\n    if (view) {\n      const cid = view.cid\n      const updates = this.updates\n      const mounted = updates.mounted\n      const unmounted = updates.unmounted\n      view.remove()\n      delete this.views[cell.id]\n      delete mounted[cid]\n      delete unmounted[cid]\n    }\n    return view\n  }\n\n  protected removeViews() {\n    if (this.views) {\n      Object.keys(this.views).forEach((id) => {\n        const view = this.views[id]\n        if (view) {\n          this.removeView(view.cell)\n        }\n      })\n    }\n    this.views = {}\n  }\n\n  protected renderView(cell: Cell, options: any = {}) {\n    const id = cell.id\n    const views = this.views\n    let flag = 0\n    let view = views[id]\n\n    if (!cell.isVisible()) {\n      return\n    }\n\n    if (cell.isEdge()) {\n      if (\n        !this.isEdgeTerminalVisible(cell, 'source') ||\n        !this.isEdgeTerminalVisible(cell, 'target')\n      ) {\n        return\n      }\n    }\n\n    if (view) {\n      flag = Renderer.FLAG_INSERT\n    } else {\n      const tmp = this.graph.hook.createCellView(cell)\n      if (tmp) {\n        view = views[cell.id] = tmp\n        view.graph = this.graph\n        flag = this.registerUnmountedView(view) | view.getBootstrapFlag()\n      }\n    }\n\n    if (view) {\n      this.requestViewUpdate(view, flag, view.priority, options)\n    }\n  }\n\n  protected isExactSorting() {\n    return this.options.sorting === 'exact'\n  }\n\n  sortViews() {\n    if (!this.isExactSorting()) {\n      return\n    }\n\n    if (this.isFrozen()) {\n      // sort views once unfrozen\n      this.updates.sort = true\n      return\n    }\n\n    this.sortViewsExact()\n  }\n\n  protected sortElements(\n    elems: Element[],\n    comparator: (a: Element, b: Element) => number,\n  ) {\n    // Highly inspired by the jquery.sortElements plugin by Padolsey.\n    // See http://james.padolsey.com/javascript/sorting-elements-with-jquery/.\n\n    const placements = elems.map((elem) => {\n      const parentNode = elem.parentNode!\n      // Since the element itself will change position, we have\n      // to have some way of storing it's original position in\n      // the DOM. The easiest way is to have a 'flag' node:\n      const nextSibling = parentNode.insertBefore(\n        document.createTextNode(''),\n        elem.nextSibling,\n      )\n\n      return (targetNode: Element) => {\n        if (parentNode === targetNode) {\n          throw new Error(\n            \"You can't sort elements if any one is a descendant of another.\",\n          )\n        }\n\n        // Insert before flag\n        parentNode.insertBefore(targetNode, nextSibling)\n        // Remove flag\n        parentNode.removeChild(nextSibling)\n      }\n    })\n\n    elems.sort(comparator).forEach((elem, index) => placements[index](elem))\n  }\n\n  sortViewsExact() {\n    // const elems = this.view.stage.querySelectorAll('[data-cell-id]')\n    // const length = elems.length\n    // const cells = []\n    // for (let i = 0; i < length; i++) {\n    //   const cell = this.model.getCell(elems[i].getAttribute('data-cell-id') || '')\n    //   cells.push({\n    //     id: cell.id,\n    //     zIndex: cell.getZIndex() || 0,\n    //     elem: elems[i],\n    //   })\n    // }\n    // const sortedCells = [...cells].sort((cell1, cell2) => cell1.zIndex - cell2.zIndex)\n    // const moves = ArrayExt.diff(cells, sortedCells, 'zIndex').moves\n\n    // if (moves && moves.length) {\n    //   moves.forEach((move) => {\n    //     if (move.type) {\n    //       const elem = move.item.elem as Element\n    //       const parentNode = elem.parentNode\n    //       const index = move.index\n    //       if (parentNode) {\n    //         if (index === length - 1) {\n    //           parentNode.appendChild(elem)\n    //         } else if (index < length - 1) {\n    //           parentNode.insertBefore(elem, elems[index + 1])\n    //         }\n    //       }\n    //     }\n    //   })\n    // }\n\n    // Run insertion sort algorithm in order to efficiently sort DOM\n    // elements according to their associated cell `zIndex` attribute.\n    const elems = this.view\n      .$(this.view.stage)\n      .children('[data-cell-id]')\n      .toArray() as Element[]\n    const model = this.model\n    this.sortElements(elems, (a, b) => {\n      const cellA = model.getCell(a.getAttribute('data-cell-id') || '')\n      const cellB = model.getCell(b.getAttribute('data-cell-id') || '')\n      const z1 = cellA.getZIndex() || 0\n      const z2 = cellB.getZIndex() || 0\n      return z1 === z2 ? 0 : z1 < z2 ? -1 : 1\n    })\n  }\n\n  protected addZPivot(zIndex = 0) {\n    if (this.zPivots == null) {\n      this.zPivots = {}\n    }\n\n    const pivots = this.zPivots\n    let pivot = pivots[zIndex]\n    if (pivot) {\n      return pivot\n    }\n\n    pivot = pivots[zIndex] = document.createComment(`z-index:${zIndex + 1}`)\n    let neighborZ = -Infinity\n    // eslint-disable-next-line\n    for (const key in pivots) {\n      const currentZ = +key\n      if (currentZ < zIndex && currentZ > neighborZ) {\n        neighborZ = currentZ\n        if (neighborZ === zIndex - 1) {\n          continue\n        }\n      }\n    }\n\n    const layer = this.view.stage\n    if (neighborZ !== -Infinity) {\n      const neighborPivot = pivots[neighborZ]\n      layer.insertBefore(pivot, neighborPivot.nextSibling)\n    } else {\n      layer.insertBefore(pivot, layer.firstChild)\n    }\n    return pivot\n  }\n\n  protected removeZPivots() {\n    if (this.zPivots) {\n      Object.keys(this.zPivots).forEach((z) => {\n        const elem = this.zPivots[z]\n        if (elem && elem.parentNode) {\n          elem.parentNode.removeChild(elem)\n        }\n      })\n    }\n    this.zPivots = {}\n  }\n\n  insertView(view: CellView) {\n    const stage = this.view.stage\n    switch (this.options.sorting) {\n      case 'approx': {\n        const zIndex = view.cell.getZIndex()\n        const pivot = this.addZPivot(zIndex)\n        stage.insertBefore(view.container, pivot)\n        break\n      }\n      case 'exact':\n      default:\n        stage.appendChild(view.container)\n        break\n    }\n  }\n\n  findViewByCell(cellId: string | number): CellView | null\n  findViewByCell(cell: Cell | null): CellView | null\n  findViewByCell(\n    cell: Cell | string | number | null | undefined,\n  ): CellView | null {\n    if (cell == null) {\n      return null\n    }\n    const id = Cell.isCell(cell) ? cell.id : cell\n    return this.views[id]\n  }\n\n  findViewByElem(elem: string | JQuery | Element | undefined | null) {\n    if (elem == null) {\n      return null\n    }\n\n    const target =\n      typeof elem === 'string'\n        ? this.view.stage.querySelector(elem)\n        : elem instanceof Element\n        ? elem\n        : elem[0]\n\n    if (target) {\n      const id = this.view.findAttr('data-cell-id', target)\n      if (id) {\n        return this.views[id]\n      }\n    }\n\n    return null\n  }\n\n  findViewsFromPoint(p: Point.PointLike) {\n    const ref = { x: p.x, y: p.y }\n    return this.model\n      .getCells()\n      .map((cell) => this.findViewByCell(cell))\n      .filter((view) => {\n        if (view != null) {\n          return Dom.getBBox(view.container as SVGElement, {\n            target: this.view.stage,\n          }).containsPoint(ref)\n        }\n        return false\n      }) as CellView[]\n  }\n\n  findEdgeViewsInArea(\n    rect: Rectangle.RectangleLike,\n    options: Renderer.FindViewsInAreaOptions = {},\n  ) {\n    const area = Rectangle.create(rect)\n    return this.model\n      .getEdges()\n      .map((edge) => this.findViewByCell(edge))\n      .filter((view) => {\n        if (view) {\n          const bbox = Dom.getBBox(view.container as SVGElement, {\n            target: this.view.stage,\n          })\n          if (bbox.width === 0) {\n            bbox.inflate(1, 0)\n          } else if (bbox.height === 0) {\n            bbox.inflate(0, 1)\n          }\n          return options.strict\n            ? area.containsRect(bbox)\n            : area.isIntersectWithRect(bbox)\n        }\n        return false\n      }) as CellView[]\n  }\n\n  findViewsInArea(\n    rect: Rectangle.RectangleLike,\n    options: Renderer.FindViewsInAreaOptions = {},\n  ) {\n    const area = Rectangle.create(rect)\n    return this.model\n      .getNodes()\n      .map((node) => this.findViewByCell(node))\n      .filter((view) => {\n        if (view) {\n          const bbox = Dom.getBBox(view.container as SVGElement, {\n            target: this.view.stage,\n          })\n          return options.strict\n            ? area.containsRect(bbox)\n            : area.isIntersectWithRect(bbox)\n        }\n        return false\n      }) as CellView[]\n  }\n\n  @Base.dispose()\n  dispose() {\n    this.resetUpdates()\n    this.stopListening()\n  }\n}\n\nexport namespace Renderer {\n  export interface Updates {\n    priorities: KeyValue<number>[]\n    mounted: KeyValue<boolean>\n    unmounted: KeyValue<number>\n    mountedCids: string[]\n    unmountedCids: string[]\n    animationId: number | null\n    count: number\n    sort: boolean\n\n    /**\n     * The last frozen state of graph.\n     */\n    frozen: boolean\n    /**\n     * The current freeze key of graph.\n     */\n    freezeKey: string | null\n  }\n\n  export type CheckViewFn = (\n    this: Graph,\n    args: {\n      view: CellView\n      unmounted: boolean\n    },\n  ) => boolean\n\n  export interface CheckViewOptions {\n    /**\n     * Callback function to determine whether a given view\n     * should be added to the DOM.\n     */\n    checkView?: CheckViewFn\n  }\n\n  export interface UpdateViewOptions extends CheckViewOptions {\n    /**\n     * For async graph, how many views should there be per\n     * one asynchronous process?\n     */\n    batchSize?: number\n  }\n\n  export interface RequestViewUpdateOptions\n    extends UpdateViewOptions,\n      Cell.SetOptions {\n    async?: boolean\n  }\n\n  export interface UpdateViewsAsyncOptions extends UpdateViewOptions {\n    before?: (this: Graph, graph: Graph) => void\n    after?: (this: Graph, graph: Graph) => void\n    /**\n     * Callback function that is called whenever a batch is\n     * finished processing.\n     */\n    progress?: (\n      this: Graph,\n      args: { done: boolean; current: number; total: number },\n    ) => void\n  }\n\n  export interface FreezeOptions {\n    key?: string\n  }\n\n  export interface UnfreezeOptions\n    extends FreezeOptions,\n      UpdateViewsAsyncOptions {}\n\n  export interface FindViewsInAreaOptions {\n    strict?: boolean\n  }\n}\n\nexport namespace Renderer {\n  export const FLAG_INSERT = 1 << 30\n  export const FLAG_REMOVE = 1 << 29\n  export const MOUNT_BATCH_SIZE = 1000\n  export const UPDATE_BATCH_SIZE = 1000\n  export const MIN_PRIORITY = 2\n  export const SORT_DELAYING_BATCHES: Model.BatchName[] = [\n    'add',\n    'to-front',\n    'to-back',\n  ]\n  export const UPDATE_DELAYING_BATCHES: Model.BatchName[] = ['translate']\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}