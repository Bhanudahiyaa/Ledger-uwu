{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport BaseModel from \"../../core/BaseModel\";\nimport { GlobelPointFillTriangulation } from \"../../core/triangulation\";\n/* babel-plugin-inline-import '../shaders/earthFill/earthFill_frag.glsl' */\nconst pointFillFrag = \"in vec4 v_data;\\nin vec4 v_color;\\nin float v_radius;\\n\\nlayout(std140) uniform commonUniform {\\n  float u_additive;\\n  float u_stroke_opacity : 1;\\n  float u_stroke_width : 2;\\n  float u_blur : 0.0;\\n};\\n#pragma include \\\"sdf_2d\\\"\\n#pragma include \\\"picking\\\"\\n\\nout vec4 outputColor;\\n\\nvoid main() {\\n  int shape = int(floor(v_data.w + 0.5));\\n\\n  vec4 strokeColor = u_stroke == vec4(0.0) ? v_color : u_stroke;\\n\\n  lowp float antialiasblur = v_data.z;\\n  float r = v_radius / (v_radius + u_stroke_width);\\n\\n  float outer_df;\\n  float inner_df;\\n  // 'circle', 'triangle', 'square', 'pentagon', 'hexagon', 'octogon', 'hexagram', 'rhombus', 'vesica'\\n  if (shape == 0) {\\n    outer_df = sdCircle(v_data.xy, 1.0);\\n    inner_df = sdCircle(v_data.xy, r);\\n  } else if (shape == 1) {\\n    outer_df = sdEquilateralTriangle(1.1 * v_data.xy);\\n    inner_df = sdEquilateralTriangle(1.1 / r * v_data.xy);\\n  } else if (shape == 2) {\\n    outer_df = sdBox(v_data.xy, vec2(1.));\\n    inner_df = sdBox(v_data.xy, vec2(r));\\n  } else if (shape == 3) {\\n    outer_df = sdPentagon(v_data.xy, 0.8);\\n    inner_df = sdPentagon(v_data.xy, r * 0.8);\\n  } else if (shape == 4) {\\n    outer_df = sdHexagon(v_data.xy, 0.8);\\n    inner_df = sdHexagon(v_data.xy, r * 0.8);\\n  } else if (shape == 5) {\\n    outer_df = sdOctogon(v_data.xy, 1.0);\\n    inner_df = sdOctogon(v_data.xy, r);\\n  } else if (shape == 6) {\\n    outer_df = sdHexagram(v_data.xy, 0.52);\\n    inner_df = sdHexagram(v_data.xy, r * 0.52);\\n  } else if (shape == 7) {\\n    outer_df = sdRhombus(v_data.xy, vec2(1.0));\\n    inner_df = sdRhombus(v_data.xy, vec2(r));\\n  } else if (shape == 8) {\\n    outer_df = sdVesica(v_data.xy, 1.1, 0.8);\\n    inner_df = sdVesica(v_data.xy, r * 1.1, r * 0.8);\\n  }\\n\\n  if(outer_df > antialiasblur + 0.018) discard;\\n\\n  float opacity_t = smoothstep(0.0, antialiasblur, outer_df);\\n\\n  float color_t = u_stroke_width < 0.01 ? 0.0 : smoothstep(\\n    antialiasblur,\\n    0.0,\\n    inner_df\\n  );\\n\\n  if(u_stroke_width < 0.01) {\\n    outputColor = vec4(v_color.rgb, v_color.a * u_opacity);\\n  } else {\\n    outputColor = mix(vec4(v_color.rgb, v_color.a * u_opacity), strokeColor * u_stroke_opacity, color_t);\\n  }\\n\\n  if(u_additive > 0.0) {\\n    outputColor *= opacity_t;\\n    outputColor = filterColorAlpha(outputColor, outputColor.a);\\n  } else {\\n    outputColor.a *= opacity_t;\\n    outputColor = filterColor(outputColor);\\n  }\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/earthFill/earthFill_vert.glsl' */\nconst pointFillVert = \"layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\\nlayout(location = ATTRIBUTE_LOCATION_SHAPE) in float a_Shape;\\nlayout(location = ATTRIBUTE_LOCATION_EXTRUDE) in vec3 a_Extrude;\\n\\nlayout(std140) uniform commonUniform {\\n  float u_additive;\\n  float u_stroke_opacity : 1;\\n  float u_stroke_width : 2;\\n  float u_blur : 0.0;\\n};\\nout vec4 v_data;\\nout vec4 v_color;\\nout float v_radius;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"picking\\\"\\n\\n\\nvoid main() {\\n  vec3 extrude = a_Extrude;\\n  float shape_type = a_Shape;\\n  /*\\n  *  setPickingSize \\u8BBE\\u7F6E\\u62FE\\u53D6\\u5927\\u5C0F\\n  */\\n  float newSize = setPickingSize(a_Size);\\n  // float newSize = setPickingSize(a_Size) * 0.00001038445708445579;\\n\\n  // unpack color(vec2)\\n  v_color = a_Color;\\n\\n  // radius(16-bit)\\n  v_radius = newSize;\\n\\n  // anti-alias\\n  //  float antialiased_blur = -max(u_blur, antialiasblur);\\n  float antialiasblur = -max(2.0 / u_DevicePixelRatio / newSize, u_blur);\\n\\n  // TODP: /abs(extrude.x) \\u662F\\u4E3A\\u4E86\\u517C\\u5BB9\\u5730\\u7403\\u6A21\\u5F0F\\n  v_data = vec4(extrude.x/abs(extrude.x), extrude.y/abs(extrude.y), antialiasblur,shape_type);\\n\\n  gl_Position = u_ViewProjectionMatrix * vec4(a_Position + extrude * newSize * 0.1 + vec3(u_offsets,0.0), 1.0);\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\nimport { mat4, vec3 } from 'gl-matrix';\nexport default class FillModel extends BaseModel {\n  get attributeLocation() {\n    return Object.assign(super.attributeLocation, {\n      MAX: super.attributeLocation.MAX,\n      SIZE: 9,\n      SHAPE: 10,\n      EXTRUDE: 11\n    });\n  }\n  getCommonUniformsInfo() {\n    const {\n      strokeOpacity = 1,\n      strokeWidth = 0,\n      // offsets = [0, 0],\n      blend,\n      blur = 0\n    } = this.layer.getLayerConfig();\n    this.layer.getLayerConfig();\n    const commonOptions = {\n      u_additive: blend === 'additive' ? 1.0 : 0.0,\n      u_stroke_opacity: strokeOpacity,\n      u_stroke_width: strokeWidth,\n      u_blur: blur\n    };\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.initUniformsBuffer();\n      return _this.buildModels();\n    })();\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.layer.triangulation = GlobelPointFillTriangulation;\n      const model = yield _this2.layer.buildLayerModel({\n        moduleName: 'pointEarthFill',\n        vertexShader: pointFillVert,\n        fragmentShader: pointFillFrag,\n        triangulation: GlobelPointFillTriangulation,\n        defines: _this2.getDefines(),\n        inject: _this2.getInject(),\n        depth: {\n          enable: true\n        },\n        blend: _this2.getBlend()\n      });\n      return [model];\n    })();\n  }\n\n  // overwrite baseModel func\n  animateOption2Array(option) {\n    return [option.enable ? 0 : 1.0, option.speed || 1, option.rings || 3, 0];\n  }\n  registerBuiltinAttributes() {\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'extrude',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Extrude',\n        shaderLocation: this.attributeLocation.EXTRUDE,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        update: (feature, featureIdx, vertex, attributeIdx) => {\n          const [x, y, z] = vertex;\n          const n1 = vec3.fromValues(0, 0, 1);\n          const n2 = vec3.fromValues(x, 0, z);\n          const xzReg = x >= 0 ? vec3.angle(n1, n2) : Math.PI * 2 - vec3.angle(n1, n2);\n          const yReg = Math.PI * 2 - Math.asin(y / 100);\n          const m = mat4.create();\n          mat4.rotateY(m, m, xzReg);\n          mat4.rotateX(m, m, yReg);\n          const v1 = vec3.fromValues(1, 1, 0);\n          vec3.transformMat4(v1, v1, m);\n          vec3.normalize(v1, v1);\n          const v2 = vec3.fromValues(-1, 1, 0);\n          vec3.transformMat4(v2, v2, m);\n          vec3.normalize(v2, v2);\n          const v3 = vec3.fromValues(-1, -1, 0);\n          vec3.transformMat4(v3, v3, m);\n          vec3.normalize(v3, v3);\n          const v4 = vec3.fromValues(1, -1, 0);\n          vec3.transformMat4(v4, v4, m);\n          vec3.normalize(v4, v4);\n          const extrude = [...v1, ...v2, ...v3, ...v4];\n          const extrudeIndex = attributeIdx % 4 * 3;\n          return [extrude[extrudeIndex], extrude[extrudeIndex + 1], extrude[extrudeIndex + 2]];\n        }\n      }\n    });\n\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Size',\n        shaderLocation: this.attributeLocation.SIZE,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 1,\n        update: feature => {\n          const {\n            size = 5\n          } = feature;\n          return Array.isArray(size) ? [size[0]] : [size];\n        }\n      }\n    });\n\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'shape',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Shape',\n        shaderLocation: this.attributeLocation.SHAPE,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 1,\n        update: feature => {\n          const {\n            shape = 2\n          } = feature;\n          const shape2d = this.layer.getLayerConfig().shape2d;\n          const shapeIndex = shape2d.indexOf(shape);\n          return [shapeIndex];\n        }\n      }\n    });\n  }\n}","map":{"version":3,"names":["_asyncToGenerator","AttributeType","gl","BaseModel","GlobelPointFillTriangulation","pointFillFrag","pointFillVert","mat4","vec3","FillModel","attributeLocation","Object","assign","MAX","SIZE","SHAPE","EXTRUDE","getCommonUniformsInfo","strokeOpacity","strokeWidth","blend","blur","layer","getLayerConfig","commonOptions","u_additive","u_stroke_opacity","u_stroke_width","u_blur","commonBufferInfo","getUniformsBufferInfo","initModels","_this","initUniformsBuffer","buildModels","_this2","triangulation","model","buildLayerModel","moduleName","vertexShader","fragmentShader","defines","getDefines","inject","getInject","depth","enable","getBlend","animateOption2Array","option","speed","rings","registerBuiltinAttributes","styleAttributeService","registerStyleAttribute","name","type","Attribute","descriptor","shaderLocation","buffer","usage","DYNAMIC_DRAW","data","FLOAT","size","update","feature","featureIdx","vertex","attributeIdx","x","y","z","n1","fromValues","n2","xzReg","angle","Math","PI","yReg","asin","m","create","rotateY","rotateX","v1","transformMat4","normalize","v2","v3","v4","extrude","extrudeIndex","Array","isArray","shape","shape2d","shapeIndex","indexOf"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/l7-layers/es/point/models/earthFill.js"],"sourcesContent":["import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport BaseModel from \"../../core/BaseModel\";\nimport { GlobelPointFillTriangulation } from \"../../core/triangulation\";\n/* babel-plugin-inline-import '../shaders/earthFill/earthFill_frag.glsl' */\nconst pointFillFrag = \"in vec4 v_data;\\nin vec4 v_color;\\nin float v_radius;\\n\\nlayout(std140) uniform commonUniform {\\n  float u_additive;\\n  float u_stroke_opacity : 1;\\n  float u_stroke_width : 2;\\n  float u_blur : 0.0;\\n};\\n#pragma include \\\"sdf_2d\\\"\\n#pragma include \\\"picking\\\"\\n\\nout vec4 outputColor;\\n\\nvoid main() {\\n  int shape = int(floor(v_data.w + 0.5));\\n\\n  vec4 strokeColor = u_stroke == vec4(0.0) ? v_color : u_stroke;\\n\\n  lowp float antialiasblur = v_data.z;\\n  float r = v_radius / (v_radius + u_stroke_width);\\n\\n  float outer_df;\\n  float inner_df;\\n  // 'circle', 'triangle', 'square', 'pentagon', 'hexagon', 'octogon', 'hexagram', 'rhombus', 'vesica'\\n  if (shape == 0) {\\n    outer_df = sdCircle(v_data.xy, 1.0);\\n    inner_df = sdCircle(v_data.xy, r);\\n  } else if (shape == 1) {\\n    outer_df = sdEquilateralTriangle(1.1 * v_data.xy);\\n    inner_df = sdEquilateralTriangle(1.1 / r * v_data.xy);\\n  } else if (shape == 2) {\\n    outer_df = sdBox(v_data.xy, vec2(1.));\\n    inner_df = sdBox(v_data.xy, vec2(r));\\n  } else if (shape == 3) {\\n    outer_df = sdPentagon(v_data.xy, 0.8);\\n    inner_df = sdPentagon(v_data.xy, r * 0.8);\\n  } else if (shape == 4) {\\n    outer_df = sdHexagon(v_data.xy, 0.8);\\n    inner_df = sdHexagon(v_data.xy, r * 0.8);\\n  } else if (shape == 5) {\\n    outer_df = sdOctogon(v_data.xy, 1.0);\\n    inner_df = sdOctogon(v_data.xy, r);\\n  } else if (shape == 6) {\\n    outer_df = sdHexagram(v_data.xy, 0.52);\\n    inner_df = sdHexagram(v_data.xy, r * 0.52);\\n  } else if (shape == 7) {\\n    outer_df = sdRhombus(v_data.xy, vec2(1.0));\\n    inner_df = sdRhombus(v_data.xy, vec2(r));\\n  } else if (shape == 8) {\\n    outer_df = sdVesica(v_data.xy, 1.1, 0.8);\\n    inner_df = sdVesica(v_data.xy, r * 1.1, r * 0.8);\\n  }\\n\\n  if(outer_df > antialiasblur + 0.018) discard;\\n\\n  float opacity_t = smoothstep(0.0, antialiasblur, outer_df);\\n\\n  float color_t = u_stroke_width < 0.01 ? 0.0 : smoothstep(\\n    antialiasblur,\\n    0.0,\\n    inner_df\\n  );\\n\\n  if(u_stroke_width < 0.01) {\\n    outputColor = vec4(v_color.rgb, v_color.a * u_opacity);\\n  } else {\\n    outputColor = mix(vec4(v_color.rgb, v_color.a * u_opacity), strokeColor * u_stroke_opacity, color_t);\\n  }\\n\\n  if(u_additive > 0.0) {\\n    outputColor *= opacity_t;\\n    outputColor = filterColorAlpha(outputColor, outputColor.a);\\n  } else {\\n    outputColor.a *= opacity_t;\\n    outputColor = filterColor(outputColor);\\n  }\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/earthFill/earthFill_vert.glsl' */\nconst pointFillVert = \"layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\\nlayout(location = ATTRIBUTE_LOCATION_SHAPE) in float a_Shape;\\nlayout(location = ATTRIBUTE_LOCATION_EXTRUDE) in vec3 a_Extrude;\\n\\nlayout(std140) uniform commonUniform {\\n  float u_additive;\\n  float u_stroke_opacity : 1;\\n  float u_stroke_width : 2;\\n  float u_blur : 0.0;\\n};\\nout vec4 v_data;\\nout vec4 v_color;\\nout float v_radius;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"picking\\\"\\n\\n\\nvoid main() {\\n  vec3 extrude = a_Extrude;\\n  float shape_type = a_Shape;\\n  /*\\n  *  setPickingSize \\u8BBE\\u7F6E\\u62FE\\u53D6\\u5927\\u5C0F\\n  */\\n  float newSize = setPickingSize(a_Size);\\n  // float newSize = setPickingSize(a_Size) * 0.00001038445708445579;\\n\\n  // unpack color(vec2)\\n  v_color = a_Color;\\n\\n  // radius(16-bit)\\n  v_radius = newSize;\\n\\n  // anti-alias\\n  //  float antialiased_blur = -max(u_blur, antialiasblur);\\n  float antialiasblur = -max(2.0 / u_DevicePixelRatio / newSize, u_blur);\\n\\n  // TODP: /abs(extrude.x) \\u662F\\u4E3A\\u4E86\\u517C\\u5BB9\\u5730\\u7403\\u6A21\\u5F0F\\n  v_data = vec4(extrude.x/abs(extrude.x), extrude.y/abs(extrude.y), antialiasblur,shape_type);\\n\\n  gl_Position = u_ViewProjectionMatrix * vec4(a_Position + extrude * newSize * 0.1 + vec3(u_offsets,0.0), 1.0);\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\nimport { mat4, vec3 } from 'gl-matrix';\nexport default class FillModel extends BaseModel {\n  get attributeLocation() {\n    return Object.assign(super.attributeLocation, {\n      MAX: super.attributeLocation.MAX,\n      SIZE: 9,\n      SHAPE: 10,\n      EXTRUDE: 11\n    });\n  }\n  getCommonUniformsInfo() {\n    const {\n      strokeOpacity = 1,\n      strokeWidth = 0,\n      // offsets = [0, 0],\n      blend,\n      blur = 0\n    } = this.layer.getLayerConfig();\n    this.layer.getLayerConfig();\n    const commonOptions = {\n      u_additive: blend === 'additive' ? 1.0 : 0.0,\n      u_stroke_opacity: strokeOpacity,\n      u_stroke_width: strokeWidth,\n      u_blur: blur\n    };\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.initUniformsBuffer();\n      return _this.buildModels();\n    })();\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.layer.triangulation = GlobelPointFillTriangulation;\n      const model = yield _this2.layer.buildLayerModel({\n        moduleName: 'pointEarthFill',\n        vertexShader: pointFillVert,\n        fragmentShader: pointFillFrag,\n        triangulation: GlobelPointFillTriangulation,\n        defines: _this2.getDefines(),\n        inject: _this2.getInject(),\n        depth: {\n          enable: true\n        },\n        blend: _this2.getBlend()\n      });\n      return [model];\n    })();\n  }\n\n  // overwrite baseModel func\n  animateOption2Array(option) {\n    return [option.enable ? 0 : 1.0, option.speed || 1, option.rings || 3, 0];\n  }\n  registerBuiltinAttributes() {\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'extrude',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Extrude',\n        shaderLocation: this.attributeLocation.EXTRUDE,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        update: (feature, featureIdx, vertex, attributeIdx) => {\n          const [x, y, z] = vertex;\n          const n1 = vec3.fromValues(0, 0, 1);\n          const n2 = vec3.fromValues(x, 0, z);\n          const xzReg = x >= 0 ? vec3.angle(n1, n2) : Math.PI * 2 - vec3.angle(n1, n2);\n          const yReg = Math.PI * 2 - Math.asin(y / 100);\n          const m = mat4.create();\n          mat4.rotateY(m, m, xzReg);\n          mat4.rotateX(m, m, yReg);\n          const v1 = vec3.fromValues(1, 1, 0);\n          vec3.transformMat4(v1, v1, m);\n          vec3.normalize(v1, v1);\n          const v2 = vec3.fromValues(-1, 1, 0);\n          vec3.transformMat4(v2, v2, m);\n          vec3.normalize(v2, v2);\n          const v3 = vec3.fromValues(-1, -1, 0);\n          vec3.transformMat4(v3, v3, m);\n          vec3.normalize(v3, v3);\n          const v4 = vec3.fromValues(1, -1, 0);\n          vec3.transformMat4(v4, v4, m);\n          vec3.normalize(v4, v4);\n          const extrude = [...v1, ...v2, ...v3, ...v4];\n          const extrudeIndex = attributeIdx % 4 * 3;\n          return [extrude[extrudeIndex], extrude[extrudeIndex + 1], extrude[extrudeIndex + 2]];\n        }\n      }\n    });\n\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Size',\n        shaderLocation: this.attributeLocation.SIZE,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 1,\n        update: feature => {\n          const {\n            size = 5\n          } = feature;\n          return Array.isArray(size) ? [size[0]] : [size];\n        }\n      }\n    });\n\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'shape',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Shape',\n        shaderLocation: this.attributeLocation.SHAPE,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 1,\n        update: feature => {\n          const {\n            shape = 2\n          } = feature;\n          const shape2d = this.layer.getLayerConfig().shape2d;\n          const shapeIndex = shape2d.indexOf(shape);\n          return [shapeIndex];\n        }\n      }\n    });\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}