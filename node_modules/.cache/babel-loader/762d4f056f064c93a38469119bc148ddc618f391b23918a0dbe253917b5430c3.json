{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { calculateCentroid, fp64LowPart, rgb2arr } from '@antv/l7-utils';\nimport BaseModel from \"../../core/BaseModel\";\nimport { PointExtrudeTriangulation } from \"../../core/triangulation\";\n/* babel-plugin-inline-import '../shaders/extrude/extrude_frag.glsl' */\nconst pointExtrudeFrag = \"\\nin vec4 v_color;\\nin float v_lightWeight;\\nout vec4 outputColor;\\n\\nlayout(std140) uniform commonUniforms {\\n  float u_pickLight;\\n  float u_heightfixed;\\n  float u_r;\\n  float u_linearColor;\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  float u_opacitylinear;\\n  float u_opacitylinear_dir;\\n  float u_lightEnable;\\n};\\n\\n#pragma include \\\"scene_uniforms\\\"\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n\\n  outputColor = v_color;\\n  // \\u5F00\\u542F\\u900F\\u660E\\u5EA6\\u6E10\\u53D8\\n  // picking\\n  if(u_pickLight > 0.0) {\\n    outputColor = filterColorAlpha(outputColor, v_lightWeight);\\n  } else {\\n    outputColor = filterColor(outputColor);\\n  }\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/extrude/extrude_vert.glsl' */\nconst pointExtrudeVert = \"#define pi (3.1415926535)\\n\\nlayout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in vec3 a_Size;\\nlayout(location = ATTRIBUTE_LOCATION_EXTRUDE) in vec4 a_Extrude;\\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\\n\\nlayout(std140) uniform commonUniforms {\\n  float u_pickLight;\\n  float u_heightfixed;\\n  float u_r;\\n  float u_linearColor;\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  float u_opacitylinear;\\n  float u_opacitylinear_dir;\\n  float u_lightEnable;\\n};\\nout vec4 v_color;\\nout float v_lightWeight;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"light\\\"\\n#pragma include \\\"picking\\\"\\n\\nfloat getYRadian(float x, float z) {\\n  if (x > 0.0 && z > 0.0) {\\n    return atan(x / z);\\n  } else if (x > 0.0 && z <= 0.0) {\\n    return atan(-z / x) + pi / 2.0;\\n  } else if (x <= 0.0 && z <= 0.0) {\\n    return pi + atan(x / z); //atan(x/z) +\\n  } else {\\n    return atan(z / -x) + pi * 3.0 / 2.0;\\n  }\\n}\\n\\nfloat getXRadian(float y, float r) {\\n  return atan(y / r);\\n}\\n\\nvoid main() {\\n  vec3 size = a_Size * a_Position;\\n\\n  vec3 offset = size; // \\u63A7\\u5236\\u5706\\u67F1\\u4F53\\u7684\\u5927\\u5C0F - \\u4ECE\\u6807\\u51C6\\u5355\\u4F4D\\u5706\\u67F1\\u4F53\\u8FDB\\u884C\\u504F\\u79FB\\n\\n  if (u_heightfixed < 1.0) {\\n    // \\u5706\\u67F1\\u4F53\\u4E0D\\u56FA\\u5B9A\\u9AD8\\u5EA6\\n  } else {\\n    // \\u5706\\u67F1\\u4F53\\u56FA\\u5B9A\\u9AD8\\u5EA6 \\uFF08 \\u5904\\u7406 mapbox \\uFF09\\n    if (\\n      u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\\n      u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\\n    ) {\\n      offset *= 4.0 / pow(2.0, 21.0 - u_Zoom);\\n    }\\n  }\\n\\n  vec2 positions = a_Extrude.xy;\\n  vec2 positions64Low = a_Extrude.zw;\\n  vec4 project_pos = project_position(vec4(positions, 0.0, 1.0), positions64Low);\\n\\n  // u_r \\u63A7\\u5236\\u5706\\u67F1\\u7684\\u751F\\u957F\\n  vec4 pos = vec4(project_pos.xy + offset.xy, offset.z * u_r, 1.0);\\n\\n  // // \\u5706\\u67F1\\u5149\\u7167\\u6548\\u679C\\n  float lightWeight = 1.0;\\n\\n  if (u_lightEnable > 0.0) {\\n    // \\u53D6\\u6D88\\u4E09\\u5143\\u8868\\u8FBE\\u5F0F\\uFF0C\\u589E\\u5F3A\\u5065\\u58EE\\u6027\\n    lightWeight = calc_lighting(pos);\\n  }\\n\\n  v_lightWeight = lightWeight;\\n\\n  v_color = a_Color;\\n\\n  // \\u8BBE\\u7F6E\\u5706\\u67F1\\u7684\\u5E95\\u8272\\n  if (u_linearColor == 1.0) {\\n    // \\u4F7F\\u7528\\u6E10\\u53D8\\u989C\\u8272\\n    v_color = mix(u_sourceColor, u_targetColor, a_Position.z);\\n    v_color.a = v_color.a * opacity;\\n  } else {\\n    v_color = vec4(a_Color.rgb * lightWeight, a_Color.w * opacity);\\n  }\\n\\n  if (u_opacitylinear > 0.0) {\\n    v_color.a *= u_opacitylinear_dir > 0.0 ? 1.0 - a_Position.z : a_Position.z;\\n  }\\n\\n  gl_Position = project_common_position_to_clipspace(pos);\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\nexport default class ExtrudeModel extends BaseModel {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"raiseCount\", 0);\n    _defineProperty(this, \"raiseRepeat\", 0);\n  }\n  get attributeLocation() {\n    return Object.assign(super.attributeLocation, {\n      MAX: super.attributeLocation.MAX,\n      SIZE: 9,\n      EXTRUDE: 10,\n      NORMAL: 11\n    });\n  }\n  getCommonUniformsInfo() {\n    const {\n      animateOption = {\n        enable: false,\n        speed: 0.01,\n        repeat: false\n      },\n      sourceColor,\n      targetColor,\n      pickLight = false,\n      heightfixed = false,\n      opacityLinear = {\n        enable: false,\n        dir: 'up'\n      },\n      lightEnable = true\n    } = this.layer.getLayerConfig();\n\n    // 转化渐变色\n    let useLinearColor = 0; // 默认不生效\n    let sourceColorArr = [0, 0, 0, 0];\n    let targetColorArr = [0, 0, 0, 0];\n    if (sourceColor && targetColor) {\n      sourceColorArr = rgb2arr(sourceColor);\n      targetColorArr = rgb2arr(targetColor);\n      useLinearColor = 1;\n    }\n    if (this.raiseCount < 1 && this.raiseRepeat > 0) {\n      if (animateOption.enable) {\n        const {\n          speed = 0.01\n        } = animateOption;\n        this.raiseCount += speed;\n        if (this.raiseCount >= 1) {\n          if (this.raiseRepeat > 1) {\n            this.raiseCount = 0;\n            this.raiseRepeat--;\n          } else {\n            this.raiseCount = 1;\n          }\n        }\n      }\n    }\n    const commonOptions = {\n      // 圆柱体的拾取高亮是否要计算光照\n      u_pickLight: Number(pickLight),\n      // 圆柱体是否固定高度\n      u_heightfixed: Number(heightfixed),\n      u_r: animateOption.enable && this.raiseRepeat > 0 ? this.raiseCount : 1.0,\n      // 渐变色支持参数\n      u_linearColor: useLinearColor,\n      u_sourceColor: sourceColorArr,\n      u_targetColor: targetColorArr,\n      // 透明度渐变\n      u_opacitylinear: Number(opacityLinear.enable),\n      u_opacitylinear_dir: opacityLinear.dir === 'up' ? 1.0 : 0.0,\n      // 光照计算开关\n      u_lightEnable: Number(lightEnable)\n    };\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return _this.buildModels();\n    })();\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        depth = true,\n        animateOption: {\n          repeat = 1\n        }\n      } = _this2.layer.getLayerConfig();\n      _this2.raiseRepeat = repeat;\n      _this2.initUniformsBuffer();\n      const model = yield _this2.layer.buildLayerModel({\n        moduleName: 'pointExtrude',\n        vertexShader: pointExtrudeVert,\n        fragmentShader: pointExtrudeFrag,\n        triangulation: PointExtrudeTriangulation,\n        defines: _this2.getDefines(),\n        inject: _this2.getInject(),\n        cull: {\n          enable: true,\n          face: gl.FRONT\n        },\n        depth: {\n          enable: depth\n        }\n      });\n      return [model];\n    })();\n  }\n  registerBuiltinAttributes() {\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Size',\n        shaderLocation: this.attributeLocation.SIZE,\n        buffer: {\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        update: feature => {\n          const {\n            size\n          } = feature;\n          if (size) {\n            let buffersize = [];\n            if (Array.isArray(size)) {\n              buffersize = size.length === 2 ? [size[0], size[0], size[1]] : size;\n            }\n            if (!Array.isArray(size)) {\n              buffersize = [size, size, size];\n            }\n            return buffersize;\n          } else {\n            return [2, 2, 2];\n          }\n        }\n      }\n    });\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'normal',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Normal',\n        shaderLocation: this.attributeLocation.NORMAL,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.STATIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        update: (feature, featureIdx, vertex, attributeIdx, normal) => {\n          return normal;\n        }\n      }\n    });\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'extrude',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Extrude',\n        shaderLocation: this.attributeLocation.EXTRUDE,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 4,\n        update: feature => {\n          const coordinates = calculateCentroid(feature.coordinates);\n          // [lng, lat, lowLng, lowLat]\n          // low part for enabled double precision\n          return [coordinates[0], coordinates[1], fp64LowPart(coordinates[0]), fp64LowPart(coordinates[1])];\n        }\n      }\n    });\n  }\n}","map":{"version":3,"names":["_asyncToGenerator","_defineProperty","AttributeType","gl","calculateCentroid","fp64LowPart","rgb2arr","BaseModel","PointExtrudeTriangulation","pointExtrudeFrag","pointExtrudeVert","ExtrudeModel","constructor","args","attributeLocation","Object","assign","MAX","SIZE","EXTRUDE","NORMAL","getCommonUniformsInfo","animateOption","enable","speed","repeat","sourceColor","targetColor","pickLight","heightfixed","opacityLinear","dir","lightEnable","layer","getLayerConfig","useLinearColor","sourceColorArr","targetColorArr","raiseCount","raiseRepeat","commonOptions","u_pickLight","Number","u_heightfixed","u_r","u_linearColor","u_sourceColor","u_targetColor","u_opacitylinear","u_opacitylinear_dir","u_lightEnable","commonBufferInfo","getUniformsBufferInfo","initModels","_this","buildModels","_this2","depth","initUniformsBuffer","model","buildLayerModel","moduleName","vertexShader","fragmentShader","triangulation","defines","getDefines","inject","getInject","cull","face","FRONT","registerBuiltinAttributes","styleAttributeService","registerStyleAttribute","name","type","Attribute","descriptor","shaderLocation","buffer","usage","DYNAMIC_DRAW","data","FLOAT","size","update","feature","buffersize","Array","isArray","length","STATIC_DRAW","featureIdx","vertex","attributeIdx","normal","coordinates"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/l7-layers/es/point/models/extrude.js"],"sourcesContent":["import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { calculateCentroid, fp64LowPart, rgb2arr } from '@antv/l7-utils';\nimport BaseModel from \"../../core/BaseModel\";\nimport { PointExtrudeTriangulation } from \"../../core/triangulation\";\n/* babel-plugin-inline-import '../shaders/extrude/extrude_frag.glsl' */\nconst pointExtrudeFrag = \"\\nin vec4 v_color;\\nin float v_lightWeight;\\nout vec4 outputColor;\\n\\nlayout(std140) uniform commonUniforms {\\n  float u_pickLight;\\n  float u_heightfixed;\\n  float u_r;\\n  float u_linearColor;\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  float u_opacitylinear;\\n  float u_opacitylinear_dir;\\n  float u_lightEnable;\\n};\\n\\n#pragma include \\\"scene_uniforms\\\"\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n\\n  outputColor = v_color;\\n  // \\u5F00\\u542F\\u900F\\u660E\\u5EA6\\u6E10\\u53D8\\n  // picking\\n  if(u_pickLight > 0.0) {\\n    outputColor = filterColorAlpha(outputColor, v_lightWeight);\\n  } else {\\n    outputColor = filterColor(outputColor);\\n  }\\n}\\n\";\n/* babel-plugin-inline-import '../shaders/extrude/extrude_vert.glsl' */\nconst pointExtrudeVert = \"#define pi (3.1415926535)\\n\\nlayout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in vec3 a_Size;\\nlayout(location = ATTRIBUTE_LOCATION_EXTRUDE) in vec4 a_Extrude;\\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\\n\\nlayout(std140) uniform commonUniforms {\\n  float u_pickLight;\\n  float u_heightfixed;\\n  float u_r;\\n  float u_linearColor;\\n  vec4 u_sourceColor;\\n  vec4 u_targetColor;\\n  float u_opacitylinear;\\n  float u_opacitylinear_dir;\\n  float u_lightEnable;\\n};\\nout vec4 v_color;\\nout float v_lightWeight;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"light\\\"\\n#pragma include \\\"picking\\\"\\n\\nfloat getYRadian(float x, float z) {\\n  if (x > 0.0 && z > 0.0) {\\n    return atan(x / z);\\n  } else if (x > 0.0 && z <= 0.0) {\\n    return atan(-z / x) + pi / 2.0;\\n  } else if (x <= 0.0 && z <= 0.0) {\\n    return pi + atan(x / z); //atan(x/z) +\\n  } else {\\n    return atan(z / -x) + pi * 3.0 / 2.0;\\n  }\\n}\\n\\nfloat getXRadian(float y, float r) {\\n  return atan(y / r);\\n}\\n\\nvoid main() {\\n  vec3 size = a_Size * a_Position;\\n\\n  vec3 offset = size; // \\u63A7\\u5236\\u5706\\u67F1\\u4F53\\u7684\\u5927\\u5C0F - \\u4ECE\\u6807\\u51C6\\u5355\\u4F4D\\u5706\\u67F1\\u4F53\\u8FDB\\u884C\\u504F\\u79FB\\n\\n  if (u_heightfixed < 1.0) {\\n    // \\u5706\\u67F1\\u4F53\\u4E0D\\u56FA\\u5B9A\\u9AD8\\u5EA6\\n  } else {\\n    // \\u5706\\u67F1\\u4F53\\u56FA\\u5B9A\\u9AD8\\u5EA6 \\uFF08 \\u5904\\u7406 mapbox \\uFF09\\n    if (\\n      u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\\n      u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\\n    ) {\\n      offset *= 4.0 / pow(2.0, 21.0 - u_Zoom);\\n    }\\n  }\\n\\n  vec2 positions = a_Extrude.xy;\\n  vec2 positions64Low = a_Extrude.zw;\\n  vec4 project_pos = project_position(vec4(positions, 0.0, 1.0), positions64Low);\\n\\n  // u_r \\u63A7\\u5236\\u5706\\u67F1\\u7684\\u751F\\u957F\\n  vec4 pos = vec4(project_pos.xy + offset.xy, offset.z * u_r, 1.0);\\n\\n  // // \\u5706\\u67F1\\u5149\\u7167\\u6548\\u679C\\n  float lightWeight = 1.0;\\n\\n  if (u_lightEnable > 0.0) {\\n    // \\u53D6\\u6D88\\u4E09\\u5143\\u8868\\u8FBE\\u5F0F\\uFF0C\\u589E\\u5F3A\\u5065\\u58EE\\u6027\\n    lightWeight = calc_lighting(pos);\\n  }\\n\\n  v_lightWeight = lightWeight;\\n\\n  v_color = a_Color;\\n\\n  // \\u8BBE\\u7F6E\\u5706\\u67F1\\u7684\\u5E95\\u8272\\n  if (u_linearColor == 1.0) {\\n    // \\u4F7F\\u7528\\u6E10\\u53D8\\u989C\\u8272\\n    v_color = mix(u_sourceColor, u_targetColor, a_Position.z);\\n    v_color.a = v_color.a * opacity;\\n  } else {\\n    v_color = vec4(a_Color.rgb * lightWeight, a_Color.w * opacity);\\n  }\\n\\n  if (u_opacitylinear > 0.0) {\\n    v_color.a *= u_opacitylinear_dir > 0.0 ? 1.0 - a_Position.z : a_Position.z;\\n  }\\n\\n  gl_Position = project_common_position_to_clipspace(pos);\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\nexport default class ExtrudeModel extends BaseModel {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"raiseCount\", 0);\n    _defineProperty(this, \"raiseRepeat\", 0);\n  }\n  get attributeLocation() {\n    return Object.assign(super.attributeLocation, {\n      MAX: super.attributeLocation.MAX,\n      SIZE: 9,\n      EXTRUDE: 10,\n      NORMAL: 11\n    });\n  }\n  getCommonUniformsInfo() {\n    const {\n      animateOption = {\n        enable: false,\n        speed: 0.01,\n        repeat: false\n      },\n      sourceColor,\n      targetColor,\n      pickLight = false,\n      heightfixed = false,\n      opacityLinear = {\n        enable: false,\n        dir: 'up'\n      },\n      lightEnable = true\n    } = this.layer.getLayerConfig();\n\n    // 转化渐变色\n    let useLinearColor = 0; // 默认不生效\n    let sourceColorArr = [0, 0, 0, 0];\n    let targetColorArr = [0, 0, 0, 0];\n    if (sourceColor && targetColor) {\n      sourceColorArr = rgb2arr(sourceColor);\n      targetColorArr = rgb2arr(targetColor);\n      useLinearColor = 1;\n    }\n    if (this.raiseCount < 1 && this.raiseRepeat > 0) {\n      if (animateOption.enable) {\n        const {\n          speed = 0.01\n        } = animateOption;\n        this.raiseCount += speed;\n        if (this.raiseCount >= 1) {\n          if (this.raiseRepeat > 1) {\n            this.raiseCount = 0;\n            this.raiseRepeat--;\n          } else {\n            this.raiseCount = 1;\n          }\n        }\n      }\n    }\n    const commonOptions = {\n      // 圆柱体的拾取高亮是否要计算光照\n      u_pickLight: Number(pickLight),\n      // 圆柱体是否固定高度\n      u_heightfixed: Number(heightfixed),\n      u_r: animateOption.enable && this.raiseRepeat > 0 ? this.raiseCount : 1.0,\n      // 渐变色支持参数\n      u_linearColor: useLinearColor,\n      u_sourceColor: sourceColorArr,\n      u_targetColor: targetColorArr,\n      // 透明度渐变\n      u_opacitylinear: Number(opacityLinear.enable),\n      u_opacitylinear_dir: opacityLinear.dir === 'up' ? 1.0 : 0.0,\n      // 光照计算开关\n      u_lightEnable: Number(lightEnable)\n    };\n    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n    return commonBufferInfo;\n  }\n  initModels() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return _this.buildModels();\n    })();\n  }\n  buildModels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        depth = true,\n        animateOption: {\n          repeat = 1\n        }\n      } = _this2.layer.getLayerConfig();\n      _this2.raiseRepeat = repeat;\n      _this2.initUniformsBuffer();\n      const model = yield _this2.layer.buildLayerModel({\n        moduleName: 'pointExtrude',\n        vertexShader: pointExtrudeVert,\n        fragmentShader: pointExtrudeFrag,\n        triangulation: PointExtrudeTriangulation,\n        defines: _this2.getDefines(),\n        inject: _this2.getInject(),\n        cull: {\n          enable: true,\n          face: gl.FRONT\n        },\n        depth: {\n          enable: depth\n        }\n      });\n      return [model];\n    })();\n  }\n  registerBuiltinAttributes() {\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Size',\n        shaderLocation: this.attributeLocation.SIZE,\n        buffer: {\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        update: feature => {\n          const {\n            size\n          } = feature;\n          if (size) {\n            let buffersize = [];\n            if (Array.isArray(size)) {\n              buffersize = size.length === 2 ? [size[0], size[0], size[1]] : size;\n            }\n            if (!Array.isArray(size)) {\n              buffersize = [size, size, size];\n            }\n            return buffersize;\n          } else {\n            return [2, 2, 2];\n          }\n        }\n      }\n    });\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'normal',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Normal',\n        shaderLocation: this.attributeLocation.NORMAL,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.STATIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 3,\n        update: (feature, featureIdx, vertex, attributeIdx, normal) => {\n          return normal;\n        }\n      }\n    });\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'extrude',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Extrude',\n        shaderLocation: this.attributeLocation.EXTRUDE,\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT\n        },\n        size: 4,\n        update: feature => {\n          const coordinates = calculateCentroid(feature.coordinates);\n          // [lng, lat, lowLng, lowLat]\n          // low part for enabled double precision\n          return [coordinates[0], coordinates[1], fp64LowPart(coordinates[0]), fp64LowPart(coordinates[1])];\n        }\n      }\n    });\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}