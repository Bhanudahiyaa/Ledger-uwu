{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _dec, _class;\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nimport { AABB } from '@antv/g-webgpu-core';\nimport { injectable } from 'inversify';\nimport { Geometry } from '.';\nimport { isNumber } from '../utils/is-number';\nimport { isTypedArray } from '../utils/is-typedarray';\nimport { merge } from '../utils/typedarray';\nexport var\n/**\n * merge many geometries into one, use a batch of draw calls\n */\nMerged = (_dec = injectable(), _dec(_class = /*#__PURE__*/function (_Geometry) {\n  _inherits(Merged, _Geometry);\n  var _super = _createSuper(Merged);\n  function Merged() {\n    _classCallCheck(this, Merged);\n    return _super.apply(this, arguments);\n  }\n  _createClass(Merged, [{\n    key: \"onEntityCreated\",\n    value: function onEntityCreated() {\n      var _this$config$geometri = this.config.geometries,\n        geometries = _this$config$geometri === void 0 ? [] : _this$config$geometri;\n      var mergedComponent = this.getComponent();\n      mergedComponent.aabb = new AABB();\n      var mergedAttributes = [];\n      var mergedIndices = [];\n      var indexOffset = 0;\n      geometries.forEach(function (geometry) {\n        var aabb = geometry.aabb,\n          indices = geometry.indices,\n          vertexCount = geometry.vertexCount,\n          attributes = geometry.attributes; // merge aabb\n\n        mergedComponent.aabb.add(aabb);\n        mergedComponent.vertexCount += vertexCount; // merge indices\n\n        if (indices) {\n          mergedIndices.push.apply(mergedIndices, _toConsumableArray(indices.map(function (index) {\n            return index + indexOffset;\n          })));\n        }\n        indexOffset += vertexCount; // merge attributes\n\n        attributes.forEach(function (attribute, i) {\n          if (!mergedAttributes[i]) {\n            mergedAttributes[i] = attribute;\n            mergedAttributes[i].dirty = true;\n          } else {\n            if (attribute.data) {\n              if (isNumber(attribute.data)) {\n                // @ts-ignore\n                mergedAttributes[i].push(attribute.data);\n              } else if (isTypedArray(attribute.data)) {\n                // @ts-ignore\n                mergedAttributes[i].data = merge(\n                // @ts-ignore\n                mergedAttributes[i].data, attribute.data);\n              } else {\n                // @ts-ignore\n                mergedAttributes[i].data = mergedAttributes[i].data.concat(attribute.data);\n              }\n            }\n          }\n        });\n      });\n      mergedComponent.attributes = mergedAttributes;\n      mergedComponent.indices = Uint32Array.from(mergedIndices);\n      mergedComponent.dirty = true;\n    }\n  }]);\n  return Merged;\n}(Geometry)) || _class);","map":{"version":3,"names":["AABB","injectable","Geometry","isNumber","isTypedArray","merge","Merged","_dec","_class","_Geometry","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","key","value","onEntityCreated","_this$config$geometri","config","geometries","mergedComponent","getComponent","aabb","mergedAttributes","mergedIndices","indexOffset","forEach","geometry","indices","vertexCount","attributes","add","push","_toConsumableArray","map","index","attribute","i","dirty","data","concat","Uint32Array","from"],"sources":["/Users/bhanudahiya/Desktop/ledger-IQ/node_modules/@antv/g-webgpu/src/geometry/Merged.ts"],"sourcesContent":["import { AABB, GeometryComponent } from '@antv/g-webgpu-core';\nimport { injectable } from 'inversify';\nimport { Geometry } from '.';\nimport { isNumber } from '../utils/is-number';\nimport { isTypedArray } from '../utils/is-typedarray';\nimport { merge } from '../utils/typedarray';\n\nexport interface IMergedGeometryParams {\n  geometries: GeometryComponent[];\n}\n\n@injectable()\n/**\n * merge many geometries into one, use a batch of draw calls\n */\nexport class Merged extends Geometry<Partial<IMergedGeometryParams>> {\n  protected onEntityCreated() {\n    const { geometries = [] } = this.config;\n\n    const mergedComponent = this.getComponent();\n    mergedComponent.aabb = new AABB();\n\n    const mergedAttributes: GeometryComponent['attributes'] = [];\n    const mergedIndices: number[] = [];\n    let indexOffset = 0;\n    geometries.forEach((geometry) => {\n      const { aabb, indices, vertexCount, attributes } = geometry;\n\n      // merge aabb\n      mergedComponent.aabb.add(aabb);\n      mergedComponent.vertexCount += vertexCount;\n\n      // merge indices\n      if (indices) {\n        mergedIndices.push(...indices.map((index) => index + indexOffset));\n      }\n      indexOffset += vertexCount;\n\n      // merge attributes\n      attributes.forEach((attribute, i) => {\n        if (!mergedAttributes[i]) {\n          mergedAttributes[i] = attribute;\n          mergedAttributes[i].dirty = true;\n        } else {\n          if (attribute.data) {\n            if (isNumber(attribute.data)) {\n              // @ts-ignore\n              mergedAttributes[i].push(attribute.data);\n            } else if (isTypedArray(attribute.data)) {\n              // @ts-ignore\n              mergedAttributes[i].data = merge(\n                // @ts-ignore\n                mergedAttributes[i].data,\n                attribute.data,\n              );\n            } else {\n              // @ts-ignore\n              mergedAttributes[i].data = mergedAttributes[i].data.concat(\n                attribute.data,\n              );\n            }\n          }\n        }\n      });\n    });\n\n    mergedComponent.attributes = mergedAttributes;\n    mergedComponent.indices = Uint32Array.from(mergedIndices);\n    mergedComponent.dirty = true;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}