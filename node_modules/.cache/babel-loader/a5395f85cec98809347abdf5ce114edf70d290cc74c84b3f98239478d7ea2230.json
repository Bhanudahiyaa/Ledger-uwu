{"ast":null,"code":"import util from './util';\n/*\n * Breaks any long edges in the graph into short segments that span 1 layer\n * each. This operation is undoable with the denormalize function.\n *\n * Pre-conditions:\n *\n *    1. The input graph is a DAG.\n *    2. Each node in the graph has a \"rank\" property.\n *\n * Post-condition:\n *\n *    1. All edges in the graph have a length of 1.\n *    2. Dummy nodes are added where edges have been split into segments.\n *    3. The graph is augmented with a \"dummyChains\" attribute which contains\n *       the first dummy in each chain of dummy nodes produced.\n */\nconst run = g => {\n  g.graph().dummyChains = [];\n  g.edges().forEach(edge => normalizeEdge(g, edge));\n};\nconst normalizeEdge = (g, e) => {\n  var _a, _b;\n  let v = e.v;\n  let vRank = g.node(v).rank;\n  const w = e.w;\n  const wRank = g.node(w).rank;\n  const name = e.name;\n  const edgeLabel = g.edge(e);\n  const labelRank = edgeLabel.labelRank;\n  if (wRank === vRank + 1) return;\n  g.removeEdge(e);\n  let dummy;\n  let attrs;\n  let i;\n  for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {\n    edgeLabel.points = [];\n    attrs = {\n      edgeLabel,\n      width: 0,\n      height: 0,\n      edgeObj: e,\n      rank: vRank\n    };\n    dummy = util.addDummyNode(g, \"edge\", attrs, \"_d\");\n    if (vRank === labelRank) {\n      attrs.width = edgeLabel.width;\n      attrs.height = edgeLabel.height;\n      attrs.dummy = \"edge-label\";\n      attrs.labelpos = edgeLabel.labelpos;\n    }\n    g.setEdge(v, dummy, {\n      weight: edgeLabel.weight\n    }, name);\n    if (i === 0) {\n      if (!g.graph().dummyChains) g.graph().dummyChains = [];\n      (_b = (_a = g.graph()) === null || _a === void 0 ? void 0 : _a.dummyChains) === null || _b === void 0 ? void 0 : _b.push(dummy);\n    }\n    v = dummy;\n  }\n  g.setEdge(v, w, {\n    weight: edgeLabel.weight\n  }, name);\n};\nconst undo = g => {\n  var _a;\n  (_a = g.graph().dummyChains) === null || _a === void 0 ? void 0 : _a.forEach(v => {\n    var _a;\n    let node = g.node(v);\n    const origLabel = node.edgeLabel;\n    let w;\n    node.edgeObj && g.setEdge(node.edgeObj, origLabel);\n    let currentV = v;\n    while (node.dummy) {\n      w = (_a = g.successors(currentV)) === null || _a === void 0 ? void 0 : _a[0];\n      g.removeNode(currentV);\n      origLabel.points.push({\n        x: node.x,\n        y: node.y\n      });\n      if (node.dummy === \"edge-label\") {\n        origLabel.x = node.x;\n        origLabel.y = node.y;\n        origLabel.width = node.width;\n        origLabel.height = node.height;\n      }\n      currentV = w;\n      node = g.node(currentV);\n    }\n  });\n};\nexport default {\n  run,\n  undo\n};","map":{"version":3,"names":["util","run","g","graph","dummyChains","edges","forEach","edge","normalizeEdge","e","v","vRank","node","rank","w","wRank","name","edgeLabel","labelRank","removeEdge","dummy","attrs","i","points","width","height","edgeObj","addDummyNode","labelpos","setEdge","weight","_b","_a","push","undo","origLabel","currentV","successors","removeNode","x","y"],"sources":["../../../../src/layout/dagre/src/normalize.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}